(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("robotjs"));
	else if(typeof define === 'function' && define.amd)
		define(["robotjs"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("robotjs")) : factory(root["robotjs"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, (__WEBPACK_EXTERNAL_MODULE_robotjs__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@azure/abort-controller/dist-esm/src/AbortController.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@azure/abort-controller/dist-esm/src/AbortController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortController": () => (/* binding */ AbortController),
/* harmony export */   "AbortError": () => (/* binding */ AbortError)
/* harmony export */ });
/* harmony import */ var _AbortSignal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortSignal */ "./node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */
class AbortError extends Error {
    constructor(message) {
        super(message);
        this.name = "AbortError";
    }
}
/**
 * An AbortController provides an AbortSignal and the associated controls to signal
 * that an asynchronous operation should be aborted.
 *
 * @example
 * Abort an operation when another event fires
 * ```ts
 * const controller = new AbortController();
 * const signal = controller.signal;
 * doAsyncWork(signal);
 * button.addEventListener('click', () => controller.abort());
 * ```
 *
 * @example
 * Share aborter cross multiple operations in 30s
 * ```ts
 * // Upload the same data to 2 different data centers at the same time,
 * // abort another when any of them is finished
 * const controller = AbortController.withTimeout(30 * 1000);
 * doAsyncWork(controller.signal).then(controller.abort);
 * doAsyncWork(controller.signal).then(controller.abort);
 *```
 *
 * @example
 * Cascaded aborting
 * ```ts
 * // All operations can't take more than 30 seconds
 * const aborter = Aborter.timeout(30 * 1000);
 *
 * // Following 2 operations can't take more than 25 seconds
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * ```
 */
class AbortController {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(parentSignals) {
        this._signal = new _AbortSignal__WEBPACK_IMPORTED_MODULE_0__.AbortSignal();
        if (!parentSignals) {
            return;
        }
        // coerce parentSignals into an array
        if (!Array.isArray(parentSignals)) {
            // eslint-disable-next-line prefer-rest-params
            parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
            // if the parent signal has already had abort() called,
            // then call abort on this signal as well.
            if (parentSignal.aborted) {
                this.abort();
            }
            else {
                // when the parent signal aborts, this signal should as well.
                parentSignal.addEventListener("abort", () => {
                    this.abort();
                });
            }
        }
    }
    /**
     * The AbortSignal associated with this controller that will signal aborted
     * when the abort method is called on this controller.
     *
     * @readonly
     */
    get signal() {
        return this._signal;
    }
    /**
     * Signal that any operations passed this controller's associated abort signal
     * to cancel any remaining work and throw an `AbortError`.
     */
    abort() {
        (0,_AbortSignal__WEBPACK_IMPORTED_MODULE_0__.abortSignal)(this._signal);
    }
    /**
     * Creates a new AbortSignal instance that will abort after the provided ms.
     * @param ms - Elapsed time in milliseconds to trigger an abort.
     */
    static timeout(ms) {
        const signal = new _AbortSignal__WEBPACK_IMPORTED_MODULE_0__.AbortSignal();
        const timer = setTimeout(_AbortSignal__WEBPACK_IMPORTED_MODULE_0__.abortSignal, ms, signal);
        // Prevent the active Timer from keeping the Node.js event loop active.
        if (typeof timer.unref === "function") {
            timer.unref();
        }
        return signal;
    }
}
//# sourceMappingURL=AbortController.js.map

/***/ }),

/***/ "./node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortSignal": () => (/* binding */ AbortSignal),
/* harmony export */   "abortSignal": () => (/* binding */ abortSignal)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference path="../shims-public.d.ts" />
const listenersMap = new WeakMap();
const abortedMap = new WeakMap();
/**
 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
 *
 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
 * cannot or will not ever be cancelled.
 *
 * @example
 * Abort without timeout
 * ```ts
 * await doAsyncWork(AbortSignal.none);
 * ```
 */
class AbortSignal {
    constructor() {
        /**
         * onabort event listener.
         */
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
    }
    /**
     * Status of whether aborted or not.
     *
     * @readonly
     */
    get aborted() {
        if (!abortedMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
    }
    /**
     * Creates a new AbortSignal instance that will never be aborted.
     *
     * @readonly
     */
    static get none() {
        return new AbortSignal();
    }
    /**
     * Added new "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be added
     */
    addEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
    }
    /**
     * Remove "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be removed
     */
    removeEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) {
            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
            listeners.splice(index, 1);
        }
    }
    /**
     * Dispatches a synthetic event to the AbortSignal.
     */
    dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
}
/**
 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
 * Will try to trigger abort event for all linked AbortSignal nodes.
 *
 * - If there is a timeout, the timer will be cancelled.
 * - If aborted is true, nothing will happen.
 *
 * @internal
 */
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
function abortSignal(signal) {
    if (signal.aborted) {
        return;
    }
    if (signal.onabort) {
        signal.onabort.call(signal);
    }
    const listeners = listenersMap.get(signal);
    if (listeners) {
        // Create a copy of listeners so mutations to the array
        // (e.g. via removeListener calls) don't affect the listeners
        // we invoke.
        listeners.slice().forEach((listener) => {
            listener.call(signal, { type: "abort" });
        });
    }
    abortedMap.set(signal, true);
}
//# sourceMappingURL=AbortSignal.js.map

/***/ }),

/***/ "./node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureNamedKeyCredential": () => (/* binding */ AzureNamedKeyCredential),
/* harmony export */   "isNamedKeyCredential": () => (/* binding */ isNamedKeyCredential)
/* harmony export */ });
/* harmony import */ var _typeguards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeguards */ "./node_modules/@azure/core-auth/dist-esm/src/typeguards.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A static name/key-based credential that supports updating
 * the underlying name and key values.
 */
class AzureNamedKeyCredential {
    /**
     * Create an instance of an AzureNamedKeyCredential for use
     * with a service client.
     *
     * @param name - The initial value of the name to use in authentication.
     * @param key - The initial value of the key to use in authentication.
     */
    constructor(name, key) {
        if (!name || !key) {
            throw new TypeError("name and key must be non-empty strings");
        }
        this._name = name;
        this._key = key;
    }
    /**
     * The value of the key to be used in authentication.
     */
    get key() {
        return this._key;
    }
    /**
     * The value of the name to be used in authentication.
     */
    get name() {
        return this._name;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newName - The new name value to be used.
     * @param newKey - The new key value to be used.
     */
    update(newName, newKey) {
        if (!newName || !newKey) {
            throw new TypeError("newName and newKey must be non-empty strings");
        }
        this._name = newName;
        this._key = newKey;
    }
}
/**
 * Tests an object to determine whether it implements NamedKeyCredential.
 *
 * @param credential - The assumed NamedKeyCredential to be tested.
 */
function isNamedKeyCredential(credential) {
    return ((0,_typeguards__WEBPACK_IMPORTED_MODULE_0__.isObjectWithProperties)(credential, ["name", "key"]) &&
        typeof credential.key === "string" &&
        typeof credential.name === "string");
}
//# sourceMappingURL=azureNamedKeyCredential.js.map

/***/ }),

/***/ "./node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureSASCredential": () => (/* binding */ AzureSASCredential),
/* harmony export */   "isSASCredential": () => (/* binding */ isSASCredential)
/* harmony export */ });
/* harmony import */ var _typeguards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeguards */ "./node_modules/@azure/core-auth/dist-esm/src/typeguards.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A static-signature-based credential that supports updating
 * the underlying signature value.
 */
class AzureSASCredential {
    /**
     * Create an instance of an AzureSASCredential for use
     * with a service client.
     *
     * @param signature - The initial value of the shared access signature to use in authentication
     */
    constructor(signature) {
        if (!signature) {
            throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = signature;
    }
    /**
     * The value of the shared access signature to be used in authentication
     */
    get signature() {
        return this._signature;
    }
    /**
     * Change the value of the signature.
     *
     * Updates will take effect upon the next request after
     * updating the signature value.
     *
     * @param newSignature - The new shared access signature value to be used
     */
    update(newSignature) {
        if (!newSignature) {
            throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = newSignature;
    }
}
/**
 * Tests an object to determine whether it implements SASCredential.
 *
 * @param credential - The assumed SASCredential to be tested.
 */
function isSASCredential(credential) {
    return ((0,_typeguards__WEBPACK_IMPORTED_MODULE_0__.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string");
}
//# sourceMappingURL=azureSASCredential.js.map

/***/ }),

/***/ "./node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isTokenCredential": () => (/* binding */ isTokenCredential)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an object to determine whether it implements TokenCredential.
 *
 * @param credential - The assumed TokenCredential to be tested.
 */
function isTokenCredential(credential) {
    // Check for an object with a 'getToken' function and possibly with
    // a 'signRequest' function.  We do this check to make sure that
    // a ServiceClientCredentials implementor (like TokenClientCredentials
    // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
    // it doesn't actually implement TokenCredential also.
    const castCredential = credential;
    return (castCredential &&
        typeof castCredential.getToken === "function" &&
        (castCredential.signRequest === undefined || castCredential.getToken.length > 0));
}
//# sourceMappingURL=tokenCredential.js.map

/***/ }),

/***/ "./node_modules/@azure/core-auth/dist-esm/src/typeguards.js":
/*!******************************************************************!*\
  !*** ./node_modules/@azure/core-auth/dist-esm/src/typeguards.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObjectWithProperties": () => (/* binding */ isObjectWithProperties)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * Note: The properties may be inherited.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 * @internal
 */
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
        return false;
    }
    for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
            return false;
        }
    }
    return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * Note: The property may be inherited.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 * @internal
 */
function objectHasProperty(thing, property) {
    return typeof thing === "object" && property in thing;
}
//# sourceMappingURL=typeguards.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "authorizeRequestOnTenantChallenge": () => (/* binding */ authorizeRequestOnTenantChallenge)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A set of constants used internally when processing requests.
 */
const Constants = {
    DefaultScope: "/.default",
    /**
     * Defines constants for use with HTTP headers.
     */
    HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization",
    },
};
/**
 * Defines a callback to handle auth challenge for Storage APIs.
 * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge
 * Handling has specific features for storage that departs to the general AAD challenge docs.
 **/
const authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
        const challengeInfo = parseChallenge(challenge);
        const challengeScopes = buildScopes(challengeOptions, challengeInfo);
        const tenantId = extractTenantId(challengeInfo);
        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));
        if (!accessToken) {
            return false;
        }
        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
        return true;
    }
    return false;
};
/**
 * Extracts the tenant id from the challenge information
 * The tenant id is contained in the authorization_uri as the first
 * path part.
 */
function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    return tenantId;
}
/**
 * Builds the authentication scopes based on the information that comes in the
 * challenge information. Scopes url is present in the resource_id, if it is empty
 * we keep using the original scopes.
 */
function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_uri) {
        return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_uri);
    challengeScopes.pathname = Constants.DefaultScope;
    return [challengeScopes.toString()];
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
        return challenge;
    }
    return;
}
/**
 * Converts: `Bearer a="b" c="d"`.
 * Into: `[ { a: 'b', c: 'd' }]`.
 *
 * @internal
 */
function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    // Key-value pairs to plain object:
    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
}
/**
 * Extracts the options form a Pipeline Request for later re-use
 */
function requestToOptions(request) {
    return {
        abortSignal: request.abortSignal,
        requestOptions: {
            timeout: request.timeout,
        },
        tracingOptions: request.tracingOptions,
    };
}
//# sourceMappingURL=authorizeRequestOnTenantChallenge.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/base64.js":
/*!****************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/base64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeString": () => (/* binding */ decodeString),
/* harmony export */   "decodeStringToString": () => (/* binding */ decodeStringToString),
/* harmony export */   "encodeByteArray": () => (/* binding */ encodeByteArray),
/* harmony export */   "encodeString": () => (/* binding */ encodeString)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - the string to encode
 * @internal
 */
function encodeString(value) {
    return Buffer.from(value).toString("base64");
}
/**
 * Encodes a byte array in base64 format.
 * @param value - the Uint8Aray to encode
 * @internal
 */
function encodeByteArray(value) {
    // Buffer.from accepts <ArrayBuffer> | <SharedArrayBuffer>-- the TypeScript definition is off here
    // https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
}
/**
 * Decodes a base64 string into a byte array.
 * @param value - the base64 string to decode
 * @internal
 */
function decodeString(value) {
    return Buffer.from(value, "base64");
}
/**
 * Decodes a base64 string into a string.
 * @param value - the base64 string to decode
 * @internal
 */
function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
}
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deserializationPolicy": () => (/* binding */ deserializationPolicy),
/* harmony export */   "deserializationPolicyName": () => (/* binding */ deserializationPolicyName)
/* harmony export */ });
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces */ "./node_modules/@azure/core-client/dist-esm/src/interfaces.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js");
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializer */ "./node_modules/@azure/core-client/dist-esm/src/serializer.js");
/* harmony import */ var _operationHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operationHelpers */ "./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




const defaultJsonContentTypes = ["application/json", "text/json"];
const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
/**
 * The programmatic identifier of the deserializationPolicy.
 */
const deserializationPolicyName = "deserializationPolicy";
/**
 * This policy handles parsing out responses according to OperationSpecs on the request.
 */
function deserializationPolicy(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : _interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_CHARKEY,
        },
    };
    return {
        name: deserializationPolicyName,
        async sendRequest(request, next) {
            const response = await next(request);
            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
        },
    };
}
function getOperationResponseMap(parsedResponse) {
    let result;
    const request = parsedResponse.request;
    const operationInfo = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_1__.getOperationRequestInfo)(request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (operationSpec) {
        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
            result = operationSpec.responses[parsedResponse.status];
        }
        else {
            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
        }
    }
    return result;
}
function shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_1__.getOperationRequestInfo)(request);
    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) {
        result = true;
    }
    else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
    }
    else {
        result = shouldDeserialize(parsedResponse);
    }
    return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
        return parsedResponse;
    }
    const operationInfo = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_1__.getOperationRequestInfo)(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
        return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
    if (error) {
        throw error;
    }
    else if (shouldReturnResponse) {
        return parsedResponse;
    }
    // An operation response spec does exist for current status code, so
    // use it to deserialize the response.
    if (responseSpec) {
        if (responseSpec.bodyMapper) {
            let valueToDeserialize = parsedResponse.parsedBody;
            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === _serializer__WEBPACK_IMPORTED_MODULE_2__.MapperTypeNames.Sequence) {
                valueToDeserialize =
                    typeof valueToDeserialize === "object"
                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]
                        : [];
            }
            try {
                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
            }
            catch (deserializeError) {
                const restError = new _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
                    statusCode: parsedResponse.status,
                    request: parsedResponse.request,
                    response: parsedResponse,
                });
                throw restError;
            }
        }
        else if (operationSpec.httpMethod === "HEAD") {
            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
        }
        if (responseSpec.headersMapper) {
            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
    }
    return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return (expectedStatusCodes.length === 0 ||
        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
    var _a;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)
        ? isSuccessByStatus
        : !!responseSpec;
    if (isExpectedStatusCode) {
        if (responseSpec) {
            if (!responseSpec.isError) {
                return { error: null, shouldReturnResponse: false };
            }
        }
        else {
            return { error: null, shouldReturnResponse: false };
        }
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))
        ? `Unexpected status code: ${parsedResponse.status}`
        : parsedResponse.bodyAsText;
    const error = new _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__.RestError(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse,
    });
    // If the item failed but there's no error spec or default spec to deserialize the error,
    // we should fail so we just throw the parsed response
    if (!errorResponseSpec) {
        throw error;
    }
    const defaultBodyMapper = errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
        // If error response has a body, try to deserialize it using default body mapper.
        // Then try to extract error code & message from it
        if (parsedResponse.parsedBody) {
            const parsedBody = parsedResponse.parsedBody;
            let deserializedError;
            if (defaultBodyMapper) {
                let valueToDeserialize = parsedBody;
                if (operationSpec.isXML && defaultBodyMapper.type.name === _serializer__WEBPACK_IMPORTED_MODULE_2__.MapperTypeNames.Sequence) {
                    valueToDeserialize = [];
                    const elementName = defaultBodyMapper.xmlElementName;
                    if (typeof parsedBody === "object" && elementName) {
                        valueToDeserialize = parsedBody[elementName];
                    }
                }
                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
            }
            const internalError = parsedBody.error || deserializedError || parsedBody;
            error.code = internalError.code;
            if (internalError.message) {
                error.message = internalError.message;
            }
            if (defaultBodyMapper) {
                error.response.parsedBody = deserializedError;
            }
        }
        // If error response has headers, try to deserialize it using default header mapper
        if (parsedResponse.headers && defaultHeadersMapper) {
            error.response.parsedHeaders =
                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
    }
    catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a;
    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&
        operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType
            ? []
            : contentType.split(";").map((component) => component.toLowerCase());
        try {
            if (contentComponents.length === 0 ||
                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
                operationResponse.parsedBody = JSON.parse(text);
                return operationResponse;
            }
            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
                if (!parseXML) {
                    throw new Error("Parsing XML not supported.");
                }
                const body = await parseXML(text, opts.xml);
                operationResponse.parsedBody = body;
                return operationResponse;
            }
        }
        catch (err) {
            const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
            const errCode = err.code || _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__.RestError.PARSE_ERROR;
            const e = new _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__.RestError(msg, {
                code: errCode,
                statusCode: operationResponse.status,
                request: operationResponse.request,
                response: operationResponse,
            });
            throw e;
        }
    }
    return operationResponse;
}
//# sourceMappingURL=deserializationPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/httpClientCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/httpClientCache.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCachedDefaultHttpClient": () => (/* binding */ getCachedDefaultHttpClient)
/* harmony export */ });
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

let cachedHttpClient;
function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
        cachedHttpClient = (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__.createDefaultHttpClient)();
    }
    return cachedHttpClient;
}
//# sourceMappingURL=httpClientCache.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPathStringFromParameter": () => (/* binding */ getPathStringFromParameter),
/* harmony export */   "getStreamingResponseStatusCodes": () => (/* binding */ getStreamingResponseStatusCodes)
/* harmony export */ });
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./serializer */ "./node_modules/@azure/core-client/dist-esm/src/serializer.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Gets the list of status codes for streaming responses.
 * @internal
 */
function getStreamingResponseStatusCodes(operationSpec) {
    const result = new Set();
    for (const statusCode in operationSpec.responses) {
        const operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper &&
            operationResponse.bodyMapper.type.name === _serializer__WEBPACK_IMPORTED_MODULE_0__.MapperTypeNames.Stream) {
            result.add(Number(statusCode));
        }
    }
    return result;
}
/**
 * Get the path to this parameter's value as a dotted string (a.b.c).
 * @param parameter - The parameter to get the path string for.
 * @returns The path to this parameter's value as a dotted string.
 * @internal
 */
function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
        result = parameterPath;
    }
    else if (Array.isArray(parameterPath)) {
        result = parameterPath.join(".");
    }
    else {
        result = mapper.serializedName;
    }
    return result;
}
//# sourceMappingURL=interfaceHelpers.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/interfaces.js":
/*!********************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/interfaces.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XML_ATTRKEY": () => (/* binding */ XML_ATTRKEY),
/* harmony export */   "XML_CHARKEY": () => (/* binding */ XML_CHARKEY)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */
const XML_ATTRKEY = "$";
/**
 * Default key used to access the XML value content.
 */
const XML_CHARKEY = "_";
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logger": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _azure_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/logger */ "./node_modules/@azure/logger/dist-esm/src/index.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const logger = (0,_azure_logger__WEBPACK_IMPORTED_MODULE_0__.createClientLogger)("core-client");
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationArgumentValueFromParameter": () => (/* binding */ getOperationArgumentValueFromParameter),
/* harmony export */   "getOperationRequestInfo": () => (/* binding */ getOperationRequestInfo)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Retrieves the value to use for a given operation argument
 * @param operationArguments - The arguments passed from the generated client
 * @param parameter - The parameter description
 * @param fallbackObject - If something isn't found in the arguments bag, look here.
 *  Generally used to look at the service client properties.
 */
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
        parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
            if (parameterMapper.isConstant) {
                value = parameterMapper.defaultValue;
            }
            else {
                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                if (!propertySearchResult.propertyFound && fallbackObject) {
                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
                }
                let useDefaultValue = false;
                if (!propertySearchResult.propertyFound) {
                    useDefaultValue =
                        parameterMapper.required ||
                            (parameterPath[0] === "options" && parameterPath.length === 2);
                }
                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
            }
        }
    }
    else {
        if (parameterMapper.required) {
            value = {};
        }
        for (const propertyName in parameterPath) {
            const propertyMapper = parameterMapper.type.modelProperties[propertyName];
            const propertyPath = parameterPath[propertyName];
            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
                parameterPath: propertyPath,
                mapper: propertyMapper,
            }, fallbackObject);
            if (propertyValue !== undefined) {
                if (!value) {
                    value = {};
                }
                value[propertyName] = propertyValue;
            }
        }
    }
    return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i = 0;
    for (; i < parameterPath.length; ++i) {
        const parameterPathPart = parameterPath[i];
        // Make sure to check inherited properties too, so don't use hasOwnProperty().
        if (parent && parameterPathPart in parent) {
            parent = parent[parameterPathPart];
        }
        else {
            break;
        }
    }
    if (i === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
    }
    return result;
}
const operationRequestMap = new WeakMap();
function getOperationRequestInfo(request) {
    let info = operationRequestMap.get(request);
    if (!info) {
        info = {};
        operationRequestMap.set(request, info);
    }
    return info;
}
//# sourceMappingURL=operationHelpers.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/pipeline.js":
/*!******************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/pipeline.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createClientPipeline": () => (/* binding */ createClientPipeline)
/* harmony export */ });
/* harmony import */ var _deserializationPolicy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deserializationPolicy */ "./node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js");
/* harmony import */ var _serializationPolicy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializationPolicy */ "./node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



/**
 * Creates a new Pipeline for use with a Service Client.
 * Adds in deserializationPolicy by default.
 * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.
 * @param options - Options to customize the created pipeline.
 */
function createClientPipeline(options = {}) {
    const pipeline = (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__.createPipelineFromOptions)(options !== null && options !== void 0 ? options : {});
    if (options.credentialOptions) {
        pipeline.addPolicy((0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_1__.bearerTokenAuthenticationPolicy)({
            credential: options.credentialOptions.credential,
            scopes: options.credentialOptions.credentialScopes,
        }));
    }
    pipeline.addPolicy((0,_serializationPolicy__WEBPACK_IMPORTED_MODULE_2__.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
    pipeline.addPolicy((0,_deserializationPolicy__WEBPACK_IMPORTED_MODULE_3__.deserializationPolicy)(options.deserializationOptions), {
        phase: "Deserialize",
    });
    return pipeline;
}
//# sourceMappingURL=pipeline.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializationPolicy": () => (/* binding */ serializationPolicy),
/* harmony export */   "serializationPolicyName": () => (/* binding */ serializationPolicyName),
/* harmony export */   "serializeHeaders": () => (/* binding */ serializeHeaders),
/* harmony export */   "serializeRequestBody": () => (/* binding */ serializeRequestBody)
/* harmony export */ });
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces */ "./node_modules/@azure/core-client/dist-esm/src/interfaces.js");
/* harmony import */ var _operationHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./operationHelpers */ "./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js");
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serializer */ "./node_modules/@azure/core-client/dist-esm/src/serializer.js");
/* harmony import */ var _interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interfaceHelpers */ "./node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




/**
 * The programmatic identifier of the serializationPolicy.
 */
const serializationPolicyName = "serializationPolicy";
/**
 * This policy handles assembling the request body and headers using
 * an OperationSpec and OperationArguments on the request.
 */
function serializationPolicy(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
        name: serializationPolicyName,
        async sendRequest(request, next) {
            const operationInfo = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationRequestInfo)(request);
            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
            if (operationSpec && operationArguments) {
                serializeHeaders(request, operationArguments, operationSpec);
                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
            }
            return next(request);
        },
    };
}
/**
 * @internal
 */
function serializeHeaders(request, operationArguments, operationSpec) {
    var _a, _b;
    if (operationSpec.headerParameters) {
        for (const headerParameter of operationSpec.headerParameters) {
            let headerValue = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {
                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(headerParameter));
                const headerCollectionPrefix = headerParameter.mapper
                    .headerCollectionPrefix;
                if (headerCollectionPrefix) {
                    for (const key of Object.keys(headerValue)) {
                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);
                    }
                }
                else {
                    request.headers.set(headerParameter.mapper.serializedName || (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(headerParameter), headerValue);
                }
            }
        }
    }
    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
    if (customHeaders) {
        for (const customHeaderName of Object.keys(customHeaders)) {
            request.headers.set(customHeaderName, customHeaders[customHeaderName]);
        }
    }
}
/**
 * @internal
 */
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {
    throw new Error("XML serialization unsupported!");
}) {
    var _a, _b, _c, _d, _e;
    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : _interfaces__WEBPACK_IMPORTED_MODULE_2__.XML_CHARKEY,
        },
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request.body = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
            if ((request.body !== undefined && request.body !== null) ||
                (nullable && request.body === null) ||
                required) {
                const requestBodyParameterPathString = (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(operationSpec.requestBody);
                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
                const isStream = typeName === _serializer__WEBPACK_IMPORTED_MODULE_3__.MapperTypeNames.Stream;
                if (operationSpec.isXML) {
                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
                    if (typeName === _serializer__WEBPACK_IMPORTED_MODULE_3__.MapperTypeNames.Sequence) {
                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
                    }
                    else if (!isStream) {
                        request.body = stringifyXML(value, {
                            rootName: xmlName || serializedName,
                            xmlCharKey,
                        });
                    }
                }
                else if (typeName === _serializer__WEBPACK_IMPORTED_MODULE_3__.MapperTypeNames.String &&
                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
                    // the String serializer has validated that request body is a string
                    // so just send the string.
                    return;
                }
                else if (!isStream) {
                    request.body = JSON.stringify(request.body);
                }
            }
        }
        catch (error) {
            throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
        }
    }
    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters) {
            const formDataParameterValue = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(formDataParameter);
                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(formDataParameter), updatedOptions);
            }
        }
    }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    // Composite and Sequence schemas already got their root namespace set during serialization
    // We just need to add xmlns to the other schema types
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
        const result = {};
        result[options.xml.xmlCharKey] = serializedValue;
        result[_interfaces__WEBPACK_IMPORTED_MODULE_2__.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
        return result;
    }
    return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
        obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
        return { [elementName]: obj };
    }
    const result = { [elementName]: obj };
    result[_interfaces__WEBPACK_IMPORTED_MODULE_2__.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result;
}
//# sourceMappingURL=serializationPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/serializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/serializer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapperTypeNames": () => (/* binding */ MapperTypeNames),
/* harmony export */   "createSerializer": () => (/* binding */ createSerializer)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64 */ "./node_modules/@azure/core-client/dist-esm/src/base64.js");
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces */ "./node_modules/@azure/core-client/dist-esm/src/interfaces.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/@azure/core-client/dist-esm/src/utils.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



class SerializerImpl {
    constructor(modelMappers = {}, isXML = false) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
    }
    /**
     * @deprecated Removing the constraints validation on client side.
     */
    validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
            throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== undefined && value !== null) {
            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;
            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
                failValidation("ExclusiveMaximum", ExclusiveMaximum);
            }
            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
                failValidation("ExclusiveMinimum", ExclusiveMinimum);
            }
            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
                failValidation("InclusiveMaximum", InclusiveMaximum);
            }
            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
                failValidation("InclusiveMinimum", InclusiveMinimum);
            }
            if (MaxItems !== undefined && value.length > MaxItems) {
                failValidation("MaxItems", MaxItems);
            }
            if (MaxLength !== undefined && value.length > MaxLength) {
                failValidation("MaxLength", MaxLength);
            }
            if (MinItems !== undefined && value.length < MinItems) {
                failValidation("MinItems", MinItems);
            }
            if (MinLength !== undefined && value.length < MinLength) {
                failValidation("MinLength", MinLength);
            }
            if (MultipleOf !== undefined && value % MultipleOf !== 0) {
                failValidation("MultipleOf", MultipleOf);
            }
            if (Pattern) {
                const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                if (typeof value !== "string" || value.match(pattern) === null) {
                    failValidation("Pattern", Pattern);
                }
            }
            if (UniqueItems &&
                value.some((item, i, ar) => ar.indexOf(item) !== i)) {
                failValidation("UniqueItems", UniqueItems);
            }
        }
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param object - A valid Javascript object to be serialized
     *
     * @param objectName - Name of the serialized object
     *
     * @param options - additional options to serialization
     *
     * @returns A valid serialized Javascript object
     */
    serialize(mapper, object, objectName, options = { xml: {} }) {
        var _a, _b, _c;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : _interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_CHARKEY,
            },
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
            objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
            payload = [];
        }
        if (mapper.isConstant) {
            object = mapper.defaultValue;
        }
        // This table of allowed values should help explain
        // the mapper.required and mapper.nullable properties.
        // X means "neither undefined or null are allowed".
        //           || required
        //           || true      | false
        //  nullable || ==========================
        //      true || null      | undefined/null
        //     false || X         | undefined
        // undefined || X         | undefined/null
        const { required, nullable } = mapper;
        if (required && nullable && object === undefined) {
            throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && (object === undefined || object === null)) {
            throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
            throw new Error(`${objectName} cannot be null.`);
        }
        if (object === undefined || object === null) {
            payload = object;
        }
        else {
            if (mapperType.match(/^any$/i) !== null) {
                payload = object;
            }
            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
                payload = serializeBasicTypes(mapperType, objectName, object);
            }
            else if (mapperType.match(/^Enum$/i) !== null) {
                const enumMapper = mapper;
                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
            }
            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
                payload = serializeDateTypes(mapperType, object, objectName);
            }
            else if (mapperType.match(/^ByteArray$/i) !== null) {
                payload = serializeByteArrayType(objectName, object);
            }
            else if (mapperType.match(/^Base64Url$/i) !== null) {
                payload = serializeBase64UrlType(objectName, object);
            }
            else if (mapperType.match(/^Sequence$/i) !== null) {
                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
            else if (mapperType.match(/^Dictionary$/i) !== null) {
                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
            else if (mapperType.match(/^Composite$/i) !== null) {
                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
        }
        return payload;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param responseBody - A valid Javascript entity to be deserialized
     *
     * @param objectName - Name of the deserialized object
     *
     * @param options - Controls behavior of XML parser and builder.
     *
     * @returns A valid deserialized Javascript object
     */
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
        var _a, _b, _c;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : _interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_CHARKEY,
            },
        };
        if (responseBody === undefined || responseBody === null) {
            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
                // between the list being empty versus being missing,
                // so let's do the more user-friendly thing and return an empty list.
                responseBody = [];
            }
            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
            if (mapper.defaultValue !== undefined) {
                responseBody = mapper.defaultValue;
            }
            return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
            objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        }
        else {
            if (this.isXML) {
                const xmlCharKey = updatedOptions.xml.xmlCharKey;
                /**
                 * If the mapper specifies this as a non-composite type value but the responseBody contains
                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
                 */
                if (responseBody[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
                    responseBody = responseBody[xmlCharKey];
                }
            }
            if (mapperType.match(/^Number$/i) !== null) {
                payload = parseFloat(responseBody);
                if (isNaN(payload)) {
                    payload = responseBody;
                }
            }
            else if (mapperType.match(/^Boolean$/i) !== null) {
                if (responseBody === "true") {
                    payload = true;
                }
                else if (responseBody === "false") {
                    payload = false;
                }
                else {
                    payload = responseBody;
                }
            }
            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
                payload = responseBody;
            }
            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
                payload = new Date(responseBody);
            }
            else if (mapperType.match(/^UnixTime$/i) !== null) {
                payload = unixTimeToDate(responseBody);
            }
            else if (mapperType.match(/^ByteArray$/i) !== null) {
                payload = _base64__WEBPACK_IMPORTED_MODULE_1__.decodeString(responseBody);
            }
            else if (mapperType.match(/^Base64Url$/i) !== null) {
                payload = base64UrlToByteArray(responseBody);
            }
            else if (mapperType.match(/^Sequence$/i) !== null) {
                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
            }
            else if (mapperType.match(/^Dictionary$/i) !== null) {
                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
            }
        }
        if (mapper.isConstant) {
            payload = mapper.defaultValue;
        }
        return payload;
    }
}
/**
 * Method that creates and returns a Serializer.
 * @param modelMappers - Known models to map
 * @param isXML - If XML should be supported
 */
function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
}
function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
        --len;
    }
    return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
    if (!buffer) {
        return undefined;
    }
    if (!(buffer instanceof Uint8Array)) {
        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    // Uint8Array to Base64.
    const str = _base64__WEBPACK_IMPORTED_MODULE_1__.encodeByteArray(buffer);
    // Base64 to Base64Url.
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
    if (!str) {
        return undefined;
    }
    if (str && typeof str.valueOf() !== "string") {
        throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    // Base64Url to Base64.
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    // Base64 to Uint8Array.
    return _base64__WEBPACK_IMPORTED_MODULE_1__.decodeString(str);
}
function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
        const subwords = prop.split(".");
        for (const item of subwords) {
            if (item.charAt(item.length - 1) === "\\") {
                partialclass += item.substr(0, item.length - 1) + ".";
            }
            else {
                partialclass += item;
                classes.push(partialclass);
                partialclass = "";
            }
        }
    }
    return classes;
}
function dateToUnixTime(d) {
    if (!d) {
        return undefined;
    }
    if (typeof d.valueOf() === "string") {
        d = new Date(d);
    }
    return Math.floor(d.getTime() / 1000);
}
function unixTimeToDate(n) {
    if (!n) {
        return undefined;
    }
    return new Date(n * 1000);
}
function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
        if (typeName.match(/^Number$/i) !== null) {
            if (typeof value !== "number") {
                throw new Error(`${objectName} with value ${value} must be of type number.`);
            }
        }
        else if (typeName.match(/^String$/i) !== null) {
            if (typeof value.valueOf() !== "string") {
                throw new Error(`${objectName} with value "${value}" must be of type string.`);
            }
        }
        else if (typeName.match(/^Uuid$/i) !== null) {
            if (!(typeof value.valueOf() === "string" && (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isValidUuid)(value))) {
                throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
            }
        }
        else if (typeName.match(/^Boolean$/i) !== null) {
            if (typeof value !== "boolean") {
                throw new Error(`${objectName} with value ${value} must be of type boolean.`);
            }
        }
        else if (typeName.match(/^Stream$/i) !== null) {
            const objectType = typeof value;
            if (objectType !== "string" &&
                typeof value.pipe !== "function" &&
                !(value instanceof ArrayBuffer) &&
                !ArrayBuffer.isView(value) &&
                // File objects count as a type of Blob, so we want to use instanceof explicitly
                !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or NodeJS.ReadableStream.`);
            }
        }
    }
    return value;
}
function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
        if (typeof item.valueOf() === "string") {
            return item.toLowerCase() === value.toLowerCase();
        }
        return item === value;
    });
    if (!isPresent) {
        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
}
function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) {
            throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = _base64__WEBPACK_IMPORTED_MODULE_1__.encodeByteArray(value);
    }
    return value;
}
function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) {
            throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = bufferToBase64Url(value);
    }
    return value;
}
function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
        if (typeName.match(/^Date$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            }
            value =
                value instanceof Date
                    ? value.toISOString().substring(0, 10)
                    : new Date(value).toISOString().substring(0, 10);
        }
        else if (typeName.match(/^DateTime$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            }
            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        }
        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
            }
            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        }
        else if (typeName.match(/^UnixTime$/i) !== null) {
            if (!(value instanceof Date ||
                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
                    `for it to be serialized in UnixTime/Epoch format.`);
            }
            value = dateToUnixTime(value);
        }
        else if (typeName.match(/^TimeSpan$/i) !== null) {
            if (!(0,_utils__WEBPACK_IMPORTED_MODULE_2__.isDuration)(value)) {
                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
            }
        }
    }
    return value;
}
function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a;
    if (!Array.isArray(object)) {
        throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}.`);
    }
    // Quirk: Composite mappers referenced by `element` might
    // not have *all* properties declared (like uberParent),
    // so let's try to look up the full definition by name.
    if (elementType.type.name === "Composite" && elementType.type.className) {
        elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;
    }
    const tempArray = [];
    for (let i = 0; i < object.length; i++) {
        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
        if (isXml && elementType.xmlNamespace) {
            const xmlnsKey = elementType.xmlNamespacePrefix
                ? `xmlns:${elementType.xmlNamespacePrefix}`
                : "xmlns";
            if (elementType.type.name === "Composite") {
                tempArray[i] = Object.assign({}, serializedValue);
                tempArray[i][_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
            }
            else {
                tempArray[i] = {};
                tempArray[i][options.xml.xmlCharKey] = serializedValue;
                tempArray[i][_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
            }
        }
        else {
            tempArray[i] = serializedValue;
        }
    }
    return tempArray;
}
function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") {
        throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        // If the element needs an XML namespace we need to add it within the $ property
        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    // Add the namespace to the root element if needed
    if (isXml && mapper.xmlNamespace) {
        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
        const result = tempDictionary;
        result[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
        return result;
    }
    return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 */
function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) {
            throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
        }
        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
        if (!modelProps) {
            throw new Error(`modelProperties cannot be null or undefined in the ` +
                `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
        }
    }
    return modelProps;
}
function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
        const payload = {};
        const modelProps = resolveModelProperties(serializer, mapper, objectName);
        for (const key of Object.keys(modelProps)) {
            const propertyMapper = modelProps[key];
            if (propertyMapper.readOnly) {
                continue;
            }
            let propName;
            let parentObject = payload;
            if (serializer.isXML) {
                if (propertyMapper.xmlIsWrapped) {
                    propName = propertyMapper.xmlName;
                }
                else {
                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
                }
            }
            else {
                const paths = splitSerializeName(propertyMapper.serializedName);
                propName = paths.pop();
                for (const pathName of paths) {
                    const childObject = parentObject[pathName];
                    if ((childObject === undefined || childObject === null) &&
                        ((object[key] !== undefined && object[key] !== null) ||
                            propertyMapper.defaultValue !== undefined)) {
                        parentObject[pathName] = {};
                    }
                    parentObject = parentObject[pathName];
                }
            }
            if (parentObject !== undefined && parentObject !== null) {
                if (isXml && mapper.xmlNamespace) {
                    const xmlnsKey = mapper.xmlNamespacePrefix
                        ? `xmlns:${mapper.xmlNamespacePrefix}`
                        : "xmlns";
                    parentObject[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
                }
                const propertyObjectName = propertyMapper.serializedName !== ""
                    ? objectName + "." + propertyMapper.serializedName
                    : objectName;
                let toSerialize = object[key];
                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                if (polymorphicDiscriminator &&
                    polymorphicDiscriminator.clientName === key &&
                    (toSerialize === undefined || toSerialize === null)) {
                    toSerialize = mapper.serializedName;
                }
                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                if (serializedValue !== undefined && propName !== undefined && propName !== null) {
                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                    if (isXml && propertyMapper.xmlIsAttribute) {
                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
                        // This keeps things simple while preventing name collision
                        // with names in user documents.
                        parentObject[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = parentObject[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] || {};
                        parentObject[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY][propName] = serializedValue;
                    }
                    else if (isXml && propertyMapper.xmlIsWrapped) {
                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };
                    }
                    else {
                        parentObject[propName] = value;
                    }
                }
            }
        }
        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
            const propNames = Object.keys(modelProps);
            for (const clientPropName in object) {
                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
                if (isAdditionalProperty) {
                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
                }
            }
        }
        return payload;
    }
    return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) {
        return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix
        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`
        : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
        if (serializedValue[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY]) {
            return serializedValue;
        }
        else {
            const result = Object.assign({}, serializedValue);
            result[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = xmlNamespace;
            return result;
        }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY] = xmlNamespace;
    return result;
}
function isSpecialXmlProperty(propertyName, options) {
    return [_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        const paths = splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        const { serializedName, xmlName, xmlElementName } = propertyMapper;
        let propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== undefined) {
            propertyObjectName = objectName + "." + serializedName;
        }
        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
            const dictionary = {};
            for (const headerKey of Object.keys(responseBody)) {
                if (headerKey.startsWith(headerCollectionPrefix)) {
                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                }
                handledPropertyNames.push(headerKey);
            }
            instance[key] = dictionary;
        }
        else if (serializer.isXML) {
            if (propertyMapper.xmlIsAttribute && responseBody[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY]) {
                instance[key] = serializer.deserialize(propertyMapper, responseBody[_interfaces__WEBPACK_IMPORTED_MODULE_0__.XML_ATTRKEY][xmlName], propertyObjectName, options);
            }
            else {
                const propertyName = xmlElementName || xmlName || serializedName;
                if (propertyMapper.xmlIsWrapped) {
                    /* a list of <xmlElementName> wrapped by <xmlName>
                      For the xml example below
                        <Cors>
                          <CorsRule>...</CorsRule>
                          <CorsRule>...</CorsRule>
                        </Cors>
                      the responseBody has
                        {
                          Cors: {
                            CorsRule: [{...}, {...}]
                          }
                        }
                      xmlName is "Cors" and xmlElementName is"CorsRule".
                    */
                    const wrapped = responseBody[xmlName];
                    const elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                }
                else {
                    const property = responseBody[propertyName];
                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                }
            }
        }
        else {
            // deserialize the property if it is present in the provided responseBody instance
            let propertyInstance;
            let res = responseBody;
            // traversing the object step by step.
            for (const item of paths) {
                if (!res)
                    break;
                res = res[item];
            }
            propertyInstance = res;
            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
            // checking that the model property name (key)(ex: "fishtype") and the
            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
            // is a better approach. The generator is not consistent with escaping '\.' in the
            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
            // the transformation of model property name (ex: "fishtype") is done consistently.
            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
            if (polymorphicDiscriminator &&
                key === polymorphicDiscriminator.clientName &&
                (propertyInstance === undefined || propertyInstance === null)) {
                propertyInstance = mapper.serializedName;
            }
            let serializedValue;
            // paging
            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                propertyInstance = responseBody[key];
                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                // Copy over any properties that have already been added into the instance, where they do
                // not exist on the newly de-serialized array
                for (const [k, v] of Object.entries(instance)) {
                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
                        arrayInstance[k] = v;
                    }
                }
                instance = arrayInstance;
            }
            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                instance[key] = serializedValue;
            }
        }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
        const isAdditionalProperty = (responsePropName) => {
            for (const clientPropName in modelProps) {
                const paths = splitSerializeName(modelProps[clientPropName].serializedName);
                if (paths[0] === responsePropName) {
                    return false;
                }
            }
            return true;
        };
        for (const responsePropName in responseBody) {
            if (isAdditionalProperty(responsePropName)) {
                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
            }
        }
    }
    else if (responseBody) {
        for (const key of Object.keys(responseBody)) {
            if (instance[key] === undefined &&
                !handledPropertyNames.includes(key) &&
                !isSpecialXmlProperty(key, options)) {
                instance[key] = responseBody[key];
            }
        }
    }
    return instance;
}
function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    /* jshint validthis: true */
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
        const tempDictionary = {};
        for (const key of Object.keys(responseBody)) {
            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        }
        return tempDictionary;
    }
    return responseBody;
}
function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the ` +
            `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
        if (!Array.isArray(responseBody)) {
            // xml2js will interpret a single element array as just the element, so force it to be an array
            responseBody = [responseBody];
        }
        // Quirk: Composite mappers referenced by `element` might
        // not have *all* properties declared (like uberParent),
        // so let's try to look up the full definition by name.
        if (element.type.name === "Composite" && element.type.className) {
            element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;
        }
        const tempArray = [];
        for (let i = 0; i < responseBody.length; i++) {
            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
        }
        return tempArray;
    }
    return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
        const currentName = typeNamesToCheck.shift();
        const indexDiscriminator = discriminatorValue === currentName
            ? discriminatorValue
            : currentName + "." + discriminatorValue;
        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
            return discriminators[indexDiscriminator];
        }
        else {
            for (const [name, mapper] of Object.entries(discriminators)) {
                if (name.startsWith(currentName + ".") &&
                    mapper.type.uberParent === currentName &&
                    mapper.type.className) {
                    typeNamesToCheck.push(mapper.type.className);
                }
            }
        }
    }
    return undefined;
}
function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a;
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName) {
            // The serializedName might have \\, which we just want to ignore
            if (polymorphicPropertyName === "serializedName") {
                discriminatorName = discriminatorName.replace(/\\/gi, "");
            }
            const discriminatorValue = object[discriminatorName];
            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;
            if (typeof discriminatorValue === "string" && typeName) {
                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
                if (polymorphicMapper) {
                    mapper = polymorphicMapper;
                }
            }
        }
    }
    return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return (mapper.type.polymorphicDiscriminator ||
        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||
        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));
}
function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return (typeName &&
        serializer.modelMappers[typeName] &&
        serializer.modelMappers[typeName].type.polymorphicDiscriminator);
}
/**
 * Known types of Mappers
 */
const MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime",
};
//# sourceMappingURL=serializer.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/serviceClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/serviceClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceClient": () => (/* binding */ ServiceClient)
/* harmony export */ });
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js");
/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pipeline */ "./node_modules/@azure/core-client/dist-esm/src/pipeline.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./node_modules/@azure/core-client/dist-esm/src/utils.js");
/* harmony import */ var _httpClientCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httpClientCache */ "./node_modules/@azure/core-client/dist-esm/src/httpClientCache.js");
/* harmony import */ var _operationHelpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./operationHelpers */ "./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js");
/* harmony import */ var _urlHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./urlHelpers */ "./node_modules/@azure/core-client/dist-esm/src/urlHelpers.js");
/* harmony import */ var _interfaceHelpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interfaceHelpers */ "./node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "./node_modules/@azure/core-client/dist-esm/src/log.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








/**
 * Initializes a new instance of the ServiceClient.
 */
class ServiceClient {
    /**
     * The ServiceClient constructor
     * @param credential - The credentials used for authentication with the service.
     * @param options - The service client options that govern the behavior of the client.
     */
    constructor(options = {}) {
        var _a, _b;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;
        if (options.baseUri) {
            _log__WEBPACK_IMPORTED_MODULE_0__.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || (0,_httpClientCache__WEBPACK_IMPORTED_MODULE_1__.getCachedDefaultHttpClient)();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
            for (const { policy, position } of options.additionalPolicies) {
                // Sign happens after Retry and is commonly needed to occur
                // before policies that intercept post-retry.
                const afterPhase = position === "perRetry" ? "Sign" : undefined;
                this.pipeline.addPolicy(policy, {
                    afterPhase,
                });
            }
        }
    }
    /**
     * Send the provided httpRequest.
     */
    async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
    }
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @typeParam T - The typed result of the request, based on the OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     */
    async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
            throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        // Templatized URLs sometimes reference properties on the ServiceClient child class,
        // so we have to pass `this` below in order to search these properties if they're
        // not part of OperationArguments
        const url = (0,_urlHelpers__WEBPACK_IMPORTED_MODULE_2__.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
        const request = (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_3__.createPipelineRequest)({
            url,
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_4__.getOperationRequestInfo)(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
            request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
            const requestOptions = options.requestOptions;
            if (requestOptions) {
                if (requestOptions.timeout) {
                    request.timeout = requestOptions.timeout;
                }
                if (requestOptions.onUploadProgress) {
                    request.onUploadProgress = requestOptions.onUploadProgress;
                }
                if (requestOptions.onDownloadProgress) {
                    request.onDownloadProgress = requestOptions.onDownloadProgress;
                }
                if (requestOptions.shouldDeserialize !== undefined) {
                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
                }
                if (requestOptions.allowInsecureConnection) {
                    request.allowInsecureConnection = true;
                }
            }
            if (options.abortSignal) {
                request.abortSignal = options.abortSignal;
            }
            if (options.tracingOptions) {
                request.tracingOptions = options.tracingOptions;
            }
        }
        if (this._allowInsecureConnection) {
            request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === undefined) {
            request.streamResponseStatusCodes = (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_5__.getStreamingResponseStatusCodes)(operationSpec);
        }
        try {
            const rawResponse = await this.sendRequest(request);
            const flatResponse = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
            return flatResponse;
        }
        catch (error) {
            if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
                const rawResponse = error.response;
                const flatResponse = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
                error.details = flatResponse;
                if (options === null || options === void 0 ? void 0 : options.onResponse) {
                    options.onResponse(rawResponse, flatResponse, error);
                }
            }
            throw error;
        }
    }
}
function createDefaultPipeline(options) {
    const credentialScopes = getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes
        ? { credentialScopes, credential: options.credential }
        : undefined;
    return (0,_pipeline__WEBPACK_IMPORTED_MODULE_7__.createClientPipeline)(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
    if (options.credentialScopes) {
        const scopes = options.credentialScopes;
        return Array.isArray(scopes)
            ? scopes.map((scope) => new URL(scope).toString())
            : new URL(scopes).toString();
    }
    if (options.endpoint) {
        return `${options.endpoint}/.default`;
    }
    if (options.baseUri) {
        return `${options.baseUri}/.default`;
    }
    if (options.credential && !options.credentialScopes) {
        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return undefined;
}
//# sourceMappingURL=serviceClient.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/urlHelpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/urlHelpers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendQueryParams": () => (/* binding */ appendQueryParams),
/* harmony export */   "getRequestUrl": () => (/* binding */ getRequestUrl)
/* harmony export */ });
/* harmony import */ var _operationHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./operationHelpers */ "./node_modules/@azure/core-client/dist-esm/src/operationHelpers.js");
/* harmony import */ var _interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interfaceHelpers */ "./node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|",
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
        let path = replaceAll(operationSpec.path, urlReplacements);
        // QUIRK: sometimes we get a path component like /{nextLink}
        // which may be a fully formed URL with a leading /. In that case, we should
        // remove the leading /
        if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
            path = path.substring(1);
        }
        // QUIRK: sometimes we get a path component like {nextLink}
        // which may be a fully formed URL. In that case, we should
        // ignore the baseUri.
        if (isAbsoluteUrl(path)) {
            requestUrl = path;
            isAbsolutePath = true;
        }
        else {
            requestUrl = appendPath(requestUrl, path);
        }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    /**
     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`
     * is an absolute path. This ensures that existing query parameter values in `requestUrl`
     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it
     * is still being built so there is nothing to overwrite.
     */
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
}
function replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
        result = result.split(searchValue).join(replaceValue);
    }
    return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {
        for (const urlParameter of operationSpec.urlParameters) {
            let urlParameterValue = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
            const parameterPathString = (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(urlParameter);
            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
            if (!urlParameter.skipEncoding) {
                urlParameterValue = encodeURIComponent(urlParameterValue);
            }
            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
        }
    }
    return result;
}
function isAbsoluteUrl(url) {
    return url.includes("://");
}
function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
        return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
        newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
        pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
        const path = pathToAppend.substring(0, searchStart);
        const search = pathToAppend.substring(searchStart + 1);
        newPath = newPath + path;
        if (search) {
            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
        }
    }
    else {
        newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    const sequenceParams = new Set();
    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {
        for (const queryParameter of operationSpec.queryParameters) {
            if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
                sequenceParams.add(queryParameter.mapper.serializedName);
            }
            let queryParameterValue = (0,_operationHelpers__WEBPACK_IMPORTED_MODULE_0__.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||
                queryParameter.mapper.required) {
                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(queryParameter));
                const delimiter = queryParameter.collectionFormat
                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]
                    : "";
                if (Array.isArray(queryParameterValue)) {
                    // replace null and undefined
                    queryParameterValue = queryParameterValue.map((item) => {
                        if (item === null || item === undefined) {
                            return "";
                        }
                        return item;
                    });
                }
                if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
                    continue;
                }
                else if (Array.isArray(queryParameterValue) &&
                    (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
                    queryParameterValue = queryParameterValue.join(delimiter);
                }
                if (!queryParameter.skipEncoding) {
                    if (Array.isArray(queryParameterValue)) {
                        queryParameterValue = queryParameterValue.map((item) => {
                            return encodeURIComponent(item);
                        });
                    }
                    else {
                        queryParameterValue = encodeURIComponent(queryParameterValue);
                    }
                }
                // Join pipes and CSV *after* encoding, or the server will be upset.
                if (Array.isArray(queryParameterValue) &&
                    (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
                    queryParameterValue = queryParameterValue.join(delimiter);
                }
                result.set(queryParameter.mapper.serializedName || (0,_interfaceHelpers__WEBPACK_IMPORTED_MODULE_1__.getPathStringFromParameter)(queryParameter), queryParameterValue);
            }
        }
    }
    return {
        queryParams: result,
        sequenceParams,
    };
}
function simpleParseQueryParams(queryString) {
    const result = new Map();
    if (!queryString || queryString[0] !== "?") {
        return result;
    }
    // remove the leading ?
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
        const [name, value] = pair.split("=", 2);
        const existingValue = result.get(name);
        if (existingValue) {
            if (Array.isArray(existingValue)) {
                existingValue.push(value);
            }
            else {
                result.set(name, [existingValue, value]);
            }
        }
        else {
            result.set(name, value);
        }
    }
    return result;
}
/** @internal */
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
        return url;
    }
    const parsedUrl = new URL(url);
    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which
    // can change their meaning to the server, such as in the case of a SAS signature.
    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
        const existingValue = combinedParams.get(name);
        if (Array.isArray(existingValue)) {
            if (Array.isArray(value)) {
                existingValue.push(...value);
                const valueSet = new Set(existingValue);
                combinedParams.set(name, Array.from(valueSet));
            }
            else {
                existingValue.push(value);
            }
        }
        else if (existingValue) {
            if (Array.isArray(value)) {
                value.unshift(existingValue);
            }
            else if (sequenceParams.has(name)) {
                combinedParams.set(name, [existingValue, value]);
            }
            if (!noOverwrite) {
                combinedParams.set(name, value);
            }
        }
        else {
            combinedParams.set(name, value);
        }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
        if (typeof value === "string") {
            searchPieces.push(`${name}=${value}`);
        }
        else if (Array.isArray(value)) {
            // QUIRK: If we get an array of values, include multiple key/value pairs
            for (const subValue of value) {
                searchPieces.push(`${name}=${subValue}`);
            }
        }
        else {
            searchPieces.push(`${name}=${value}`);
        }
    }
    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
}
//# sourceMappingURL=urlHelpers.js.map

/***/ }),

/***/ "./node_modules/@azure/core-client/dist-esm/src/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@azure/core-client/dist-esm/src/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flattenResponse": () => (/* binding */ flattenResponse),
/* harmony export */   "isDuration": () => (/* binding */ isDuration),
/* harmony export */   "isPrimitiveBody": () => (/* binding */ isPrimitiveBody),
/* harmony export */   "isValidUuid": () => (/* binding */ isValidUuid)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A type guard for a primitive response body.
 * @param value - Value to test
 *
 * @internal
 */
function isPrimitiveBody(value, mapperTypeName) {
    return (mapperTypeName !== "Composite" &&
        mapperTypeName !== "Dictionary" &&
        (typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean" ||
            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==
                null ||
            value === undefined ||
            value === null));
}
const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
/**
 * Returns true if the given string is in ISO 8601 format.
 * @param value - The value to be validated for ISO 8601 duration format.
 * @internal
 */
function isDuration(value) {
    return validateISODuration.test(value);
}
const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Returns true if the provided uuid is valid.
 *
 * @param uuid - The uuid that needs to be validated.
 *
 * @internal
 */
function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
}
/**
 * Maps the response as follows:
 * - wraps the response body if needed (typically if its type is primitive).
 * - returns null if the combination of the headers and the body is empty.
 * - otherwise, returns the combination of the headers and the body.
 *
 * @param responseObject - a representation of the parsed response
 * @returns the response that will be returned to the user which can be null and/or wrapped
 *
 * @internal
 */
function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType &&
        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
        return responseObject.shouldWrapBody ? { body: null } : null;
    }
    else {
        return responseObject.shouldWrapBody
            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
    }
}
/**
 * Take a `FullOperationResponse` and turn it into a flat
 * response object to hand back to the consumer.
 * @param fullResponse - The processed response from the operation request
 * @param responseSpec - The response map from the OperationSpec
 *
 * @internal
 */
function flattenResponse(fullResponse, responseSpec) {
    var _a, _b;
    const parsedHeaders = fullResponse.parsedHeaders;
    // head methods never have a body, but we return a boolean set to body property
    // to indicate presence/absence of the resource
    if (fullResponse.request.method === "HEAD") {
        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
    /** If the body is asked for, we look at the expected body type to handle it */
    if (expectedBodyTypeName === "Stream") {
        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
    }
    const modelProperties = (expectedBodyTypeName === "Composite" &&
        bodyMapper.type.modelProperties) ||
        {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];
        for (const key of Object.keys(modelProperties)) {
            if (modelProperties[key].serializedName) {
                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
            }
        }
        if (parsedHeaders) {
            for (const key of Object.keys(parsedHeaders)) {
                arrayResponse[key] = parsedHeaders[key];
            }
        }
        return isNullable &&
            !fullResponse.parsedBody &&
            !parsedHeaders &&
            Object.getOwnPropertyNames(modelProperties).length === 0
            ? null
            : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
        body: fullResponse.parsedBody,
        headers: parsedHeaders,
        hasNullableType: isNullable,
        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),
    });
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPagedAsyncIterator": () => (/* binding */ getPagedAsyncIterator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * returns an async iterator that iterates over results. It also has a `byPage`
 * method that returns pages of items at once.
 *
 * @param pagedResult - an object that specifies how to get pages.
 * @returns a paged async iterator that iterates over results.
 */
function getPagedAsyncIterator(pagedResult) {
    var _a;
    const iter = getItemAsyncIterator(pagedResult);
    return {
        next() {
            return iter.next();
        },
        [Symbol.asyncIterator]() {
            return this;
        },
        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : ((settings) => {
            const { continuationToken, maxPageSize } = settings !== null && settings !== void 0 ? settings : {};
            return getPageAsyncIterator(pagedResult, {
                pageLink: continuationToken,
                maxPageSize,
            });
        }),
    };
}
function getItemAsyncIterator(pagedResult) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function* getItemAsyncIterator_1() {
        var e_1, _a;
        const pages = getPageAsyncIterator(pagedResult);
        const firstVal = yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(pages.next());
        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is
        if (!Array.isArray(firstVal.value)) {
            yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(firstVal.value);
            // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case
            yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(yield* (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncDelegator)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncValues)(pages)));
        }
        else {
            yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(yield* (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncDelegator)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncValues)(firstVal.value)));
            try {
                for (var pages_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncValues)(pages), pages_1_1; pages_1_1 = yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(pages_1.next()), !pages_1_1.done;) {
                    const page = pages_1_1.value;
                    // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,
                    // it must be the case that `TPage = TElement[]`
                    yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(yield* (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncDelegator)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncValues)(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(_a.call(pages_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    });
}
function getPageAsyncIterator(pagedResult, options = {}) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function* getPageAsyncIterator_1() {
        const { pageLink, maxPageSize } = options;
        let response = yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));
        yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(response.page);
        while (response.nextPageLink) {
            response = yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(pagedResult.getPage(response.nextPageLink, maxPageSize));
            yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(response.page);
        }
    });
}
//# sourceMappingURL=getPagedAsyncIterator.js.map

/***/ }),

/***/ "./node_modules/@azure/core-paging/dist-esm/src/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@azure/core-paging/dist-esm/src/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPagedAsyncIterator": () => (/* reexport safe */ _getPagedAsyncIterator__WEBPACK_IMPORTED_MODULE_1__.getPagedAsyncIterator)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ "./node_modules/@azure/core-paging/dist-esm/src/models.js");
/* harmony import */ var _getPagedAsyncIterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getPagedAsyncIterator */ "./node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@azure/core-paging/dist-esm/src/models.js":
/*!****************************************************************!*\
  !*** ./node_modules/@azure/core-paging/dist-esm/src/models.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

//# sourceMappingURL=models.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RETRY_POLICY_COUNT": () => (/* binding */ DEFAULT_RETRY_POLICY_COUNT),
/* harmony export */   "SDK_VERSION": () => (/* binding */ SDK_VERSION)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.9.2";
const DEFAULT_RETRY_POLICY_COUNT = 3;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPipelineFromOptions": () => (/* binding */ createPipelineFromOptions)
/* harmony export */ });
/* harmony import */ var _policies_logPolicy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./policies/logPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js");
/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js");
/* harmony import */ var _policies_redirectPolicy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./policies/redirectPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js");
/* harmony import */ var _policies_userAgentPolicy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./policies/userAgentPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js");
/* harmony import */ var _policies_decompressResponsePolicy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./policies/decompressResponsePolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.js");
/* harmony import */ var _policies_defaultRetryPolicy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./policies/defaultRetryPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js");
/* harmony import */ var _policies_formDataPolicy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./policies/formDataPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js");
/* harmony import */ var _azure_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-util */ "./node_modules/@azure/core-util/dist-esm/src/isNode.js");
/* harmony import */ var _policies_proxyPolicy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./policies/proxyPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.js");
/* harmony import */ var _policies_setClientRequestIdPolicy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./policies/setClientRequestIdPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js");
/* harmony import */ var _policies_tlsPolicy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./policies/tlsPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js");
/* harmony import */ var _policies_tracingPolicy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./policies/tracingPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.












/**
 * Create a new pipeline with a default set of customizable policies.
 * @param options - Options to configure a custom pipeline.
 */
function createPipelineFromOptions(options) {
    const pipeline = (0,_pipeline__WEBPACK_IMPORTED_MODULE_0__.createEmptyPipeline)();
    if (_azure_core_util__WEBPACK_IMPORTED_MODULE_1__.isNode) {
        if (options.tlsOptions) {
            pipeline.addPolicy((0,_policies_tlsPolicy__WEBPACK_IMPORTED_MODULE_2__.tlsPolicy)(options.tlsOptions));
        }
        pipeline.addPolicy((0,_policies_proxyPolicy__WEBPACK_IMPORTED_MODULE_3__.proxyPolicy)(options.proxyOptions));
        pipeline.addPolicy((0,_policies_decompressResponsePolicy__WEBPACK_IMPORTED_MODULE_4__.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0,_policies_formDataPolicy__WEBPACK_IMPORTED_MODULE_5__.formDataPolicy)());
    pipeline.addPolicy((0,_policies_userAgentPolicy__WEBPACK_IMPORTED_MODULE_6__.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0,_policies_setClientRequestIdPolicy__WEBPACK_IMPORTED_MODULE_7__.setClientRequestIdPolicy)());
    pipeline.addPolicy((0,_policies_defaultRetryPolicy__WEBPACK_IMPORTED_MODULE_8__.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    pipeline.addPolicy((0,_policies_tracingPolicy__WEBPACK_IMPORTED_MODULE_9__.tracingPolicy)(options.userAgentOptions), { afterPhase: "Retry" });
    if (_azure_core_util__WEBPACK_IMPORTED_MODULE_1__.isNode) {
        // Both XHR and Fetch expect to handle redirects automatically,
        // so only include this policy when we're in Node.
        pipeline.addPolicy((0,_policies_redirectPolicy__WEBPACK_IMPORTED_MODULE_10__.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0,_policies_logPolicy__WEBPACK_IMPORTED_MODULE_11__.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
}
//# sourceMappingURL=createPipelineFromOptions.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDefaultHttpClient": () => (/* binding */ createDefaultHttpClient)
/* harmony export */ });
/* harmony import */ var _nodeHttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodeHttpClient */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/nodeHttpClient.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Create the correct HttpClient for the current environment.
 */
function createDefaultHttpClient() {
    return (0,_nodeHttpClient__WEBPACK_IMPORTED_MODULE_0__.createNodeHttpClient)();
}
//# sourceMappingURL=defaultHttpClient.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createHttpHeaders": () => (/* binding */ createHttpHeaders)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function normalizeName(name) {
    return name.toLowerCase();
}
function* headerIterator(map) {
    for (const entry of map.values()) {
        yield [entry.name, entry.value];
    }
}
class HttpHeadersImpl {
    constructor(rawHeaders) {
        this._headersMap = new Map();
        if (rawHeaders) {
            for (const headerName of Object.keys(rawHeaders)) {
                this.set(headerName, rawHeaders[headerName]);
            }
        }
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param name - The name of the header to set. This value is case-insensitive.
     * @param value - The value of the header to set.
     */
    set(name, value) {
        this._headersMap.set(normalizeName(name), { name, value: String(value) });
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param name - The name of the header. This value is case-insensitive.
     */
    get(name) {
        var _a;
        return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     * @param name - The name of the header to set. This value is case-insensitive.
     */
    has(name) {
        return this._headersMap.has(normalizeName(name));
    }
    /**
     * Remove the header with the provided headerName.
     * @param name - The name of the header to remove.
     */
    delete(name) {
        this._headersMap.delete(normalizeName(name));
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
    toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
            for (const entry of this._headersMap.values()) {
                result[entry.name] = entry.value;
            }
        }
        else {
            for (const [normalizedName, entry] of this._headersMap) {
                result[normalizedName] = entry.value;
            }
        }
        return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
    toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    /**
     * Iterate over tuples of header [name, value] pairs.
     */
    [Symbol.iterator]() {
        return headerIterator(this._headersMap);
    }
}
/**
 * Creates an object that satisfies the `HttpHeaders` interface.
 * @param rawHeaders - A simple object representing initial headers
 */
function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
}
//# sourceMappingURL=httpHeaders.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js":
/*!********************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logger": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _azure_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/logger */ "./node_modules/@azure/logger/dist-esm/src/index.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const logger = (0,_azure_logger__WEBPACK_IMPORTED_MODULE_0__.createClientLogger)("core-rest-pipeline");
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/nodeHttpClient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/nodeHttpClient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createNodeHttpClient": () => (/* binding */ createNodeHttpClient),
/* harmony export */   "getBodyLength": () => (/* binding */ getBodyLength)
/* harmony export */ });
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ "zlib");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _azure_abort_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @azure/abort-controller */ "./node_modules/@azure/abort-controller/dist-esm/src/AbortController.js");
/* harmony import */ var _httpHeaders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./httpHeaders */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js");
/* harmony import */ var _restError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./restError */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








const DEFAULT_TLS_SETTINGS = {};
function isReadableStream(body) {
    return body && typeof body.pipe === "function";
}
function isStreamComplete(stream) {
    return new Promise((resolve) => {
        stream.on("close", resolve);
        stream.on("end", resolve);
        stream.on("error", resolve);
    });
}
function isArrayBuffer(body) {
    return body && typeof body.byteLength === "number";
}
class ReportTransform extends stream__WEBPACK_IMPORTED_MODULE_3__.Transform {
    constructor(progressCallback) {
        super();
        this.loadedBytes = 0;
        this.progressCallback = progressCallback;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
            this.progressCallback({ loadedBytes: this.loadedBytes });
            callback();
        }
        catch (e) {
            callback(e);
        }
    }
}
/**
 * A HttpClient implementation that uses Node's "https" module to send HTTPS requests.
 * @internal
 */
class NodeHttpClient {
    constructor() {
        this.cachedHttpsAgents = new WeakMap();
    }
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */
    async sendRequest(request) {
        var _a, _b, _c;
        const abortController = new _azure_abort_controller__WEBPACK_IMPORTED_MODULE_4__.AbortController();
        let abortListener;
        if (request.abortSignal) {
            if (request.abortSignal.aborted) {
                throw new _azure_abort_controller__WEBPACK_IMPORTED_MODULE_4__.AbortError("The operation was aborted.");
            }
            abortListener = (event) => {
                if (event.type === "abort") {
                    abortController.abort();
                }
            };
            request.abortSignal.addEventListener("abort", abortListener);
        }
        if (request.timeout > 0) {
            setTimeout(() => {
                abortController.abort();
            }, request.timeout);
        }
        const acceptEncoding = request.headers.get("Accept-Encoding");
        const shouldDecompress = (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("deflate"));
        let body = typeof request.body === "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
            const bodyLength = getBodyLength(body);
            if (bodyLength !== null) {
                request.headers.set("Content-Length", bodyLength);
            }
        }
        let responseStream;
        try {
            if (body && request.onUploadProgress) {
                const onUploadProgress = request.onUploadProgress;
                const uploadReportStream = new ReportTransform(onUploadProgress);
                uploadReportStream.on("error", (e) => {
                    _log__WEBPACK_IMPORTED_MODULE_5__.logger.error("Error in upload progress", e);
                });
                if (isReadableStream(body)) {
                    body.pipe(uploadReportStream);
                }
                else {
                    uploadReportStream.end(body);
                }
                body = uploadReportStream;
            }
            const res = await this.makeRequest(request, abortController, body);
            const headers = getResponseHeaders(res);
            const status = (_a = res.statusCode) !== null && _a !== void 0 ? _a : 0;
            const response = {
                status,
                headers,
                request,
            };
            // Responses to HEAD must not have a body.
            // If they do return a body, that body must be ignored.
            if (request.method === "HEAD") {
                res.destroy();
                return response;
            }
            responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
            const onDownloadProgress = request.onDownloadProgress;
            if (onDownloadProgress) {
                const downloadReportStream = new ReportTransform(onDownloadProgress);
                downloadReportStream.on("error", (e) => {
                    _log__WEBPACK_IMPORTED_MODULE_5__.logger.error("Error in download progress", e);
                });
                responseStream.pipe(downloadReportStream);
                responseStream = downloadReportStream;
            }
            if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(Number.POSITIVE_INFINITY)) ||
                ((_c = request.streamResponseStatusCodes) === null || _c === void 0 ? void 0 : _c.has(response.status))) {
                response.readableStreamBody = responseStream;
            }
            else {
                response.bodyAsText = await streamToText(responseStream);
            }
            return response;
        }
        finally {
            // clean up event listener
            if (request.abortSignal && abortListener) {
                let uploadStreamDone = Promise.resolve();
                if (isReadableStream(body)) {
                    uploadStreamDone = isStreamComplete(body);
                }
                let downloadStreamDone = Promise.resolve();
                if (isReadableStream(responseStream)) {
                    downloadStreamDone = isStreamComplete(responseStream);
                }
                Promise.all([uploadStreamDone, downloadStreamDone])
                    .then(() => {
                    var _a;
                    // eslint-disable-next-line promise/always-return
                    if (abortListener) {
                        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortListener);
                    }
                })
                    .catch((e) => {
                    _log__WEBPACK_IMPORTED_MODULE_5__.logger.warning("Error when cleaning up abortListener on httpRequest", e);
                });
            }
        }
    }
    makeRequest(request, abortController, body) {
        var _a;
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const agent = (_a = request.agent) !== null && _a !== void 0 ? _a : this.getOrCreateAgent(request, isInsecure);
        const options = {
            agent,
            hostname: url.hostname,
            path: `${url.pathname}${url.search}`,
            port: url.port,
            method: request.method,
            headers: request.headers.toJSON({ preserveCase: true }),
        };
        return new Promise((resolve, reject) => {
            const req = isInsecure ? http__WEBPACK_IMPORTED_MODULE_0__.request(options, resolve) : https__WEBPACK_IMPORTED_MODULE_1__.request(options, resolve);
            req.once("error", (err) => {
                var _a;
                reject(new _restError__WEBPACK_IMPORTED_MODULE_6__.RestError(err.message, { code: (_a = err.code) !== null && _a !== void 0 ? _a : _restError__WEBPACK_IMPORTED_MODULE_6__.RestError.REQUEST_SEND_ERROR, request }));
            });
            abortController.signal.addEventListener("abort", () => {
                const abortError = new _azure_abort_controller__WEBPACK_IMPORTED_MODULE_4__.AbortError("The operation was aborted.");
                req.destroy(abortError);
                reject(abortError);
            });
            if (body && isReadableStream(body)) {
                body.pipe(req);
            }
            else if (body) {
                if (typeof body === "string" || Buffer.isBuffer(body)) {
                    req.end(body);
                }
                else if (isArrayBuffer(body)) {
                    req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
                }
                else {
                    _log__WEBPACK_IMPORTED_MODULE_5__.logger.error("Unrecognized body type", body);
                    reject(new _restError__WEBPACK_IMPORTED_MODULE_6__.RestError("Unrecognized body type"));
                }
            }
            else {
                // streams don't like "undefined" being passed as data
                req.end();
            }
        });
    }
    getOrCreateAgent(request, isInsecure) {
        var _a;
        const disableKeepAlive = request.disableKeepAlive;
        // Handle Insecure requests first
        if (isInsecure) {
            if (disableKeepAlive) {
                // keepAlive:false is the default so we don't need a custom Agent
                return http__WEBPACK_IMPORTED_MODULE_0__.globalAgent;
            }
            if (!this.cachedHttpAgent) {
                // If there is no cached agent create a new one and cache it.
                this.cachedHttpAgent = new http__WEBPACK_IMPORTED_MODULE_0__.Agent({ keepAlive: true });
            }
            return this.cachedHttpAgent;
        }
        else {
            if (disableKeepAlive && !request.tlsSettings) {
                // When there are no tlsSettings and keepAlive is false
                // we don't need a custom agent
                return https__WEBPACK_IMPORTED_MODULE_1__.globalAgent;
            }
            // We use the tlsSettings to index cached clients
            const tlsSettings = (_a = request.tlsSettings) !== null && _a !== void 0 ? _a : DEFAULT_TLS_SETTINGS;
            // Get the cached agent or create a new one with the
            // provided values for keepAlive and tlsSettings
            let agent = this.cachedHttpsAgents.get(tlsSettings);
            if (agent && agent.options.keepAlive === !disableKeepAlive) {
                return agent;
            }
            _log__WEBPACK_IMPORTED_MODULE_5__.logger.info("No cached TLS Agent exist, creating a new Agent");
            agent = new https__WEBPACK_IMPORTED_MODULE_1__.Agent(Object.assign({ 
                // keepAlive is true if disableKeepAlive is false.
                keepAlive: !disableKeepAlive }, tlsSettings));
            this.cachedHttpsAgents.set(tlsSettings, agent);
            return agent;
        }
    }
}
function getResponseHeaders(res) {
    const headers = (0,_httpHeaders__WEBPACK_IMPORTED_MODULE_7__.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        if (Array.isArray(value)) {
            if (value.length > 0) {
                headers.set(header, value[0]);
            }
        }
        else if (value) {
            headers.set(header, value);
        }
    }
    return headers;
}
function getDecodedResponseStream(stream, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
        const unzip = zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip();
        stream.pipe(unzip);
        return unzip;
    }
    else if (contentEncoding === "deflate") {
        const inflate = zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate();
        stream.pipe(inflate);
        return inflate;
    }
    return stream;
}
function streamToText(stream) {
    return new Promise((resolve, reject) => {
        const buffer = [];
        stream.on("data", (chunk) => {
            if (Buffer.isBuffer(chunk)) {
                buffer.push(chunk);
            }
            else {
                buffer.push(Buffer.from(chunk));
            }
        });
        stream.on("end", () => {
            resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream.on("error", (e) => {
            if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
                reject(e);
            }
            else {
                reject(new _restError__WEBPACK_IMPORTED_MODULE_6__.RestError(`Error reading response as text: ${e.message}`, {
                    code: _restError__WEBPACK_IMPORTED_MODULE_6__.RestError.PARSE_ERROR,
                }));
            }
        });
    });
}
/** @internal */
function getBodyLength(body) {
    if (!body) {
        return 0;
    }
    else if (Buffer.isBuffer(body)) {
        return body.length;
    }
    else if (isReadableStream(body)) {
        return null;
    }
    else if (isArrayBuffer(body)) {
        return body.byteLength;
    }
    else if (typeof body === "string") {
        return Buffer.from(body).length;
    }
    else {
        return null;
    }
}
/**
 * Create a new HttpClient instance for the NodeJS environment.
 * @internal
 */
function createNodeHttpClient() {
    return new NodeHttpClient();
}
//# sourceMappingURL=nodeHttpClient.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEmptyPipeline": () => (/* binding */ createEmptyPipeline)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
/**
 * A private implementation of Pipeline.
 * Do not export this class from the package.
 * @internal
 */
class HttpPipeline {
    constructor(policies = []) {
        this._policies = [];
        this._policies = policies;
        this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
            throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
            throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
            policy,
            options,
        });
        this._orderedPolicies = undefined;
    }
    removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
            if ((options.name && policyDescriptor.policy.name === options.name) ||
                (options.phase && policyDescriptor.options.phase === options.phase)) {
                removedPolicies.push(policyDescriptor.policy);
                return false;
            }
            else {
                return true;
            }
        });
        this._orderedPolicies = undefined;
        return removedPolicies;
    }
    sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
            return (req) => {
                return policy.sendRequest(req, next);
            };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
    }
    getOrderedPolicies() {
        if (!this._orderedPolicies) {
            this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
    }
    clone() {
        return new HttpPipeline(this._policies);
    }
    static create() {
        return new HttpPipeline();
    }
    orderPolicies() {
        /**
         * The goal of this method is to reliably order pipeline policies
         * based on their declared requirements when they were added.
         *
         * Order is first determined by phase:
         *
         * 1. Serialize Phase
         * 2. Policies not in a phase
         * 3. Deserialize Phase
         * 4. Retry Phase
         * 5. Sign Phase
         *
         * Within each phase, policies are executed in the order
         * they were added unless they were specified to execute
         * before/after other policies or after a particular phase.
         *
         * To determine the final order, we will walk the policy list
         * in phase order multiple times until all dependencies are
         * satisfied.
         *
         * `afterPolicies` are the set of policies that must be
         * executed before a given policy. This requirement is
         * considered satisfied when each of the listed policies
         * have been scheduled.
         *
         * `beforePolicies` are the set of policies that must be
         * executed after a given policy. Since this dependency
         * can be expressed by converting it into a equivalent
         * `afterPolicies` declarations, they are normalized
         * into that form for simplicity.
         *
         * An `afterPhase` dependency is considered satisfied when all
         * policies in that phase have scheduled.
         *
         */
        const result = [];
        // Track all policies we know about.
        const policyMap = new Map();
        function createPhase(name) {
            return {
                name,
                policies: new Set(),
                hasRun: false,
                hasAfterPolicies: false,
            };
        }
        // Track policies for each phase.
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        // a list of phases in order
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        // Small helper function to map phase name to each Phase
        function getPhase(phase) {
            if (phase === "Retry") {
                return retryPhase;
            }
            else if (phase === "Serialize") {
                return serializePhase;
            }
            else if (phase === "Deserialize") {
                return deserializePhase;
            }
            else if (phase === "Sign") {
                return signPhase;
            }
            else {
                return noPhase;
            }
        }
        // First walk each policy and create a node to track metadata.
        for (const descriptor of this._policies) {
            const policy = descriptor.policy;
            const options = descriptor.options;
            const policyName = policy.name;
            if (policyMap.has(policyName)) {
                throw new Error("Duplicate policy names not allowed in pipeline");
            }
            const node = {
                policy,
                dependsOn: new Set(),
                dependants: new Set(),
            };
            if (options.afterPhase) {
                node.afterPhase = getPhase(options.afterPhase);
                node.afterPhase.hasAfterPolicies = true;
            }
            policyMap.set(policyName, node);
            const phase = getPhase(options.phase);
            phase.policies.add(node);
        }
        // Now that each policy has a node, connect dependency references.
        for (const descriptor of this._policies) {
            const { policy, options } = descriptor;
            const policyName = policy.name;
            const node = policyMap.get(policyName);
            if (!node) {
                throw new Error(`Missing node for policy ${policyName}`);
            }
            if (options.afterPolicies) {
                for (const afterPolicyName of options.afterPolicies) {
                    const afterNode = policyMap.get(afterPolicyName);
                    if (afterNode) {
                        // Linking in both directions helps later
                        // when we want to notify dependants.
                        node.dependsOn.add(afterNode);
                        afterNode.dependants.add(node);
                    }
                }
            }
            if (options.beforePolicies) {
                for (const beforePolicyName of options.beforePolicies) {
                    const beforeNode = policyMap.get(beforePolicyName);
                    if (beforeNode) {
                        // To execute before another node, make it
                        // depend on the current node.
                        beforeNode.dependsOn.add(node);
                        node.dependants.add(beforeNode);
                    }
                }
            }
        }
        function walkPhase(phase) {
            phase.hasRun = true;
            // Sets iterate in insertion order
            for (const node of phase.policies) {
                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
                    // If this node is waiting on a phase to complete,
                    // we need to skip it for now.
                    // Even if the phase is empty, we should wait for it
                    // to be walked to avoid re-ordering policies.
                    continue;
                }
                if (node.dependsOn.size === 0) {
                    // If there's nothing else we're waiting for, we can
                    // add this policy to the result list.
                    result.push(node.policy);
                    // Notify anything that depends on this policy that
                    // the policy has been scheduled.
                    for (const dependant of node.dependants) {
                        dependant.dependsOn.delete(node);
                    }
                    policyMap.delete(node.policy.name);
                    phase.policies.delete(node);
                }
            }
        }
        function walkPhases() {
            for (const phase of orderedPhases) {
                walkPhase(phase);
                // if the phase isn't complete
                if (phase.policies.size > 0 && phase !== noPhase) {
                    if (!noPhase.hasRun) {
                        // Try running noPhase to see if that unblocks this phase next tick.
                        // This can happen if a phase that happens before noPhase
                        // is waiting on a noPhase policy to complete.
                        walkPhase(noPhase);
                    }
                    // Don't proceed to the next phase until this phase finishes.
                    return;
                }
                if (phase.hasAfterPolicies) {
                    // Run any policies unblocked by this phase
                    walkPhase(noPhase);
                }
            }
        }
        // Iterate until we've put every node in the result list.
        let iteration = 0;
        while (policyMap.size > 0) {
            iteration++;
            const initialResultLength = result.length;
            // Keep walking each phase in order until we can order every node.
            walkPhases();
            // The result list *should* get at least one larger each time
            // after the first full pass.
            // Otherwise, we're going to loop forever.
            if (result.length <= initialResultLength && iteration > 1) {
                throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
            }
        }
        return result;
    }
}
/**
 * Creates a totally empty pipeline.
 * Useful for testing or creating a custom one.
 */
function createEmptyPipeline() {
    return HttpPipeline.create();
}
//# sourceMappingURL=pipeline.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPipelineRequest": () => (/* binding */ createPipelineRequest)
/* harmony export */ });
/* harmony import */ var _httpHeaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./httpHeaders */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js");
/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/uuid */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/uuid.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


class PipelineRequestImpl {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : (0,_httpHeaders__WEBPACK_IMPORTED_MODULE_0__.createHttpHeaders)();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || (0,_util_uuid__WEBPACK_IMPORTED_MODULE_1__.generateUuid)();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
    }
}
/**
 * Creates a new pipeline request with the given options.
 * This method is to allow for the easy setting of default values and not required.
 * @param options - The options to create the request with.
 */
function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
}
//# sourceMappingURL=pipelineRequest.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bearerTokenAuthenticationPolicy": () => (/* binding */ bearerTokenAuthenticationPolicy),
/* harmony export */   "bearerTokenAuthenticationPolicyName": () => (/* binding */ bearerTokenAuthenticationPolicyName)
/* harmony export */ });
/* harmony import */ var _util_tokenCycler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/tokenCycler */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../log */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
/**
 * Default authorize request handler
 */
async function defaultAuthorizeRequest(options) {
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions,
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
        return challenge;
    }
    return;
}
/**
 * A policy that can request a token from a TokenCredential implementation and
 * then apply it to the Authorization header of a request as a Bearer token.
 */
function bearerTokenAuthenticationPolicy(options) {
    var _a;
    const { credential, scopes, challengeCallbacks } = options;
    const logger = options.logger || _log__WEBPACK_IMPORTED_MODULE_0__.logger;
    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
    // This function encapsulates the entire process of reliably retrieving the token
    // The options are left out of the public API until there's demand to configure this.
    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
    // in order to pass through the `options` object.
    const getAccessToken = credential
        ? (0,_util_tokenCycler__WEBPACK_IMPORTED_MODULE_1__.createTokenCycler)(credential /* , options */)
        : () => Promise.resolve(null);
    return {
        name: bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request, next) {
            if (!request.url.toLowerCase().startsWith("https://")) {
                throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
            }
            await callbacks.authorizeRequest({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request,
                getAccessToken,
                logger,
            });
            let response;
            let error;
            try {
                response = await next(request);
            }
            catch (err) {
                error = err;
                response = err.response;
            }
            if (callbacks.authorizeRequestOnChallenge &&
                (response === null || response === void 0 ? void 0 : response.status) === 401 &&
                getChallenge(response)) {
                // processes challenge
                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    request,
                    response,
                    getAccessToken,
                    logger,
                });
                if (shouldSendRequest) {
                    return next(request);
                }
            }
            if (error) {
                throw error;
            }
            else {
                return response;
            }
        },
    };
}
//# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decompressResponsePolicy": () => (/* binding */ decompressResponsePolicy),
/* harmony export */   "decompressResponsePolicyName": () => (/* binding */ decompressResponsePolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the decompressResponsePolicy.
 */
const decompressResponsePolicyName = "decompressResponsePolicy";
/**
 * A policy to enable response decompression according to Accept-Encoding header
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
 */
function decompressResponsePolicy() {
    return {
        name: decompressResponsePolicyName,
        async sendRequest(request, next) {
            // HEAD requests have no body
            if (request.method !== "HEAD") {
                request.headers.set("Accept-Encoding", "gzip,deflate");
            }
            return next(request);
        },
    };
}
//# sourceMappingURL=decompressResponsePolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultRetryPolicy": () => (/* binding */ defaultRetryPolicy),
/* harmony export */   "defaultRetryPolicyName": () => (/* binding */ defaultRetryPolicyName)
/* harmony export */ });
/* harmony import */ var _retryStrategies_exponentialRetryStrategy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../retryStrategies/exponentialRetryStrategy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js");
/* harmony import */ var _retryStrategies_throttlingRetryStrategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../retryStrategies/throttlingRetryStrategy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js");
/* harmony import */ var _retryPolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retryPolicy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




/**
 * Name of the {@link defaultRetryPolicy}
 */
const defaultRetryPolicyName = "defaultRetryPolicy";
/**
 * A policy that retries according to three strategies:
 * - When the server sends a 429 response with a Retry-After header.
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
 */
function defaultRetryPolicy(options = {}) {
    var _a;
    return {
        name: defaultRetryPolicyName,
        sendRequest: (0,_retryPolicy__WEBPACK_IMPORTED_MODULE_0__.retryPolicy)([(0,_retryStrategies_throttlingRetryStrategy__WEBPACK_IMPORTED_MODULE_1__.throttlingRetryStrategy)(), (0,_retryStrategies_exponentialRetryStrategy__WEBPACK_IMPORTED_MODULE_2__.exponentialRetryStrategy)(options)], {
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : _constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_RETRY_POLICY_COUNT,
        }).sendRequest,
    };
}
//# sourceMappingURL=defaultRetryPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formDataPolicy": () => (/* binding */ formDataPolicy),
/* harmony export */   "formDataPolicyName": () => (/* binding */ formDataPolicyName)
/* harmony export */ });
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/form_data.js");
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The programmatic identifier of the formDataPolicy.
 */
const formDataPolicyName = "formDataPolicy";
/**
 * A policy that encodes FormData on the request into the body.
 */
function formDataPolicy() {
    return {
        name: formDataPolicyName,
        async sendRequest(request, next) {
            if (request.formData) {
                const contentType = request.headers.get("Content-Type");
                if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
                    request.body = wwwFormUrlEncode(request.formData);
                    request.formData = undefined;
                }
                else {
                    prepareFormData(request.formData, request);
                }
            }
            return next(request);
        },
    };
}
function wwwFormUrlEncode(formData) {
    const urlSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
            for (const subValue of value) {
                urlSearchParams.append(key, subValue.toString());
            }
        }
        else {
            urlSearchParams.append(key, value.toString());
        }
    }
    return urlSearchParams.toString();
}
async function prepareFormData(formData, request) {
    const requestForm = new (form_data__WEBPACK_IMPORTED_MODULE_0___default())();
    for (const formKey of Object.keys(formData)) {
        const formValue = formData[formKey];
        if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
                requestForm.append(formKey, subValue);
            }
        }
        else {
            requestForm.append(formKey, formValue);
        }
    }
    request.body = requestForm;
    request.formData = undefined;
    const contentType = request.headers.get("Content-Type");
    if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
        request.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
    }
    try {
        const contentLength = await new Promise((resolve, reject) => {
            requestForm.getLength((err, length) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(length);
                }
            });
        });
        request.headers.set("Content-Length", contentLength);
    }
    catch (e) {
        // ignore setting the length if this fails
    }
}
//# sourceMappingURL=formDataPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logPolicy": () => (/* binding */ logPolicy),
/* harmony export */   "logPolicyName": () => (/* binding */ logPolicyName)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../log */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js");
/* harmony import */ var _util_sanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/sanitizer */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


/**
 * The programmatic identifier of the logPolicy.
 */
const logPolicyName = "logPolicy";
/**
 * A policy that logs all requests and responses.
 * @param options - Options to configure logPolicy.
 */
function logPolicy(options = {}) {
    var _a;
    const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : _log__WEBPACK_IMPORTED_MODULE_0__.logger.info;
    const sanitizer = new _util_sanitizer__WEBPACK_IMPORTED_MODULE_1__.Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
    });
    return {
        name: logPolicyName,
        async sendRequest(request, next) {
            if (!logger.enabled) {
                return next(request);
            }
            logger(`Request: ${sanitizer.sanitize(request)}`);
            const response = await next(request);
            logger(`Response status code: ${response.status}`);
            logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
            return response;
        },
    };
}
//# sourceMappingURL=logPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultProxySettings": () => (/* binding */ getDefaultProxySettings),
/* harmony export */   "getProxyAgentOptions": () => (/* binding */ getProxyAgentOptions),
/* harmony export */   "globalNoProxyList": () => (/* binding */ globalNoProxyList),
/* harmony export */   "loadNoProxy": () => (/* binding */ loadNoProxy),
/* harmony export */   "proxyPolicy": () => (/* binding */ proxyPolicy),
/* harmony export */   "proxyPolicyName": () => (/* binding */ proxyPolicyName)
/* harmony export */ });
/* harmony import */ var https_proxy_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https-proxy-agent */ "./node_modules/https-proxy-agent/dist/index.js");
/* harmony import */ var https_proxy_agent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(https_proxy_agent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var http_proxy_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http-proxy-agent */ "./node_modules/http-proxy-agent/dist/index.js");
/* harmony import */ var http_proxy_agent__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http_proxy_agent__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



const HTTPS_PROXY = "HTTPS_PROXY";
const HTTP_PROXY = "HTTP_PROXY";
const ALL_PROXY = "ALL_PROXY";
const NO_PROXY = "NO_PROXY";
/**
 * The programmatic identifier of the proxyPolicy.
 */
const proxyPolicyName = "proxyPolicy";
/**
 * Stores the patterns specified in NO_PROXY environment variable.
 * @internal
 */
const globalNoProxyList = [];
let noProxyListLoaded = false;
/** A cache of whether a host should bypass the proxy. */
const globalBypassedMap = new Map();
function getEnvironmentValue(name) {
    if (process.env[name]) {
        return process.env[name];
    }
    else if (process.env[name.toLowerCase()]) {
        return process.env[name.toLowerCase()];
    }
    return undefined;
}
function loadEnvironmentProxyValue() {
    if (!process) {
        return undefined;
    }
    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
    const allProxy = getEnvironmentValue(ALL_PROXY);
    const httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
}
/**
 * Check whether the host of a given `uri` matches any pattern in the no proxy list.
 * If there's a match, any request sent to the same host shouldn't have the proxy settings set.
 * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210
 */
function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
        return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.has(host)) {
        return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
            // This should match either domain it self or any subdomain or host
            // .foo.com will match foo.com it self or *.foo.com
            if (host.endsWith(pattern)) {
                isBypassedFlag = true;
            }
            else {
                if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
                    isBypassedFlag = true;
                }
            }
        }
        else {
            if (host === pattern) {
                isBypassedFlag = true;
            }
        }
    }
    bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.set(host, isBypassedFlag);
    return isBypassedFlag;
}
function loadNoProxy() {
    const noProxy = getEnvironmentValue(NO_PROXY);
    noProxyListLoaded = true;
    if (noProxy) {
        return noProxy
            .split(",")
            .map((item) => item.trim())
            .filter((item) => item.length);
    }
    return [];
}
/**
 * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
 * If no argument is given, it attempts to parse a proxy URL from the environment
 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
 * @param proxyUrl - The url of the proxy to use. May contain authentication information.
 */
function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
            return undefined;
        }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password,
    };
}
/**
 * @internal
 */
function getProxyAgentOptions(proxySettings, { headers, tlsSettings }) {
    let parsedProxyUrl;
    try {
        parsedProxyUrl = new URL(proxySettings.host);
    }
    catch (_error) {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
    }
    if (tlsSettings) {
        _log__WEBPACK_IMPORTED_MODULE_2__.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const proxyAgentOptions = {
        hostname: parsedProxyUrl.hostname,
        port: proxySettings.port,
        protocol: parsedProxyUrl.protocol,
        headers: headers.toJSON(),
    };
    if (proxySettings.username && proxySettings.password) {
        proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;
    }
    else if (proxySettings.username) {
        proxyAgentOptions.auth = `${proxySettings.username}`;
    }
    return proxyAgentOptions;
}
function setProxyAgentOnRequest(request, cachedAgents) {
    // Custom Agent should take precedence so if one is present
    // we should skip to avoid overwriting it.
    if (request.agent) {
        return;
    }
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    const proxySettings = request.proxySettings;
    if (proxySettings) {
        if (isInsecure) {
            if (!cachedAgents.httpProxyAgent) {
                const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
                cachedAgents.httpProxyAgent = new http_proxy_agent__WEBPACK_IMPORTED_MODULE_1__.HttpProxyAgent(proxyAgentOptions);
            }
            request.agent = cachedAgents.httpProxyAgent;
        }
        else {
            if (!cachedAgents.httpsProxyAgent) {
                const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
                cachedAgents.httpsProxyAgent = new https_proxy_agent__WEBPACK_IMPORTED_MODULE_0__.HttpsProxyAgent(proxyAgentOptions);
            }
            request.agent = cachedAgents.httpsProxyAgent;
        }
    }
}
/**
 * A policy that allows one to apply proxy settings to all requests.
 * If not passed static settings, they will be retrieved from the HTTPS_PROXY
 * or HTTP_PROXY environment variables.
 * @param proxySettings - ProxySettings to use on each request.
 * @param options - additional settings, for example, custom NO_PROXY patterns
 */
function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
    if (!noProxyListLoaded) {
        globalNoProxyList.push(...loadNoProxy());
    }
    const cachedAgents = {};
    return {
        name: proxyPolicyName,
        async sendRequest(request, next) {
            var _a;
            if (!request.proxySettings &&
                !isBypassed(request.url, (_a = options === null || options === void 0 ? void 0 : options.customNoProxyList) !== null && _a !== void 0 ? _a : globalNoProxyList, (options === null || options === void 0 ? void 0 : options.customNoProxyList) ? undefined : globalBypassedMap)) {
                request.proxySettings = proxySettings;
            }
            if (request.proxySettings) {
                setProxyAgentOnRequest(request, cachedAgents);
            }
            return next(request);
        },
    };
}
//# sourceMappingURL=proxyPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "redirectPolicy": () => (/* binding */ redirectPolicy),
/* harmony export */   "redirectPolicyName": () => (/* binding */ redirectPolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the redirectPolicy.
 */
const redirectPolicyName = "redirectPolicy";
/**
 * Methods that are allowed to follow redirects 301 and 302
 */
const allowedRedirect = ["GET", "HEAD"];
/**
 * A policy to follow Location headers from the server in order
 * to support server-side redirection.
 * In the browser, this policy is not used.
 * @param options - Options to control policy behavior.
 */
function redirectPolicy(options = {}) {
    const { maxRetries = 20 } = options;
    return {
        name: redirectPolicyName,
        async sendRequest(request, next) {
            const response = await next(request);
            return handleRedirect(next, response, maxRetries);
        },
    };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader &&
        (status === 300 ||
            (status === 301 && allowedRedirect.includes(request.method)) ||
            (status === 302 && allowedRedirect.includes(request.method)) ||
            (status === 303 && request.method === "POST") ||
            status === 307) &&
        currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        // POST request with Status code 303 should be converted into a
        // redirected GET request if the redirect url is present in the location header
        if (status === 303) {
            request.method = "GET";
            request.headers.delete("Content-Length");
            delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
}
//# sourceMappingURL=redirectPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retryPolicy": () => (/* binding */ retryPolicy)
/* harmony export */ });
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/helpers */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js");
/* harmony import */ var _azure_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/logger */ "./node_modules/@azure/logger/dist-esm/src/index.js");
/* harmony import */ var _azure_abort_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @azure/abort-controller */ "./node_modules/@azure/abort-controller/dist-esm/src/AbortController.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




const retryPolicyLogger = (0,_azure_logger__WEBPACK_IMPORTED_MODULE_0__.createClientLogger)("core-rest-pipeline retryPolicy");
/**
 * The programmatic identifier of the retryPolicy.
 */
const retryPolicyName = "retryPolicy";
/**
 * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
 */
function retryPolicy(strategies, options = { maxRetries: _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger = options.logger || retryPolicyLogger;
    return {
        name: retryPolicyName,
        async sendRequest(request, next) {
            var _a, _b;
            let response;
            let responseError;
            let retryCount = -1;
            // eslint-disable-next-line no-constant-condition
            retryRequest: while (true) {
                retryCount += 1;
                response = undefined;
                responseError = undefined;
                try {
                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                    response = await next(request);
                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
                }
                catch (e) {
                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                    // RestErrors are valid targets for the retry strategies.
                    // If none of the retry strategies can work with them, they will be thrown later in this policy.
                    // If the received error is not a RestError, it is immediately thrown.
                    responseError = e;
                    if (!e || responseError.name !== "RestError") {
                        throw e;
                    }
                    response = responseError.response;
                }
                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    logger.error(`Retry ${retryCount}: Request aborted.`);
                    const abortError = new _azure_abort_controller__WEBPACK_IMPORTED_MODULE_2__.AbortError();
                    throw abortError;
                }
                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RETRY_POLICY_COUNT)) {
                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                    if (responseError) {
                        throw responseError;
                    }
                    else if (response) {
                        return response;
                    }
                    else {
                        throw new Error("Maximum retries reached with no response or error to throw");
                    }
                }
                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
                strategiesLoop: for (const strategy of strategies) {
                    const strategyLogger = strategy.logger || retryPolicyLogger;
                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                    const modifiers = strategy.retry({
                        retryCount,
                        response,
                        responseError,
                    });
                    if (modifiers.skipStrategy) {
                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                        continue strategiesLoop;
                    }
                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                    if (errorToThrow) {
                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                        throw errorToThrow;
                    }
                    if (retryAfterInMs || retryAfterInMs === 0) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                        await (0,_util_helpers__WEBPACK_IMPORTED_MODULE_3__.delay)(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                        continue retryRequest;
                    }
                    if (redirectTo) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                        request.url = redirectTo;
                        continue retryRequest;
                    }
                }
                if (responseError) {
                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
                    throw responseError;
                }
                if (response) {
                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);
                    return response;
                }
                // If all the retries skip and there's no response,
                // we're still in the retry loop, so a new request will be sent
                // until `maxRetries` is reached.
            }
        },
    };
}
//# sourceMappingURL=retryPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setClientRequestIdPolicy": () => (/* binding */ setClientRequestIdPolicy),
/* harmony export */   "setClientRequestIdPolicyName": () => (/* binding */ setClientRequestIdPolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the setClientRequestIdPolicy.
 */
const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
/**
 * Each PipelineRequest gets a unique id upon creation.
 * This policy passes that unique id along via an HTTP header to enable better
 * telemetry and tracing.
 * @param requestIdHeaderName - The name of the header to pass the request ID to.
 */
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
        name: setClientRequestIdPolicyName,
        async sendRequest(request, next) {
            if (!request.headers.has(requestIdHeaderName)) {
                request.headers.set(requestIdHeaderName, request.requestId);
            }
            return next(request);
        },
    };
}
//# sourceMappingURL=setClientRequestIdPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tlsPolicy": () => (/* binding */ tlsPolicy),
/* harmony export */   "tlsPolicyName": () => (/* binding */ tlsPolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Name of the TLS Policy
 */
const tlsPolicyName = "tlsPolicy";
/**
 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
 */
function tlsPolicy(tlsSettings) {
    return {
        name: tlsPolicyName,
        sendRequest: async (req, next) => {
            // Users may define a request tlsSettings, honor those over the client level one
            if (!req.tlsSettings) {
                req.tlsSettings = tlsSettings;
            }
            return next(req);
        },
    };
}
//# sourceMappingURL=tlsPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tracingPolicy": () => (/* binding */ tracingPolicy),
/* harmony export */   "tracingPolicyName": () => (/* binding */ tracingPolicyName)
/* harmony export */ });
/* harmony import */ var _azure_core_tracing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-tracing */ "./node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js");
/* harmony import */ var _util_userAgent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/userAgent */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../log */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js");
/* harmony import */ var _azure_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @azure/core-util */ "./node_modules/@azure/core-util/dist-esm/src/error.js");
/* harmony import */ var _restError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../restError */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.






/**
 * The programmatic identifier of the tracingPolicy.
 */
const tracingPolicyName = "tracingPolicy";
/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 * @param options - Options to configure the telemetry logged by the tracing policy.
 */
function tracingPolicy(options = {}) {
    const userAgent = (0,_util_userAgent__WEBPACK_IMPORTED_MODULE_0__.getUserAgentValue)(options.userAgentPrefix);
    const tracingClient = tryCreateTracingClient();
    return {
        name: tracingPolicyName,
        async sendRequest(request, next) {
            var _a, _b;
            if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {
                return next(request);
            }
            const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
            if (!span || !tracingContext) {
                return next(request);
            }
            try {
                const response = await tracingClient.withContext(tracingContext, next, request);
                tryProcessResponse(span, response);
                return response;
            }
            catch (err) {
                tryProcessError(span, err);
                throw err;
            }
        },
    };
}
function tryCreateTracingClient() {
    try {
        return (0,_azure_core_tracing__WEBPACK_IMPORTED_MODULE_1__.createTracingClient)({
            namespace: "",
            packageName: "@azure/core-rest-pipeline",
            packageVersion: _constants__WEBPACK_IMPORTED_MODULE_2__.SDK_VERSION,
        });
    }
    catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_3__.logger.warning(`Error when creating the TracingClient: ${(0,_azure_core_util__WEBPACK_IMPORTED_MODULE_4__.getErrorMessage)(e)}`);
        return undefined;
    }
}
function tryCreateSpan(tracingClient, request, userAgent) {
    try {
        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
            spanKind: "client",
            spanAttributes: {
                "http.method": request.method,
                "http.url": request.url,
                requestId: request.requestId,
            },
        });
        // If the span is not recording, don't do any more work.
        if (!span.isRecording()) {
            span.end();
            return undefined;
        }
        if (userAgent) {
            span.setAttribute("http.user_agent", userAgent);
        }
        // set headers
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) {
            request.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    }
    catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_3__.logger.warning(`Skipping creating a tracing span due to an error: ${(0,_azure_core_util__WEBPACK_IMPORTED_MODULE_4__.getErrorMessage)(e)}`);
        return undefined;
    }
}
function tryProcessError(span, error) {
    try {
        span.setStatus({
            status: "error",
            error: (0,_azure_core_util__WEBPACK_IMPORTED_MODULE_4__.isError)(error) ? error : undefined,
        });
        if ((0,_restError__WEBPACK_IMPORTED_MODULE_5__.isRestError)(error) && error.statusCode) {
            span.setAttribute("http.status_code", error.statusCode);
        }
        span.end();
    }
    catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_3__.logger.warning(`Skipping tracing span processing due to an error: ${(0,_azure_core_util__WEBPACK_IMPORTED_MODULE_4__.getErrorMessage)(e)}`);
    }
}
function tryProcessResponse(span, response) {
    try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) {
            span.setAttribute("serviceRequestId", serviceRequestId);
        }
        span.setStatus({
            status: "success",
        });
        span.end();
    }
    catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_3__.logger.warning(`Skipping tracing span processing due to an error: ${(0,_azure_core_util__WEBPACK_IMPORTED_MODULE_4__.getErrorMessage)(e)}`);
    }
}
//# sourceMappingURL=tracingPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "userAgentPolicy": () => (/* binding */ userAgentPolicy),
/* harmony export */   "userAgentPolicyName": () => (/* binding */ userAgentPolicyName)
/* harmony export */ });
/* harmony import */ var _util_userAgent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/userAgent */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const UserAgentHeaderName = (0,_util_userAgent__WEBPACK_IMPORTED_MODULE_0__.getUserAgentHeaderName)();
/**
 * The programmatic identifier of the userAgentPolicy.
 */
const userAgentPolicyName = "userAgentPolicy";
/**
 * A policy that sets the User-Agent header (or equivalent) to reflect
 * the library version.
 * @param options - Options to customize the user agent value.
 */
function userAgentPolicy(options = {}) {
    const userAgentValue = (0,_util_userAgent__WEBPACK_IMPORTED_MODULE_0__.getUserAgentValue)(options.userAgentPrefix);
    return {
        name: userAgentPolicyName,
        async sendRequest(request, next) {
            if (!request.headers.has(UserAgentHeaderName)) {
                request.headers.set(UserAgentHeaderName, userAgentValue);
            }
            return next(request);
        },
    };
}
//# sourceMappingURL=userAgentPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RestError": () => (/* binding */ RestError),
/* harmony export */   "isRestError": () => (/* binding */ isRestError)
/* harmony export */ });
/* harmony import */ var _azure_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @azure/core-util */ "./node_modules/@azure/core-util/dist-esm/src/error.js");
/* harmony import */ var _util_inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/inspect */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.js");
/* harmony import */ var _util_sanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/sanitizer */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



const errorSanitizer = new _util_sanitizer__WEBPACK_IMPORTED_MODULE_0__.Sanitizer();
/**
 * A custom error type for failed pipeline requests.
 */
class RestError extends Error {
    constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, RestError.prototype);
    }
    /**
     * Logging method for util.inspect in Node
     */
    [_util_inspect__WEBPACK_IMPORTED_MODULE_1__.custom]() {
        return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
    }
}
/**
 * Something went wrong when making the request.
 * This means the actual request failed for some reason,
 * such as a DNS issue or the connection being lost.
 */
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
/**
 * This means that parsing the response from the server failed.
 * It may have been malformed.
 */
RestError.PARSE_ERROR = "PARSE_ERROR";
/**
 * Typeguard for RestError
 * @param e - Something caught by a catch clause.
 */
function isRestError(e) {
    if (e instanceof RestError) {
        return true;
    }
    return (0,_azure_core_util__WEBPACK_IMPORTED_MODULE_2__.isError)(e) && e.name === "RestError";
}
//# sourceMappingURL=restError.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exponentialRetryStrategy": () => (/* binding */ exponentialRetryStrategy),
/* harmony export */   "isExponentialRetryResponse": () => (/* binding */ isExponentialRetryResponse),
/* harmony export */   "isSystemError": () => (/* binding */ isSystemError)
/* harmony export */ });
/* harmony import */ var _azure_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-util */ "./node_modules/@azure/core-util/dist-esm/src/random.js");
/* harmony import */ var _throttlingRetryStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./throttlingRetryStrategy */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


// intervals are in milliseconds
const DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
/**
 * A retry strategy that retries with an exponentially increasing delay in these two cases:
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
 */
function exponentialRetryStrategy(options = {}) {
    var _a, _b;
    const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    let retryAfterInMs = retryInterval;
    return {
        name: "exponentialRetryStrategy",
        retry({ retryCount, response, responseError }) {
            const matchedSystemError = isSystemError(responseError);
            const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
            const isExponential = isExponentialRetryResponse(response);
            const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
            const unknownResponse = response && ((0,_throttlingRetryStrategy__WEBPACK_IMPORTED_MODULE_0__.isThrottlingRetryResponse)(response) || !isExponential);
            if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
                return { skipStrategy: true };
            }
            if (responseError && !matchedSystemError && !isExponential) {
                return { errorToThrow: responseError };
            }
            // Exponentially increase the delay each time
            const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
            // Don't let the delay exceed the maximum
            const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
            // Allow the final value to have some "jitter" (within 50% of the delay size) so
            // that retries across multiple clients don't occur simultaneously.
            retryAfterInMs =
                clampedExponentialDelay / 2 + (0,_azure_core_util__WEBPACK_IMPORTED_MODULE_1__.getRandomIntegerInclusive)(0, clampedExponentialDelay / 2);
            return { retryAfterInMs };
        },
    };
}
/**
 * A response is a retry response if it has status codes:
 * - 408, or
 * - Greater or equal than 500, except for 501 and 505.
 */
function isExponentialRetryResponse(response) {
    return Boolean(response &&
        response.status !== undefined &&
        (response.status >= 500 || response.status === 408) &&
        response.status !== 501 &&
        response.status !== 505);
}
/**
 * Determines whether an error from a pipeline response was triggered in the network layer.
 */
function isSystemError(err) {
    if (!err) {
        return false;
    }
    return (err.code === "ETIMEDOUT" ||
        err.code === "ESOCKETTIMEDOUT" ||
        err.code === "ECONNREFUSED" ||
        err.code === "ECONNRESET" ||
        err.code === "ENOENT");
}
//# sourceMappingURL=exponentialRetryStrategy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isThrottlingRetryResponse": () => (/* binding */ isThrottlingRetryResponse),
/* harmony export */   "throttlingRetryStrategy": () => (/* binding */ throttlingRetryStrategy)
/* harmony export */ });
/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/helpers */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The header that comes back from Azure services representing
 * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
 */
const RetryAfterHeader = "Retry-After";
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry.
 *
 * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
 * "Retry-After" : seconds or timestamp
 */
const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
/**
 * A response is a throttling retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 *
 * Returns the `retryAfterInMs` value if the response is a throttling retry response.
 * If not throttling retry response, returns `undefined`.
 *
 * @internal
 */
function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
        return undefined;
    try {
        // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
        for (const header of AllRetryAfterHeaders) {
            const retryAfterValue = (0,_util_helpers__WEBPACK_IMPORTED_MODULE_0__.parseHeaderValueAsNumber)(response, header);
            if (retryAfterValue === 0 || retryAfterValue) {
                // "Retry-After" header ==> seconds
                // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
                const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
                return retryAfterValue * multiplyingFactor; // in milli-seconds
            }
        }
        // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
        const retryAfterHeader = response.headers.get(RetryAfterHeader);
        if (!retryAfterHeader)
            return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        // negative diff would mean a date in the past, so retry asap with 0 milliseconds
        return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    }
    catch (e) {
        return undefined;
    }
}
/**
 * A response is a retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 */
function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
    return {
        name: "throttlingRetryStrategy",
        retry({ response }) {
            const retryAfterInMs = getRetryAfterInMs(response);
            if (!Number.isFinite(retryAfterInMs)) {
                return { skipStrategy: true };
            }
            return {
                retryAfterInMs,
            };
        },
    };
}
//# sourceMappingURL=throttlingRetryStrategy.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": () => (/* binding */ delay),
/* harmony export */   "parseHeaderValueAsNumber": () => (/* binding */ parseHeaderValueAsNumber)
/* harmony export */ });
/* harmony import */ var _azure_abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/abort-controller */ "./node_modules/@azure/abort-controller/dist-esm/src/AbortController.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const StandardAbortMessage = "The operation was aborted.";
/**
 * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
 * @param delayInMs - The number of milliseconds to be delayed.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @param options - The options for delay - currently abort options
 *                  - abortSignal - The abortSignal associated with containing operation.
 *                  - abortErrorMsg - The abort error message associated with containing operation.
 * @returns Resolved promise
 */
function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = () => {
            return reject(new _azure_abort_controller__WEBPACK_IMPORTED_MODULE_0__.AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
                options.abortSignal.removeEventListener("abort", onAborted);
            }
        };
        onAborted = () => {
            if (timer) {
                clearTimeout(timer);
            }
            removeListeners();
            return rejectOnAbort();
        };
        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
            return rejectOnAbort();
        }
        timer = setTimeout(() => {
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
            options.abortSignal.addEventListener("abort", onAborted);
        }
    });
}
/**
 * @internal
 * @returns the parsed value or undefined if the parsed value is invalid.
 */
function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
        return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
        return;
    return valueAsNum;
}
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "custom": () => (/* binding */ custom)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const custom = util__WEBPACK_IMPORTED_MODULE_0__.inspect.custom;
//# sourceMappingURL=inspect.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sanitizer": () => (/* binding */ Sanitizer)
/* harmony export */ });
/* harmony import */ var _azure_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-util */ "./node_modules/@azure/core-util/dist-esm/src/object.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const RedactedString = "REDACTED";
// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
const defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate",
];
const defaultAllowedQueryParameters = ["api-version"];
/**
 * @internal
 */
class Sanitizer {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [], } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
        const seen = new Set();
        return JSON.stringify(obj, (key, value) => {
            // Ensure Errors include their interesting non-enumerable members
            if (value instanceof Error) {
                return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
            }
            if (key === "headers") {
                return this.sanitizeHeaders(value);
            }
            else if (key === "url") {
                return this.sanitizeUrl(value);
            }
            else if (key === "query") {
                return this.sanitizeQuery(value);
            }
            else if (key === "body") {
                // Don't log the request body
                return undefined;
            }
            else if (key === "response") {
                // Don't log response again
                return undefined;
            }
            else if (key === "operationSpec") {
                // When using sendOperationRequest, the request carries a massive
                // field with the autorest spec. No need to log it.
                return undefined;
            }
            else if (Array.isArray(value) || (0,_azure_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
                if (seen.has(value)) {
                    return "[Circular]";
                }
                seen.add(value);
            }
            return value;
        }, 2);
    }
    sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
            if (this.allowedHeaderNames.has(key.toLowerCase())) {
                sanitized[key] = obj[key];
            }
            else {
                sanitized[key] = RedactedString;
            }
        }
        return sanitized;
    }
    sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
            return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
            if (this.allowedQueryParameters.has(k.toLowerCase())) {
                sanitized[k] = value[k];
            }
            else {
                sanitized[k] = RedactedString;
            }
        }
        return sanitized;
    }
    sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
            return value;
        }
        const url = new URL(value);
        if (!url.search) {
            return value;
        }
        for (const [key] of url.searchParams) {
            if (!this.allowedQueryParameters.has(key.toLowerCase())) {
                url.searchParams.set(key, RedactedString);
            }
        }
        return url.toString();
    }
}
//# sourceMappingURL=sanitizer.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CYCLER_OPTIONS": () => (/* binding */ DEFAULT_CYCLER_OPTIONS),
/* harmony export */   "createTokenCycler": () => (/* binding */ createTokenCycler)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Default options for the cycler if none are provided
const DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    // This wrapper handles exceptions gracefully as long as we haven't exceeded
    // the timeout.
    async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
            try {
                return await getAccessToken();
            }
            catch (_a) {
                return null;
            }
        }
        else {
            const finalToken = await getAccessToken();
            // Timeout is up, so throw if it's still null
            if (finalToken === null) {
                throw new Error("Failed to refresh access token.");
            }
            return finalToken;
        }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
        await (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.delay)(retryIntervalInMs);
        token = await tryGetAccessToken();
    }
    return token;
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */
function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */
    const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
            var _a;
            return (!cycler.isRefreshing &&
                ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
        },
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */
    function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
            // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
                .then((_token) => {
                refreshWorker = null;
                token = _token;
                tenantId = getTokenOptions.tenantId;
                return token;
            })
                .catch((reason) => {
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                tenantId = undefined;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
        //
        // Simple rules:
        // - If we MUST refresh, then return the refresh task, blocking
        //   the pipeline until a token is available.
        // - If we SHOULD refresh, then run refresh but don't return it
        //   (we can still use the cached token).
        // - Return the token, since it's fine if we didn't return in
        //   step 1.
        //
        // If the tenantId passed in token options is different to the one we have
        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
        // refresh the token with the new tenantId or token.
        const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
        if (mustRefresh)
            return refresh(scopes, tokenOptions);
        if (cycler.shouldRefresh) {
            refresh(scopes, tokenOptions);
        }
        return token;
    };
}
//# sourceMappingURL=tokenCycler.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUserAgentHeaderName": () => (/* binding */ getUserAgentHeaderName),
/* harmony export */   "getUserAgentValue": () => (/* binding */ getUserAgentValue)
/* harmony export */ });
/* harmony import */ var _userAgentPlatform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userAgentPlatform */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
    }
    return parts.join(" ");
}
/**
 * @internal
 */
function getUserAgentHeaderName() {
    return (0,_userAgentPlatform__WEBPACK_IMPORTED_MODULE_0__.getHeaderName)();
}
/**
 * @internal
 */
function getUserAgentValue(prefix) {
    const runtimeInfo = new Map();
    runtimeInfo.set("core-rest-pipeline", _constants__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION);
    (0,_userAgentPlatform__WEBPACK_IMPORTED_MODULE_0__.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
}
//# sourceMappingURL=userAgent.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getHeaderName": () => (/* binding */ getHeaderName),
/* harmony export */   "setPlatformSpecificData": () => (/* binding */ setPlatformSpecificData)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 */
function getHeaderName() {
    return "User-Agent";
}
/**
 * @internal
 */
function setPlatformSpecificData(map) {
    map.set("Node", process.version);
    map.set("OS", `(${os__WEBPACK_IMPORTED_MODULE_0__.arch()}-${os__WEBPACK_IMPORTED_MODULE_0__.type()}-${os__WEBPACK_IMPORTED_MODULE_0__.release()})`);
}
//# sourceMappingURL=userAgentPlatform.js.map

/***/ }),

/***/ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/uuid.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/core-rest-pipeline/dist-esm/src/util/uuid.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateUuid": () => (/* binding */ generateUuid)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 * @internal
 */
function generateUuid() {
    return (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
}
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDefaultInstrumenter": () => (/* binding */ createDefaultInstrumenter),
/* harmony export */   "createDefaultTracingSpan": () => (/* binding */ createDefaultTracingSpan),
/* harmony export */   "getInstrumenter": () => (/* binding */ getInstrumenter),
/* harmony export */   "useInstrumenter": () => (/* binding */ useInstrumenter)
/* harmony export */ });
/* harmony import */ var _tracingContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracingContext */ "./node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function createDefaultTracingSpan() {
    return {
        end: () => {
            // noop
        },
        isRecording: () => false,
        recordException: () => {
            // noop
        },
        setAttribute: () => {
            // noop
        },
        setStatus: () => {
            // noop
        },
    };
}
function createDefaultInstrumenter() {
    return {
        createRequestHeaders: () => {
            return {};
        },
        parseTraceparentHeader: () => {
            return undefined;
        },
        startSpan: (_name, spanOptions) => {
            return {
                span: createDefaultTracingSpan(),
                tracingContext: (0,_tracingContext__WEBPACK_IMPORTED_MODULE_0__.createTracingContext)({ parentContext: spanOptions.tracingContext }),
            };
        },
        withContext(_context, callback, ...callbackArgs) {
            return callback(...callbackArgs);
        },
    };
}
/** @internal */
let instrumenterImplementation;
/**
 * Extends the Azure SDK with support for a given instrumenter implementation.
 *
 * @param instrumenter - The instrumenter implementation to use.
 */
function useInstrumenter(instrumenter) {
    instrumenterImplementation = instrumenter;
}
/**
 * Gets the currently set instrumenter, a No-Op instrumenter by default.
 *
 * @returns The currently set instrumenter
 */
function getInstrumenter() {
    if (!instrumenterImplementation) {
        instrumenterImplementation = createDefaultInstrumenter();
    }
    return instrumenterImplementation;
}
//# sourceMappingURL=instrumenter.js.map

/***/ }),

/***/ "./node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTracingClient": () => (/* binding */ createTracingClient)
/* harmony export */ });
/* harmony import */ var _instrumenter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instrumenter */ "./node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js");
/* harmony import */ var _tracingContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracingContext */ "./node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


/**
 * Creates a new tracing client.
 *
 * @param options - Options used to configure the tracing client.
 * @returns - An instance of {@link TracingClient}.
 */
function createTracingClient(options) {
    const { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
        var _a;
        const startSpanResult = (0,_instrumenter__WEBPACK_IMPORTED_MODULE_0__.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue(_tracingContext__WEBPACK_IMPORTED_MODULE_1__.knownContextKeys.namespace)) {
            tracingContext = tracingContext.setValue(_tracingContext__WEBPACK_IMPORTED_MODULE_1__.knownContextKeys.namespace, namespace);
        }
        span.setAttribute("az.namespace", tracingContext.getValue(_tracingContext__WEBPACK_IMPORTED_MODULE_1__.knownContextKeys.namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),
        });
        return {
            span,
            updatedOptions,
        };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
        try {
            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
            span.setStatus({ status: "success" });
            return result;
        }
        catch (err) {
            span.setStatus({ status: "error", error: err });
            throw err;
        }
        finally {
            span.end();
        }
    }
    function withContext(context, callback, ...callbackArgs) {
        return (0,_instrumenter__WEBPACK_IMPORTED_MODULE_0__.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    /**
     * Parses a traceparent header value into a span identifier.
     *
     * @param traceparentHeader - The traceparent header to parse.
     * @returns An implementation-specific identifier for the span.
     */
    function parseTraceparentHeader(traceparentHeader) {
        return (0,_instrumenter__WEBPACK_IMPORTED_MODULE_0__.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    /**
     * Creates a set of request headers to propagate tracing information to a backend.
     *
     * @param tracingContext - The context containing the span to serialize.
     * @returns The set of headers to add to a request.
     */
    function createRequestHeaders(tracingContext) {
        return (0,_instrumenter__WEBPACK_IMPORTED_MODULE_0__.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
        startSpan,
        withSpan,
        withContext,
        parseTraceparentHeader,
        createRequestHeaders,
    };
}
//# sourceMappingURL=tracingClient.js.map

/***/ }),

/***/ "./node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TracingContextImpl": () => (/* binding */ TracingContextImpl),
/* harmony export */   "createTracingContext": () => (/* binding */ createTracingContext),
/* harmony export */   "knownContextKeys": () => (/* binding */ knownContextKeys)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @internal */
const knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace"),
};
/**
 * Creates a new {@link TracingContext} with the given options.
 * @param options - A set of known keys that may be set on the context.
 * @returns A new {@link TracingContext} with the given options.
 *
 * @internal
 */
function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span) {
        context = context.setValue(knownContextKeys.span, options.span);
    }
    if (options.namespace) {
        context = context.setValue(knownContextKeys.namespace, options.namespace);
    }
    return context;
}
/** @internal */
class TracingContextImpl {
    constructor(initialContext) {
        this._contextMap =
            initialContext instanceof TracingContextImpl
                ? new Map(initialContext._contextMap)
                : new Map();
    }
    setValue(key, value) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
    }
    getValue(key) {
        return this._contextMap.get(key);
    }
    deleteValue(key) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
    }
}
//# sourceMappingURL=tracingContext.js.map

/***/ }),

/***/ "./node_modules/@azure/core-util/dist-esm/src/error.js":
/*!*************************************************************!*\
  !*** ./node_modules/@azure/core-util/dist-esm/src/error.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getErrorMessage": () => (/* binding */ getErrorMessage),
/* harmony export */   "isError": () => (/* binding */ isError)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ "./node_modules/@azure/core-util/dist-esm/src/object.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Typeguard for an error object shape (has name and message)
 * @param e - Something caught by a catch clause.
 */
function isError(e) {
    if ((0,_object__WEBPACK_IMPORTED_MODULE_0__.isObject)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
    }
    return false;
}
/**
 * Given what is thought to be an error object, return the message if possible.
 * If the message is missing, returns a stringified version of the input.
 * @param e - Something thrown from a try block
 * @returns The error message or a string of the input
 */
function getErrorMessage(e) {
    if (isError(e)) {
        return e.message;
    }
    else {
        let stringified;
        try {
            if (typeof e === "object" && e) {
                stringified = JSON.stringify(e);
            }
            else {
                stringified = String(e);
            }
        }
        catch (err) {
            stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
    }
}
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "./node_modules/@azure/core-util/dist-esm/src/isNode.js":
/*!**************************************************************!*\
  !*** ./node_modules/@azure/core-util/dist-esm/src/isNode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNode": () => (/* binding */ isNode)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */
const isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);
//# sourceMappingURL=isNode.js.map

/***/ }),

/***/ "./node_modules/@azure/core-util/dist-esm/src/object.js":
/*!**************************************************************!*\
  !*** ./node_modules/@azure/core-util/dist-esm/src/object.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => (/* binding */ isObject)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */
function isObject(input) {
    return (typeof input === "object" &&
        input !== null &&
        !Array.isArray(input) &&
        !(input instanceof RegExp) &&
        !(input instanceof Date));
}
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@azure/core-util/dist-esm/src/random.js":
/*!**************************************************************!*\
  !*** ./node_modules/@azure/core-util/dist-esm/src/random.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRandomIntegerInclusive": () => (/* binding */ getRandomIntegerInclusive)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@azure/core-xml/dist-esm/src/xml.common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@azure/core-xml/dist-esm/src/xml.common.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XML_ATTRKEY": () => (/* binding */ XML_ATTRKEY),
/* harmony export */   "XML_CHARKEY": () => (/* binding */ XML_CHARKEY)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */
const XML_ATTRKEY = "$";
/**
 * Default key used to access the XML value content.
 */
const XML_CHARKEY = "_";
//# sourceMappingURL=xml.common.js.map

/***/ }),

/***/ "./node_modules/@azure/core-xml/dist-esm/src/xml.js":
/*!**********************************************************!*\
  !*** ./node_modules/@azure/core-xml/dist-esm/src/xml.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseXML": () => (/* binding */ parseXML),
/* harmony export */   "stringifyXML": () => (/* binding */ stringifyXML)
/* harmony export */ });
/* harmony import */ var fast_xml_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
/* harmony import */ var fast_xml_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_xml_parser__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _xml_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xml.common */ "./node_modules/@azure/core-xml/dist-esm/src/xml.common.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


function getCommonOptions(options) {
    var _a;
    return {
        attributesGroupName: _xml_common__WEBPACK_IMPORTED_MODULE_1__.XML_ATTRKEY,
        textNodeName: (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : _xml_common__WEBPACK_IMPORTED_MODULE_1__.XML_CHARKEY,
        ignoreAttributes: false,
        suppressBooleanAttributes: false,
    };
}
function getSerializerOptions(options = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "root", cdataPropName: (_b = options.cdataPropName) !== null && _b !== void 0 ? _b : "__cdata" });
}
function getParserOptions(options = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: false });
}
/**
 * Converts given JSON object to XML string
 * @param obj - JSON object to be converted into XML string
 * @param opts - Options that govern the XML building of given JSON object
 * `rootName` indicates the name of the root element in the resulting XML
 */
function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser__WEBPACK_IMPORTED_MODULE_0__.XMLBuilder(parserOptions);
    const node = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
}
/**
 * Converts given XML string into JSON
 * @param str - String containing the XML content to be parsed into JSON
 * @param opts - Options that govern the parsing of given xml string
 * `includeRoot` indicates whether the root element is to be included or not in the output
 */
async function parseXML(str, opts = {}) {
    if (!str) {
        throw new Error("Document is empty");
    }
    const validation = fast_xml_parser__WEBPACK_IMPORTED_MODULE_0__.XMLValidator.validate(str);
    if (validation !== true) {
        throw validation;
    }
    const parser = new fast_xml_parser__WEBPACK_IMPORTED_MODULE_0__.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(unescapeHTML(str));
    // Remove the <?xml version="..." ?> node.
    // This is a change in behavior on fxp v4. Issue #424
    if (parsedXml["?xml"]) {
        delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
        for (const key of Object.keys(parsedXml)) {
            const value = parsedXml[key];
            return typeof value === "object" ? Object.assign({}, value) : value;
        }
    }
    return parsedXml;
}
function unescapeHTML(str) {
    return str
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"');
}
//# sourceMappingURL=xml.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/TableClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/TableClient.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TableClient": () => (/* binding */ TableClient)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _azure_core_paging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-paging */ "./node_modules/@azure/core-paging/dist-esm/src/index.js");
/* harmony import */ var _generated__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generated */ "./node_modules/@azure/data-tables/dist-esm/src/generated/generatedClient.js");
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js");
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js");
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js");
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/constants */ "./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js");
/* harmony import */ var _utils_continuationToken__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/continuationToken */ "./node_modules/@azure/data-tables/dist-esm/src/utils/continuationToken.js");
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./serialization */ "./node_modules/@azure/data-tables/dist-esm/src/serialization.js");
/* harmony import */ var _azure_core_xml__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @azure/core-xml */ "./node_modules/@azure/core-xml/dist-esm/src/xml.js");
/* harmony import */ var _TableTransaction__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./TableTransaction */ "./node_modules/@azure/data-tables/dist-esm/src/TableTransaction.js");
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/uuid */ "./node_modules/@azure/data-tables/dist-esm/src/utils/uuid.js");
/* harmony import */ var _utils_apiVersionPolicy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/apiVersionPolicy */ "./node_modules/@azure/data-tables/dist-esm/src/utils/apiVersionPolicy.js");
/* harmony import */ var _cosmosPathPolicy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cosmosPathPolicy */ "./node_modules/@azure/data-tables/dist-esm/src/cosmosPathPolicy.js");
/* harmony import */ var _odata__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./odata */ "./node_modules/@azure/data-tables/dist-esm/src/odata.js");
/* harmony import */ var _utils_connectionString__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./utils/connectionString */ "./node_modules/@azure/data-tables/dist-esm/src/utils/connectionString.js");
/* harmony import */ var _utils_errorHelpers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/errorHelpers */ "./node_modules/@azure/data-tables/dist-esm/src/utils/errorHelpers.js");
/* harmony import */ var _utils_isCosmosEndpoint__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/isCosmosEndpoint */ "./node_modules/@azure/data-tables/dist-esm/src/utils/isCosmosEndpoint.js");
/* harmony import */ var _utils_isCredential__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/isCredential */ "./node_modules/@azure/data-tables/dist-esm/src/utils/isCredential.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger */ "./node_modules/@azure/data-tables/dist-esm/src/logger.js");
/* harmony import */ var _utils_challengeAuthenticationUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/challengeAuthenticationUtils */ "./node_modules/@azure/data-tables/dist-esm/src/utils/challengeAuthenticationUtils.js");
/* harmony import */ var _tablesNamedCredentialPolicy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tablesNamedCredentialPolicy */ "./node_modules/@azure/data-tables/dist-esm/src/tablesNamedCredentialPolicy.js");
/* harmony import */ var _tablesSASTokenPolicy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tablesSASTokenPolicy */ "./node_modules/@azure/data-tables/dist-esm/src/tablesSASTokenPolicy.js");
/* harmony import */ var _utils_tracing__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/tracing */ "./node_modules/@azure/data-tables/dist-esm/src/utils/tracing.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.






















/**
 * A TableClient represents a Client to the Azure Tables service allowing you
 * to perform operations on a single table.
 */
class TableClient {
    constructor(url, tableName, credentialOrOptions, options = {}) {
        var _a;
        this.url = url;
        this.tableName = tableName;
        const credential = (0,_utils_isCredential__WEBPACK_IMPORTED_MODULE_1__.isCredential)(credentialOrOptions) ? credentialOrOptions : undefined;
        this.credential = credential;
        this.clientOptions = (!(0,_utils_isCredential__WEBPACK_IMPORTED_MODULE_1__.isCredential)(credentialOrOptions) ? credentialOrOptions : options) || {};
        this.allowInsecureConnection = (_a = this.clientOptions.allowInsecureConnection) !== null && _a !== void 0 ? _a : false;
        this.clientOptions.endpoint = this.clientOptions.endpoint || this.url;
        const internalPipelineOptions = Object.assign(Object.assign({}, this.clientOptions), { loggingOptions: {
                logger: _logger__WEBPACK_IMPORTED_MODULE_2__.logger.info,
                additionalAllowedHeaderNames: [..._utils_constants__WEBPACK_IMPORTED_MODULE_3__.TablesLoggingAllowedHeaderNames],
            }, deserializationOptions: {
                parseXML: _azure_core_xml__WEBPACK_IMPORTED_MODULE_4__.parseXML,
            }, serializationOptions: {
                stringifyXML: _azure_core_xml__WEBPACK_IMPORTED_MODULE_4__.stringifyXML,
            } });
        const generatedClient = new _generated__WEBPACK_IMPORTED_MODULE_5__.GeneratedClient(this.url, internalPipelineOptions);
        if ((0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_6__.isNamedKeyCredential)(credential)) {
            generatedClient.pipeline.addPolicy((0,_tablesNamedCredentialPolicy__WEBPACK_IMPORTED_MODULE_7__.tablesNamedKeyCredentialPolicy)(credential));
        }
        else if ((0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_8__.isSASCredential)(credential)) {
            generatedClient.pipeline.addPolicy((0,_tablesSASTokenPolicy__WEBPACK_IMPORTED_MODULE_9__.tablesSASTokenPolicy)(credential));
        }
        if ((0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_10__.isTokenCredential)(credential)) {
            (0,_utils_challengeAuthenticationUtils__WEBPACK_IMPORTED_MODULE_11__.setTokenChallengeAuthenticationPolicy)(generatedClient.pipeline, credential, _utils_constants__WEBPACK_IMPORTED_MODULE_3__.STORAGE_SCOPE);
        }
        if ((0,_utils_isCosmosEndpoint__WEBPACK_IMPORTED_MODULE_12__.isCosmosEndpoint)(this.url)) {
            generatedClient.pipeline.addPolicy((0,_cosmosPathPolicy__WEBPACK_IMPORTED_MODULE_13__.cosmosPatchPolicy)());
        }
        if (options.version) {
            generatedClient.pipeline.addPolicy((0,_utils_apiVersionPolicy__WEBPACK_IMPORTED_MODULE_14__.apiVersionPolicy)(options.version));
        }
        this.generatedClient = generatedClient;
        this.table = generatedClient.table;
        this.pipeline = generatedClient.pipeline;
    }
    /**
     * Permanently deletes the current table with all of its entities.
     * @param options - The options parameters.
     *
     * ### Example deleting a table
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // calling deleteTable will delete the table used
     * // to instantiate the TableClient.
     * // Note: If the table doesn't exist this function doesn't fail.
     * await client.deleteTable();
     * ```
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    deleteTable(options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.deleteTable", options, async (updatedOptions) => {
            try {
                await this.table.delete(this.tableName, updatedOptions);
            }
            catch (e) {
                if (e.statusCode === 404) {
                    _logger__WEBPACK_IMPORTED_MODULE_2__.logger.info("TableClient.deleteTable: Table doesn't exist");
                }
                else {
                    throw e;
                }
            }
        });
    }
    /**
     *  Creates a table with the tableName passed to the client constructor
     * @param options - The options parameters.
     *
     * ### Example creating a table
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // calling create table will create the table used
     * // to instantiate the TableClient.
     * // Note: If the table already
     * // exists this function doesn't throw.
     * await client.createTable();
     * ```
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    createTable(options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.createTable", options, async (updatedOptions) => {
            try {
                await this.table.create({ name: this.tableName }, updatedOptions);
            }
            catch (e) {
                (0,_utils_errorHelpers__WEBPACK_IMPORTED_MODULE_16__.handleTableAlreadyExists)(e, Object.assign(Object.assign({}, updatedOptions), { logger: _logger__WEBPACK_IMPORTED_MODULE_2__.logger, tableName: this.tableName }));
            }
        });
    }
    /**
     * Returns a single entity in the table.
     * @param partitionKey - The partition key of the entity.
     * @param rowKey - The row key of the entity.
     * @param options - The options parameters.
     *
     * ### Example getting an entity
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // getEntity will get a single entity stored in the service that
     * // matches exactly the partitionKey and rowKey used as parameters
     * // to the method.
     * const entity = await client.getEntity("<partitionKey>", "<rowKey>");
     * console.log(entity);
     * ```
     */
    getEntity(partitionKey, rowKey, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.getEntity", options, async (updatedOptions) => {
            let parsedBody;
            function onResponse(rawResponse, flatResponse) {
                parsedBody = rawResponse.parsedBody;
                if (updatedOptions.onResponse) {
                    updatedOptions.onResponse(rawResponse, flatResponse);
                }
            }
            const { disableTypeConversion, queryOptions } = updatedOptions, getEntityOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__rest)(updatedOptions, ["disableTypeConversion", "queryOptions"]);
            await this.table.queryEntitiesWithPartitionAndRowKey(this.tableName, (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(partitionKey), (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(rowKey), Object.assign(Object.assign({}, getEntityOptions), { queryOptions: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serializeQueryOptions)(queryOptions || {}), onResponse }));
            const tableEntity = (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.deserialize)(parsedBody, disableTypeConversion !== null && disableTypeConversion !== void 0 ? disableTypeConversion : false);
            return tableEntity;
        });
    }
    /**
     * Queries entities in a table.
     * @param options - The options parameters.
     *
     * Example listing entities
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // list entities returns a AsyncIterableIterator
     * // this helps consuming paginated responses by
     * // automatically handling getting the next pages
     * const entities = client.listEntities();
     *
     * // this loop will get all the entities from all the pages
     * // returned by the service
     * for await (const entity of entities) {
     *    console.log(entity);
     * }
     * ```
     */
    listEntities(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        const tableName = this.tableName;
        const iter = this.listEntitiesAll(tableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { queryOptions: Object.assign(Object.assign({}, options.queryOptions), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize }) });
                if (settings === null || settings === void 0 ? void 0 : settings.continuationToken) {
                    pageOptions.continuationToken = settings.continuationToken;
                }
                return this.listEntitiesPage(tableName, pageOptions);
            },
        };
    }
    listEntitiesAll(tableName, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncGenerator)(this, arguments, function* listEntitiesAll_1() {
            var e_1, _a;
            const firstPage = yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(this._listEntities(tableName, options));
            yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(yield* (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncDelegator)((0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncValues)(firstPage)));
            if (firstPage.continuationToken) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { continuationToken: firstPage.continuationToken });
                try {
                    for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncValues)(this.listEntitiesPage(tableName, optionsWithContinuation)), _c; _c = yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(_b.next()), !_c.done;) {
                        const page = _c.value;
                        yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(yield* (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncDelegator)((0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncValues)(page)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(_a.call(_b));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    listEntitiesPage(tableName, options = {}) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__asyncGenerator)(this, arguments, function* listEntitiesPage_1() {
            let result = yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(_utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.listEntitiesPage", options, (updatedOptions) => this._listEntities(tableName, updatedOptions)));
            yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(result);
            while (result.continuationToken) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { continuationToken: result.continuationToken });
                result = yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(_utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.listEntitiesPage", optionsWithContinuation, (updatedOptions, span) => {
                    span.setAttribute("continuationToken", result.continuationToken);
                    return this._listEntities(tableName, updatedOptions);
                }));
                yield yield (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__await)(result);
            }
        });
    }
    async _listEntities(tableName, options = {}) {
        const { disableTypeConversion = false } = options;
        const queryOptions = (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serializeQueryOptions)(options.queryOptions || {});
        const listEntitiesOptions = Object.assign(Object.assign({}, options), { queryOptions });
        // If a continuation token is used, decode it and set the next row and partition key
        if (options.continuationToken) {
            const continuationToken = (0,_utils_continuationToken__WEBPACK_IMPORTED_MODULE_20__.decodeContinuationToken)(options.continuationToken);
            listEntitiesOptions.nextRowKey = continuationToken.nextRowKey;
            listEntitiesOptions.nextPartitionKey = continuationToken.nextPartitionKey;
        }
        const { xMsContinuationNextPartitionKey: nextPartitionKey, xMsContinuationNextRowKey: nextRowKey, value, } = await this.table.queryEntities(tableName, listEntitiesOptions);
        const tableEntities = (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.deserializeObjectsArray)(value !== null && value !== void 0 ? value : [], disableTypeConversion);
        // Encode nextPartitionKey and nextRowKey as a single continuation token and add it as a
        // property to the page.
        const continuationToken = (0,_utils_continuationToken__WEBPACK_IMPORTED_MODULE_20__.encodeContinuationToken)(nextPartitionKey, nextRowKey);
        const page = Object.assign([...tableEntities], {
            continuationToken,
        });
        return page;
    }
    /**
     * Insert entity in the table.
     * @param entity - The properties for the table entity.
     * @param options - The options parameters.
     *
     * ### Example creating an entity
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // partitionKey and rowKey are required properties of the entity to create
     * // and accepts any other properties
     * await client.createEntity({partitionKey: "p1", rowKey: "r1", foo: "Hello!"});
     * ```
     */
    createEntity(entity, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.createEntity", options, (updatedOptions) => {
            const createTableEntity = (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__rest)(updatedOptions || {}, []);
            return this.table.insertEntity(this.tableName, Object.assign(Object.assign({}, createTableEntity), { tableEntityProperties: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serialize)(entity), responsePreference: "return-no-content" }));
        });
    }
    /**
     * Deletes the specified entity in the table.
     * @param partitionKey - The partition key of the entity.
     * @param rowKey - The row key of the entity.
     * @param options - The options parameters.
     *
     * ### Example deleting an entity
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * // deleteEntity deletes the entity that matches
     * // exactly the partitionKey and rowKey passed as parameters
     * await client.deleteEntity("<partitionKey>", "<rowKey>")
     * ```
     */
    deleteEntity(partitionKey, rowKey, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.deleteEntity", options, (updatedOptions) => {
            const { etag = "*" } = updatedOptions, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__rest)(updatedOptions, ["etag"]);
            const deleteOptions = Object.assign({}, rest);
            return this.table.deleteEntity(this.tableName, (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(partitionKey), (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(rowKey), etag, deleteOptions);
        });
    }
    /**
     * Update an entity in the table.
     * @param entity - The properties of the entity to be updated.
     * @param mode - The different modes for updating the entity:
     *               - Merge: Updates an entity by updating the entity's properties without replacing the existing entity.
     *               - Replace: Updates an existing entity by replacing the entire entity.
     * @param options - The options parameters.
     *
     * ### Example updating an entity
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * const entity = {partitionKey: "p1", rowKey: "r1", bar: "updatedBar"};
     *
     * // Update uses update mode "Merge" as default
     * // merge means that update will match a stored entity
     * // that has the same partitionKey and rowKey as the entity
     * // passed to the method and then will only update the properties present in it.
     * // Any other properties that are not defined in the entity passed to updateEntity
     * // will remain as they are in the service
     * await client.updateEntity(entity)
     *
     * // We can also set the update mode to Replace, which will match the entity passed
     * // to updateEntity with one stored in the service and replace with the new one.
     * // If there are any missing properties in the entity passed to updateEntity, they
     * // will be removed from the entity stored in the service
     * await client.updateEntity(entity, "Replace")
     * ```
     */
    updateEntity(entity, mode = "Merge", 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.updateEntity", options, async (updatedOptions) => {
            const partitionKey = (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(entity.partitionKey);
            const rowKey = (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(entity.rowKey);
            const _a = updatedOptions || {}, { etag = "*" } = _a, updateEntityOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_17__.__rest)(_a, ["etag"]);
            if (mode === "Merge") {
                return this.table.mergeEntity(this.tableName, partitionKey, rowKey, Object.assign({ tableEntityProperties: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serialize)(entity), ifMatch: etag }, updateEntityOptions));
            }
            if (mode === "Replace") {
                return this.table.updateEntity(this.tableName, partitionKey, rowKey, Object.assign({ tableEntityProperties: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serialize)(entity), ifMatch: etag }, updateEntityOptions));
            }
            throw new Error(`Unexpected value for update mode: ${mode}`);
        }, {
            spanAttributes: {
                updateEntityMode: mode,
            },
        });
    }
    /**
     * Upsert an entity in the table.
     * @param entity - The properties for the table entity.
     * @param mode - The different modes for updating the entity:
     *               - Merge: Updates an entity by updating the entity's properties without replacing the existing entity.
     *               - Replace: Updates an existing entity by replacing the entire entity.
     * @param options - The options parameters.
     *
     * ### Example upserting an entity
     * ```js
     * const { AzureNamedKeyCredential, TableClient } = require("@azure/data-tables")
     * const account = "<storage account name>";
     * const accountKey = "<account key>"
     * const tableName = "<table name>";
     * const sharedKeyCredential = new AzureNamedKeyCredential(account, accountKey);
     *
     * const client = new TableClient(
     *   `https://${account}.table.core.windows.net`,
     *   `${tableName}`,
     *   sharedKeyCredential
     * );
     *
     * const entity = {partitionKey: "p1", rowKey: "r1", bar: "updatedBar"};
     *
     * // Upsert uses update mode "Merge" as default.
     * // This behaves similarly to update but creates the entity
     * // if it doesn't exist in the service
     * await client.upsertEntity(entity)
     *
     * // We can also set the update mode to Replace.
     * // This behaves similarly to update but creates the entity
     * // if it doesn't exist in the service
     * await client.upsertEntity(entity, "Replace")
     * ```
     */
    upsertEntity(entity, mode = "Merge", 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.upsertEntity", options, async (updatedOptions) => {
            const partitionKey = (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(entity.partitionKey);
            const rowKey = (0,_odata__WEBPACK_IMPORTED_MODULE_18__.escapeQuotes)(entity.rowKey);
            if (mode === "Merge") {
                return this.table.mergeEntity(this.tableName, partitionKey, rowKey, Object.assign({ tableEntityProperties: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serialize)(entity) }, updatedOptions));
            }
            if (mode === "Replace") {
                return this.table.updateEntity(this.tableName, partitionKey, rowKey, Object.assign({ tableEntityProperties: (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serialize)(entity) }, updatedOptions));
            }
            throw new Error(`Unexpected value for update mode: ${mode}`);
        }, {
            spanAttributes: {
                upsertEntityMode: mode,
            },
        });
    }
    /**
     * Retrieves details about any stored access policies specified on the table that may be used with
     * Shared Access Signatures.
     * @param options - The options parameters.
     */
    getAccessPolicy(options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.getAccessPolicy", options, async (updatedOptions) => {
            const signedIdentifiers = await this.table.getAccessPolicy(this.tableName, updatedOptions);
            return (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.deserializeSignedIdentifier)(signedIdentifiers);
        });
    }
    /**
     * Sets stored access policies for the table that may be used with Shared Access Signatures.
     * @param tableAcl - The Access Control List for the table.
     * @param options - The options parameters.
     */
    setAccessPolicy(tableAcl, options = {}) {
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_15__.tracingClient.withSpan("TableClient.setAccessPolicy", options, (updatedOptions) => {
            const serlializedAcl = (0,_serialization__WEBPACK_IMPORTED_MODULE_19__.serializeSignedIdentifiers)(tableAcl);
            return this.table.setAccessPolicy(this.tableName, Object.assign(Object.assign({}, updatedOptions), { tableAcl: serlializedAcl }));
        });
    }
    /**
     * Submits a Transaction which is composed of a set of actions. You can provide the actions as a list
     * or you can use {@link TableTransaction} to help building the transaction.
     *
     * Example usage:
     * ```typescript
     * const { TableClient } = require("@azure/data-tables");
     * const connectionString = "<connection-string>"
     * const tableName = "<tableName>"
     * const client = TableClient.fromConnectionString(connectionString, tableName);
     * const actions = [
     *    ["create", {partitionKey: "p1", rowKey: "1", data: "test1"}],
     *    ["delete", {partitionKey: "p1", rowKey: "2"}],
     *    ["update", {partitionKey: "p1", rowKey: "3", data: "newTest"}, "Merge"]
     * ]
     * const result = await client.submitTransaction(actions);
     * ```
     *
     * Example usage with TableTransaction:
     * ```js
     * const { TableClient } = require("@azure/data-tables");
     * const connectionString = "<connection-string>"
     * const tableName = "<tableName>"
     * const client = TableClient.fromConnectionString(connectionString, tableName);
     * const transaction = new TableTransaction();
     * // Call the available action in the TableTransaction object
     * transaction.create({partitionKey: "p1", rowKey: "1", data: "test1"});
     * transaction.delete("p1", "2");
     * transaction.update({partitionKey: "p1", rowKey: "3", data: "newTest"}, "Merge")
     * // submitTransaction with the actions list on the transaction.
     * const result = await client.submitTransaction(transaction.actions);
     * ```
     *
     * @param actions - tuple that contains the action to perform, and the entity to perform the action with
     */
    async submitTransaction(actions) {
        const partitionKey = actions[0][1].partitionKey;
        const transactionId = _utils_uuid__WEBPACK_IMPORTED_MODULE_21__.Uuid.generateUuid();
        const changesetId = _utils_uuid__WEBPACK_IMPORTED_MODULE_21__.Uuid.generateUuid();
        if (!this.transactionClient) {
            // Add pipeline
            this.transactionClient = new _TableTransaction__WEBPACK_IMPORTED_MODULE_22__.InternalTableTransaction(this.url, partitionKey, transactionId, changesetId, this.generatedClient, new TableClient(this.url, this.tableName), this.credential, this.allowInsecureConnection);
        }
        else {
            this.transactionClient.reset(transactionId, changesetId, partitionKey);
        }
        for (const item of actions) {
            const [action, entity, updateMode = "Merge", updateOptions] = item;
            switch (action) {
                case "create":
                    this.transactionClient.createEntity(entity);
                    break;
                case "delete":
                    this.transactionClient.deleteEntity(entity.partitionKey, entity.rowKey);
                    break;
                case "update":
                    this.transactionClient.updateEntity(entity, updateMode, updateOptions);
                    break;
                case "upsert":
                    this.transactionClient.upsertEntity(entity, updateMode);
            }
        }
        return this.transactionClient.submitTransaction();
    }
    /**
     *
     * Creates an instance of TableClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                           [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                           Account connection string example -
     *                           `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                           SAS connection string example -
     *                           `BlobEndpoint=https://myaccount.table.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Options to configure the HTTP pipeline.
     * @returns A new TableClient from the given connection string.
     */
    static fromConnectionString(connectionString, tableName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        const { url, options: clientOptions, credential, } = (0,_utils_connectionString__WEBPACK_IMPORTED_MODULE_23__.getClientParamsFromConnectionString)(connectionString, options);
        if (credential) {
            return new TableClient(url, tableName, credential, clientOptions);
        }
        else {
            return new TableClient(url, tableName, clientOptions);
        }
    }
}
//# sourceMappingURL=TableClient.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/TablePolicies.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/TablePolicies.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transactionHeaderFilterPolicy": () => (/* binding */ transactionHeaderFilterPolicy),
/* harmony export */   "transactionHeaderFilterPolicyName": () => (/* binding */ transactionHeaderFilterPolicyName),
/* harmony export */   "transactionRequestAssemblePolicy": () => (/* binding */ transactionRequestAssemblePolicy),
/* harmony export */   "transactionRequestAssemblePolicyName": () => (/* binding */ transactionRequestAssemblePolicyName)
/* harmony export */ });
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/constants */ "./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js");
/* harmony import */ var _utils_transactionHelpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/transactionHelpers */ "./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHelpers.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



const transactionRequestAssemblePolicyName = "transactionRequestAssemblePolicy";
const dummyResponse = {
    request: (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__.createPipelineRequest)({ url: "FAKE" }),
    status: 200,
    headers: (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_1__.createHttpHeaders)(),
};
function transactionRequestAssemblePolicy(bodyParts, changesetId) {
    return {
        name: transactionRequestAssemblePolicyName,
        async sendRequest(request) {
            const subRequest = getNextSubrequestBodyPart(request, changesetId);
            bodyParts.push(subRequest);
            // Intercept request from going to wire
            return dummyResponse;
        },
    };
}
const transactionHeaderFilterPolicyName = "transactionHeaderFilterPolicy";
function transactionHeaderFilterPolicy() {
    return {
        name: transactionHeaderFilterPolicyName,
        async sendRequest(request, next) {
            // The subrequests should not have the x-ms-version header.
            request.headers.delete(_utils_constants__WEBPACK_IMPORTED_MODULE_2__.HeaderConstants.X_MS_VERSION);
            return next(request);
        },
    };
}
function getSubRequestUrl(url) {
    const sasTokenParts = ["sv", "ss", "srt", "sp", "se", "st", "spr", "sig"];
    const urlParsed = new URL(url);
    sasTokenParts.forEach((part) => urlParsed.searchParams.delete(part));
    return urlParsed.toString();
}
function getNextSubrequestBodyPart(request, changesetId) {
    const changesetBoundary = (0,_utils_transactionHelpers__WEBPACK_IMPORTED_MODULE_3__.getChangeSetBoundary)(changesetId);
    const subRequestPrefix = `--${changesetBoundary}${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.TRANSACTION_HTTP_LINE_ENDING}${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.HeaderConstants.CONTENT_TYPE}: application/http${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.TRANSACTION_HTTP_LINE_ENDING}${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
    const subRequestUrl = getSubRequestUrl(request.url);
    // Start to assemble sub request
    const subRequest = [
        subRequestPrefix,
        "",
        `${request.method.toString()} ${subRequestUrl} ${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.TRANSACTION_HTTP_VERSION_1_1}`, // sub request start line with method,
    ];
    // Add required headers
    for (const [name, value] of request.headers) {
        subRequest.push(`${name}: ${value}`);
    }
    // Append sub-request body
    subRequest.push(`${_utils_constants__WEBPACK_IMPORTED_MODULE_2__.TRANSACTION_HTTP_LINE_ENDING}`); // sub request's headers need end with an empty line
    if (request.body) {
        subRequest.push(String(request.body));
    }
    // Add subrequest to transaction body
    return subRequest.join(_utils_constants__WEBPACK_IMPORTED_MODULE_2__.TRANSACTION_HTTP_LINE_ENDING);
}
//# sourceMappingURL=TablePolicies.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/TableTransaction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/TableTransaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InternalTableTransaction": () => (/* binding */ InternalTableTransaction),
/* harmony export */   "TableTransaction": () => (/* binding */ TableTransaction),
/* harmony export */   "parseTransactionResponse": () => (/* binding */ parseTransactionResponse),
/* harmony export */   "prepateTransactionPipeline": () => (/* binding */ prepateTransactionPipeline)
/* harmony export */ });
/* harmony import */ var _azure_core_client__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @azure/core-client */ "./node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js");
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js");
/* harmony import */ var _utils_transactionHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/transactionHelpers */ "./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHelpers.js");
/* harmony import */ var _TablePolicies__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TablePolicies */ "./node_modules/@azure/data-tables/dist-esm/src/TablePolicies.js");
/* harmony import */ var _cosmosPathPolicy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cosmosPathPolicy */ "./node_modules/@azure/data-tables/dist-esm/src/cosmosPathPolicy.js");
/* harmony import */ var _utils_transactionHeaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/transactionHeaders */ "./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHeaders.js");
/* harmony import */ var _utils_isCosmosEndpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/isCosmosEndpoint */ "./node_modules/@azure/data-tables/dist-esm/src/utils/isCosmosEndpoint.js");
/* harmony import */ var _utils_tracing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tracing */ "./node_modules/@azure/data-tables/dist-esm/src/utils/tracing.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








/**
 * Helper to build a list of transaction actions
 */
class TableTransaction {
    constructor(actions) {
        this.actions = actions !== null && actions !== void 0 ? actions : [];
    }
    /**
     * Adds a create action to the transaction
     * @param entity - entity to create
     */
    createEntity(entity) {
        this.actions.push(["create", entity]);
    }
    /**
     * Adds a delete action to the transaction
     * @param partitionKey - partition key of the entity to delete
     * @param rowKey - rowKey of the entity to delete
     */
    deleteEntity(partitionKey, rowKey) {
        this.actions.push(["delete", { partitionKey, rowKey }]);
    }
    /**
     * Adds an update action to the transaction
     * @param entity - entity to update
     * @param updateModeOrOptions - update mode or update options
     * @param updateOptions - options for the update operation
     */
    updateEntity(entity, updateModeOrOptions, updateOptions) {
        // UpdateMode is a string union
        const realUpdateMode = typeof updateModeOrOptions === "string" ? updateModeOrOptions : undefined;
        const realUpdateOptions = typeof updateModeOrOptions === "object" ? updateModeOrOptions : updateOptions;
        this.actions.push(["update", entity, realUpdateMode !== null && realUpdateMode !== void 0 ? realUpdateMode : "Merge", realUpdateOptions !== null && realUpdateOptions !== void 0 ? realUpdateOptions : {}]);
    }
    /**
     * Adds an upsert action to the transaction, which inserts if the entity doesn't exist or updates the existing one
     * @param entity - entity to upsert
     * @param updateMode - update mode
     */
    upsertEntity(entity, updateMode = "Merge") {
        this.actions.push(["upsert", entity, updateMode]);
    }
}
/**
 * TableTransaction collects sub-operations that can be submitted together via submitTransaction
 */
class InternalTableTransaction {
    /**
     * @param url - Tables account url
     * @param partitionKey - partition key
     * @param credential - credential to authenticate the transaction request
     */
    constructor(url, partitionKey, transactionId, changesetId, client, interceptClient, credential, allowInsecureConnection = false) {
        this.client = client;
        this.url = url;
        this.interceptClient = interceptClient;
        this.allowInsecureConnection = allowInsecureConnection;
        // Initialize Reset-able properties
        this.resetableState = this.initializeSharedState(transactionId, changesetId, partitionKey);
        // Depending on the auth method used we need to build the url
        if (!credential) {
            // When the SAS token is provided as part of the URL we need to move it after $batch
            const urlParts = url.split("?");
            this.url = urlParts[0];
            const sas = urlParts.length > 1 ? `?${urlParts[1]}` : "";
            this.url = `${this.getUrlWithSlash()}$batch${sas}`;
        }
        else {
            // When using a SharedKey credential no SAS token is needed
            this.url = `${this.getUrlWithSlash()}$batch`;
        }
    }
    /**
     * Resets the state of the Transaction.
     */
    reset(transactionId, changesetId, partitionKey) {
        this.resetableState = this.initializeSharedState(transactionId, changesetId, partitionKey);
    }
    initializeSharedState(transactionId, changesetId, partitionKey) {
        const pendingOperations = [];
        const bodyParts = (0,_utils_transactionHelpers__WEBPACK_IMPORTED_MODULE_0__.getInitialTransactionBody)(transactionId, changesetId);
        const isCosmos = (0,_utils_isCosmosEndpoint__WEBPACK_IMPORTED_MODULE_1__.isCosmosEndpoint)(this.url);
        prepateTransactionPipeline(this.interceptClient.pipeline, bodyParts, changesetId, isCosmos);
        return {
            transactionId,
            changesetId,
            partitionKey,
            pendingOperations,
            bodyParts,
        };
    }
    /**
     * Adds a createEntity operation to the transaction
     * @param entity - Entity to create
     */
    createEntity(entity) {
        this.checkPartitionKey(entity.partitionKey);
        this.resetableState.pendingOperations.push(this.interceptClient.createEntity(entity));
    }
    /**
     * Adds a createEntity operation to the transaction per each entity in the entities array
     * @param entities - Array of entities to create
     */
    createEntities(entities) {
        for (const entity of entities) {
            this.checkPartitionKey(entity.partitionKey);
            this.resetableState.pendingOperations.push(this.interceptClient.createEntity(entity));
        }
    }
    /**
     * Adds a deleteEntity operation to the transaction
     * @param partitionKey - Partition key of the entity to delete
     * @param rowKey - Row key of the entity to delete
     * @param options - Options for the delete operation
     */
    deleteEntity(partitionKey, rowKey, options) {
        this.checkPartitionKey(partitionKey);
        this.resetableState.pendingOperations.push(this.interceptClient.deleteEntity(partitionKey, rowKey, options));
    }
    /**
     * Adds an updateEntity operation to the transaction
     * @param entity - Entity to update
     * @param mode - Update mode (Merge or Replace)
     * @param options - Options for the update operation
     */
    updateEntity(entity, mode, options) {
        this.checkPartitionKey(entity.partitionKey);
        this.resetableState.pendingOperations.push(this.interceptClient.updateEntity(entity, mode, options));
    }
    /**
     * Adds an upsertEntity operation to the transaction
     * @param entity - The properties for the table entity.
     * @param mode   - The different modes for updating the entity:
     *               - Merge: Updates an entity by updating the entity's properties without replacing the existing entity.
     *               - Replace: Updates an existing entity by replacing the entire entity.
     * @param options - The options parameters.
     */
    upsertEntity(entity, mode, options) {
        this.checkPartitionKey(entity.partitionKey);
        this.resetableState.pendingOperations.push(this.interceptClient.upsertEntity(entity, mode, options));
    }
    /**
     * Submits the operations in the transaction
     */
    async submitTransaction() {
        await Promise.all(this.resetableState.pendingOperations);
        const body = (0,_utils_transactionHelpers__WEBPACK_IMPORTED_MODULE_0__.getTransactionHttpRequestBody)(this.resetableState.bodyParts, this.resetableState.transactionId, this.resetableState.changesetId);
        const headers = (0,_utils_transactionHeaders__WEBPACK_IMPORTED_MODULE_2__.getTransactionHeaders)(this.resetableState.transactionId);
        return _utils_tracing__WEBPACK_IMPORTED_MODULE_3__.tracingClient.withSpan("TableTransaction.submitTransaction", {}, async (updatedOptions) => {
            const request = (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_4__.createPipelineRequest)({
                url: this.url,
                method: "POST",
                body,
                headers: (0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_5__.createHttpHeaders)(headers),
                tracingOptions: updatedOptions.tracingOptions,
                allowInsecureConnection: this.allowInsecureConnection,
            });
            const rawTransactionResponse = await this.client.sendRequest(request);
            return parseTransactionResponse(rawTransactionResponse);
        });
    }
    checkPartitionKey(partitionKey) {
        if (this.resetableState.partitionKey !== partitionKey) {
            throw new Error("All operations in a transaction must target the same partitionKey");
        }
    }
    getUrlWithSlash() {
        return this.url.endsWith("/") ? this.url : `${this.url}/`;
    }
}
function parseTransactionResponse(transactionResponse) {
    const subResponsePrefix = `--changesetresponse_`;
    const status = transactionResponse.status;
    const rawBody = transactionResponse.bodyAsText || "";
    const splitBody = rawBody.split(subResponsePrefix);
    const isSuccessByStatus = 200 <= status && status < 300;
    if (!isSuccessByStatus) {
        handleBodyError(rawBody, status, transactionResponse.request, transactionResponse);
    }
    // Dropping the first and last elements as they are the boundaries
    // we just care about sub request content
    const subResponses = splitBody.slice(1, splitBody.length - 1);
    const responses = subResponses.map((subResponse) => {
        const statusMatch = subResponse.match(/HTTP\/1.1 ([0-9]*)/);
        if ((statusMatch === null || statusMatch === void 0 ? void 0 : statusMatch.length) !== 2) {
            throw new Error(`Couldn't extract status from sub-response:\n ${subResponse}`);
        }
        const subResponseStatus = Number.parseInt(statusMatch[1]);
        if (!Number.isInteger(subResponseStatus)) {
            throw new Error(`Expected sub-response status to be an integer ${subResponseStatus}`);
        }
        const bodyMatch = subResponse.match(/\{(.*)\}/);
        if ((bodyMatch === null || bodyMatch === void 0 ? void 0 : bodyMatch.length) === 2) {
            handleBodyError(bodyMatch[0], subResponseStatus, transactionResponse.request, transactionResponse);
        }
        const etagMatch = subResponse.match(/ETag: (.*)/);
        const rowKeyMatch = subResponse.match(/RowKey='(.*)'/);
        return Object.assign(Object.assign({ status: subResponseStatus }, ((rowKeyMatch === null || rowKeyMatch === void 0 ? void 0 : rowKeyMatch.length) === 2 && { rowKey: rowKeyMatch[1] })), ((etagMatch === null || etagMatch === void 0 ? void 0 : etagMatch.length) === 2 && { etag: etagMatch[1] }));
    });
    return {
        status,
        subResponses: responses,
        getResponseForEntity: (rowKey) => responses.find((r) => r.rowKey === rowKey),
    };
}
function handleBodyError(bodyAsText, statusCode, request, response) {
    var _a, _b;
    let parsedError;
    try {
        parsedError = JSON.parse(bodyAsText);
    }
    catch (_c) {
        parsedError = {};
    }
    let message = "Transaction Failed";
    let code;
    // Only transaction sub-responses return body
    if (parsedError && parsedError["odata.error"]) {
        const error = parsedError["odata.error"];
        message = (_b = (_a = error.message) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : message;
        code = error.code;
    }
    throw new _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_6__.RestError(message, {
        code,
        statusCode,
        request,
        response,
    });
}
/**
 * Prepares the transaction pipeline to intercept operations
 * @param pipeline - Client pipeline
 */
function prepateTransactionPipeline(pipeline, bodyParts, changesetId, isCosmos) {
    // Fist, we need to clear all the existing policies to make sure we start
    // with a fresh state.
    const policies = pipeline.getOrderedPolicies();
    for (const policy of policies) {
        pipeline.removePolicy({
            name: policy.name,
        });
    }
    // With the clear state we now initialize the pipelines required for intercepting the requests.
    // Use transaction assemble policy to assemble request and intercept request from going to wire
    pipeline.addPolicy((0,_azure_core_client__WEBPACK_IMPORTED_MODULE_7__.serializationPolicy)(), { phase: "Serialize" });
    pipeline.addPolicy((0,_TablePolicies__WEBPACK_IMPORTED_MODULE_8__.transactionHeaderFilterPolicy)());
    pipeline.addPolicy((0,_TablePolicies__WEBPACK_IMPORTED_MODULE_8__.transactionRequestAssemblePolicy)(bodyParts, changesetId));
    if (isCosmos) {
        pipeline.addPolicy((0,_cosmosPathPolicy__WEBPACK_IMPORTED_MODULE_9__.cosmosPatchPolicy)(), {
            afterPolicies: [_TablePolicies__WEBPACK_IMPORTED_MODULE_8__.transactionHeaderFilterPolicyName],
            beforePolicies: [_azure_core_client__WEBPACK_IMPORTED_MODULE_7__.serializationPolicyName, _TablePolicies__WEBPACK_IMPORTED_MODULE_8__.transactionRequestAssemblePolicyName],
        });
    }
}
//# sourceMappingURL=TableTransaction.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/cosmosPathPolicy.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/cosmosPathPolicy.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cosmosPatchPolicy": () => (/* binding */ cosmosPatchPolicy)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const cosmosPatchPolicyName = "cosmosPatchPolicy";
function cosmosPatchPolicy() {
    return {
        name: cosmosPatchPolicyName,
        sendRequest: (request, next) => {
            if (request.method === "PATCH") {
                request.method = "POST";
                request.headers.set("X-HTTP-Method", "MERGE");
            }
            return next(request);
        },
    };
}
//# sourceMappingURL=cosmosPathPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/generated/generatedClient.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/generated/generatedClient.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeneratedClient": () => (/* binding */ GeneratedClient)
/* harmony export */ });
/* harmony import */ var _azure_core_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-client */ "./node_modules/@azure/core-client/dist-esm/src/serviceClient.js");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operations */ "./node_modules/@azure/data-tables/dist-esm/src/generated/operations/table.js");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./operations */ "./node_modules/@azure/data-tables/dist-esm/src/generated/operations/service.js");
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */


/** @internal */
class GeneratedClient extends _azure_core_client__WEBPACK_IMPORTED_MODULE_0__.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param url The URL of the service account or table that is the target of the desired operation.
     * @param options The parameter options
     */
    constructor(url, options) {
        var _a, _b;
        if (url === undefined) {
            throw new Error("'url' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-data-tables/13.1.2`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{url}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.url = url;
        // Assigning values to Constant parameters
        this.version = options.version || "2019-02-02";
        this.table = new _operations__WEBPACK_IMPORTED_MODULE_1__.TableImpl(this);
        this.service = new _operations__WEBPACK_IMPORTED_MODULE_2__.ServiceImpl(this);
    }
}
//# sourceMappingURL=generatedClient.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/mappers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/generated/models/mappers.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessPolicy": () => (/* binding */ AccessPolicy),
/* harmony export */   "CorsRule": () => (/* binding */ CorsRule),
/* harmony export */   "GeoReplication": () => (/* binding */ GeoReplication),
/* harmony export */   "Logging": () => (/* binding */ Logging),
/* harmony export */   "Metrics": () => (/* binding */ Metrics),
/* harmony export */   "RetentionPolicy": () => (/* binding */ RetentionPolicy),
/* harmony export */   "ServiceGetPropertiesExceptionHeaders": () => (/* binding */ ServiceGetPropertiesExceptionHeaders),
/* harmony export */   "ServiceGetPropertiesHeaders": () => (/* binding */ ServiceGetPropertiesHeaders),
/* harmony export */   "ServiceGetStatisticsExceptionHeaders": () => (/* binding */ ServiceGetStatisticsExceptionHeaders),
/* harmony export */   "ServiceGetStatisticsHeaders": () => (/* binding */ ServiceGetStatisticsHeaders),
/* harmony export */   "ServiceSetPropertiesExceptionHeaders": () => (/* binding */ ServiceSetPropertiesExceptionHeaders),
/* harmony export */   "ServiceSetPropertiesHeaders": () => (/* binding */ ServiceSetPropertiesHeaders),
/* harmony export */   "SignedIdentifier": () => (/* binding */ SignedIdentifier),
/* harmony export */   "TableCreateExceptionHeaders": () => (/* binding */ TableCreateExceptionHeaders),
/* harmony export */   "TableCreateHeaders": () => (/* binding */ TableCreateHeaders),
/* harmony export */   "TableDeleteEntityExceptionHeaders": () => (/* binding */ TableDeleteEntityExceptionHeaders),
/* harmony export */   "TableDeleteEntityHeaders": () => (/* binding */ TableDeleteEntityHeaders),
/* harmony export */   "TableDeleteExceptionHeaders": () => (/* binding */ TableDeleteExceptionHeaders),
/* harmony export */   "TableDeleteHeaders": () => (/* binding */ TableDeleteHeaders),
/* harmony export */   "TableEntityQueryResponse": () => (/* binding */ TableEntityQueryResponse),
/* harmony export */   "TableGetAccessPolicyExceptionHeaders": () => (/* binding */ TableGetAccessPolicyExceptionHeaders),
/* harmony export */   "TableGetAccessPolicyHeaders": () => (/* binding */ TableGetAccessPolicyHeaders),
/* harmony export */   "TableInsertEntityExceptionHeaders": () => (/* binding */ TableInsertEntityExceptionHeaders),
/* harmony export */   "TableInsertEntityHeaders": () => (/* binding */ TableInsertEntityHeaders),
/* harmony export */   "TableMergeEntityExceptionHeaders": () => (/* binding */ TableMergeEntityExceptionHeaders),
/* harmony export */   "TableMergeEntityHeaders": () => (/* binding */ TableMergeEntityHeaders),
/* harmony export */   "TableProperties": () => (/* binding */ TableProperties),
/* harmony export */   "TableQueryEntitiesExceptionHeaders": () => (/* binding */ TableQueryEntitiesExceptionHeaders),
/* harmony export */   "TableQueryEntitiesHeaders": () => (/* binding */ TableQueryEntitiesHeaders),
/* harmony export */   "TableQueryEntitiesWithPartitionAndRowKeyExceptionHeaders": () => (/* binding */ TableQueryEntitiesWithPartitionAndRowKeyExceptionHeaders),
/* harmony export */   "TableQueryEntitiesWithPartitionAndRowKeyHeaders": () => (/* binding */ TableQueryEntitiesWithPartitionAndRowKeyHeaders),
/* harmony export */   "TableQueryExceptionHeaders": () => (/* binding */ TableQueryExceptionHeaders),
/* harmony export */   "TableQueryHeaders": () => (/* binding */ TableQueryHeaders),
/* harmony export */   "TableQueryResponse": () => (/* binding */ TableQueryResponse),
/* harmony export */   "TableResponse": () => (/* binding */ TableResponse),
/* harmony export */   "TableResponseProperties": () => (/* binding */ TableResponseProperties),
/* harmony export */   "TableServiceError": () => (/* binding */ TableServiceError),
/* harmony export */   "TableServiceErrorOdataError": () => (/* binding */ TableServiceErrorOdataError),
/* harmony export */   "TableServiceErrorOdataErrorMessage": () => (/* binding */ TableServiceErrorOdataErrorMessage),
/* harmony export */   "TableServiceProperties": () => (/* binding */ TableServiceProperties),
/* harmony export */   "TableServiceStats": () => (/* binding */ TableServiceStats),
/* harmony export */   "TableSetAccessPolicyExceptionHeaders": () => (/* binding */ TableSetAccessPolicyExceptionHeaders),
/* harmony export */   "TableSetAccessPolicyHeaders": () => (/* binding */ TableSetAccessPolicyHeaders),
/* harmony export */   "TableUpdateEntityExceptionHeaders": () => (/* binding */ TableUpdateEntityExceptionHeaders),
/* harmony export */   "TableUpdateEntityHeaders": () => (/* binding */ TableUpdateEntityHeaders)
/* harmony export */ });
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const TableQueryResponse = {
    serializedName: "TableQueryResponse",
    type: {
        name: "Composite",
        className: "TableQueryResponse",
        modelProperties: {
            odataMetadata: {
                serializedName: "odata\\.metadata",
                xmlName: "odata\\.metadata",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "TableResponseProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TableResponseProperties"
                        }
                    }
                }
            }
        }
    }
};
const TableResponseProperties = {
    serializedName: "TableResponseProperties",
    type: {
        name: "Composite",
        className: "TableResponseProperties",
        modelProperties: {
            name: {
                serializedName: "TableName",
                xmlName: "TableName",
                type: {
                    name: "String"
                }
            },
            odataType: {
                serializedName: "odata\\.type",
                xmlName: "odata\\.type",
                type: {
                    name: "String"
                }
            },
            odataId: {
                serializedName: "odata\\.id",
                xmlName: "odata\\.id",
                type: {
                    name: "String"
                }
            },
            odataEditLink: {
                serializedName: "odata\\.editLink",
                xmlName: "odata\\.editLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableServiceError = {
    serializedName: "TableServiceError",
    type: {
        name: "Composite",
        className: "TableServiceError",
        modelProperties: {
            odataError: {
                serializedName: "odata\\.error",
                xmlName: "odata\\.error",
                type: {
                    name: "Composite",
                    className: "TableServiceErrorOdataError"
                }
            }
        }
    }
};
const TableServiceErrorOdataError = {
    serializedName: "TableServiceErrorOdataError",
    type: {
        name: "Composite",
        className: "TableServiceErrorOdataError",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "Composite",
                    className: "TableServiceErrorOdataErrorMessage"
                }
            }
        }
    }
};
const TableServiceErrorOdataErrorMessage = {
    serializedName: "TableServiceErrorOdataErrorMessage",
    type: {
        name: "Composite",
        className: "TableServiceErrorOdataErrorMessage",
        modelProperties: {
            lang: {
                serializedName: "lang",
                xmlName: "lang",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableProperties = {
    serializedName: "TableProperties",
    type: {
        name: "Composite",
        className: "TableProperties",
        modelProperties: {
            name: {
                serializedName: "TableName",
                xmlName: "TableName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableEntityQueryResponse = {
    serializedName: "TableEntityQueryResponse",
    type: {
        name: "Composite",
        className: "TableEntityQueryResponse",
        modelProperties: {
            odataMetadata: {
                serializedName: "odata\\.metadata",
                xmlName: "odata\\.metadata",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "TableEntityProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "any" } }
                        }
                    }
                }
            }
        }
    }
};
const SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
            id: {
                serializedName: "Id",
                required: true,
                xmlName: "Id",
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                serializedName: "AccessPolicy",
                xmlName: "AccessPolicy",
                type: {
                    name: "Composite",
                    className: "AccessPolicy"
                }
            }
        }
    }
};
const AccessPolicy = {
    serializedName: "AccessPolicy",
    xmlName: "AccessPolicy",
    type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
            start: {
                serializedName: "Start",
                xmlName: "Start",
                type: {
                    name: "String"
                }
            },
            expiry: {
                serializedName: "Expiry",
                xmlName: "Expiry",
                type: {
                    name: "String"
                }
            },
            permission: {
                serializedName: "Permission",
                xmlName: "Permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableServiceProperties = {
    serializedName: "TableServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
        name: "Composite",
        className: "TableServiceProperties",
        modelProperties: {
            logging: {
                serializedName: "Logging",
                xmlName: "Logging",
                type: {
                    name: "Composite",
                    className: "Logging"
                }
            },
            hourMetrics: {
                serializedName: "HourMetrics",
                xmlName: "HourMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            minuteMetrics: {
                serializedName: "MinuteMetrics",
                xmlName: "MinuteMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            cors: {
                serializedName: "Cors",
                xmlName: "Cors",
                xmlIsWrapped: true,
                xmlElementName: "CorsRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsRule"
                        }
                    }
                }
            }
        }
    }
};
const Logging = {
    serializedName: "Logging",
    xmlName: "Logging",
    type: {
        name: "Composite",
        className: "Logging",
        modelProperties: {
            version: {
                serializedName: "Version",
                required: true,
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            delete: {
                serializedName: "Delete",
                required: true,
                xmlName: "Delete",
                type: {
                    name: "Boolean"
                }
            },
            read: {
                serializedName: "Read",
                required: true,
                xmlName: "Read",
                type: {
                    name: "Boolean"
                }
            },
            write: {
                serializedName: "Write",
                required: true,
                xmlName: "Write",
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "RetentionPolicy",
                xmlName: "RetentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            }
        }
    }
};
const RetentionPolicy = {
    serializedName: "RetentionPolicy",
    xmlName: "RetentionPolicy",
    type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            days: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "Days",
                xmlName: "Days",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Metrics = {
    serializedName: "Metrics",
    type: {
        name: "Composite",
        className: "Metrics",
        modelProperties: {
            version: {
                serializedName: "Version",
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            includeAPIs: {
                serializedName: "IncludeAPIs",
                xmlName: "IncludeAPIs",
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "RetentionPolicy",
                xmlName: "RetentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            }
        }
    }
};
const CorsRule = {
    serializedName: "CorsRule",
    xmlName: "CorsRule",
    type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
            allowedOrigins: {
                serializedName: "AllowedOrigins",
                required: true,
                xmlName: "AllowedOrigins",
                type: {
                    name: "String"
                }
            },
            allowedMethods: {
                serializedName: "AllowedMethods",
                required: true,
                xmlName: "AllowedMethods",
                type: {
                    name: "String"
                }
            },
            allowedHeaders: {
                serializedName: "AllowedHeaders",
                required: true,
                xmlName: "AllowedHeaders",
                type: {
                    name: "String"
                }
            },
            exposedHeaders: {
                serializedName: "ExposedHeaders",
                required: true,
                xmlName: "ExposedHeaders",
                type: {
                    name: "String"
                }
            },
            maxAgeInSeconds: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "MaxAgeInSeconds",
                required: true,
                xmlName: "MaxAgeInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TableServiceStats = {
    serializedName: "TableServiceStats",
    xmlName: "StorageServiceStats",
    type: {
        name: "Composite",
        className: "TableServiceStats",
        modelProperties: {
            geoReplication: {
                serializedName: "GeoReplication",
                xmlName: "GeoReplication",
                type: {
                    name: "Composite",
                    className: "GeoReplication"
                }
            }
        }
    }
};
const GeoReplication = {
    serializedName: "GeoReplication",
    xmlName: "GeoReplication",
    type: {
        name: "Composite",
        className: "GeoReplication",
        modelProperties: {
            status: {
                serializedName: "Status",
                required: true,
                xmlName: "Status",
                type: {
                    name: "String"
                }
            },
            lastSyncTime: {
                serializedName: "LastSyncTime",
                required: true,
                xmlName: "LastSyncTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const TableResponse = {
    serializedName: "TableResponse",
    type: {
        name: "Composite",
        className: "TableResponse",
        modelProperties: Object.assign(Object.assign({}, TableResponseProperties.type.modelProperties), { odataMetadata: {
                serializedName: "odata\\.metadata",
                xmlName: "odata\\.metadata",
                type: {
                    name: "String"
                }
            } })
    }
};
const TableQueryHeaders = {
    serializedName: "Table_queryHeaders",
    type: {
        name: "Composite",
        className: "TableQueryHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            xMsContinuationNextTableName: {
                serializedName: "x-ms-continuation-nexttablename",
                xmlName: "x-ms-continuation-nexttablename",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableQueryExceptionHeaders = {
    serializedName: "Table_queryExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableQueryExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableCreateHeaders = {
    serializedName: "Table_createHeaders",
    type: {
        name: "Composite",
        className: "TableCreateHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            preferenceApplied: {
                serializedName: "preference-applied",
                xmlName: "preference-applied",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableCreateExceptionHeaders = {
    serializedName: "Table_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableDeleteHeaders = {
    serializedName: "Table_deleteHeaders",
    type: {
        name: "Composite",
        className: "TableDeleteHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const TableDeleteExceptionHeaders = {
    serializedName: "Table_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableQueryEntitiesHeaders = {
    serializedName: "Table_queryEntitiesHeaders",
    type: {
        name: "Composite",
        className: "TableQueryEntitiesHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            xMsContinuationNextPartitionKey: {
                serializedName: "x-ms-continuation-nextpartitionkey",
                xmlName: "x-ms-continuation-nextpartitionkey",
                type: {
                    name: "String"
                }
            },
            xMsContinuationNextRowKey: {
                serializedName: "x-ms-continuation-nextrowkey",
                xmlName: "x-ms-continuation-nextrowkey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableQueryEntitiesExceptionHeaders = {
    serializedName: "Table_queryEntitiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableQueryEntitiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableQueryEntitiesWithPartitionAndRowKeyHeaders = {
    serializedName: "Table_queryEntitiesWithPartitionAndRowKeyHeaders",
    type: {
        name: "Composite",
        className: "TableQueryEntitiesWithPartitionAndRowKeyHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            xMsContinuationNextPartitionKey: {
                serializedName: "x-ms-continuation-nextpartitionkey",
                xmlName: "x-ms-continuation-nextpartitionkey",
                type: {
                    name: "String"
                }
            },
            xMsContinuationNextRowKey: {
                serializedName: "x-ms-continuation-nextrowkey",
                xmlName: "x-ms-continuation-nextrowkey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableQueryEntitiesWithPartitionAndRowKeyExceptionHeaders = {
    serializedName: "Table_queryEntitiesWithPartitionAndRowKeyExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableQueryEntitiesWithPartitionAndRowKeyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableUpdateEntityHeaders = {
    serializedName: "Table_updateEntityHeaders",
    type: {
        name: "Composite",
        className: "TableUpdateEntityHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableUpdateEntityExceptionHeaders = {
    serializedName: "Table_updateEntityExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableUpdateEntityExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableMergeEntityHeaders = {
    serializedName: "Table_mergeEntityHeaders",
    type: {
        name: "Composite",
        className: "TableMergeEntityHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableMergeEntityExceptionHeaders = {
    serializedName: "Table_mergeEntityExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableMergeEntityExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableDeleteEntityHeaders = {
    serializedName: "Table_deleteEntityHeaders",
    type: {
        name: "Composite",
        className: "TableDeleteEntityHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const TableDeleteEntityExceptionHeaders = {
    serializedName: "Table_deleteEntityExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableDeleteEntityExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableInsertEntityHeaders = {
    serializedName: "Table_insertEntityHeaders",
    type: {
        name: "Composite",
        className: "TableInsertEntityHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            preferenceApplied: {
                serializedName: "preference-applied",
                xmlName: "preference-applied",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableInsertEntityExceptionHeaders = {
    serializedName: "Table_insertEntityExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableInsertEntityExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableGetAccessPolicyHeaders = {
    serializedName: "Table_getAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "TableGetAccessPolicyHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const TableGetAccessPolicyExceptionHeaders = {
    serializedName: "Table_getAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableGetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableSetAccessPolicyHeaders = {
    serializedName: "Table_setAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "TableSetAccessPolicyHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const TableSetAccessPolicyExceptionHeaders = {
    serializedName: "Table_setAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "TableSetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetStatisticsHeaders",
        modelProperties: {
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetStatisticsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
//# sourceMappingURL=mappers.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/parameters.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/generated/models/parameters.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "accept": () => (/* binding */ accept),
/* harmony export */   "accept1": () => (/* binding */ accept1),
/* harmony export */   "accept2": () => (/* binding */ accept2),
/* harmony export */   "accept3": () => (/* binding */ accept3),
/* harmony export */   "comp": () => (/* binding */ comp),
/* harmony export */   "comp1": () => (/* binding */ comp1),
/* harmony export */   "comp2": () => (/* binding */ comp2),
/* harmony export */   "contentType": () => (/* binding */ contentType),
/* harmony export */   "contentType1": () => (/* binding */ contentType1),
/* harmony export */   "contentType2": () => (/* binding */ contentType2),
/* harmony export */   "dataServiceVersion": () => (/* binding */ dataServiceVersion),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "ifMatch": () => (/* binding */ ifMatch),
/* harmony export */   "ifMatch1": () => (/* binding */ ifMatch1),
/* harmony export */   "nextPartitionKey": () => (/* binding */ nextPartitionKey),
/* harmony export */   "nextRowKey": () => (/* binding */ nextRowKey),
/* harmony export */   "nextTableName": () => (/* binding */ nextTableName),
/* harmony export */   "partitionKey": () => (/* binding */ partitionKey),
/* harmony export */   "requestId": () => (/* binding */ requestId),
/* harmony export */   "responsePreference": () => (/* binding */ responsePreference),
/* harmony export */   "restype": () => (/* binding */ restype),
/* harmony export */   "rowKey": () => (/* binding */ rowKey),
/* harmony export */   "select": () => (/* binding */ select),
/* harmony export */   "table": () => (/* binding */ table),
/* harmony export */   "tableAcl": () => (/* binding */ tableAcl),
/* harmony export */   "tableEntityProperties": () => (/* binding */ tableEntityProperties),
/* harmony export */   "tableProperties": () => (/* binding */ tableProperties),
/* harmony export */   "tableServiceProperties": () => (/* binding */ tableServiceProperties),
/* harmony export */   "timeout": () => (/* binding */ timeout),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "url": () => (/* binding */ url),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _models_mappers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/mappers */ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/mappers.js");
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json;odata=minimalmetadata",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const url = {
    parameterPath: "url",
    mapper: {
        serializedName: "url",
        required: true,
        xmlName: "url",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const version = {
    parameterPath: "version",
    mapper: {
        defaultValue: "2019-02-02",
        isConstant: true,
        serializedName: "x-ms-version",
        type: {
            name: "String"
        }
    }
};
const requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
            name: "String"
        }
    }
};
const dataServiceVersion = {
    parameterPath: "dataServiceVersion",
    mapper: {
        defaultValue: "3.0",
        isConstant: true,
        serializedName: "DataServiceVersion",
        type: {
            name: "String"
        }
    }
};
const format = {
    parameterPath: ["options", "queryOptions", "format"],
    mapper: {
        serializedName: "$format",
        xmlName: "$format",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "queryOptions", "top"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "Number"
        }
    }
};
const select = {
    parameterPath: ["options", "queryOptions", "select"],
    mapper: {
        serializedName: "$select",
        xmlName: "$select",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "queryOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String"
        }
    }
};
const nextTableName = {
    parameterPath: ["options", "nextTableName"],
    mapper: {
        serializedName: "NextTableName",
        xmlName: "NextTableName",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json;odata=nometadata",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const tableProperties = {
    parameterPath: "tableProperties",
    mapper: _models_mappers__WEBPACK_IMPORTED_MODULE_0__.TableProperties
};
const responsePreference = {
    parameterPath: ["options", "responsePreference"],
    mapper: {
        serializedName: "Prefer",
        xmlName: "Prefer",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const table = {
    parameterPath: "table",
    mapper: {
        serializedName: "table",
        required: true,
        xmlName: "table",
        type: {
            name: "String"
        }
    }
};
const timeout = {
    parameterPath: ["options", "timeout"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "timeout",
        xmlName: "timeout",
        type: {
            name: "Number"
        }
    }
};
const nextPartitionKey = {
    parameterPath: ["options", "nextPartitionKey"],
    mapper: {
        serializedName: "NextPartitionKey",
        xmlName: "NextPartitionKey",
        type: {
            name: "String"
        }
    }
};
const nextRowKey = {
    parameterPath: ["options", "nextRowKey"],
    mapper: {
        serializedName: "NextRowKey",
        xmlName: "NextRowKey",
        type: {
            name: "String"
        }
    }
};
const partitionKey = {
    parameterPath: "partitionKey",
    mapper: {
        serializedName: "partitionKey",
        required: true,
        xmlName: "partitionKey",
        type: {
            name: "String"
        }
    }
};
const rowKey = {
    parameterPath: "rowKey",
    mapper: {
        serializedName: "rowKey",
        required: true,
        xmlName: "rowKey",
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const tableEntityProperties = {
    parameterPath: ["options", "tableEntityProperties"],
    mapper: {
        serializedName: "tableEntityProperties",
        xmlName: "tableEntityProperties",
        type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        xmlName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifMatch1 = {
    parameterPath: "ifMatch",
    mapper: {
        serializedName: "If-Match",
        required: true,
        xmlName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const comp = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "acl",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const contentType2 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const tableAcl = {
    parameterPath: ["options", "tableAcl"],
    mapper: {
        serializedName: "tableAcl",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: true,
        xmlElementName: "SignedIdentifier",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "SignedIdentifier"
                }
            }
        }
    }
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const tableServiceProperties = {
    parameterPath: "tableServiceProperties",
    mapper: _models_mappers__WEBPACK_IMPORTED_MODULE_0__.TableServiceProperties
};
const restype = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "service",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
const comp1 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "properties",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const comp2 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "stats",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
//# sourceMappingURL=parameters.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/generated/operations/service.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/generated/operations/service.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceImpl": () => (/* binding */ ServiceImpl)
/* harmony export */ });
/* harmony import */ var _azure_core_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-client */ "./node_modules/@azure/core-client/dist-esm/src/serializer.js");
/* harmony import */ var _models_mappers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/mappers */ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/mappers.js");
/* harmony import */ var _models_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/parameters */ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/parameters.js");
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */



/** Class containing Service operations. */
class ServiceImpl {
    /**
     * Initialize a new instance of the class Service class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Sets properties for an account's Table service endpoint, including properties for Analytics and CORS
     * (Cross-Origin Resource Sharing) rules.
     * @param tableServiceProperties The Table Service properties.
     * @param options The options parameters.
     */
    setProperties(tableServiceProperties, options) {
        return this.client.sendOperationRequest({ tableServiceProperties, options }, setPropertiesOperationSpec);
    }
    /**
     * Gets the properties of an account's Table service, including properties for Analytics and CORS
     * (Cross-Origin Resource Sharing) rules.
     * @param options The options parameters.
     */
    getProperties(options) {
        return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    /**
     * Retrieves statistics related to replication for the Table service. It is only available on the
     * secondary location endpoint when read-access geo-redundant replication is enabled for the account.
     * @param options The options parameters.
     */
    getStatistics(options) {
        return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer = _azure_core_client__WEBPACK_IMPORTED_MODULE_0__.createSerializer(_models_mappers__WEBPACK_IMPORTED_MODULE_1__, /* isXml */ true);
const setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceSetPropertiesExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableServiceProperties,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.restype, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.comp1],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType2,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept3
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
};
const getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceProperties,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.restype, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.comp1],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept2
    ],
    isXML: true,
    serializer: xmlSerializer
};
const getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceStats,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceGetStatisticsHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.ServiceGetStatisticsExceptionHeaders
        }
    },
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.restype, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.comp2],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept2
    ],
    isXML: true,
    serializer: xmlSerializer
};
//# sourceMappingURL=service.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/generated/operations/table.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/generated/operations/table.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TableImpl": () => (/* binding */ TableImpl)
/* harmony export */ });
/* harmony import */ var _azure_core_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-client */ "./node_modules/@azure/core-client/dist-esm/src/serializer.js");
/* harmony import */ var _models_mappers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/mappers */ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/mappers.js");
/* harmony import */ var _models_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/parameters */ "./node_modules/@azure/data-tables/dist-esm/src/generated/models/parameters.js");
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */



/** Class containing Table operations. */
class TableImpl {
    /**
     * Initialize a new instance of the class Table class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Queries tables under the given account.
     * @param options The options parameters.
     */
    query(options) {
        return this.client.sendOperationRequest({ options }, queryOperationSpec);
    }
    /**
     * Creates a new table under the given account.
     * @param tableProperties The Table properties.
     * @param options The options parameters.
     */
    create(tableProperties, options) {
        return this.client.sendOperationRequest({ tableProperties, options }, createOperationSpec);
    }
    /**
     * Operation permanently deletes the specified table.
     * @param table The name of the table.
     * @param options The options parameters.
     */
    delete(table, options) {
        return this.client.sendOperationRequest({ table, options }, deleteOperationSpec);
    }
    /**
     * Queries entities in a table.
     * @param table The name of the table.
     * @param options The options parameters.
     */
    queryEntities(table, options) {
        return this.client.sendOperationRequest({ table, options }, queryEntitiesOperationSpec);
    }
    /**
     * Queries entities in a table.
     * @param table The name of the table.
     * @param partitionKey The partition key of the entity.
     * @param rowKey The row key of the entity.
     * @param options The options parameters.
     */
    queryEntitiesWithPartitionAndRowKey(table, partitionKey, rowKey, options) {
        return this.client.sendOperationRequest({ table, partitionKey, rowKey, options }, queryEntitiesWithPartitionAndRowKeyOperationSpec);
    }
    /**
     * Update entity in a table.
     * @param table The name of the table.
     * @param partitionKey The partition key of the entity.
     * @param rowKey The row key of the entity.
     * @param options The options parameters.
     */
    updateEntity(table, partitionKey, rowKey, options) {
        return this.client.sendOperationRequest({ table, partitionKey, rowKey, options }, updateEntityOperationSpec);
    }
    /**
     * Merge entity in a table.
     * @param table The name of the table.
     * @param partitionKey The partition key of the entity.
     * @param rowKey The row key of the entity.
     * @param options The options parameters.
     */
    mergeEntity(table, partitionKey, rowKey, options) {
        return this.client.sendOperationRequest({ table, partitionKey, rowKey, options }, mergeEntityOperationSpec);
    }
    /**
     * Deletes the specified entity in a table.
     * @param table The name of the table.
     * @param partitionKey The partition key of the entity.
     * @param rowKey The row key of the entity.
     * @param ifMatch Match condition for an entity to be deleted. If specified and a matching entity is
     *                not found, an error will be raised. To force an unconditional delete, set to the wildcard character
     *                (*).
     * @param options The options parameters.
     */
    deleteEntity(table, partitionKey, rowKey, ifMatch, options) {
        return this.client.sendOperationRequest({ table, partitionKey, rowKey, ifMatch, options }, deleteEntityOperationSpec);
    }
    /**
     * Insert entity in a table.
     * @param table The name of the table.
     * @param options The options parameters.
     */
    insertEntity(table, options) {
        return this.client.sendOperationRequest({ table, options }, insertEntityOperationSpec);
    }
    /**
     * Retrieves details about any stored access policies specified on the table that may be used with
     * Shared Access Signatures.
     * @param table The name of the table.
     * @param options The options parameters.
     */
    getAccessPolicy(table, options) {
        return this.client.sendOperationRequest({ table, options }, getAccessPolicyOperationSpec);
    }
    /**
     * Sets stored access policies for the table that may be used with Shared Access Signatures.
     * @param table The name of the table.
     * @param options The options parameters.
     */
    setAccessPolicy(table, options) {
        return this.client.sendOperationRequest({ table, options }, setAccessPolicyOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer = _azure_core_client__WEBPACK_IMPORTED_MODULE_0__.createSerializer(_models_mappers__WEBPACK_IMPORTED_MODULE_1__, /* isXml */ true);
const serializer = _azure_core_client__WEBPACK_IMPORTED_MODULE_0__.createSerializer(_models_mappers__WEBPACK_IMPORTED_MODULE_1__, /* isXml */ false);
const queryOperationSpec = {
    path: "/Tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryResponse,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryExceptionHeaders
        }
    },
    queryParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.format,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.top,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.select,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.filter,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.nextTableName
    ],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion
    ],
    serializer
};
const createOperationSpec = {
    path: "/Tables",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableResponse,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableCreateHeaders
        },
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableCreateHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableCreateExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableProperties,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.format],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.responsePreference
    ],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/Tables('{table}')",
    httpMethod: "DELETE",
    responses: {
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableDeleteHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableDeleteExceptionHeaders
        }
    },
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept1
    ],
    serializer
};
const queryEntitiesOperationSpec = {
    path: "/{table}()",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableEntityQueryResponse,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryEntitiesHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryEntitiesExceptionHeaders
        }
    },
    queryParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.format,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.top,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.select,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.filter,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.nextPartitionKey,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.nextRowKey
    ],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion
    ],
    serializer
};
const queryEntitiesWithPartitionAndRowKeyOperationSpec = {
    path: "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            },
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryEntitiesWithPartitionAndRowKeyHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableQueryEntitiesWithPartitionAndRowKeyExceptionHeaders
        }
    },
    queryParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.format,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.select,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.filter,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout
    ],
    urlParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.url,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.partitionKey,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.rowKey
    ],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion
    ],
    serializer
};
const updateEntityOperationSpec = {
    path: "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    httpMethod: "PUT",
    responses: {
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableUpdateEntityHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableUpdateEntityExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableEntityProperties,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.format, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout],
    urlParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.url,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.partitionKey,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.rowKey
    ],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept1,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType1,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.ifMatch
    ],
    mediaType: "json",
    serializer
};
const mergeEntityOperationSpec = {
    path: "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    httpMethod: "PATCH",
    responses: {
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableMergeEntityHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableMergeEntityExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableEntityProperties,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.format, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout],
    urlParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.url,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.partitionKey,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.rowKey
    ],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept1,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType1,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.ifMatch
    ],
    mediaType: "json",
    serializer
};
const deleteEntityOperationSpec = {
    path: "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    httpMethod: "DELETE",
    responses: {
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableDeleteEntityHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableDeleteEntityExceptionHeaders
        }
    },
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.format, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout],
    urlParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.url,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.partitionKey,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.rowKey
    ],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.ifMatch1
    ],
    serializer
};
const insertEntityOperationSpec = {
    path: "/{table}",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            },
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableInsertEntityHeaders
        },
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableInsertEntityHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableInsertEntityExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableEntityProperties,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.format, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.dataServiceVersion,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.responsePreference
    ],
    mediaType: "json",
    serializer
};
const getAccessPolicyOperationSpec = {
    path: "/{table}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "SignedIdentifier" }
                    }
                },
                serializedName: "SignedIdentifiers",
                xmlName: "SignedIdentifiers",
                xmlIsWrapped: true,
                xmlElementName: "SignedIdentifier"
            },
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableGetAccessPolicyExceptionHeaders
        }
    },
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.comp],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept2
    ],
    isXML: true,
    serializer: xmlSerializer
};
const setAccessPolicyOperationSpec = {
    path: "/{table}",
    httpMethod: "PUT",
    responses: {
        204: {
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableServiceError,
            headersMapper: _models_mappers__WEBPACK_IMPORTED_MODULE_1__.TableSetAccessPolicyExceptionHeaders
        }
    },
    requestBody: _models_parameters__WEBPACK_IMPORTED_MODULE_2__.tableAcl,
    queryParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.timeout, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.comp],
    urlParameters: [_models_parameters__WEBPACK_IMPORTED_MODULE_2__.url, _models_parameters__WEBPACK_IMPORTED_MODULE_2__.table],
    headerParameters: [
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.version,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.requestId,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.contentType2,
        _models_parameters__WEBPACK_IMPORTED_MODULE_2__.accept3
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
};
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/logger.js":
/*!****************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/logger.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logger": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _azure_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/logger */ "./node_modules/@azure/logger/dist-esm/src/index.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The \@azure/logger configuration for this package.
 */
const logger = (0,_azure_logger__WEBPACK_IMPORTED_MODULE_0__.createClientLogger)("data-tables");
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/odata.js":
/*!***************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/odata.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeQuotes": () => (/* binding */ escapeQuotes),
/* harmony export */   "odata": () => (/* binding */ odata)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = escapeQuotes(input);
        // check if we need to escape this literal
        if (previous !== "" && !previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
function escapeQuotes(input) {
    return input.replace(/'/g, "''");
}
function encodeDate(input) {
    return input instanceof Date ? `datetime'${input.toISOString()}'` : input;
}
/**
 * Escapes an odata filter expression to avoid errors with quoting string literals.
 * Encodes Date objects.
 */
function odata(strings, ...values) {
    const fixEncoding = (value, string) => {
        return encodeDate(escapeQuotesIfString(value, string));
    };
    const results = [];
    for (let i = 0; i < strings.length; i++) {
        results.push(strings[i]);
        if (i < values.length) {
            results.push(fixEncoding(values[i], strings[i]));
        }
    }
    return results.join("");
}
//# sourceMappingURL=odata.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/serialization.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/serialization.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deserialize": () => (/* binding */ deserialize),
/* harmony export */   "deserializeObjectsArray": () => (/* binding */ deserializeObjectsArray),
/* harmony export */   "deserializeSignedIdentifier": () => (/* binding */ deserializeSignedIdentifier),
/* harmony export */   "serialize": () => (/* binding */ serialize),
/* harmony export */   "serializeQueryOptions": () => (/* binding */ serializeQueryOptions),
/* harmony export */   "serializeSignedIdentifiers": () => (/* binding */ serializeSignedIdentifiers)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils_bufferSerializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/bufferSerializer */ "./node_modules/@azure/data-tables/dist-esm/src/utils/bufferSerializer.js");
/* harmony import */ var _utils_truncateISO8061Date__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/truncateISO8061Date */ "./node_modules/@azure/data-tables/dist-esm/src/utils/truncateISO8061Date.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



const propertyCaseMap = new Map([
    ["PartitionKey", "partitionKey"],
    ["RowKey", "rowKey"],
    ["odata.etag", "etag"],
    ["Timestamp", "timestamp"],
]);
const Edm = {
    Binary: "Edm.Binary",
    Boolean: "Edm.Boolean",
    DateTime: "Edm.DateTime",
    Double: "Edm.Double",
    Guid: "Edm.Guid",
    Int32: "Edm.Int32",
    Int64: "Edm.Int64",
    String: "Edm.String",
};
function serializePrimitive(value) {
    const serializedValue = { value };
    if (value === undefined ||
        value === null ||
        typeof value === "boolean" ||
        typeof value === "string" ||
        typeof value === "number") {
        serializedValue.value = value;
    }
    else if (typeof value === "bigint") {
        serializedValue.value = value.toString();
        serializedValue.type = Edm.Int64;
    }
    else if (value instanceof Date) {
        serializedValue.value = value;
        serializedValue.type = Edm.DateTime;
    }
    else if (value instanceof Uint8Array) {
        serializedValue.value = (0,_utils_bufferSerializer__WEBPACK_IMPORTED_MODULE_0__.base64Encode)(value);
        serializedValue.type = Edm.Binary;
    }
    else {
        throw new Error(`Unknown EDM type ${typeof value}`);
    }
    return serializedValue;
}
function serializeObject(obj) {
    const serializedValue = { value: obj.value };
    if (obj.type === "Boolean" ||
        obj.type === "DateTime" ||
        obj.type === "Double" ||
        obj.type === "Guid" ||
        obj.type === "Int32" ||
        obj.type === "Int64" ||
        obj.type === "String" ||
        obj.type === "Binary") {
        serializedValue.value = obj.value;
        serializedValue.type = Edm[obj.type];
    }
    else {
        throw new Error(`Unknown EDM type ${typeof obj.value}`);
    }
    return serializedValue;
}
function getSerializedValue(value) {
    if (typeof value === "object" && (value === null || value === void 0 ? void 0 : value.value) !== undefined && (value === null || value === void 0 ? void 0 : value.type) !== undefined) {
        return serializeObject(value);
    }
    else {
        return serializePrimitive(value);
    }
}
function translatePropertyNameForSerialization(propertyName) {
    for (const [original, internal] of propertyCaseMap) {
        if (internal === propertyName) {
            return original;
        }
    }
    return propertyName;
}
function serialize(obj) {
    const serialized = {};
    for (const [propertyName, propertyValue] of Object.entries(obj)) {
        const transformedKey = translatePropertyNameForSerialization(propertyName);
        const serializedVal = getSerializedValue(propertyValue);
        serialized[transformedKey] = serializedVal.value;
        if (serializedVal.type) {
            serialized[`${transformedKey}@odata.type`] = serializedVal.type;
        }
    }
    return serialized;
}
function getTypedObject(value, type, disableTypeConversion) {
    switch (type) {
        case Edm.Boolean:
            return disableTypeConversion ? { value, type: "Boolean" } : value;
        case Edm.Double:
            return disableTypeConversion ? { value, type: "Double" } : value;
        case Edm.Int32:
            return disableTypeConversion ? { value, type: "Int32" } : value;
        case Edm.String:
            return disableTypeConversion ? { value, type: "String" } : value;
        case Edm.DateTime:
            return disableTypeConversion ? { value, type: "DateTime" } : new Date(value);
        case Edm.Int64:
            return disableTypeConversion ? { value, type: "Int64" } : BigInt(value);
        case Edm.Guid:
            return { value, type: "Guid" };
        case Edm.Binary:
            return disableTypeConversion ? { value, type: "Binary" } : (0,_utils_bufferSerializer__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(value);
        default:
            throw new Error(`Unknown EDM type ${type}`);
    }
}
function deserialize(obj, disableTypeConversion = false) {
    var _a;
    const deserialized = {};
    for (const [key, value] of Object.entries(obj)) {
        if (key.indexOf("@odata.type") === -1) {
            const transformedKey = (_a = propertyCaseMap.get(key)) !== null && _a !== void 0 ? _a : key;
            let typedValue = value;
            if (`${key}@odata.type` in obj) {
                const type = obj[`${key}@odata.type`];
                typedValue = getTypedObject(value, type, disableTypeConversion);
            }
            else if (disableTypeConversion && ["number", "string", "boolean"].includes(typeof value)) {
                // The service, doesn't return type metadata for number, strings or booleans
                // if automatic type conversion is disabled we'll infer the EDM object
                typedValue = inferTypedObject(key, value);
            }
            deserialized[transformedKey] = typedValue;
        }
    }
    return deserialized;
}
function inferTypedObject(propertyName, value) {
    // We need to skip service metadata fields such as partitionKey and rowKey and use the same value returned by the service
    if (propertyCaseMap.has(propertyName)) {
        return value;
    }
    switch (typeof value) {
        case "boolean":
            return { value: String(value), type: "Boolean" };
        case "number":
            return getTypedNumber(value);
        case "string":
            return { value, type: "String" };
        default:
            return value;
    }
}
/**
 * Returns the number when typeConversion is enabled or the EDM object with the correct number format Double or Int32 if disabled
 */
function getTypedNumber(value) {
    const valueStr = String(value);
    if (Number.isSafeInteger(value)) {
        return { value: valueStr, type: "Int32" };
    }
    else {
        return { value: valueStr, type: "Double" };
    }
}
function deserializeObjectsArray(objArray, disableTypeConversion) {
    return objArray.map((obj) => deserialize(obj, disableTypeConversion));
}
/**
 * For ACL endpoints the Tables Service takes an ISO Date without decimals however
 * serializing a JavaScript date gives us a date with decimals 2021-07-08T09:10:09.000Z
 * which makes the XML request body invalid, these 2 functions serialize and deserialize the
 * dates so that they are in the expected format
 */
function serializeSignedIdentifiers(signedIdentifiers) {
    return signedIdentifiers.map((acl) => {
        const { id, accessPolicy } = acl;
        const _a = accessPolicy !== null && accessPolicy !== void 0 ? accessPolicy : {}, { start, expiry } = _a, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["start", "expiry"]);
        const serializedStart = start
            ? (0,_utils_truncateISO8061Date__WEBPACK_IMPORTED_MODULE_2__.truncatedISO8061Date)(start, false /** withMilliseconds */)
            : undefined;
        const serializedExpiry = expiry
            ? (0,_utils_truncateISO8061Date__WEBPACK_IMPORTED_MODULE_2__.truncatedISO8061Date)(expiry, false /** withMilliseconds */)
            : undefined;
        return {
            id,
            accessPolicy: Object.assign(Object.assign(Object.assign({}, (serializedExpiry && { expiry: serializedExpiry })), (serializedStart && { start: serializedStart })), rest),
        };
    });
}
function deserializeSignedIdentifier(signedIdentifiers) {
    return signedIdentifiers.map((si) => {
        const { id, accessPolicy } = si;
        const _a = accessPolicy !== null && accessPolicy !== void 0 ? accessPolicy : {}, { start, expiry } = _a, restAcl = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["start", "expiry"]);
        const deserializedStart = start ? new Date(start) : undefined;
        const deserializedExpiry = expiry ? new Date(expiry) : undefined;
        return {
            id,
            accessPolicy: Object.assign(Object.assign(Object.assign({}, (deserializedExpiry && { expiry: deserializedExpiry })), (deserializedStart && { start: deserializedStart })), restAcl),
        };
    });
}
function serializeQueryOptions(query) {
    const { select } = query, queryOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(query, ["select"]);
    const mappedQuery = Object.assign({}, queryOptions);
    // Properties that are always returned by the service but are not allowed in select
    const excludeFromSelect = ["etag", "odata.etag"];
    if (select) {
        mappedQuery.select = select
            .filter((p) => !excludeFromSelect.includes(p))
            .map(translatePropertyNameForSerialization)
            .join(",");
    }
    return mappedQuery;
}
//# sourceMappingURL=serialization.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/tablesNamedCredentialPolicy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/tablesNamedCredentialPolicy.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAuthorizationHeader": () => (/* binding */ getAuthorizationHeader),
/* harmony export */   "tablesNamedKeyCredentialPolicy": () => (/* binding */ tablesNamedKeyCredentialPolicy),
/* harmony export */   "tablesNamedKeyCredentialPolicyName": () => (/* binding */ tablesNamedKeyCredentialPolicyName)
/* harmony export */ });
/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/constants */ "./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js");
/* harmony import */ var _utils_computeHMACSHA256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/computeHMACSHA256 */ "./node_modules/@azure/data-tables/dist-esm/src/utils/computeHMACSHA256.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


/**
 * The programmatic identifier of the tablesNamedKeyCredentialPolicy.
 */
const tablesNamedKeyCredentialPolicyName = "tablesNamedKeyCredentialPolicy";
/**
 * tablesNamedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 */
function tablesNamedKeyCredentialPolicy(credential) {
    function signRequest(request) {
        const headerValue = getAuthorizationHeader(request, credential);
        request.headers.set(_utils_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.AUTHORIZATION, headerValue);
    }
    return {
        name: tablesNamedKeyCredentialPolicyName,
        async sendRequest(request, next) {
            signRequest(request);
            return next(request);
        },
    };
}
function getAuthorizationHeader(request, credential) {
    if (!request.headers.has(_utils_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.X_MS_DATE)) {
        request.headers.set(_utils_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.X_MS_DATE, new Date().toUTCString());
    }
    if (request.body && typeof request.body === "string" && request.body.length > 0) {
        request.headers.set(_utils_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
    }
    // If x-ms-date is present, use it otherwise date
    const dateHeader = getHeaderValueToSign(request, _utils_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.X_MS_DATE);
    if (!dateHeader) {
        throw new Error("Failed to sign request: x-ms-date or date header must be present");
    }
    const stringToSign = [
        dateHeader,
        getCanonicalizedResourceString(request, credential),
    ].join("\n");
    const signature = (0,_utils_computeHMACSHA256__WEBPACK_IMPORTED_MODULE_1__.computeHMACSHA256)(stringToSign, credential.key);
    return `SharedKeyLite ${credential.name}:${signature}`;
}
function getHeaderValueToSign(request, headerName) {
    const value = request.headers.get(headerName);
    if (!value) {
        return "";
    }
    return value;
}
function getCanonicalizedResourceString(request, credential) {
    // https://docs.microsoft.com/rest/api/storageservices/authorize-with-shared-key#shared-key-lite-and-table-service-format-for-2009-09-19-and-later
    const url = new URL(request.url);
    const path = url.pathname || "/";
    let canonicalizedResourceString = "/" + credential.name + path;
    // The query string should include the question mark and the comp parameter (for example, ?comp=metadata). No other parameters should be included on the query string.
    const comp = url.searchParams.get("comp");
    if (comp) {
        canonicalizedResourceString = `${canonicalizedResourceString}?comp=${comp}`;
    }
    return canonicalizedResourceString;
}
//# sourceMappingURL=tablesNamedCredentialPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/tablesSASTokenPolicy.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/tablesSASTokenPolicy.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "signURLWithSAS": () => (/* binding */ signURLWithSAS),
/* harmony export */   "tablesSASTokenPolicy": () => (/* binding */ tablesSASTokenPolicy),
/* harmony export */   "tablesSASTokenPolicyName": () => (/* binding */ tablesSASTokenPolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the tablesSASTokenPolicy.
 */
const tablesSASTokenPolicyName = "tablesSASTokenPolicy";
/**
 * tablesSASTokenPolicy is a policy used to sign HTTP request with a shared key.
 */
function tablesSASTokenPolicy(credential) {
    return {
        name: tablesSASTokenPolicyName,
        async sendRequest(request, next) {
            signURLWithSAS(request, credential);
            return next(request);
        },
    };
}
function signURLWithSAS(request, credential) {
    const sasParams = new URLSearchParams(credential.signature);
    const url = new URL(request.url);
    for (const [name, value] of sasParams) {
        url.searchParams.append(name, value);
    }
    request.url = url.toString();
}
//# sourceMappingURL=tablesSASTokenPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/accountConnectionString.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/accountConnectionString.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromAccountConnectionString": () => (/* binding */ fromAccountConnectionString),
/* harmony export */   "getAccountConnectionString": () => (/* binding */ getAccountConnectionString)
/* harmony export */ });
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Gets client parameters from an Account Connection String
 * Only supported in Node.js not supported for Browsers
 * @param extractedCreds - parsed connection string
 * @param options - TablesServiceClient options
 */
function fromAccountConnectionString(extractedCreds, options = {}) {
    const sharedKeyCredential = new _azure_core_auth__WEBPACK_IMPORTED_MODULE_0__.AzureNamedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
    return {
        url: extractedCreds.url,
        options,
        credential: sharedKeyCredential,
    };
}
function getAccountConnectionString(accountName, accountKey, defaultEndpointsProtocol, endpointSuffix, tableEndpoint) {
    if (!tableEndpoint) {
        // TableEndpoint is not present in the Account connection string
        // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.table.${endpointSuffix}`
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
            throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        if (!endpointSuffix) {
            throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        tableEndpoint = `${defaultEndpointsProtocol}://${accountName}.table.${endpointSuffix}`;
    }
    if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
    }
    else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
    }
    return {
        kind: "AccountConnString",
        url: tableEndpoint,
        accountName,
        accountKey,
    };
}
//# sourceMappingURL=accountConnectionString.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/apiVersionPolicy.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/apiVersionPolicy.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "apiVersionPolicy": () => (/* binding */ apiVersionPolicy),
/* harmony export */   "apiVersionPolicyName": () => (/* binding */ apiVersionPolicyName)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Name of the apiVersion Policy
 * @internal
 */
const apiVersionPolicyName = "apiVersionPolicy";
/**
 * Pipeline policy that enables users to override the default api version
 * @internal
 */
const apiVersionPolicy = (apiVersion) => {
    return {
        name: apiVersionPolicyName,
        sendRequest: async (req, next) => {
            req.headers.set("x-ms-version", apiVersion);
            return next(req);
        },
    };
};
//# sourceMappingURL=apiVersionPolicy.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/baseTransactionHeaders.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/baseTransactionHeaders.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBaseTransactionHeaders": () => (/* binding */ getBaseTransactionHeaders)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds an object with the required headers for a Transaction request. For both Node and Browser
 */
function getBaseTransactionHeaders(transactionGuid) {
    return {
        accept: "application/json",
        "x-ms-version": "2019-02-02",
        DataServiceVersion: "3.0;",
        MaxDataServiceVersion: "3.0;NetFx",
        "Content-Type": `multipart/mixed; boundary=batch_${transactionGuid}`,
    };
}
//# sourceMappingURL=baseTransactionHeaders.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/bufferSerializer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/bufferSerializer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64Decode": () => (/* binding */ base64Decode),
/* harmony export */   "base64Encode": () => (/* binding */ base64Encode)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a byte array in base64 format.
 * @param value - The Uint8Aray or string to encode
 */
function base64Encode(value) {
    if (value instanceof Uint8Array) {
        const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
        return bufferValue.toString("base64");
    }
    else {
        return Buffer.from(value).toString("base64");
    }
}
/**
 * Decodes a base64 string into a byte array.
 * @param value - The base64 string to decode
 */
function base64Decode(value) {
    return Buffer.from(value, "base64");
}
//# sourceMappingURL=bufferSerializer.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/challengeAuthenticationUtils.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/challengeAuthenticationUtils.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setTokenChallengeAuthenticationPolicy": () => (/* binding */ setTokenChallengeAuthenticationPolicy)
/* harmony export */ });
/* harmony import */ var _azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-rest-pipeline */ "./node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js");
/* harmony import */ var _azure_core_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-client */ "./node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


/**
 * @internal
 * Setups the challenge authentication policy for the provided token credential.
 */
function setTokenChallengeAuthenticationPolicy(pipeline, credential, scopes) {
    // Make sure no bearerTokenPolicy is set.
    pipeline.removePolicy({ name: "bearerTokenPolicy" });
    pipeline.addPolicy((0,_azure_core_rest_pipeline__WEBPACK_IMPORTED_MODULE_0__.bearerTokenAuthenticationPolicy)({
        credential,
        scopes,
        challengeCallbacks: { authorizeRequestOnChallenge: _azure_core_client__WEBPACK_IMPORTED_MODULE_1__.authorizeRequestOnTenantChallenge },
    }), {
        phase: "Sign",
    });
}
//# sourceMappingURL=challengeAuthenticationUtils.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/computeHMACSHA256.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/computeHMACSHA256.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeHMACSHA256": () => (/* binding */ computeHMACSHA256)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function computeHMACSHA256(stringToSign, accountKey) {
    const key = Buffer.from(accountKey, "base64");
    return (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac)("sha256", key).update(stringToSign, "utf8").digest("base64");
}
//# sourceMappingURL=computeHMACSHA256.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/connectionString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/connectionString.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extractConnectionStringParts": () => (/* binding */ extractConnectionStringParts),
/* harmony export */   "getClientParamsFromConnectionString": () => (/* binding */ getClientParamsFromConnectionString)
/* harmony export */ });
/* harmony import */ var _accountConnectionString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accountConnectionString */ "./node_modules/@azure/data-tables/dist-esm/src/utils/accountConnectionString.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const DevelopmentConnectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;TableEndpoint=http://127.0.0.1:10002/devstoreaccount1";
/**
 * This function parses a connection string into a set of
 * parameters to pass to be passed to TableClientService,
 * depending on the connection string type these parameter would
 * contain:
 * - Account Connection String:  A pipeline to sign the request with a SharedKey
 * - SAS Connection String: Attach a SAS token to the storage account url for authentication
 * @param connectionString - Connection string to parse
 * @param options - TableService client options
 */
function getClientParamsFromConnectionString(connectionString, options = {}) {
    if (connectionString.toLowerCase().indexOf("usedevelopmentstorage=true") !== -1) {
        connectionString = DevelopmentConnectionString;
        options.allowInsecureConnection = true;
    }
    const extractedCreds = extractConnectionStringParts(connectionString);
    if (extractedCreds.kind === "AccountConnString") {
        return (0,_accountConnectionString__WEBPACK_IMPORTED_MODULE_0__.fromAccountConnectionString)(extractedCreds, options);
    }
    else if (extractedCreds.kind === "SASConnString") {
        return {
            url: `${extractedCreds.url}?${extractedCreds.accountSas}`,
            options,
        };
    }
    else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    }
}
/**
 * Extracts the parts of an Storage account connection string.
 *
 * @param connectionString - Connection string.
 * @returns String key value pairs of the storage account's url and credentials.
 */
function extractConnectionStringParts(connectionString) {
    // Matching TableEndpoint in the Account connection string
    let tableEndpoint = getValueInConnString(connectionString, "TableEndpoint");
    // Slicing off '/' at the end if exists
    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)
    tableEndpoint = tableEndpoint.endsWith("/") ? tableEndpoint.slice(0, -1) : tableEndpoint;
    if (isAccountConnectionString(connectionString)) {
        return (0,_accountConnectionString__WEBPACK_IMPORTED_MODULE_0__.getAccountConnectionString)(getValueInConnString(connectionString, "AccountName"), getValueInConnString(connectionString, "AccountKey"), getValueInConnString(connectionString, "DefaultEndpointsProtocol"), getValueInConnString(connectionString, "EndpointSuffix"), tableEndpoint);
    }
    else {
        return getSASConnectionString(connectionString, tableEndpoint);
    }
}
/**
 * Checks whether a connection string is an Account Connection string or not
 */
function isAccountConnectionString(connectionString) {
    const lowercaseConnectionString = connectionString.toLowerCase();
    return (lowercaseConnectionString.search("defaultendpointsprotocol=") !== -1 &&
        lowercaseConnectionString.search("accountkey=") !== -1);
}
function getSASConnectionString(connectionString, tableEndpoint) {
    const accountName = getAccountNameFromUrl(tableEndpoint);
    const accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
    if (!tableEndpoint) {
        throw new Error("Invalid TableEndpoint in the provided SAS Connection String");
    }
    else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
    }
    else if (!accountName) {
        throw new Error("Invalid AccountName in the provided SAS Connection String");
    }
    return { kind: "SASConnString", url: tableEndpoint, accountName, accountSas };
}
function getValueInConnString(connectionString, argument) {
    const searchKey = argument.toLowerCase();
    const elements = connectionString.split(";").filter((e) => Boolean(e));
    for (const element of elements) {
        const trimmedElement = element.trim();
        const [elementKey, value] = getValuePair(trimmedElement);
        const key = elementKey.toLowerCase();
        if (key === searchKey) {
            return value;
        }
    }
    return "";
}
function getValuePair(kvp) {
    // If the string is not in kvp format <key>=<valye> return an empty array
    if (!kvp || kvp.indexOf("=") === -1) {
        return [];
    }
    // Get the substring before the first '='
    const key = kvp.substr(0, kvp.indexOf("="));
    // Get the substring after the first '='
    const value = kvp.substr(kvp.indexOf("=") + 1);
    return [key, value];
}
/**
 * Extracts account name from the url
 * @param url - URL to extract the account name from
 * @returns The account name
 */
function getAccountNameFromUrl(url) {
    if (!url) {
        return url;
    }
    const parsedUrl = new URL(url);
    let accountName;
    const host = parsedUrl.host || "";
    const path = parsedUrl.pathname || "";
    const hostParts = host.split(".");
    const pathParts = path.split("/");
    if (hostParts.length >= 1 && hostParts[1] === "table") {
        // `${defaultEndpointsProtocol}://${accountName}.table.${endpointSuffix}`;
        // Slicing off '/' at the end if exists
        url = url.endsWith("/") ? url.slice(0, -1) : url;
        accountName = host.split(".")[0];
    }
    else if (pathParts.length >= 1) {
        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/
        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/
        // .getPath() -> /devstoreaccount1/
        accountName = pathParts[1];
    }
    else {
        throw new Error("Unable to extract accountName with provided information.");
    }
    return accountName;
}
//# sourceMappingURL=connectionString.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HeaderConstants": () => (/* binding */ HeaderConstants),
/* harmony export */   "SERVICE_VERSION": () => (/* binding */ SERVICE_VERSION),
/* harmony export */   "STORAGE_SCOPE": () => (/* binding */ STORAGE_SCOPE),
/* harmony export */   "TRANSACTION_HTTP_LINE_ENDING": () => (/* binding */ TRANSACTION_HTTP_LINE_ENDING),
/* harmony export */   "TRANSACTION_HTTP_VERSION_1_1": () => (/* binding */ TRANSACTION_HTTP_VERSION_1_1),
/* harmony export */   "TablesLoggingAllowedHeaderNames": () => (/* binding */ TablesLoggingAllowedHeaderNames)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SERVICE_VERSION = "2019-02-02";
const TRANSACTION_HTTP_VERSION_1_1 = "HTTP/1.1";
const TRANSACTION_HTTP_LINE_ENDING = "\r\n";
const STORAGE_SCOPE = "https://storage.azure.com/.default";
const HeaderConstants = {
    AUTHORIZATION: "authorization",
    CONTENT_LENGTH: "content-length",
    CONTENT_MD5: "content-md5",
    CONTENT_TYPE: "content-type",
    CONTENT_TRANSFER_ENCODING: "content-transfer-encoding",
    DATE: "date",
    X_MS_DATE: "x-ms-date",
    X_MS_VERSION: "x-ms-version",
};
const TablesLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Prefer",
    "Preference-Applied",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-user-agent",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Accept",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-continuation-NextTableName",
    "x-ms-continuation-NextPartitionKey",
    "x-ms-continuation-NextRowKey",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
];
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/continuationToken.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/continuationToken.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeContinuationToken": () => (/* binding */ decodeContinuationToken),
/* harmony export */   "encodeContinuationToken": () => (/* binding */ encodeContinuationToken)
/* harmony export */ });
/* harmony import */ var _bufferSerializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bufferSerializer */ "./node_modules/@azure/data-tables/dist-esm/src/utils/bufferSerializer.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Encodes the nextPartitionKey and nextRowKey into a single continuation token
 */
function encodeContinuationToken(nextPartitionKey, nextRowKey) {
    if (!nextPartitionKey) {
        return undefined;
    }
    const continuationToken = Object.assign({ nextPartitionKey }, (nextRowKey && { nextRowKey }));
    return (0,_bufferSerializer__WEBPACK_IMPORTED_MODULE_0__.base64Encode)(JSON.stringify(continuationToken));
}
/**
 * Decodes a continuationToken into an object containing a nextPartitionKey and nextRowKey
 */
function decodeContinuationToken(encodedToken) {
    const decodedToken = (0,_bufferSerializer__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(encodedToken);
    let tokenStr = "";
    for (const byte of decodedToken) {
        tokenStr += String.fromCharCode(byte);
    }
    const continuationToken = JSON.parse(tokenStr);
    return continuationToken;
}
//# sourceMappingURL=continuationToken.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/errorHelpers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/errorHelpers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleTableAlreadyExists": () => (/* binding */ handleTableAlreadyExists)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function handleTableAlreadyExists(error, options = {}) {
    var _a, _b;
    const responseError = getErrorResponse(error);
    if (responseError &&
        responseError.status === 409 &&
        ((_a = responseError.parsedBody.odataError) === null || _a === void 0 ? void 0 : _a.code) === "TableAlreadyExists") {
        (_b = options.logger) === null || _b === void 0 ? void 0 : _b.info(`Table ${options.tableName} already Exists`);
        if (options.onResponse) {
            options.onResponse(responseError, {});
        }
    }
    else {
        throw error;
    }
}
function getErrorResponse(error) {
    if (!isRestError(error)) {
        return undefined;
    }
    const errorResponse = error.response;
    if (!errorResponse || !isTableServiceErrorResponse(errorResponse.parsedBody)) {
        return undefined;
    }
    return errorResponse;
}
function isRestError(error) {
    return error.name === "RestError";
}
function isTableServiceErrorResponse(errorResponseBody) {
    return Boolean(errorResponseBody === null || errorResponseBody === void 0 ? void 0 : errorResponseBody.odataError);
}
//# sourceMappingURL=errorHelpers.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/isCosmosEndpoint.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/isCosmosEndpoint.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCosmosEndpoint": () => (/* binding */ isCosmosEndpoint)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isCosmosEndpoint(url) {
    const parsedURL = new URL(url);
    if (parsedURL.hostname.indexOf(".table.cosmosdb.") !== -1) {
        return true;
    }
    if (parsedURL.hostname.indexOf(".table.cosmos.") !== -1) {
        return true;
    }
    if (parsedURL.hostname === "localhost" && parsedURL.port !== "10002") {
        return true;
    }
    return false;
}
//# sourceMappingURL=isCosmosEndpoint.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/isCredential.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/isCredential.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCredential": () => (/* binding */ isCredential)
/* harmony export */ });
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js");
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js");
/* harmony import */ var _azure_core_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @azure/core-auth */ "./node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function isCredential(credential) {
    return ((0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_0__.isSASCredential)(credential) || (0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_1__.isNamedKeyCredential)(credential) || (0,_azure_core_auth__WEBPACK_IMPORTED_MODULE_2__.isTokenCredential)(credential));
}
//# sourceMappingURL=isCredential.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/tracing.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/tracing.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tracingClient": () => (/* binding */ tracingClient)
/* harmony export */ });
/* harmony import */ var _azure_core_tracing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @azure/core-tracing */ "./node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A tracing client that can be used to manage spans.
 * @internal
 */
const tracingClient = (0,_azure_core_tracing__WEBPACK_IMPORTED_MODULE_0__.createTracingClient)({
    namespace: "Microsoft.Data.Tables",
    packageName: "@azure/data-tables",
    packageVersion: "13.2.0",
});
//# sourceMappingURL=tracing.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHeaders.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHeaders.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTransactionHeaders": () => (/* binding */ getTransactionHeaders)
/* harmony export */ });
/* harmony import */ var _baseTransactionHeaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseTransactionHeaders */ "./node_modules/@azure/data-tables/dist-esm/src/utils/baseTransactionHeaders.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * Builds an object with the required headers for a Transaction request. For Node
 */
function getTransactionHeaders(transactionGuid) {
    const baseHeaders = (0,_baseTransactionHeaders__WEBPACK_IMPORTED_MODULE_0__.getBaseTransactionHeaders)(transactionGuid);
    return Object.assign(Object.assign({}, baseHeaders), { 
        // The below headers are not supported in the browser as they are flagged as "unsafe headers"
        "Accept-Charset": "UTF-8", Connection: "Keep-Alive" });
}
//# sourceMappingURL=transactionHeaders.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHelpers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/transactionHelpers.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getChangeSetBoundary": () => (/* binding */ getChangeSetBoundary),
/* harmony export */   "getInitialTransactionBody": () => (/* binding */ getInitialTransactionBody),
/* harmony export */   "getTransactionBoundary": () => (/* binding */ getTransactionBoundary),
/* harmony export */   "getTransactionHttpRequestBody": () => (/* binding */ getTransactionHttpRequestBody)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@azure/data-tables/dist-esm/src/utils/constants.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Builds a transaction change set boundary to be added to the transaction request body
 * @param changesetId - Id of the transaction changeset
 */
function getChangeSetBoundary(changesetId) {
    return `changeset_${changesetId}`;
}
/**
 * Builds a transaction boundary to be added to the transaction request body
 * @param transactionId - Id of the transaction
 */
function getTransactionBoundary(transactionId) {
    return `batch_${transactionId}`;
}
/**
 * Returns an initial representation of the Transaction body.
 * @param transactionId - Id of the transaction
 * @param changesetId - Id of the transaction changeset
 */
function getInitialTransactionBody(transactionId, changesetId) {
    const transactionBoundary = `batch_${transactionId}`;
    return [
        `--${transactionBoundary}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}${_constants__WEBPACK_IMPORTED_MODULE_0__.HeaderConstants.CONTENT_TYPE}: multipart/mixed; boundary=changeset_${changesetId}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}`,
    ];
}
/**
 * Build the Transaction http request body to send to the service.
 * @param bodyParts - Parts of the transaction body, containing information about the actions to be included in the transaction request
 * @param transactionId - Id of the transaction
 * @param changesetId - Id of the transaction changeset
 */
function getTransactionHttpRequestBody(bodyParts, transactionId, changesetId) {
    const transactionBoundary = getTransactionBoundary(transactionId);
    const changesetBoundary = getChangeSetBoundary(changesetId);
    const changesetEnding = `--${changesetBoundary}--`;
    const transactionEnding = `--${transactionBoundary}--`;
    const bodyContent = bodyParts.join(_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING);
    return `${bodyContent}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}${changesetEnding}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}${transactionEnding}${_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION_HTTP_LINE_ENDING}`;
}
//# sourceMappingURL=transactionHelpers.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/truncateISO8061Date.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/truncateISO8061Date.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "truncatedISO8061Date": () => (/* binding */ truncatedISO8061Date)
/* harmony export */ });
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Rounds a date off to seconds.
 *
 * @param date -
 * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;
 *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.
 * @returns Date string in ISO8061 format, with or without 7 milliseconds component
 */
function truncatedISO8061Date(date, withMilliseconds = true) {
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    const dateString = date.toISOString();
    return withMilliseconds
        ? dateString.substring(0, dateString.length - 1) + "0000" + "Z"
        : dateString.substring(0, dateString.length - 5) + "Z";
}
//# sourceMappingURL=truncateISO8061Date.js.map

/***/ }),

/***/ "./node_modules/@azure/data-tables/dist-esm/src/utils/uuid.js":
/*!********************************************************************!*\
  !*** ./node_modules/@azure/data-tables/dist-esm/src/utils/uuid.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Uuid": () => (/* binding */ Uuid)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// This is used as a workaround to be able to stub generateUuid
// during testing.
class Uuid {
    static generateUuid() {
        return (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
    }
}
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/@azure/logger/dist-esm/src/debug.js":
/*!**********************************************************!*\
  !*** ./node_modules/@azure/logger/dist-esm/src/debug.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "./node_modules/@azure/logger/dist-esm/src/log.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
let enabledString;
let enabledNamespaces = [];
let skippedNamespaces = [];
const debuggers = [];
if (debugEnvVariable) {
    enable(debugEnvVariable);
}
const debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
}, {
    enable,
    enabled,
    disable,
    log: _log__WEBPACK_IMPORTED_MODULE_0__.log
});
function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList) {
        if (ns.startsWith("-")) {
            skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
        }
        else {
            enabledNamespaces.push(new RegExp(`^${ns}$`));
        }
    }
    for (const instance of debuggers) {
        instance.enabled = enabled(instance.namespace);
    }
}
function enabled(namespace) {
    if (namespace.endsWith("*")) {
        return true;
    }
    for (const skipped of skippedNamespaces) {
        if (skipped.test(namespace)) {
            return false;
        }
    }
    for (const enabledNamespace of enabledNamespaces) {
        if (enabledNamespace.test(namespace)) {
            return true;
        }
    }
    return false;
}
function disable() {
    const result = enabledString || "";
    enable("");
    return result;
}
function createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
        enabled: enabled(namespace),
        destroy,
        log: debugObj.log,
        namespace,
        extend
    });
    function debug(...args) {
        if (!newDebugger.enabled) {
            return;
        }
        if (args.length > 0) {
            args[0] = `${namespace} ${args[0]}`;
        }
        newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
}
function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
    }
    return false;
}
function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debugObj);
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@azure/logger/dist-esm/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@azure/logger/dist-esm/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureLogger": () => (/* binding */ AzureLogger),
/* harmony export */   "createClientLogger": () => (/* binding */ createClientLogger),
/* harmony export */   "getLogLevel": () => (/* binding */ getLogLevel),
/* harmony export */   "setLogLevel": () => (/* binding */ setLogLevel)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug */ "./node_modules/@azure/logger/dist-esm/src/debug.js");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const registeredLoggers = new Set();
const logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;
let azureLogLevel;
/**
 * The AzureLogger provides a mechanism for overriding where logs are output to.
 * By default, logs are sent to stderr.
 * Override the `log` method to redirect logs to another location.
 */
const AzureLogger = (0,_debug__WEBPACK_IMPORTED_MODULE_0__["default"])("azure");
AzureLogger.log = (...args) => {
    _debug__WEBPACK_IMPORTED_MODULE_0__["default"].log(...args);
};
const AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
if (logLevelFromEnv) {
    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
    if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
    }
    else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
    }
}
/**
 * Immediately enables logging at the specified log level.
 * @param level - The log level to enable for logging.
 * Options from most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */
function setLogLevel(level) {
    if (level && !isAzureLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    }
    azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of registeredLoggers) {
        if (shouldEnable(logger)) {
            enabledNamespaces.push(logger.namespace);
        }
    }
    _debug__WEBPACK_IMPORTED_MODULE_0__["default"].enable(enabledNamespaces.join(","));
}
/**
 * Retrieves the currently specified log level.
 */
function getLogLevel() {
    return azureLogLevel;
}
const levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
};
/**
 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
 * @param namespace - The name of the SDK package.
 * @hidden
 */
function createClientLogger(namespace) {
    const clientRootLogger = AzureLogger.extend(namespace);
    patchLogMethod(AzureLogger, clientRootLogger);
    return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
    };
}
function patchLogMethod(parent, child) {
    child.log = (...args) => {
        parent.log(...args);
    };
}
function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
        level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
        const enabledNamespaces = _debug__WEBPACK_IMPORTED_MODULE_0__["default"].disable();
        _debug__WEBPACK_IMPORTED_MODULE_0__["default"].enable(enabledNamespaces + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
}
function shouldEnable(logger) {
    if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {
        return true;
    }
    else {
        return false;
    }
}
function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@azure/logger/dist-esm/src/log.js":
/*!********************************************************!*\
  !*** ./node_modules/@azure/logger/dist-esm/src/log.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log": () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


function log(message, ...args) {
    process.stderr.write(`${util__WEBPACK_IMPORTED_MODULE_0___default().format(message, ...args)}${os__WEBPACK_IMPORTED_MODULE_1__.EOL}`);
}
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@sindresorhus/df/index.js":
/*!************************************************!*\
  !*** ./node_modules/@sindresorhus/df/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const execa = __webpack_require__(/*! execa */ "./node_modules/@sindresorhus/df/node_modules/execa/index.js");

const getColumnBoundaries = async header => {
	// Regex captures each individual column
	// ^\S+\s+       -> First column
	// \s*\S+\s*\S+$ -> Last column (combined)
	// \s*\S+        -> Regular columns
	const regex = /^\S+\s+|\s*\S+\s*\S+$|\s*\S+/g;
	const boundaries = [];
	let match;

	while ((match = regex.exec(header))) {
		boundaries.push(match[0].length);
	}

	// Extend last column boundary
	boundaries[boundaries.length - 1] = -1;

	return boundaries;
};

const parseOutput = async output => {
	const lines = output.trim().split('\n');
	const boundaries = await getColumnBoundaries(lines[0]);

	return lines.slice(1).map(line => {
		const cl = boundaries.map(boundary => {
			// Handle extra-long last column
			const column = boundary > 0 ? line.slice(0, boundary) : line;
			line = line.slice(boundary);
			return column.trim();
		});

		return {
			filesystem: cl[0],
			size: parseInt(cl[1], 10) * 1024,
			used: parseInt(cl[2], 10) * 1024,
			available: parseInt(cl[3], 10) * 1024,
			capacity: parseInt(cl[4], 10) / 100,
			mountpoint: cl[5]
		};
	});
};

const run = async args => {
	const {stdout} = await execa('df', args);
	return parseOutput(stdout);
};

const df = async () => run(['-kP']);

df.fs = async name => {
	if (typeof name !== 'string') {
		throw new TypeError('The `name` parameter required');
	}

	const data = await run(['-kP']);

	for (const item of data) {
		if (item.filesystem === name) {
			return item;
		}
	}

	throw new Error(`The specified filesystem \`${name}\` doesn't exist`);
};

df.file = async file => {
	if (typeof file !== 'string') {
		throw new TypeError('The `file` parameter is required');
	}

	let data;
	try {
		data = await run(['-kP', file]);
	} catch (error) {
		if (/No such file or directory/.test(error.stderr)) {
			throw new Error(`The specified file \`${file}\` doesn't exist`);
		}

		throw error;
	}

	return data[0];
};

module.exports = df;
// TODO: remove this in the next major version
module.exports["default"] = df;

if (false) {}


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const childProcess = __webpack_require__(/*! child_process */ "child_process");
const crossSpawn = __webpack_require__(/*! cross-spawn */ "./node_modules/cross-spawn/index.js");
const stripFinalNewline = __webpack_require__(/*! strip-final-newline */ "./node_modules/strip-final-newline/index.js");
const npmRunPath = __webpack_require__(/*! npm-run-path */ "./node_modules/@sindresorhus/df/node_modules/npm-run-path/index.js");
const onetime = __webpack_require__(/*! onetime */ "./node_modules/onetime/index.js");
const makeError = __webpack_require__(/*! ./lib/error */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/error.js");
const normalizeStdio = __webpack_require__(/*! ./lib/stdio */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/stdio.js");
const {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = __webpack_require__(/*! ./lib/kill */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/kill.js");
const {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = __webpack_require__(/*! ./lib/stream.js */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/stream.js");
const {mergePromise, getSpawnedPromise} = __webpack_require__(/*! ./lib/promise.js */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/promise.js");
const {joinCommand, parseCommand} = __webpack_require__(/*! ./lib/command.js */ "./node_modules/@sindresorhus/df/node_modules/execa/lib/command.js");

const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

const getEnv = ({env: envOption, extendEnv, preferLocal, localDir}) => {
	const env = extendEnv ? {...process.env, ...envOption} : envOption;

	if (preferLocal) {
		return npmRunPath.env({env, cwd: localDir});
	}

	return env;
};

const handleArgs = (file, args, options = {}) => {
	const parsed = crossSpawn._parse(file, args, options);
	file = parsed.command;
	args = parsed.args;
	options = parsed.options;

	options = {
		maxBuffer: DEFAULT_MAX_BUFFER,
		buffer: true,
		stripFinalNewline: true,
		extendEnv: true,
		preferLocal: false,
		localDir: options.cwd || process.cwd(),
		encoding: 'utf8',
		reject: true,
		cleanup: true,
		...options,
		windowsHide: true
	};

	options.env = getEnv(options);

	options.stdio = normalizeStdio(options);

	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
		// #116
		args.unshift('/q');
	}

	return {file, args, options, parsed};
};

const handleOutput = (options, value, error) => {
	if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
		// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`
		return error === undefined ? undefined : '';
	}

	if (options.stripFinalNewline) {
		return stripFinalNewline(value);
	}

	return value;
};

const execa = (file, args, options) => {
	const parsed = handleArgs(file, args, options);
	const command = joinCommand(file, args);

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		// Ensure the returned error is always both a promise and a child process
		const dummySpawned = new childProcess.ChildProcess();
		const errorPromise = Promise.reject(makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
		}));
		return mergePromise(dummySpawned, errorPromise);
	}

	const spawnedPromise = getSpawnedPromise(spawned);
	const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
	const processDone = setExitHandler(spawned, parsed.options, timedPromise);

	const context = {isCanceled: false};

	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
	spawned.cancel = spawnedCancel.bind(null, spawned, context);

	const handlePromise = async () => {
		const [{error, code, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
		const stdout = handleOutput(parsed.options, stdoutResult);
		const stderr = handleOutput(parsed.options, stderrResult);
		const all = handleOutput(parsed.options, allResult);

		if (error || code !== 0 || signal !== null) {
			const returnedError = makeError({
				error,
				code,
				signal,
				stdout,
				stderr,
				all,
				command,
				parsed,
				timedOut,
				isCanceled: context.isCanceled,
				killed: spawned.killed
			});

			if (!parsed.options.reject) {
				return returnedError;
			}

			throw returnedError;
		}

		return {
			command,
			exitCode: 0,
			exitCodeName: 'SUCCESS',
			stdout,
			stderr,
			all,
			failed: false,
			timedOut: false,
			isCanceled: false,
			killed: false
		};
	};

	const handlePromiseOnce = onetime(handlePromise);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.options.input);

	spawned.all = makeAllStream(spawned);

	return mergePromise(spawned, handlePromiseOnce);
};

module.exports = execa;

module.exports.sync = (file, args, options) => {
	const parsed = handleArgs(file, args, options);
	const command = joinCommand(file, args);

	validateInputSync(parsed.options);

	let result;
	try {
		result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		throw makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
		});
	}

	result.stdout = handleOutput(parsed.options, result.stdout, result.error);
	result.stderr = handleOutput(parsed.options, result.stderr, result.error);

	if (result.error || result.status !== 0 || result.signal !== null) {
		const error = makeError({
			...result,
			code: result.status,
			command,
			parsed,
			timedOut: result.error && result.error.code === 'ETIMEDOUT',
			isCanceled: false,
			killed: result.signal !== null
		});

		if (!parsed.options.reject) {
			return error;
		}

		throw error;
	}

	return {
		command,
		exitCode: 0,
		exitCodeName: 'SUCCESS',
		stdout: result.stdout,
		stderr: result.stderr,
		failed: false,
		timedOut: false,
		isCanceled: false,
		killed: false
	};
};

module.exports.command = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa(file, args, options);
};

module.exports.commandSync = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa.sync(file, args, options);
};

module.exports.node = (scriptPath, args, options = {}) => {
	if (args && !Array.isArray(args) && typeof args === 'object') {
		options = args;
		args = [];
	}

	const stdio = normalizeStdio.node(options);

	const {nodePath = process.execPath, nodeOptions = process.execArgv} = options;

	return execa(
		nodePath,
		[
			...nodeOptions,
			scriptPath,
			...(Array.isArray(args) ? args : [])
		],
		{
			...options,
			stdin: undefined,
			stdout: undefined,
			stderr: undefined,
			stdio,
			shell: false
		}
	);
};


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/command.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/command.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";

const SPACES_REGEXP = / +/g;

const joinCommand = (file, args = []) => {
	if (!Array.isArray(args)) {
		return file;
	}

	return [file, ...args].join(' ');
};

// Allow spaces to be escaped by a backslash if not meant as a delimiter
const handleEscaping = (tokens, token, index) => {
	if (index === 0) {
		return [token];
	}

	const previousToken = tokens[tokens.length - 1];

	if (previousToken.endsWith('\\')) {
		return [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token}`];
	}

	return [...tokens, token];
};

// Handle `execa.command()`
const parseCommand = command => {
	return command
		.trim()
		.split(SPACES_REGEXP)
		.reduce(handleEscaping, []);
};

module.exports = {
	joinCommand,
	parseCommand
};


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/error.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/error.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const util = __webpack_require__(/*! util */ "util");

const getCode = (error, code) => {
	if (error && error.code) {
		return [error.code, os.constants.errno[error.code]];
	}

	if (Number.isInteger(code)) {
		return [util.getSystemErrorName(-code), code];
	}

	return [];
};

const getErrorPrefix = ({timedOut, timeout, signal, exitCodeName, exitCode, isCanceled}) => {
	if (timedOut) {
		return `timed out after ${timeout} milliseconds`;
	}

	if (isCanceled) {
		return 'was canceled';
	}

	if (signal) {
		return `was killed with ${signal}`;
	}

	if (exitCode !== undefined) {
		return `failed with exit code ${exitCode} (${exitCodeName})`;
	}

	return 'failed';
};

const makeError = ({
	stdout,
	stderr,
	all,
	error,
	signal,
	code,
	command,
	timedOut,
	isCanceled,
	killed,
	parsed: {options: {timeout}}
}) => {
	const [exitCodeName, exitCode] = getCode(error, code);

	const prefix = getErrorPrefix({timedOut, timeout, signal, exitCodeName, exitCode, isCanceled});
	const message = `Command ${prefix}: ${command}`;

	if (error instanceof Error) {
		error.originalMessage = error.message;
		error.message = `${message}\n${error.message}`;
	} else {
		error = new Error(message);
	}

	error.command = command;
	delete error.code;
	error.exitCode = exitCode;
	error.exitCodeName = exitCodeName;
	error.stdout = stdout;
	error.stderr = stderr;

	if (all !== undefined) {
		error.all = all;
	}

	if ('bufferedData' in error) {
		delete error.bufferedData;
	}

	error.failed = true;
	error.timedOut = Boolean(timedOut);
	error.isCanceled = isCanceled;
	error.killed = killed && !timedOut;
	// `signal` emitted on `spawned.on('exit')` event can be `null`. We normalize
	// it to `undefined`
	error.signal = signal || undefined;

	return error;
};

module.exports = makeError;


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/kill.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/kill.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const onExit = __webpack_require__(/*! signal-exit */ "./node_modules/signal-exit/index.js");
const pFinally = __webpack_require__(/*! p-finally */ "./node_modules/p-finally/index.js");

const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {
	const killResult = kill(signal);
	setKillTimeout(kill, signal, options, killResult);
	return killResult;
};

const setKillTimeout = (kill, signal, options, killResult) => {
	if (!shouldForceKill(signal, options, killResult)) {
		return;
	}

	const timeout = getForceKillAfterTimeout(options);
	setTimeout(() => {
		kill('SIGKILL');
	}, timeout).unref();
};

const shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
	return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};

const isSigterm = signal => {
	return signal === os.constants.signals.SIGTERM ||
		(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
};

const getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
	if (forceKillAfterTimeout === true) {
		return DEFAULT_FORCE_KILL_TIMEOUT;
	}

	if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
	}

	return forceKillAfterTimeout;
};

// `childProcess.cancel()`
const spawnedCancel = (spawned, context) => {
	const killResult = spawned.kill();

	if (killResult) {
		context.isCanceled = true;
	}
};

const timeoutKill = (spawned, signal, reject) => {
	spawned.kill(signal);
	reject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));
};

// `timeout` option handling
const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {
	if (timeout === 0 || timeout === undefined) {
		return spawnedPromise;
	}

	if (!Number.isInteger(timeout) || timeout < 0) {
		throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
	}

	let timeoutId;
	const timeoutPromise = new Promise((resolve, reject) => {
		timeoutId = setTimeout(() => {
			timeoutKill(spawned, killSignal, reject);
		}, timeout);
	});

	const safeSpawnedPromise = pFinally(spawnedPromise, () => {
		clearTimeout(timeoutId);
	});

	return Promise.race([timeoutPromise, safeSpawnedPromise]);
};

// `cleanup` option handling
const setExitHandler = (spawned, {cleanup, detached}, timedPromise) => {
	if (!cleanup || detached) {
		return timedPromise;
	}

	const removeExitHandler = onExit(() => {
		spawned.kill();
	});

	// TODO: Use native "finally" syntax when targeting Node.js 10
	return pFinally(timedPromise, removeExitHandler);
};

module.exports = {
	spawnedKill,
	spawnedCancel,
	setupTimeout,
	setExitHandler
};


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/promise.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/promise.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";

const mergePromiseProperty = (spawned, promise, property) => {
	// Starting the main `promise` is deferred to avoid consuming streams
	const value = typeof promise === 'function' ?
		(...args) => promise()[property](...args) :
		promise[property].bind(promise);

	Object.defineProperty(spawned, property, {
		value,
		writable: true,
		enumerable: false,
		configurable: true
	});
};

// The return value is a mixin of `childProcess` and `Promise`
const mergePromise = (spawned, promise) => {
	mergePromiseProperty(spawned, promise, 'then');
	mergePromiseProperty(spawned, promise, 'catch');

	// TODO: Remove the `if`-guard when targeting Node.js 10
	if (Promise.prototype.finally) {
		mergePromiseProperty(spawned, promise, 'finally');
	}

	return spawned;
};

// Use promises instead of `child_process` events
const getSpawnedPromise = spawned => {
	return new Promise((resolve, reject) => {
		spawned.on('exit', (code, signal) => {
			resolve({code, signal});
		});

		spawned.on('error', error => {
			reject(error);
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', error => {
				reject(error);
			});
		}
	});
};

module.exports = {
	mergePromise,
	getSpawnedPromise
};



/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/stdio.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/stdio.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";

const aliases = ['stdin', 'stdout', 'stderr'];

const hasAlias = opts => aliases.some(alias => opts[alias] !== undefined);

const normalizeStdio = opts => {
	if (!opts) {
		return;
	}

	const {stdio} = opts;

	if (stdio === undefined) {
		return aliases.map(alias => opts[alias]);
	}

	if (hasAlias(opts)) {
		throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map(alias => `\`${alias}\``).join(', ')}`);
	}

	if (typeof stdio === 'string') {
		return stdio;
	}

	if (!Array.isArray(stdio)) {
		throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	}

	const length = Math.max(stdio.length, aliases.length);
	return Array.from({length}, (value, index) => stdio[index]);
};

module.exports = normalizeStdio;

// `ipc` is pushed unless it is already present
module.exports.node = opts => {
	const stdio = normalizeStdio(opts);

	if (stdio === 'ipc') {
		return 'ipc';
	}

	if (stdio === undefined || typeof stdio === 'string') {
		return [stdio, stdio, stdio, 'ipc'];
	}

	if (stdio.includes('ipc')) {
		return stdio;
	}

	return [...stdio, 'ipc'];
};


/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/execa/lib/stream.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/execa/lib/stream.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isStream = __webpack_require__(/*! is-stream */ "./node_modules/is-stream/index.js");
const getStream = __webpack_require__(/*! get-stream */ "./node_modules/get-stream/index.js");
const mergeStream = __webpack_require__(/*! merge-stream */ "./node_modules/merge-stream/index.js");

// `input` option
const handleInput = (spawned, input) => {
	// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852
	// TODO: Remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0
	if (input === undefined || spawned.stdin === undefined) {
		return;
	}

	if (isStream(input)) {
		input.pipe(spawned.stdin);
	} else {
		spawned.stdin.end(input);
	}
};

// `all` interleaves `stdout` and `stderr`
const makeAllStream = spawned => {
	if (!spawned.stdout && !spawned.stderr) {
		return;
	}

	const mixed = mergeStream();

	if (spawned.stdout) {
		mixed.add(spawned.stdout);
	}

	if (spawned.stderr) {
		mixed.add(spawned.stderr);
	}

	return mixed;
};

// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const getBufferedData = async (stream, streamPromise) => {
	if (!stream) {
		return;
	}

	stream.destroy();

	try {
		return await streamPromise;
	} catch (error) {
		return error.bufferedData;
	}
};

const getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
	if (!stream) {
		return;
	}

	if (!buffer) {
		// TODO: Use `ret = util.promisify(stream.finished)(stream);` when targeting Node.js 10
		return new Promise((resolve, reject) => {
			stream
				.once('end', resolve)
				.once('error', reject);
		});
	}

	if (encoding) {
		return getStream(stream, {encoding, maxBuffer});
	}

	return getStream.buffer(stream, {maxBuffer});
};

// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
	const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
	const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
	const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});

	try {
		return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
	} catch (error) {
		return Promise.all([
			{error, code: error.code, signal: error.signal, timedOut: error.timedOut},
			getBufferedData(stdout, stdoutPromise),
			getBufferedData(stderr, stderrPromise),
			getBufferedData(all, allPromise)
		]);
	}
};

const validateInputSync = ({input}) => {
	if (isStream(input)) {
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	}
};

module.exports = {
	handleInput,
	makeAllStream,
	getSpawnedResult,
	validateInputSync
};



/***/ }),

/***/ "./node_modules/@sindresorhus/df/node_modules/npm-run-path/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@sindresorhus/df/node_modules/npm-run-path/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const pathKey = __webpack_require__(/*! path-key */ "./node_modules/path-key/index.js");

const npmRunPath = options => {
	options = {
		cwd: process.cwd(),
		path: process.env[pathKey()],
		...options
	};

	let previous;
	let cwdPath = path.resolve(options.cwd);
	const result = [];

	while (previous !== cwdPath) {
		result.push(path.join(cwdPath, 'node_modules/.bin'));
		previous = cwdPath;
		cwdPath = path.resolve(cwdPath, '..');
	}

	// Ensure the running `node` binary is used
	result.push(path.dirname(process.execPath));

	return result.concat(options.path).join(path.delimiter);
};

module.exports = npmRunPath;
// TODO: Remove this for the next major release
module.exports["default"] = npmRunPath;

module.exports.env = options => {
	options = {
		env: process.env,
		...options
	};

	const env = {...options.env};
	const path = pathKey({env});

	options.path = env[path];
	env[path] = module.exports(options);

	return env;
};


/***/ }),

/***/ "./node_modules/@tootallnate/once/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tootallnate/once/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function once(emitter, name, { signal } = {}) {
    return new Promise((resolve, reject) => {
        function cleanup() {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', cleanup);
            emitter.removeListener(name, onEvent);
            emitter.removeListener('error', onError);
        }
        function onEvent(...args) {
            cleanup();
            resolve(args);
        }
        function onError(err) {
            cleanup();
            reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', cleanup);
        emitter.on(name, onEvent);
        emitter.on('error', onError);
    });
}
exports["default"] = once;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/agent-base/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/agent-base/dist/src/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __webpack_require__(/*! events */ "events");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/index.js"));
const promisify_1 = __importDefault(__webpack_require__(/*! ./promisify */ "./node_modules/agent-base/dist/src/promisify.js"));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string')
        return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function (createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            }
            else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err) => {
                if (req._hadError)
                    return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = () => {
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err) => {
                if (timedOut)
                    return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket) => {
                if (timedOut)
                    return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', () => {
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                }
                else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            }
            catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/agent-base/dist/src/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/agent-base/dist/src/promisify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function promisify(fn) {
    return function (req, opts) {
        return new Promise((resolve, reject) => {
            fn.call(this, req, opts, (err, rtn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports["default"] = promisify;
//# sourceMappingURL=promisify.js.map

/***/ }),

/***/ "./node_modules/asynckit/index.js":
/*!****************************************!*\
  !*** ./node_modules/asynckit/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(/*! ./parallel.js */ "./node_modules/asynckit/parallel.js"),
  serial        : __webpack_require__(/*! ./serial.js */ "./node_modules/asynckit/serial.js"),
  serialOrdered : __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js")
};


/***/ }),

/***/ "./node_modules/asynckit/lib/abort.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/abort.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/async.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/async.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(/*! ./defer.js */ "./node_modules/asynckit/lib/defer.js");

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ "./node_modules/asynckit/lib/defer.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/defer.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/iterate.js":
/*!**********************************************!*\
  !*** ./node_modules/asynckit/lib/iterate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  , abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/state.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/state.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/terminator.js":
/*!*************************************************!*\
  !*** ./node_modules/asynckit/lib/terminator.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  , async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ "./node_modules/asynckit/parallel.js":
/*!*******************************************!*\
  !*** ./node_modules/asynckit/parallel.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serial.js":
/*!*****************************************!*\
  !*** ./node_modules/asynckit/serial.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js");

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serialOrdered.js":
/*!************************************************!*\
  !*** ./node_modules/asynckit/serialOrdered.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ "./node_modules/combined-stream/lib/combined_stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/combined-stream/lib/combined_stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! util */ "util");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var DelayedStream = __webpack_require__(/*! delayed-stream */ "./node_modules/delayed-stream/lib/delayed_stream.js");

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ "./node_modules/cross-spawn/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cross-spawn/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const cp = __webpack_require__(/*! child_process */ "child_process");
const parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/cross-spawn/lib/parse.js");
const enoent = __webpack_require__(/*! ./lib/enoent */ "./node_modules/cross-spawn/lib/enoent.js");

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;

module.exports._parse = parse;
module.exports._enoent = enoent;


/***/ }),

/***/ "./node_modules/cross-spawn/lib/enoent.js":
/*!************************************************!*\
  !*** ./node_modules/cross-spawn/lib/enoent.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed, 'spawn');

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};


/***/ }),

/***/ "./node_modules/cross-spawn/lib/parse.js":
/*!***********************************************!*\
  !*** ./node_modules/cross-spawn/lib/parse.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const resolveCommand = __webpack_require__(/*! ./util/resolveCommand */ "./node_modules/cross-spawn/lib/util/resolveCommand.js");
const escape = __webpack_require__(/*! ./util/escape */ "./node_modules/cross-spawn/lib/util/escape.js");
const readShebang = __webpack_require__(/*! ./util/readShebang */ "./node_modules/cross-spawn/lib/util/readShebang.js");

const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}

module.exports = parse;


/***/ }),

/***/ "./node_modules/cross-spawn/lib/util/escape.js":
/*!*****************************************************!*\
  !*** ./node_modules/cross-spawn/lib/util/escape.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;


/***/ }),

/***/ "./node_modules/cross-spawn/lib/util/readShebang.js":
/*!**********************************************************!*\
  !*** ./node_modules/cross-spawn/lib/util/readShebang.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const shebangCommand = __webpack_require__(/*! shebang-command */ "./node_modules/shebang-command/index.js");

function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

module.exports = readShebang;


/***/ }),

/***/ "./node_modules/cross-spawn/lib/util/resolveCommand.js":
/*!*************************************************************!*\
  !*** ./node_modules/cross-spawn/lib/util/resolveCommand.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const which = __webpack_require__(/*! which */ "./node_modules/which/which.js");
const getPathKey = __webpack_require__(/*! path-key */ "./node_modules/path-key/index.js");

function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

module.exports = resolveCommand;


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || "main" === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "./node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "./node_modules/delayed-stream/lib/delayed_stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/delayed-stream/lib/delayed_stream.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var util = __webpack_require__(/*! util */ "util");

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ "./node_modules/end-of-stream/index.js":
/*!*********************************************!*\
  !*** ./node_modules/end-of-stream/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "./node_modules/once/once.js");

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ "./node_modules/execa/index.js":
/*!*************************************!*\
  !*** ./node_modules/execa/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const childProcess = __webpack_require__(/*! child_process */ "child_process");
const crossSpawn = __webpack_require__(/*! cross-spawn */ "./node_modules/cross-spawn/index.js");
const stripFinalNewline = __webpack_require__(/*! strip-final-newline */ "./node_modules/strip-final-newline/index.js");
const npmRunPath = __webpack_require__(/*! npm-run-path */ "./node_modules/npm-run-path/index.js");
const onetime = __webpack_require__(/*! onetime */ "./node_modules/onetime/index.js");
const makeError = __webpack_require__(/*! ./lib/error */ "./node_modules/execa/lib/error.js");
const normalizeStdio = __webpack_require__(/*! ./lib/stdio */ "./node_modules/execa/lib/stdio.js");
const {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = __webpack_require__(/*! ./lib/kill */ "./node_modules/execa/lib/kill.js");
const {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = __webpack_require__(/*! ./lib/stream */ "./node_modules/execa/lib/stream.js");
const {mergePromise, getSpawnedPromise} = __webpack_require__(/*! ./lib/promise */ "./node_modules/execa/lib/promise.js");
const {joinCommand, parseCommand, getEscapedCommand} = __webpack_require__(/*! ./lib/command */ "./node_modules/execa/lib/command.js");

const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
	const env = extendEnv ? {...process.env, ...envOption} : envOption;

	if (preferLocal) {
		return npmRunPath.env({env, cwd: localDir, execPath});
	}

	return env;
};

const handleArguments = (file, args, options = {}) => {
	const parsed = crossSpawn._parse(file, args, options);
	file = parsed.command;
	args = parsed.args;
	options = parsed.options;

	options = {
		maxBuffer: DEFAULT_MAX_BUFFER,
		buffer: true,
		stripFinalNewline: true,
		extendEnv: true,
		preferLocal: false,
		localDir: options.cwd || process.cwd(),
		execPath: process.execPath,
		encoding: 'utf8',
		reject: true,
		cleanup: true,
		all: false,
		windowsHide: true,
		...options
	};

	options.env = getEnv(options);

	options.stdio = normalizeStdio(options);

	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
		// #116
		args.unshift('/q');
	}

	return {file, args, options, parsed};
};

const handleOutput = (options, value, error) => {
	if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
		// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`
		return error === undefined ? undefined : '';
	}

	if (options.stripFinalNewline) {
		return stripFinalNewline(value);
	}

	return value;
};

const execa = (file, args, options) => {
	const parsed = handleArguments(file, args, options);
	const command = joinCommand(file, args);
	const escapedCommand = getEscapedCommand(file, args);

	validateTimeout(parsed.options);

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		// Ensure the returned error is always both a promise and a child process
		const dummySpawned = new childProcess.ChildProcess();
		const errorPromise = Promise.reject(makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
		}));
		return mergePromise(dummySpawned, errorPromise);
	}

	const spawnedPromise = getSpawnedPromise(spawned);
	const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
	const processDone = setExitHandler(spawned, parsed.options, timedPromise);

	const context = {isCanceled: false};

	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
	spawned.cancel = spawnedCancel.bind(null, spawned, context);

	const handlePromise = async () => {
		const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
		const stdout = handleOutput(parsed.options, stdoutResult);
		const stderr = handleOutput(parsed.options, stderrResult);
		const all = handleOutput(parsed.options, allResult);

		if (error || exitCode !== 0 || signal !== null) {
			const returnedError = makeError({
				error,
				exitCode,
				signal,
				stdout,
				stderr,
				all,
				command,
				escapedCommand,
				parsed,
				timedOut,
				isCanceled: context.isCanceled,
				killed: spawned.killed
			});

			if (!parsed.options.reject) {
				return returnedError;
			}

			throw returnedError;
		}

		return {
			command,
			escapedCommand,
			exitCode: 0,
			stdout,
			stderr,
			all,
			failed: false,
			timedOut: false,
			isCanceled: false,
			killed: false
		};
	};

	const handlePromiseOnce = onetime(handlePromise);

	handleInput(spawned, parsed.options.input);

	spawned.all = makeAllStream(spawned, parsed.options);

	return mergePromise(spawned, handlePromiseOnce);
};

module.exports = execa;

module.exports.sync = (file, args, options) => {
	const parsed = handleArguments(file, args, options);
	const command = joinCommand(file, args);
	const escapedCommand = getEscapedCommand(file, args);

	validateInputSync(parsed.options);

	let result;
	try {
		result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		throw makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
		});
	}

	const stdout = handleOutput(parsed.options, result.stdout, result.error);
	const stderr = handleOutput(parsed.options, result.stderr, result.error);

	if (result.error || result.status !== 0 || result.signal !== null) {
		const error = makeError({
			stdout,
			stderr,
			error: result.error,
			signal: result.signal,
			exitCode: result.status,
			command,
			escapedCommand,
			parsed,
			timedOut: result.error && result.error.code === 'ETIMEDOUT',
			isCanceled: false,
			killed: result.signal !== null
		});

		if (!parsed.options.reject) {
			return error;
		}

		throw error;
	}

	return {
		command,
		escapedCommand,
		exitCode: 0,
		stdout,
		stderr,
		failed: false,
		timedOut: false,
		isCanceled: false,
		killed: false
	};
};

module.exports.command = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa(file, args, options);
};

module.exports.commandSync = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa.sync(file, args, options);
};

module.exports.node = (scriptPath, args, options = {}) => {
	if (args && !Array.isArray(args) && typeof args === 'object') {
		options = args;
		args = [];
	}

	const stdio = normalizeStdio.node(options);
	const defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));

	const {
		nodePath = process.execPath,
		nodeOptions = defaultExecArgv
	} = options;

	return execa(
		nodePath,
		[
			...nodeOptions,
			scriptPath,
			...(Array.isArray(args) ? args : [])
		],
		{
			...options,
			stdin: undefined,
			stdout: undefined,
			stderr: undefined,
			stdio,
			shell: false
		}
	);
};


/***/ }),

/***/ "./node_modules/execa/lib/command.js":
/*!*******************************************!*\
  !*** ./node_modules/execa/lib/command.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";

const normalizeArgs = (file, args = []) => {
	if (!Array.isArray(args)) {
		return [file];
	}

	return [file, ...args];
};

const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const DOUBLE_QUOTES_REGEXP = /"/g;

const escapeArg = arg => {
	if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
		return arg;
	}

	return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};

const joinCommand = (file, args) => {
	return normalizeArgs(file, args).join(' ');
};

const getEscapedCommand = (file, args) => {
	return normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');
};

const SPACES_REGEXP = / +/g;

// Handle `execa.command()`
const parseCommand = command => {
	const tokens = [];
	for (const token of command.trim().split(SPACES_REGEXP)) {
		// Allow spaces to be escaped by a backslash if not meant as a delimiter
		const previousToken = tokens[tokens.length - 1];
		if (previousToken && previousToken.endsWith('\\')) {
			// Merge previous token with current one
			tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
		} else {
			tokens.push(token);
		}
	}

	return tokens;
};

module.exports = {
	joinCommand,
	getEscapedCommand,
	parseCommand
};


/***/ }),

/***/ "./node_modules/execa/lib/error.js":
/*!*****************************************!*\
  !*** ./node_modules/execa/lib/error.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {signalsByName} = __webpack_require__(/*! human-signals */ "./node_modules/human-signals/build/src/main.js");

const getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
	if (timedOut) {
		return `timed out after ${timeout} milliseconds`;
	}

	if (isCanceled) {
		return 'was canceled';
	}

	if (errorCode !== undefined) {
		return `failed with ${errorCode}`;
	}

	if (signal !== undefined) {
		return `was killed with ${signal} (${signalDescription})`;
	}

	if (exitCode !== undefined) {
		return `failed with exit code ${exitCode}`;
	}

	return 'failed';
};

const makeError = ({
	stdout,
	stderr,
	all,
	error,
	signal,
	exitCode,
	command,
	escapedCommand,
	timedOut,
	isCanceled,
	killed,
	parsed: {options: {timeout}}
}) => {
	// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
	// We normalize them to `undefined`
	exitCode = exitCode === null ? undefined : exitCode;
	signal = signal === null ? undefined : signal;
	const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;

	const errorCode = error && error.code;

	const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
	const execaMessage = `Command ${prefix}: ${command}`;
	const isError = Object.prototype.toString.call(error) === '[object Error]';
	const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
	const message = [shortMessage, stderr, stdout].filter(Boolean).join('\n');

	if (isError) {
		error.originalMessage = error.message;
		error.message = message;
	} else {
		error = new Error(message);
	}

	error.shortMessage = shortMessage;
	error.command = command;
	error.escapedCommand = escapedCommand;
	error.exitCode = exitCode;
	error.signal = signal;
	error.signalDescription = signalDescription;
	error.stdout = stdout;
	error.stderr = stderr;

	if (all !== undefined) {
		error.all = all;
	}

	if ('bufferedData' in error) {
		delete error.bufferedData;
	}

	error.failed = true;
	error.timedOut = Boolean(timedOut);
	error.isCanceled = isCanceled;
	error.killed = killed && !timedOut;

	return error;
};

module.exports = makeError;


/***/ }),

/***/ "./node_modules/execa/lib/kill.js":
/*!****************************************!*\
  !*** ./node_modules/execa/lib/kill.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const onExit = __webpack_require__(/*! signal-exit */ "./node_modules/signal-exit/index.js");

const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {
	const killResult = kill(signal);
	setKillTimeout(kill, signal, options, killResult);
	return killResult;
};

const setKillTimeout = (kill, signal, options, killResult) => {
	if (!shouldForceKill(signal, options, killResult)) {
		return;
	}

	const timeout = getForceKillAfterTimeout(options);
	const t = setTimeout(() => {
		kill('SIGKILL');
	}, timeout);

	// Guarded because there's no `.unref()` when `execa` is used in the renderer
	// process in Electron. This cannot be tested since we don't run tests in
	// Electron.
	// istanbul ignore else
	if (t.unref) {
		t.unref();
	}
};

const shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
	return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};

const isSigterm = signal => {
	return signal === os.constants.signals.SIGTERM ||
		(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
};

const getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
	if (forceKillAfterTimeout === true) {
		return DEFAULT_FORCE_KILL_TIMEOUT;
	}

	if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
	}

	return forceKillAfterTimeout;
};

// `childProcess.cancel()`
const spawnedCancel = (spawned, context) => {
	const killResult = spawned.kill();

	if (killResult) {
		context.isCanceled = true;
	}
};

const timeoutKill = (spawned, signal, reject) => {
	spawned.kill(signal);
	reject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));
};

// `timeout` option handling
const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {
	if (timeout === 0 || timeout === undefined) {
		return spawnedPromise;
	}

	let timeoutId;
	const timeoutPromise = new Promise((resolve, reject) => {
		timeoutId = setTimeout(() => {
			timeoutKill(spawned, killSignal, reject);
		}, timeout);
	});

	const safeSpawnedPromise = spawnedPromise.finally(() => {
		clearTimeout(timeoutId);
	});

	return Promise.race([timeoutPromise, safeSpawnedPromise]);
};

const validateTimeout = ({timeout}) => {
	if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
		throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
	}
};

// `cleanup` option handling
const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
	if (!cleanup || detached) {
		return timedPromise;
	}

	const removeExitHandler = onExit(() => {
		spawned.kill();
	});

	return timedPromise.finally(() => {
		removeExitHandler();
	});
};

module.exports = {
	spawnedKill,
	spawnedCancel,
	setupTimeout,
	validateTimeout,
	setExitHandler
};


/***/ }),

/***/ "./node_modules/execa/lib/promise.js":
/*!*******************************************!*\
  !*** ./node_modules/execa/lib/promise.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


const nativePromisePrototype = (async () => {})().constructor.prototype;
const descriptors = ['then', 'catch', 'finally'].map(property => [
	property,
	Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// The return value is a mixin of `childProcess` and `Promise`
const mergePromise = (spawned, promise) => {
	for (const [property, descriptor] of descriptors) {
		// Starting the main `promise` is deferred to avoid consuming streams
		const value = typeof promise === 'function' ?
			(...args) => Reflect.apply(descriptor.value, promise(), args) :
			descriptor.value.bind(promise);

		Reflect.defineProperty(spawned, property, {...descriptor, value});
	}

	return spawned;
};

// Use promises instead of `child_process` events
const getSpawnedPromise = spawned => {
	return new Promise((resolve, reject) => {
		spawned.on('exit', (exitCode, signal) => {
			resolve({exitCode, signal});
		});

		spawned.on('error', error => {
			reject(error);
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', error => {
				reject(error);
			});
		}
	});
};

module.exports = {
	mergePromise,
	getSpawnedPromise
};



/***/ }),

/***/ "./node_modules/execa/lib/stdio.js":
/*!*****************************************!*\
  !*** ./node_modules/execa/lib/stdio.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";

const aliases = ['stdin', 'stdout', 'stderr'];

const hasAlias = options => aliases.some(alias => options[alias] !== undefined);

const normalizeStdio = options => {
	if (!options) {
		return;
	}

	const {stdio} = options;

	if (stdio === undefined) {
		return aliases.map(alias => options[alias]);
	}

	if (hasAlias(options)) {
		throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map(alias => `\`${alias}\``).join(', ')}`);
	}

	if (typeof stdio === 'string') {
		return stdio;
	}

	if (!Array.isArray(stdio)) {
		throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	}

	const length = Math.max(stdio.length, aliases.length);
	return Array.from({length}, (value, index) => stdio[index]);
};

module.exports = normalizeStdio;

// `ipc` is pushed unless it is already present
module.exports.node = options => {
	const stdio = normalizeStdio(options);

	if (stdio === 'ipc') {
		return 'ipc';
	}

	if (stdio === undefined || typeof stdio === 'string') {
		return [stdio, stdio, stdio, 'ipc'];
	}

	if (stdio.includes('ipc')) {
		return stdio;
	}

	return [...stdio, 'ipc'];
};


/***/ }),

/***/ "./node_modules/execa/lib/stream.js":
/*!******************************************!*\
  !*** ./node_modules/execa/lib/stream.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isStream = __webpack_require__(/*! is-stream */ "./node_modules/is-stream/index.js");
const getStream = __webpack_require__(/*! get-stream */ "./node_modules/execa/node_modules/get-stream/index.js");
const mergeStream = __webpack_require__(/*! merge-stream */ "./node_modules/merge-stream/index.js");

// `input` option
const handleInput = (spawned, input) => {
	// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852
	// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0
	if (input === undefined || spawned.stdin === undefined) {
		return;
	}

	if (isStream(input)) {
		input.pipe(spawned.stdin);
	} else {
		spawned.stdin.end(input);
	}
};

// `all` interleaves `stdout` and `stderr`
const makeAllStream = (spawned, {all}) => {
	if (!all || (!spawned.stdout && !spawned.stderr)) {
		return;
	}

	const mixed = mergeStream();

	if (spawned.stdout) {
		mixed.add(spawned.stdout);
	}

	if (spawned.stderr) {
		mixed.add(spawned.stderr);
	}

	return mixed;
};

// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const getBufferedData = async (stream, streamPromise) => {
	if (!stream) {
		return;
	}

	stream.destroy();

	try {
		return await streamPromise;
	} catch (error) {
		return error.bufferedData;
	}
};

const getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
	if (!stream || !buffer) {
		return;
	}

	if (encoding) {
		return getStream(stream, {encoding, maxBuffer});
	}

	return getStream.buffer(stream, {maxBuffer});
};

// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
	const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
	const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
	const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});

	try {
		return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
	} catch (error) {
		return Promise.all([
			{error, signal: error.signal, timedOut: error.timedOut},
			getBufferedData(stdout, stdoutPromise),
			getBufferedData(stderr, stderrPromise),
			getBufferedData(all, allPromise)
		]);
	}
};

const validateInputSync = ({input}) => {
	if (isStream(input)) {
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	}
};

module.exports = {
	handleInput,
	makeAllStream,
	getSpawnedResult,
	validateInputSync
};



/***/ }),

/***/ "./node_modules/execa/node_modules/get-stream/buffer-stream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/execa/node_modules/get-stream/buffer-stream.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(/*! stream */ "stream");

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ "./node_modules/execa/node_modules/get-stream/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/execa/node_modules/get-stream/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {constants: BufferConstants} = __webpack_require__(/*! buffer */ "buffer");
const stream = __webpack_require__(/*! stream */ "stream");
const {promisify} = __webpack_require__(/*! util */ "util");
const bufferStream = __webpack_require__(/*! ./buffer-stream */ "./node_modules/execa/node_modules/get-stream/buffer-stream.js");

const streamPipelinePromisified = promisify(stream.pipeline);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		throw new Error('Expected a stream');
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;
	const stream = bufferStream(options);

	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		(async () => {
			try {
				await streamPipelinePromisified(inputStream, stream);
				resolve();
			} catch (error) {
				rejectPromise(error);
			}
		})();

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/fxp.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/fxp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(/*! ./validator */ "./node_modules/fast-xml-parser/src/validator.js");
const XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js");
const XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js");

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ./util */ "./node_modules/fast-xml-parser/src/util.js");

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js");

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  transformTagName: false,
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }

  if (this.options.suppressEmptyNode) {
    this.buildTextNode = buildEmptyTextNode;
    this.buildObjNode = buildEmptyObjNode;
  } else {
    this.buildTextNode = buildTextValNode;
    this.buildObjNode = buildObjectNode;
  }

  this.buildTextValNode = buildTextValNode;
  this.buildObjectNode = buildObjectNode;

  this.replaceEntitiesValue = replaceEntitiesValue;
  this.buildAttrPairStr = buildAttrPairStr;
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          val += this.processTextOrObjNode(item, key, level)
        } else {
          val += this.buildTextNode(item, key, '', level);
        }
      }
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

function buildAttrPairStr(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjNode(result.val, key, result.attrStr, level);
  }
}

function buildObjectNode(val, key, attrStr, level) {
  let tagEndExp = '</' + key + this.tagEndChar;
  let piClosingChar = "";
  
  if(key[0] === "?") {
    piClosingChar = "?";
    tagEndExp = "";
  }

  if (attrStr && val.indexOf('<') === -1) {
    return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
    return this.indentate(level) + `<!--${val}-->` + this.newLine;
  }else {
    return (
      this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
      val +
      this.indentate(level) + tagEndExp    );
  }
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
  }
}

function buildTextValNode(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
      if(this.options.suppressUnpairedNode){
        return this.indentate(level) + '<' + key + this.tagEndChar;
      }else{
        return this.indentate(level) + '<' + key + "/" + this.tagEndChar;
      }
    } else{
      return (
        this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar  );
    }

  }
}

function replaceEntitiesValue(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function buildEmptyTextNode(val, key, attrStr, level) {
  if( val === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(this.options.suppressUnpairedNode){
      return this.indentate(level) + '<' + key + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + "/" + this.tagEndChar;
    }
  }else if (val !== '') { //empty
    return this.buildTextValNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; //PI tag
    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar; //normal
  }
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \**********************************************************************/
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options){
    return arrToStr( jArray, options, "", 0);
}

function arrToStr(arr, options, jPath, level){
    let xmlStr = "";

    let indentation = "";
    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call
        indentation = EOL + "" + options.indentBy.repeat(level);
    }

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if(jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if(tagName === options.textNodeName){
            let tagText = tagObj[tagName];
            if(!isStopNode(newJPath, options)){
                tagText = options.tagValueProcessor( tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            xmlStr += indentation + tagText;
            continue;
        }else if( tagName === options.cdataPropName){
            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            continue;
        }else if( tagName === options.commentPropName){
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            continue;
        }else if( tagName[0] === "?"){
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            continue;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        let tagStart =  indentation + `<${tagName}${attStr}`;
        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);
        if(options.unpairedTags.indexOf(tagName) !== -1){
            if(options.suppressUnpairedNode)  xmlStr += tagStart + ">"; 
            else xmlStr += tagStart + "/>"; 
        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ 
            xmlStr += tagStart + "/>"; 
        }else{ 
            //TODO: node with only text value should not parse the text value in next line
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;
        }
    }
    
    return xmlStr;
}

function propName(obj){
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if(key !== ":@") return key;
    }
  }

function attr_to_str(attrMap, options){
    let attrStr = "";
    if(attrMap && !options.ignoreAttributes){
        for (let attr in attrMap){
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if(attrVal === true && options.suppressBooleanAttributes){
                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;
            }else{
                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options){
    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for(let index in options.stopNodes){
        if(options.stopNodes[index] === jPath || options.stopNodes[index] === "*."+tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options){
    if(textValue && textValue.length > 0 && options.processEntities){
      for (let i=0; i< options.entities.length; i++) {
        const entity = options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
module.exports = toXml;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((module) => {

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<') {
                if( hasBody && 
                     xmlData[i+1] === '!' &&
                     xmlData[i+2] === 'E' &&
                     xmlData[i+3] === 'N' &&
                     xmlData[i+4] === 'T' &&
                     xmlData[i+5] === 'I' &&
                     xmlData[i+6] === 'T' &&
                     xmlData[i+7] === 'Y'
                ){
                    i += 7;
                    entity = true;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                     xmlData[i+2] === 'E' &&
                     xmlData[i+3] === 'L' &&
                     xmlData[i+4] === 'E' &&
                     xmlData[i+5] === 'M' &&
                     xmlData[i+6] === 'E' &&
                     xmlData[i+7] === 'N' &&
                     xmlData[i+8] === 'T'
                ){
                    //Not supported
                    i += 8;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === 'A' &&
                    xmlData[i+3] === 'T' &&
                    xmlData[i+4] === 'T' &&
                    xmlData[i+5] === 'L' &&
                    xmlData[i+6] === 'I' &&
                    xmlData[i+7] === 'S' &&
                    xmlData[i+8] === 'T'
                ){
                    //Not supported
                    i += 8;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === 'N' &&
                    xmlData[i+3] === 'O' &&
                    xmlData[i+4] === 'T' &&
                    xmlData[i+5] === 'A' &&
                    xmlData[i+6] === 'T' &&
                    xmlData[i+7] === 'I' &&
                    xmlData[i+8] === 'O' &&
                    xmlData[i+9] === 'N'
                ){
                    //Not supported
                    i += 9;
                }else if( //comment
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === '-' &&
                    xmlData[i+3] === '-'
                ){
                    comment = true;
                }else{
                    throw new Error("Invalid DOCTYPE");
                }
                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') {
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                    }else{
                        throw new Error(`Invalid XML comment in DOCTYPE`);
                    }
                }else if(entity){
                    parseEntityExp(exp, entities);
                    entity = false;
                }
                angleBracketsCount--;
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

const entityRegex = RegExp("^\\s([a-zA-z0-0]+)[ \t](['\"])([^&]+)\\2");
function parseEntityExp(exp, entities){
    const match = entityRegex.exec(exp);
    if(match){
        entities[ match[1] ] = {
            regx : RegExp( `&${match[1]};`,"g"),
            val: match[3]
        };
    }
}
module.exports = readDocType;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

///@ts-check

const util = __webpack_require__(/*! ../util */ "./node_modules/fast-xml-parser/src/util.js");
const xmlNode = __webpack_require__(/*! ./xmlNode */ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js");
const readDocType = __webpack_require__(/*! ./DocTypeReader */ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js");
const toNumber = __webpack_require__(/*! strnum */ "./node_modules/strnum/strnum.js");

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      const aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        jPath = jPath.substr(0, jPath.lastIndexOf("."));
        
        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
          }
          currentNode.addChild(childNode);

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
        }

        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //boolean tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          currentNode.addChild(childNode);
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode.addChild(childNode);
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            currentNode.addChild(childNode);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-dobule quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { buildOptions} = __webpack_require__(/*! ./OptionsBuilder */ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js");
const OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js");
const { prettify} = __webpack_require__(/*! ./node2json */ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js");
const validator = __webpack_require__(/*! ../validator */ "./node_modules/fast-xml-parser/src/validator.js");

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const propCount = Object.keys(obj).length;
  if( propCount === 0 || (propCount === 1 && obj[options.textNodeName]) ) return true;
  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ "./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CombinedStream = __webpack_require__(/*! combined-stream */ "./node_modules/combined-stream/lib/combined_stream.js");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var parseUrl = (__webpack_require__(/*! url */ "url").parse);
var fs = __webpack_require__(/*! fs */ "fs");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
var asynckit = __webpack_require__(/*! asynckit */ "./node_modules/asynckit/index.js");
var populate = __webpack_require__(/*! ./populate.js */ "./node_modules/form-data/lib/populate.js");

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ "./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ "./node_modules/get-stream/buffer-stream.js":
/*!**************************************************!*\
  !*** ./node_modules/get-stream/buffer-stream.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(/*! stream */ "stream");

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ "./node_modules/get-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/get-stream/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {constants: BufferConstants} = __webpack_require__(/*! buffer */ "buffer");
const pump = __webpack_require__(/*! pump */ "./node_modules/pump/index.js");
const bufferStream = __webpack_require__(/*! ./buffer-stream */ "./node_modules/get-stream/buffer-stream.js");

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports["default"] = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/http-proxy-agent/dist/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/http-proxy-agent/dist/agent.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __importDefault(__webpack_require__(/*! net */ "net"));
const tls_1 = __importDefault(__webpack_require__(/*! tls */ "tls"));
const url_1 = __importDefault(__webpack_require__(/*! url */ "url"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/index.js"));
const once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ "./node_modules/@tootallnate/once/dist/index.js"));
const agent_base_1 = __webpack_require__(/*! agent-base */ "./node_modules/agent-base/dist/src/index.js");
const debug = (0, debug_1.default)('http-proxy-agent');
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
/**
 * The `HttpProxyAgent` implements an HTTP Agent subclass that connects
 * to the specified "HTTP proxy server" in order to proxy HTTP requests.
 *
 * @api public
 */
class HttpProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('Creating new HttpProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            const parsed = url_1.default.parse(req.path);
            if (!parsed.protocol) {
                parsed.protocol = 'http:';
            }
            if (!parsed.hostname) {
                parsed.hostname = opts.hostname || opts.host || null;
            }
            if (parsed.port == null && typeof opts.port) {
                parsed.port = String(opts.port);
            }
            if (parsed.port === '80') {
                // if port is 80, then we can remove the port so that the
                // ":80" portion is not on the produced URL
                parsed.port = '';
            }
            // Change the `http.ClientRequest` instance's "path" field
            // to the absolute path of the URL that will be requested.
            req.path = url_1.default.format(parsed);
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);
            }
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            // At this point, the http ClientRequest's internal `_header` field
            // might have already been set. If this is the case then we'll need
            // to re-generate the string since we just changed the `req.path`.
            if (req._header) {
                let first;
                let endOfHeaders;
                debug('Regenerating stored HTTP header string for request');
                req._header = null;
                req._implicitHeader();
                if (req.output && req.output.length > 0) {
                    // Node < 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.output[0];
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.output[0] = req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.output);
                }
                else if (req.outputData && req.outputData.length > 0) {
                    // Node >= 12
                    debug('Patching connection write() output buffer with updated header');
                    first = req.outputData[0].data;
                    endOfHeaders = first.indexOf('\r\n\r\n') + 4;
                    req.outputData[0].data =
                        req._header + first.substring(endOfHeaders);
                    debug('Output buffer: %o', req.outputData[0].data);
                }
            }
            // Wait for the socket's `connect` event, so that this `callback()`
            // function throws instead of the `http` request machinery. This is
            // important for i.e. `PacProxyAgent` which determines a failed proxy
            // connection via the `callback()` function throwing.
            yield (0, once_1.default)(socket, 'connect');
            return socket;
        });
    }
}
exports["default"] = HttpProxyAgent;
//# sourceMappingURL=agent.js.map

/***/ }),

/***/ "./node_modules/http-proxy-agent/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/http-proxy-agent/dist/index.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__webpack_require__(/*! ./agent */ "./node_modules/http-proxy-agent/dist/agent.js"));
function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpProxyAgent) {
    createHttpProxyAgent.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent.prototype = agent_1.default.prototype;
})(createHttpProxyAgent || (createHttpProxyAgent = {}));
module.exports = createHttpProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __importDefault(__webpack_require__(/*! net */ "net"));
const tls_1 = __importDefault(__webpack_require__(/*! tls */ "tls"));
const url_1 = __importDefault(__webpack_require__(/*! url */ "url"));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "assert"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/index.js"));
const agent_base_1 = __webpack_require__(/*! agent-base */ "./node_modules/agent-base/dist/src/index.js");
const parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ "./node_modules/https-proxy-agent/dist/parse-proxy-response.js"));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */
class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        }
        else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = ['http 1.1'];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            }
            else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)) {
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    const servername = opts.servername || opts.host;
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,
                        servername }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket({ writable: false });
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s) => {
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports["default"] = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean((!secure && port === 80) || (secure && port === 443));
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
//# sourceMappingURL=agent.js.map

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const agent_1 = __importDefault(__webpack_require__(/*! ./agent */ "./node_modules/https-proxy-agent/dist/agent.js"));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function (createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/index.js"));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b)
                ondata(b);
            else
                socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports["default"] = parseProxyResponse;
//# sourceMappingURL=parse-proxy-response.js.map

/***/ }),

/***/ "./node_modules/human-signals/build/src/core.js":
/*!******************************************************!*\
  !*** ./node_modules/human-signals/build/src/core.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports.SIGNALS=void 0;

const SIGNALS=[
{
name:"SIGHUP",
number:1,
action:"terminate",
description:"Terminal closed",
standard:"posix"},

{
name:"SIGINT",
number:2,
action:"terminate",
description:"User interruption with CTRL-C",
standard:"ansi"},

{
name:"SIGQUIT",
number:3,
action:"core",
description:"User interruption with CTRL-\\",
standard:"posix"},

{
name:"SIGILL",
number:4,
action:"core",
description:"Invalid machine instruction",
standard:"ansi"},

{
name:"SIGTRAP",
number:5,
action:"core",
description:"Debugger breakpoint",
standard:"posix"},

{
name:"SIGABRT",
number:6,
action:"core",
description:"Aborted",
standard:"ansi"},

{
name:"SIGIOT",
number:6,
action:"core",
description:"Aborted",
standard:"bsd"},

{
name:"SIGBUS",
number:7,
action:"core",
description:
"Bus error due to misaligned, non-existing address or paging error",
standard:"bsd"},

{
name:"SIGEMT",
number:7,
action:"terminate",
description:"Command should be emulated but is not implemented",
standard:"other"},

{
name:"SIGFPE",
number:8,
action:"core",
description:"Floating point arithmetic error",
standard:"ansi"},

{
name:"SIGKILL",
number:9,
action:"terminate",
description:"Forced termination",
standard:"posix",
forced:true},

{
name:"SIGUSR1",
number:10,
action:"terminate",
description:"Application-specific signal",
standard:"posix"},

{
name:"SIGSEGV",
number:11,
action:"core",
description:"Segmentation fault",
standard:"ansi"},

{
name:"SIGUSR2",
number:12,
action:"terminate",
description:"Application-specific signal",
standard:"posix"},

{
name:"SIGPIPE",
number:13,
action:"terminate",
description:"Broken pipe or socket",
standard:"posix"},

{
name:"SIGALRM",
number:14,
action:"terminate",
description:"Timeout or timer",
standard:"posix"},

{
name:"SIGTERM",
number:15,
action:"terminate",
description:"Termination",
standard:"ansi"},

{
name:"SIGSTKFLT",
number:16,
action:"terminate",
description:"Stack is empty or overflowed",
standard:"other"},

{
name:"SIGCHLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"posix"},

{
name:"SIGCLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"other"},

{
name:"SIGCONT",
number:18,
action:"unpause",
description:"Unpaused",
standard:"posix",
forced:true},

{
name:"SIGSTOP",
number:19,
action:"pause",
description:"Paused",
standard:"posix",
forced:true},

{
name:"SIGTSTP",
number:20,
action:"pause",
description:"Paused using CTRL-Z or \"suspend\"",
standard:"posix"},

{
name:"SIGTTIN",
number:21,
action:"pause",
description:"Background process cannot read terminal input",
standard:"posix"},

{
name:"SIGBREAK",
number:21,
action:"terminate",
description:"User interruption with CTRL-BREAK",
standard:"other"},

{
name:"SIGTTOU",
number:22,
action:"pause",
description:"Background process cannot write to terminal output",
standard:"posix"},

{
name:"SIGURG",
number:23,
action:"ignore",
description:"Socket received out-of-band data",
standard:"bsd"},

{
name:"SIGXCPU",
number:24,
action:"core",
description:"Process timed out",
standard:"bsd"},

{
name:"SIGXFSZ",
number:25,
action:"core",
description:"File too big",
standard:"bsd"},

{
name:"SIGVTALRM",
number:26,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"},

{
name:"SIGPROF",
number:27,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"},

{
name:"SIGWINCH",
number:28,
action:"ignore",
description:"Terminal window size changed",
standard:"bsd"},

{
name:"SIGIO",
number:29,
action:"terminate",
description:"I/O is available",
standard:"other"},

{
name:"SIGPOLL",
number:29,
action:"terminate",
description:"Watched event",
standard:"other"},

{
name:"SIGINFO",
number:29,
action:"ignore",
description:"Request for process information",
standard:"other"},

{
name:"SIGPWR",
number:30,
action:"terminate",
description:"Device running out of power",
standard:"systemv"},

{
name:"SIGSYS",
number:31,
action:"core",
description:"Invalid system call",
standard:"other"},

{
name:"SIGUNUSED",
number:31,
action:"terminate",
description:"Invalid system call",
standard:"other"}];exports.SIGNALS=SIGNALS;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./node_modules/human-signals/build/src/main.js":
/*!******************************************************!*\
  !*** ./node_modules/human-signals/build/src/main.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports.signalsByNumber=exports.signalsByName=void 0;var _os=__webpack_require__(/*! os */ "os");

var _signals=__webpack_require__(/*! ./signals.js */ "./node_modules/human-signals/build/src/signals.js");
var _realtime=__webpack_require__(/*! ./realtime.js */ "./node_modules/human-signals/build/src/realtime.js");



const getSignalsByName=function(){
const signals=(0,_signals.getSignals)();
return signals.reduce(getSignalByName,{});
};

const getSignalByName=function(
signalByNameMemo,
{name,number,description,supported,action,forced,standard})
{
return{
...signalByNameMemo,
[name]:{name,number,description,supported,action,forced,standard}};

};

const signalsByName=getSignalsByName();exports.signalsByName=signalsByName;




const getSignalsByNumber=function(){
const signals=(0,_signals.getSignals)();
const length=_realtime.SIGRTMAX+1;
const signalsA=Array.from({length},(value,number)=>
getSignalByNumber(number,signals));

return Object.assign({},...signalsA);
};

const getSignalByNumber=function(number,signals){
const signal=findSignalByNumber(number,signals);

if(signal===undefined){
return{};
}

const{name,description,supported,action,forced,standard}=signal;
return{
[number]:{
name,
number,
description,
supported,
action,
forced,
standard}};


};



const findSignalByNumber=function(number,signals){
const signal=signals.find(({name})=>_os.constants.signals[name]===number);

if(signal!==undefined){
return signal;
}

return signals.find(signalA=>signalA.number===number);
};

const signalsByNumber=getSignalsByNumber();exports.signalsByNumber=signalsByNumber;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/human-signals/build/src/realtime.js":
/*!**********************************************************!*\
  !*** ./node_modules/human-signals/build/src/realtime.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports.SIGRTMAX=exports.getRealtimeSignals=void 0;
const getRealtimeSignals=function(){
const length=SIGRTMAX-SIGRTMIN+1;
return Array.from({length},getRealtimeSignal);
};exports.getRealtimeSignals=getRealtimeSignals;

const getRealtimeSignal=function(value,index){
return{
name:`SIGRT${index+1}`,
number:SIGRTMIN+index,
action:"terminate",
description:"Application-specific signal (realtime)",
standard:"posix"};

};

const SIGRTMIN=34;
const SIGRTMAX=64;exports.SIGRTMAX=SIGRTMAX;
//# sourceMappingURL=realtime.js.map

/***/ }),

/***/ "./node_modules/human-signals/build/src/signals.js":
/*!*********************************************************!*\
  !*** ./node_modules/human-signals/build/src/signals.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports.getSignals=void 0;var _os=__webpack_require__(/*! os */ "os");

var _core=__webpack_require__(/*! ./core.js */ "./node_modules/human-signals/build/src/core.js");
var _realtime=__webpack_require__(/*! ./realtime.js */ "./node_modules/human-signals/build/src/realtime.js");



const getSignals=function(){
const realtimeSignals=(0,_realtime.getRealtimeSignals)();
const signals=[..._core.SIGNALS,...realtimeSignals].map(normalizeSignal);
return signals;
};exports.getSignals=getSignals;







const normalizeSignal=function({
name,
number:defaultNumber,
description,
action,
forced=false,
standard})
{
const{
signals:{[name]:constantSignal}}=
_os.constants;
const supported=constantSignal!==undefined;
const number=supported?constantSignal:defaultNumber;
return{name,number,description,supported,action,forced,standard};
};
//# sourceMappingURL=signals.js.map

/***/ }),

/***/ "./node_modules/is-stream/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-stream/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function';

module.exports = isStream;


/***/ }),

/***/ "./node_modules/isexe/index.js":
/*!*************************************!*\
  !*** ./node_modules/isexe/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(/*! ./windows.js */ "./node_modules/isexe/windows.js")
} else {
  core = __webpack_require__(/*! ./mode.js */ "./node_modules/isexe/mode.js")
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),

/***/ "./node_modules/isexe/mode.js":
/*!************************************!*\
  !*** ./node_modules/isexe/mode.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(/*! fs */ "fs")

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),

/***/ "./node_modules/isexe/windows.js":
/*!***************************************!*\
  !*** ./node_modules/isexe/windows.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(/*! fs */ "fs")

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/classes/comparator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/classes/comparator.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/macos-version/node_modules/semver/internal/parse-options.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/macos-version/node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/macos-version/node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/classes/range.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/classes/range.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/macos-version/node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/macos-version/node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/macos-version/node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(/*! ../internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/classes/semver.js":
/*!**************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/classes/semver.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/macos-version/node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/macos-version/node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/macos-version/node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/macos-version/node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/clean.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/clean.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/cmp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/cmp.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/macos-version/node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/macos-version/node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/macos-version/node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/macos-version/node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/macos-version/node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/macos-version/node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/coerce.js":
/*!****************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/coerce.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/compare-build.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/compare-build.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/compare-loose.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/compare-loose.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/compare.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/compare.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/diff.js":
/*!**************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/diff.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const eq = __webpack_require__(/*! ./eq */ "./node_modules/macos-version/node_modules/semver/functions/eq.js")

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/eq.js":
/*!************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/eq.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/gt.js":
/*!************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/gt.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/gte.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/gte.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/inc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/inc.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/lt.js":
/*!************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/lt.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/lte.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/lte.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/major.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/major.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/minor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/minor.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/neq.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/neq.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/parse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/parse.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { MAX_LENGTH } = __webpack_require__(/*! ../internal/constants */ "./node_modules/macos-version/node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")
const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/macos-version/node_modules/semver/internal/parse-options.js")
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/patch.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/patch.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/prerelease.js":
/*!********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/prerelease.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/rcompare.js":
/*!******************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/rcompare.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/rsort.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/rsort.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/macos-version/node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/satisfies.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/satisfies.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/sort.js":
/*!**************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/sort.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/macos-version/node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/functions/valid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/functions/valid.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/macos-version/node_modules/semver/internal/re.js")
const constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/macos-version/node_modules/semver/internal/constants.js")
const SemVer = __webpack_require__(/*! ./classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const identifiers = __webpack_require__(/*! ./internal/identifiers */ "./node_modules/macos-version/node_modules/semver/internal/identifiers.js")
const parse = __webpack_require__(/*! ./functions/parse */ "./node_modules/macos-version/node_modules/semver/functions/parse.js")
const valid = __webpack_require__(/*! ./functions/valid */ "./node_modules/macos-version/node_modules/semver/functions/valid.js")
const clean = __webpack_require__(/*! ./functions/clean */ "./node_modules/macos-version/node_modules/semver/functions/clean.js")
const inc = __webpack_require__(/*! ./functions/inc */ "./node_modules/macos-version/node_modules/semver/functions/inc.js")
const diff = __webpack_require__(/*! ./functions/diff */ "./node_modules/macos-version/node_modules/semver/functions/diff.js")
const major = __webpack_require__(/*! ./functions/major */ "./node_modules/macos-version/node_modules/semver/functions/major.js")
const minor = __webpack_require__(/*! ./functions/minor */ "./node_modules/macos-version/node_modules/semver/functions/minor.js")
const patch = __webpack_require__(/*! ./functions/patch */ "./node_modules/macos-version/node_modules/semver/functions/patch.js")
const prerelease = __webpack_require__(/*! ./functions/prerelease */ "./node_modules/macos-version/node_modules/semver/functions/prerelease.js")
const compare = __webpack_require__(/*! ./functions/compare */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
const rcompare = __webpack_require__(/*! ./functions/rcompare */ "./node_modules/macos-version/node_modules/semver/functions/rcompare.js")
const compareLoose = __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/macos-version/node_modules/semver/functions/compare-loose.js")
const compareBuild = __webpack_require__(/*! ./functions/compare-build */ "./node_modules/macos-version/node_modules/semver/functions/compare-build.js")
const sort = __webpack_require__(/*! ./functions/sort */ "./node_modules/macos-version/node_modules/semver/functions/sort.js")
const rsort = __webpack_require__(/*! ./functions/rsort */ "./node_modules/macos-version/node_modules/semver/functions/rsort.js")
const gt = __webpack_require__(/*! ./functions/gt */ "./node_modules/macos-version/node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ./functions/lt */ "./node_modules/macos-version/node_modules/semver/functions/lt.js")
const eq = __webpack_require__(/*! ./functions/eq */ "./node_modules/macos-version/node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./functions/neq */ "./node_modules/macos-version/node_modules/semver/functions/neq.js")
const gte = __webpack_require__(/*! ./functions/gte */ "./node_modules/macos-version/node_modules/semver/functions/gte.js")
const lte = __webpack_require__(/*! ./functions/lte */ "./node_modules/macos-version/node_modules/semver/functions/lte.js")
const cmp = __webpack_require__(/*! ./functions/cmp */ "./node_modules/macos-version/node_modules/semver/functions/cmp.js")
const coerce = __webpack_require__(/*! ./functions/coerce */ "./node_modules/macos-version/node_modules/semver/functions/coerce.js")
const Comparator = __webpack_require__(/*! ./classes/comparator */ "./node_modules/macos-version/node_modules/semver/classes/comparator.js")
const Range = __webpack_require__(/*! ./classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ./functions/satisfies */ "./node_modules/macos-version/node_modules/semver/functions/satisfies.js")
const toComparators = __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/macos-version/node_modules/semver/ranges/to-comparators.js")
const maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/macos-version/node_modules/semver/ranges/max-satisfying.js")
const minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/macos-version/node_modules/semver/ranges/min-satisfying.js")
const minVersion = __webpack_require__(/*! ./ranges/min-version */ "./node_modules/macos-version/node_modules/semver/ranges/min-version.js")
const validRange = __webpack_require__(/*! ./ranges/valid */ "./node_modules/macos-version/node_modules/semver/ranges/valid.js")
const outside = __webpack_require__(/*! ./ranges/outside */ "./node_modules/macos-version/node_modules/semver/ranges/outside.js")
const gtr = __webpack_require__(/*! ./ranges/gtr */ "./node_modules/macos-version/node_modules/semver/ranges/gtr.js")
const ltr = __webpack_require__(/*! ./ranges/ltr */ "./node_modules/macos-version/node_modules/semver/ranges/ltr.js")
const intersects = __webpack_require__(/*! ./ranges/intersects */ "./node_modules/macos-version/node_modules/semver/ranges/intersects.js")
const simplifyRange = __webpack_require__(/*! ./ranges/simplify */ "./node_modules/macos-version/node_modules/semver/ranges/simplify.js")
const subset = __webpack_require__(/*! ./ranges/subset */ "./node_modules/macos-version/node_modules/semver/ranges/subset.js")
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/internal/constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/internal/constants.js ***!
  \******************************************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH,
}


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/internal/debug.js":
/*!**************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/internal/debug.js ***!
  \**************************************************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/internal/identifiers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/internal/identifiers.js ***!
  \********************************************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/internal/parse-options.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/internal/parse-options.js ***!
  \**********************************************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((o, k) => {
    o[k] = true
    return o
  }, {})
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/internal/re.js":
/*!***********************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/internal/re.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ "./node_modules/macos-version/node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/macos-version/node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/gtr.js":
/*!**********************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/gtr.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/macos-version/node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/intersects.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/intersects.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/ltr.js":
/*!**********************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/ltr.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/macos-version/node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/max-satisfying.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/max-satisfying.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/min-satisfying.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/min-satisfying.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/min-version.js":
/*!******************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/min-version.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/macos-version/node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/outside.js":
/*!**************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/outside.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/macos-version/node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/macos-version/node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/macos-version/node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/macos-version/node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/macos-version/node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/macos-version/node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/macos-version/node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/simplify.js":
/*!***************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/simplify.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/macos-version/node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/subset.js":
/*!*************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/subset.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/macos-version/node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/macos-version/node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/macos-version/node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = [new Comparator('>=0.0.0-0')]
    } else {
      sub = [new Comparator('>=0.0.0')]
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = [new Comparator('>=0.0.0')]
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/to-comparators.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/to-comparators.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/macos-version/node_modules/semver/ranges/valid.js":
/*!************************************************************************!*\
  !*** ./node_modules/macos-version/node_modules/semver/ranges/valid.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/macos-version/node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/merge-stream/index.js":
/*!********************************************!*\
  !*** ./node_modules/merge-stream/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { PassThrough } = __webpack_require__(/*! stream */ "stream");

module.exports = function (/*streams...*/) {
  var sources = []
  var output  = new PassThrough({objectMode: true})

  output.setMaxListeners(0)

  output.add = add
  output.isEmpty = isEmpty

  output.on('unpipe', remove)

  Array.prototype.slice.call(arguments).forEach(add)

  return output

  function add (source) {
    if (Array.isArray(source)) {
      source.forEach(add)
      return this
    }

    sources.push(source);
    source.once('end', remove.bind(null, source))
    source.once('error', output.emit.bind(output, 'error'))
    source.pipe(output, {end: false})
    return this
  }

  function isEmpty () {
    return sources.length == 0;
  }

  function remove (source) {
    sources = sources.filter(function (it) { return it !== source })
    if (!sources.length && output.readable) { output.end() }
  }
}


/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/mimic-fn/index.js":
/*!****************************************!*\
  !*** ./node_modules/mimic-fn/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


const mimicFn = (to, from) => {
	for (const prop of Reflect.ownKeys(from)) {
		Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
	}

	return to;
};

module.exports = mimicFn;
// TODO: Remove this for the next major release
module.exports["default"] = mimicFn;


/***/ }),

/***/ "./node_modules/mount-point/index.js":
/*!*******************************************!*\
  !*** ./node_modules/mount-point/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var df = __webpack_require__(/*! @sindresorhus/df */ "./node_modules/mount-point/node_modules/@sindresorhus/df/index.js");
var pify = __webpack_require__(/*! pify */ "./node_modules/mount-point/node_modules/pify/index.js");
var Promise = __webpack_require__(/*! pinkie-promise */ "./node_modules/pinkie-promise/index.js");

module.exports = function (file) {
	return pify(df.file, Promise)(file).then(function (data) {
		return data.mountpoint;
	});
};


/***/ }),

/***/ "./node_modules/mount-point/node_modules/@sindresorhus/df/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mount-point/node_modules/@sindresorhus/df/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var childProcess = __webpack_require__(/*! child_process */ "child_process");

function run(args, cb) {
	childProcess.execFile('df', args, function (err, stdout) {
		if (err) {
			cb(err);
			return;
		}

		cb(null, stdout.trim().split('\n').slice(1).map(function (el) {
			var cl = el.split(/\s+(?=[\d\/])/);

			return {
				filesystem: cl[0],
				size: parseInt(cl[1], 10) * 1024,
				used: parseInt(cl[2], 10) * 1024,
				available: parseInt(cl[3], 10) * 1024,
				capacity: parseInt(cl[4], 10) / 100,
				mountpoint: cl[5]
			};
		}));
	});
};

var df = module.exports = function (cb) {
	run(['-kP'], cb);
};

df.fs = function (name, cb) {
	if (typeof name !== 'string') {
		throw new Error('name required');
	}

	run(['-kP'], function (err, data) {
		if (err) {
			cb(err);
			return;
		}

		var ret;

		data.forEach(function (el) {
			if (el.filesystem === name) {
				ret = el;
			}
		});

		cb(null, ret);
	});
};

df.file = function (file, cb) {
	if (typeof file !== 'string') {
		throw new Error('file required');
	}

	run(['-kP', file], function (err, data) {
		if (err) {
			cb(err);
			return;
		}

		cb(null, data[0]);
	});
};


/***/ }),

/***/ "./node_modules/mount-point/node_modules/pify/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/mount-point/node_modules/pify/index.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


var processFn = function (fn, P, opts) {
	return function () {
		var that = this;
		var args = new Array(arguments.length);

		for (var i = 0; i < arguments.length; i++) {
			args[i] = arguments[i];
		}

		return new P(function (resolve, reject) {
			args.push(function (err, result) {
				if (err) {
					reject(err);
				} else if (opts.multiArgs) {
					var results = new Array(arguments.length - 1);

					for (var i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});

			fn.apply(that, args);
		});
	};
};

var pify = module.exports = function (obj, P, opts) {
	if (typeof P !== 'function') {
		opts = P;
		P = Promise;
	}

	opts = opts || {};
	opts.exclude = opts.exclude || [/.+Sync$/];

	var filter = function (key) {
		var match = function (pattern) {
			return typeof pattern === 'string' ? key === pattern : pattern.test(key);
		};

		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	var ret = typeof obj === 'function' ? function () {
		if (opts.excludeMain) {
			return obj.apply(this, arguments);
		}

		return processFn(obj, P, opts).apply(this, arguments);
	} : {};

	return Object.keys(obj).reduce(function (ret, key) {
		var x = obj[key];

		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;

		return ret;
	}, ret);
};

pify.all = pify;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/npm-run-path/index.js":
/*!********************************************!*\
  !*** ./node_modules/npm-run-path/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const pathKey = __webpack_require__(/*! path-key */ "./node_modules/path-key/index.js");

const npmRunPath = options => {
	options = {
		cwd: process.cwd(),
		path: process.env[pathKey()],
		execPath: process.execPath,
		...options
	};

	let previous;
	let cwdPath = path.resolve(options.cwd);
	const result = [];

	while (previous !== cwdPath) {
		result.push(path.join(cwdPath, 'node_modules/.bin'));
		previous = cwdPath;
		cwdPath = path.resolve(cwdPath, '..');
	}

	// Ensure the running `node` binary is used
	const execPathDir = path.resolve(options.cwd, options.execPath, '..');
	result.push(execPathDir);

	return result.concat(options.path).join(path.delimiter);
};

module.exports = npmRunPath;
// TODO: Remove this for the next major release
module.exports["default"] = npmRunPath;

module.exports.env = options => {
	options = {
		env: process.env,
		...options
	};

	const env = {...options.env};
	const path = pathKey({env});

	options.path = env[path];
	env[path] = module.exports(options);

	return env;
};


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/onetime/index.js":
/*!***************************************!*\
  !*** ./node_modules/onetime/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const mimicFn = __webpack_require__(/*! mimic-fn */ "./node_modules/mimic-fn/index.js");

const calledFunctions = new WeakMap();

const onetime = (function_, options = {}) => {
	if (typeof function_ !== 'function') {
		throw new TypeError('Expected a function');
	}

	let returnValue;
	let callCount = 0;
	const functionName = function_.displayName || function_.name || '<anonymous>';

	const onetime = function (...arguments_) {
		calledFunctions.set(onetime, ++callCount);

		if (callCount === 1) {
			returnValue = function_.apply(this, arguments_);
			function_ = null;
		} else if (options.throw === true) {
			throw new Error(`Function \`${functionName}\` can only be called once`);
		}

		return returnValue;
	};

	mimicFn(onetime, function_);
	calledFunctions.set(onetime, callCount);

	return onetime;
};

module.exports = onetime;
// TODO: Remove this for the next major release
module.exports["default"] = onetime;

module.exports.callCount = function_ => {
	if (!calledFunctions.has(function_)) {
		throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
	}

	return calledFunctions.get(function_);
};


/***/ }),

/***/ "./node_modules/os-homedir/index.js":
/*!******************************************!*\
  !*** ./node_modules/os-homedir/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");

function homedir() {
	var env = process.env;
	var home = env.HOME;
	var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;

	if (process.platform === 'win32') {
		return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
	}

	if (process.platform === 'darwin') {
		return home || (user ? '/Users/' + user : null);
	}

	if (process.platform === 'linux') {
		return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
	}

	return home || null;
}

module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;


/***/ }),

/***/ "./node_modules/p-finally/index.js":
/*!*****************************************!*\
  !*** ./node_modules/p-finally/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


module.exports = async (
	promise,
	onFinally = (() => {})
) => {
	let value;
	try {
		value = await promise;
	} catch (error) {
		await onFinally();
		throw error;
	}

	await onFinally();
	return value;
};


/***/ }),

/***/ "./node_modules/path-key/index.js":
/*!****************************************!*\
  !*** ./node_modules/path-key/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


const pathKey = (options = {}) => {
	const environment = options.env || process.env;
	const platform = options.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports["default"] = pathKey;


/***/ }),

/***/ "./node_modules/pinkie-promise/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pinkie-promise/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = typeof Promise === 'function' ? Promise : __webpack_require__(/*! pinkie */ "./node_modules/pinkie/index.js");


/***/ }),

/***/ "./node_modules/pinkie/index.js":
/*!**************************************!*\
  !*** ./node_modules/pinkie/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var NOOP = function () {};
var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
	// run promise callbacks
	for (var i = 0; i < asyncQueue.length; i++) {
		asyncQueue[i][0](asyncQueue[i][1]);
	}

	// reset async asyncQueue
	asyncQueue = [];
	asyncTimer = false;
}

function asyncCall(callback, arg) {
	asyncQueue.push([callback, arg]);

	if (!asyncTimer) {
		asyncTimer = true;
		asyncSetTimer(asyncFlush, 0);
	}
}

function invokeResolver(resolver, promise) {
	function resolvePromise(value) {
		resolve(promise, value);
	}

	function rejectPromise(reason) {
		reject(promise, reason);
	}

	try {
		resolver(resolvePromise, rejectPromise);
	} catch (e) {
		rejectPromise(e);
	}
}

function invokeCallback(subscriber) {
	var owner = subscriber.owner;
	var settled = owner._state;
	var value = owner._data;
	var callback = subscriber[settled];
	var promise = subscriber.then;

	if (typeof callback === 'function') {
		settled = FULFILLED;
		try {
			value = callback(value);
		} catch (e) {
			reject(promise, e);
		}
	}

	if (!handleThenable(promise, value)) {
		if (settled === FULFILLED) {
			resolve(promise, value);
		}

		if (settled === REJECTED) {
			reject(promise, value);
		}
	}
}

function handleThenable(promise, value) {
	var resolved;

	try {
		if (promise === value) {
			throw new TypeError('A promises callback cannot return that same promise.');
		}

		if (value && (typeof value === 'function' || typeof value === 'object')) {
			// then should be retrieved only once
			var then = value.then;

			if (typeof then === 'function') {
				then.call(value, function (val) {
					if (!resolved) {
						resolved = true;

						if (value === val) {
							fulfill(promise, val);
						} else {
							resolve(promise, val);
						}
					}
				}, function (reason) {
					if (!resolved) {
						resolved = true;

						reject(promise, reason);
					}
				});

				return true;
			}
		}
	} catch (e) {
		if (!resolved) {
			reject(promise, e);
		}

		return true;
	}

	return false;
}

function resolve(promise, value) {
	if (promise === value || !handleThenable(promise, value)) {
		fulfill(promise, value);
	}
}

function fulfill(promise, value) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = value;

		asyncCall(publishFulfillment, promise);
	}
}

function reject(promise, reason) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = reason;

		asyncCall(publishRejection, promise);
	}
}

function publish(promise) {
	promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
	promise._state = FULFILLED;
	publish(promise);
}

function publishRejection(promise) {
	promise._state = REJECTED;
	publish(promise);
	if (!promise._handled && isNode) {
		global.process.emit('unhandledRejection', promise._data, promise);
	}
}

function notifyRejectionHandled(promise) {
	global.process.emit('rejectionHandled', promise);
}

/**
 * @class
 */
function Promise(resolver) {
	if (typeof resolver !== 'function') {
		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
	}

	if (this instanceof Promise === false) {
		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
	}

	this._then = [];

	invokeResolver(resolver, this);
}

Promise.prototype = {
	constructor: Promise,

	_state: PENDING,
	_then: null,
	_data: undefined,
	_handled: false,

	then: function (onFulfillment, onRejection) {
		var subscriber = {
			owner: this,
			then: new this.constructor(NOOP),
			fulfilled: onFulfillment,
			rejected: onRejection
		};

		if ((onRejection || onFulfillment) && !this._handled) {
			this._handled = true;
			if (this._state === REJECTED && isNode) {
				asyncCall(notifyRejectionHandled, this);
			}
		}

		if (this._state === FULFILLED || this._state === REJECTED) {
			// already resolved, call callback async
			asyncCall(invokeCallback, subscriber);
		} else {
			// subscribe
			this._then.push(subscriber);
		}

		return subscriber.then;
	},

	catch: function (onRejection) {
		return this.then(null, onRejection);
	}
};

Promise.all = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.all().');
	}

	return new Promise(function (resolve, reject) {
		var results = [];
		var remaining = 0;

		function resolver(index) {
			remaining++;
			return function (value) {
				results[index] = value;
				if (!--remaining) {
					resolve(results);
				}
			};
		}

		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolver(i), reject);
			} else {
				results[i] = promise;
			}
		}

		if (!remaining) {
			resolve(results);
		}
	});
};

Promise.race = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.race().');
	}

	return new Promise(function (resolve, reject) {
		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolve, reject);
			} else {
				resolve(promise);
			}
		}
	});
};

Promise.resolve = function (value) {
	if (value && typeof value === 'object' && value.constructor === Promise) {
		return value;
	}

	return new Promise(function (resolve) {
		resolve(value);
	});
};

Promise.reject = function (reason) {
	return new Promise(function (resolve, reject) {
		reject(reason);
	});
};

module.exports = Promise;


/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "./node_modules/once/once.js")
var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js")
var fs = __webpack_require__(/*! fs */ "fs") // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ "./node_modules/shebang-command/index.js":
/*!***********************************************!*\
  !*** ./node_modules/shebang-command/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const shebangRegex = __webpack_require__(/*! shebang-regex */ "./node_modules/shebang-regex/index.js");

module.exports = (string = '') => {
	const match = string.match(shebangRegex);

	if (!match) {
		return null;
	}

	const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
	const binary = path.split('/').pop();

	if (binary === 'env') {
		return argument;
	}

	return argument ? `${binary} ${argument}` : binary;
};


/***/ }),

/***/ "./node_modules/shebang-regex/index.js":
/*!*********************************************!*\
  !*** ./node_modules/shebang-regex/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";

module.exports = /^#!(.*)/;


/***/ }),

/***/ "./node_modules/signal-exit/index.js":
/*!*******************************************!*\
  !*** ./node_modules/signal-exit/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var process = global.process

const processOk = function (process) {
  return process &&
    typeof process === 'object' &&
    typeof process.removeListener === 'function' &&
    typeof process.emit === 'function' &&
    typeof process.reallyExit === 'function' &&
    typeof process.listeners === 'function' &&
    typeof process.kill === 'function' &&
    typeof process.pid === 'number' &&
    typeof process.on === 'function'
}

// some kind of non-node environment, just no-op
/* istanbul ignore if */
if (!processOk(process)) {
  module.exports = function () {
    return function () {}
  }
} else {
  var assert = __webpack_require__(/*! assert */ "assert")
  var signals = __webpack_require__(/*! ./signals.js */ "./node_modules/signal-exit/signals.js")
  var isWin = /^win/i.test(process.platform)

  var EE = __webpack_require__(/*! events */ "events")
  /* istanbul ignore if */
  if (typeof EE !== 'function') {
    EE = EE.EventEmitter
  }

  var emitter
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__
  } else {
    emitter = process.__signal_exit_emitter__ = new EE()
    emitter.count = 0
    emitter.emitted = {}
  }

  // Because this emitter is a global, we have to check to see if a
  // previous version of this library failed to enable infinite listeners.
  // I know what you're about to say.  But literally everything about
  // signal-exit is a compromise with evil.  Get used to it.
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity)
    emitter.infinite = true
  }

  module.exports = function (cb, opts) {
    /* istanbul ignore if */
    if (!processOk(global.process)) {
      return function () {}
    }
    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

    if (loaded === false) {
      load()
    }

    var ev = 'exit'
    if (opts && opts.alwaysLast) {
      ev = 'afterexit'
    }

    var remove = function () {
      emitter.removeListener(ev, cb)
      if (emitter.listeners('exit').length === 0 &&
          emitter.listeners('afterexit').length === 0) {
        unload()
      }
    }
    emitter.on(ev, cb)

    return remove
  }

  var unload = function unload () {
    if (!loaded || !processOk(global.process)) {
      return
    }
    loaded = false

    signals.forEach(function (sig) {
      try {
        process.removeListener(sig, sigListeners[sig])
      } catch (er) {}
    })
    process.emit = originalProcessEmit
    process.reallyExit = originalProcessReallyExit
    emitter.count -= 1
  }
  module.exports.unload = unload

  var emit = function emit (event, code, signal) {
    /* istanbul ignore if */
    if (emitter.emitted[event]) {
      return
    }
    emitter.emitted[event] = true
    emitter.emit(event, code, signal)
  }

  // { <signal>: <listener fn>, ... }
  var sigListeners = {}
  signals.forEach(function (sig) {
    sigListeners[sig] = function listener () {
      /* istanbul ignore if */
      if (!processOk(global.process)) {
        return
      }
      // If there are no other listeners, an exit is coming!
      // Simplest way: remove us and then re-send the signal.
      // We know that this will kill the process, so we can
      // safely emit now.
      var listeners = process.listeners(sig)
      if (listeners.length === emitter.count) {
        unload()
        emit('exit', null, sig)
        /* istanbul ignore next */
        emit('afterexit', null, sig)
        /* istanbul ignore next */
        if (isWin && sig === 'SIGHUP') {
          // "SIGHUP" throws an `ENOSYS` error on Windows,
          // so use a supported signal instead
          sig = 'SIGINT'
        }
        /* istanbul ignore next */
        process.kill(process.pid, sig)
      }
    }
  })

  module.exports.signals = function () {
    return signals
  }

  var loaded = false

  var load = function load () {
    if (loaded || !processOk(global.process)) {
      return
    }
    loaded = true

    // This is the number of onSignalExit's that are in play.
    // It's important so that we can count the correct number of
    // listeners on signals, and don't wait for the other one to
    // handle it instead of us.
    emitter.count += 1

    signals = signals.filter(function (sig) {
      try {
        process.on(sig, sigListeners[sig])
        return true
      } catch (er) {
        return false
      }
    })

    process.emit = processEmit
    process.reallyExit = processReallyExit
  }
  module.exports.load = load

  var originalProcessReallyExit = process.reallyExit
  var processReallyExit = function processReallyExit (code) {
    /* istanbul ignore if */
    if (!processOk(global.process)) {
      return
    }
    process.exitCode = code || /* istanbul ignore next */ 0
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    /* istanbul ignore next */
    originalProcessReallyExit.call(process, process.exitCode)
  }

  var originalProcessEmit = process.emit
  var processEmit = function processEmit (ev, arg) {
    if (ev === 'exit' && processOk(global.process)) {
      /* istanbul ignore else */
      if (arg !== undefined) {
        process.exitCode = arg
      }
      var ret = originalProcessEmit.apply(this, arguments)
      /* istanbul ignore next */
      emit('exit', process.exitCode, null)
      /* istanbul ignore next */
      emit('afterexit', process.exitCode, null)
      /* istanbul ignore next */
      return ret
    } else {
      return originalProcessEmit.apply(this, arguments)
    }
  }
}


/***/ }),

/***/ "./node_modules/signal-exit/signals.js":
/*!*********************************************!*\
  !*** ./node_modules/signal-exit/signals.js ***!
  \*********************************************/
/***/ ((module) => {

// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
]

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  )
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  )
}


/***/ }),

/***/ "./node_modules/strip-final-newline/index.js":
/*!***************************************************!*\
  !*** ./node_modules/strip-final-newline/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = input => {
	const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
	const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();

	if (input[input.length - 1] === LF) {
		input = input.slice(0, input.length - 1);
	}

	if (input[input.length - 1] === CR) {
		input = input.slice(0, input.length - 1);
	}

	return input;
};


/***/ }),

/***/ "./node_modules/strnum/strnum.js":
/*!***************************************!*\
  !*** ./node_modules/strnum/strnum.js ***!
  \***************************************/
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ "./node_modules/sudo-prompt/index.js":
/*!*******************************************!*\
  !*** ./node_modules/sudo-prompt/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Node = {
  child: __webpack_require__(/*! child_process */ "child_process"),
  crypto: __webpack_require__(/*! crypto */ "crypto"),
  fs: __webpack_require__(/*! fs */ "fs"),
  os: __webpack_require__(/*! os */ "os"),
  path: __webpack_require__(/*! path */ "path"),
  process: process,
  util: __webpack_require__(/*! util */ "util")
};

function Attempt(instance, end) {
  var platform = Node.process.platform;
  if (platform === 'darwin') return Mac(instance, end);
  if (platform === 'linux') return Linux(instance, end);
  if (platform === 'win32') return Windows(instance, end);
  end(new Error('Platform not yet supported.'));
}

function EscapeDoubleQuotes(string) {
  if (typeof string !== 'string') throw new Error('Expected a string.');
  return string.replace(/"/g, '\\"');
}

function Exec() {
  if (arguments.length < 1 || arguments.length > 3) {
    throw new Error('Wrong number of arguments.');
  }
  var command = arguments[0];
  var options = {};
  var end = function() {};
  if (typeof command !== 'string') {
    throw new Error('Command should be a string.');
  }
  if (arguments.length === 2) {
    if (Node.util.isObject(arguments[1])) {
      options = arguments[1];
    } else if (Node.util.isFunction(arguments[1])) {
      end = arguments[1];
    } else {
      throw new Error('Expected options or callback.');
    }
  } else if (arguments.length === 3) {
    if (Node.util.isObject(arguments[1])) {
      options = arguments[1];
    } else {
      throw new Error('Expected options to be an object.');
    }
    if (Node.util.isFunction(arguments[2])) {
      end = arguments[2];
    } else {
      throw new Error('Expected callback to be a function.');
    }
  }
  if (/^sudo/i.test(command)) {
    return end(new Error('Command should not be prefixed with "sudo".'));
  }
  if (typeof options.name === 'undefined') {
    var title = Node.process.title;
    if (ValidName(title)) {
      options.name = title;
    } else {
      return end(new Error('process.title cannot be used as a valid name.'));
    }
  } else if (!ValidName(options.name)) {
    var error = '';
    error += 'options.name must be alphanumeric only ';
    error += '(spaces are allowed) and <= 70 characters.';
    return end(new Error(error));
  }
  if (typeof options.icns !== 'undefined') {
    if (typeof options.icns !== 'string') {
      return end(new Error('options.icns must be a string if provided.'));
    } else if (options.icns.trim().length === 0) {
      return end(new Error('options.icns must not be empty if provided.'));
    }
  }
  if (typeof options.env !== 'undefined') {
    if (typeof options.env !== 'object') {
      return end(new Error('options.env must be an object if provided.'));
    } else if (Object.keys(options.env).length === 0) {
      return end(new Error('options.env must not be empty if provided.'));
    } else {
      for (var key in options.env) {
        var value = options.env[key];
        if (typeof key !== 'string' || typeof value !== 'string') {
          return end(
            new Error('options.env environment variables must be strings.')
          );
        }
        // "Environment variable names used by the utilities in the Shell and
        // Utilities volume of IEEE Std 1003.1-2001 consist solely of uppercase
        // letters, digits, and the '_' (underscore) from the characters defined
        // in Portable Character Set and do not begin with a digit. Other
        // characters may be permitted by an implementation; applications shall
        // tolerate the presence of such names."
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
          return end(
            new Error(
              'options.env has an invalid environment variable name: ' +
              JSON.stringify(key)
            )
          );
        }
        if (/[\r\n]/.test(value)) {
          return end(
            new Error(
              'options.env has an invalid environment variable value: ' +
              JSON.stringify(value)
            )
          );
        }
      }
    }
  }
  var platform = Node.process.platform;
  if (platform !== 'darwin' && platform !== 'linux' && platform !== 'win32') {
    return end(new Error('Platform not yet supported.'));
  }
  var instance = {
    command: command,
    options: options,
    uuid: undefined,
    path: undefined
  };
  Attempt(instance, end);
}

function Linux(instance, end) {
  LinuxBinary(instance,
    function(error, binary) {
      if (error) return end(error);
      var command = [];
      // Preserve current working directory:
      command.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '";');
      // Export environment variables:
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        command.push('export ' + key + '="' + EscapeDoubleQuotes(value) + '";');
      }
      command.push('"' + EscapeDoubleQuotes(binary) + '"');
      if (/kdesudo/i.test(binary)) {
        command.push(
          '--comment',
          '"' + instance.options.name + ' wants to make changes. ' +
          'Enter your password to allow this."'
        );
        command.push('-d'); // Do not show the command to be run in the dialog.
        command.push('--');
      } else if (/pkexec/i.test(binary)) {
        command.push('--disable-internal-agent');
      }
      var magic = 'SUDOPROMPT\n';
      command.push(
        '/bin/bash -c "echo ' + EscapeDoubleQuotes(magic.trim()) + '; ' +
        EscapeDoubleQuotes(instance.command) +
        '"'
      );
      command = command.join(' ');
      Node.child.exec(command, { encoding: 'utf-8', maxBuffer: MAX_BUFFER },
        function(error, stdout, stderr) {
          // ISSUE 88:
          // We must distinguish between elevation errors and command errors.
          //
          // KDESUDO:
          // kdesudo provides no way to do this. We add a magic marker to know
          // if elevation succeeded. Any error thereafter is a command error.
          //
          // PKEXEC:
          // "Upon successful completion, the return value is the return value of
          // PROGRAM. If the calling process is not authorized or an
          // authorization could not be obtained through authentication or an
          // error occured, pkexec exits with a return value of 127. If the
          // authorization could not be obtained because the user dismissed the
          // authentication dialog, pkexec exits with a return value of 126."
          //
          // However, we do not rely on pkexec's return of 127 since our magic
          // marker is more reliable, and we already use it for kdesudo.
          var elevated = stdout && stdout.slice(0, magic.length) === magic;
          if (elevated) stdout = stdout.slice(magic.length);
          // Only normalize the error if it is definitely not a command error:
          // In other words, if we know that the command was never elevated.
          // We do not inspect error messages beyond NO_POLKIT_AGENT.
          // We cannot rely on English errors because of internationalization.
          if (error && !elevated) {
            if (/No authentication agent found/.test(stderr)) {
              error.message = NO_POLKIT_AGENT;
            } else {
              error.message = PERMISSION_DENIED;
            }
          }
          end(error, stdout, stderr);
        }
      );
    }
  );
}

function LinuxBinary(instance, end) {
  var index = 0;
  // We used to prefer gksudo over pkexec since it enabled a better prompt.
  // However, gksudo cannot run multiple commands concurrently.
  var paths = ['/usr/bin/kdesudo', '/usr/bin/pkexec'];
  function test() {
    if (index === paths.length) {
      return end(new Error('Unable to find pkexec or kdesudo.'));
    }
    var path = paths[index++];
    Node.fs.stat(path,
      function(error) {
        if (error) {
          if (error.code === 'ENOTDIR') return test();
          if (error.code === 'ENOENT') return test();
          end(error);
        } else {
          end(undefined, path);
        }
      }
    );
  }
  test();
}

function Mac(instance, callback) {
  var temp = Node.os.tmpdir();
  if (!temp) return callback(new Error('os.tmpdir() not defined.'));
  var user = Node.process.env.USER; // Applet shell scripts require $USER.
  if (!user) return callback(new Error('env[\'USER\'] not defined.'));
  UUID(instance,
    function(error, uuid) {
      if (error) return callback(error);
      instance.uuid = uuid;
      instance.path = Node.path.join(
        temp,
        instance.uuid,
        instance.options.name + '.app'
      );
      function end(error, stdout, stderr) {
        Remove(Node.path.dirname(instance.path),
          function(errorRemove) {
            if (error) return callback(error);
            if (errorRemove) return callback(errorRemove);
            callback(undefined, stdout, stderr);
          }
        );
      }
      MacApplet(instance,
        function(error, stdout, stderr) {
          if (error) return end(error, stdout, stderr);
          MacIcon(instance,
            function(error) {
              if (error) return end(error);
              MacPropertyList(instance,
                function(error, stdout, stderr) {
                  if (error) return end(error, stdout, stderr);
                  MacCommand(instance,
                    function(error) {
                      if (error) return end(error);
                      MacOpen(instance,
                        function(error, stdout, stderr) {
                          if (error) return end(error, stdout, stderr);
                          MacResult(instance, end);
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

function MacApplet(instance, end) {
  var parent = Node.path.dirname(instance.path);
  Node.fs.mkdir(parent,
    function(error) {
      if (error) return end(error);
      var zip = Node.path.join(parent, 'sudo-prompt-applet.zip');
      Node.fs.writeFile(zip, APPLET, 'base64',
        function(error) {
          if (error) return end(error);
          var command = [];
          command.push('/usr/bin/unzip');
          command.push('-o'); // Overwrite any existing applet.
          command.push('"' + EscapeDoubleQuotes(zip) + '"');
          command.push('-d "' + EscapeDoubleQuotes(instance.path) + '"');
          command = command.join(' ');
          Node.child.exec(command, { encoding: 'utf-8' }, end);
        }
      );
    }
  );
}

function MacCommand(instance, end) {
  var path = Node.path.join(
    instance.path,
    'Contents',
    'MacOS',
    'sudo-prompt-command'
  );
  var script = [];
  // Preserve current working directory:
  // We do this for commands that rely on relative paths.
  // This runs in a subshell and will not change the cwd of sudo-prompt-script.
  script.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '"');
  // Export environment variables:
  for (var key in instance.options.env) {
    var value = instance.options.env[key];
    script.push('export ' + key + '="' + EscapeDoubleQuotes(value) + '"');
  }
  script.push(instance.command);
  script = script.join('\n');
  Node.fs.writeFile(path, script, 'utf-8', end);
}

function MacIcon(instance, end) {
  if (!instance.options.icns) return end();
  Node.fs.readFile(instance.options.icns,
    function(error, buffer) {
      if (error) return end(error);
      var icns = Node.path.join(
        instance.path,
        'Contents',
        'Resources',
        'applet.icns'
      );
      Node.fs.writeFile(icns, buffer, end);
    }
  );
}

function MacOpen(instance, end) {
  // We must run the binary directly so that the cwd will apply.
  var binary = Node.path.join(instance.path, 'Contents', 'MacOS', 'applet');
  // We must set the cwd so that the AppleScript can find the shell scripts.
  var options = {
    cwd: Node.path.dirname(binary),
    encoding: 'utf-8'
  };
  // We use the relative path rather than the absolute path. The instance.path
  // may contain spaces which the cwd can handle, but which exec() cannot.
  Node.child.exec('./' + Node.path.basename(binary), options, end);
}

function MacPropertyList(instance, end) {
  // Value must be in single quotes (not double quotes) according to man entry.
  // e.g. defaults write com.companyname.appname "Default Color" '(255, 0, 0)'
  // The defaults command will be changed in an upcoming major release to only
  // operate on preferences domains. General plist manipulation utilities will
  // be folded into a different command-line program.
  var plist = Node.path.join(instance.path, 'Contents', 'Info.plist');
  var path = EscapeDoubleQuotes(plist);
  var key = EscapeDoubleQuotes('CFBundleName');
  var value = instance.options.name + ' Password Prompt';
  if (/'/.test(value)) {
    return end(new Error('Value should not contain single quotes.'));
  }
  var command = [];
  command.push('/usr/bin/defaults');
  command.push('write');
  command.push('"' + path + '"');
  command.push('"' + key + '"');
  command.push("'" + value + "'"); // We must use single quotes for value.
  command = command.join(' ');
  Node.child.exec(command, { encoding: 'utf-8' }, end);
}

function MacResult(instance, end) {
  var cwd = Node.path.join(instance.path, 'Contents', 'MacOS');
  Node.fs.readFile(Node.path.join(cwd, 'code'), 'utf-8',
    function(error, code) {
      if (error) {
        if (error.code === 'ENOENT') return end(new Error(PERMISSION_DENIED));
        end(error);
      } else {
        Node.fs.readFile(Node.path.join(cwd, 'stdout'), 'utf-8',
          function(error, stdout) {
            if (error) return end(error);
            Node.fs.readFile(Node.path.join(cwd, 'stderr'), 'utf-8',
              function(error, stderr) {
                if (error) return end(error);
                code = parseInt(code.trim(), 10); // Includes trailing newline.
                if (code === 0) {
                  end(undefined, stdout, stderr);
                } else {
                  error = new Error(
                    'Command failed: ' + instance.command + '\n' + stderr
                  );
                  error.code = code;
                  end(error, stdout, stderr);
                }
              }
            );
          }
        );
      }
    }
  );
}

function Remove(path, end) {
  if (typeof path !== 'string' || !path.trim()) {
    return end(new Error('Argument path not defined.'));
  }
  var command = [];
  if (Node.process.platform === 'win32') {
    if (/"/.test(path)) {
      return end(new Error('Argument path cannot contain double-quotes.'));
    }
    command.push('rmdir /s /q "' + path + '"');
  } else {
    command.push('/bin/rm');
    command.push('-rf');
    command.push('"' + EscapeDoubleQuotes(Node.path.normalize(path)) + '"');
  }
  command = command.join(' ');
  Node.child.exec(command, { encoding: 'utf-8' }, end);
}

function UUID(instance, end) {
  Node.crypto.randomBytes(256,
    function(error, random) {
      if (error) random = Date.now() + '' + Math.random();
      var hash = Node.crypto.createHash('SHA256');
      hash.update('sudo-prompt-3');
      hash.update(instance.options.name);
      hash.update(instance.command);
      hash.update(random);
      var uuid = hash.digest('hex').slice(-32);
      if (!uuid || typeof uuid !== 'string' || uuid.length !== 32) {
        // This is critical to ensure we don't remove the wrong temp directory.
        return end(new Error('Expected a valid UUID.'));
      }
      end(undefined, uuid);
    }
  );
}

function ValidName(string) {
  // We use 70 characters as a limit to side-step any issues with Unicode
  // normalization form causing a 255 character string to exceed the fs limit.
  if (!/^[a-z0-9 ]+$/i.test(string)) return false;
  if (string.trim().length === 0) return false;
  if (string.length > 70) return false;
  return true;
}

function Windows(instance, callback) {
  var temp = Node.os.tmpdir();
  if (!temp) return callback(new Error('os.tmpdir() not defined.'));
  UUID(instance,
    function(error, uuid) {
      if (error) return callback(error);
      instance.uuid = uuid;
      instance.path = Node.path.join(temp, instance.uuid);
      if (/"/.test(instance.path)) {
        // We expect double quotes to be reserved on Windows.
        // Even so, we test for this and abort if they are present.
        return callback(
          new Error('instance.path cannot contain double-quotes.')
        );
      }
      instance.pathElevate = Node.path.join(instance.path, 'elevate.vbs');
      instance.pathExecute = Node.path.join(instance.path, 'execute.bat');
      instance.pathCommand = Node.path.join(instance.path, 'command.bat');
      instance.pathStdout = Node.path.join(instance.path, 'stdout');
      instance.pathStderr = Node.path.join(instance.path, 'stderr');
      instance.pathStatus = Node.path.join(instance.path, 'status');
      Node.fs.mkdir(instance.path,
        function(error) {
          if (error) return callback(error);
          function end(error, stdout, stderr) {
            Remove(instance.path,
              function(errorRemove) {
                if (error) return callback(error);
                if (errorRemove) return callback(errorRemove);
                callback(undefined, stdout, stderr);
              }
            );
          }
          WindowsWriteExecuteScript(instance,
            function(error) {
              if (error) return end(error);
              WindowsWriteCommandScript(instance,
                function(error) {
                  if (error) return end(error);
                  WindowsElevate(instance,
                    function(error, stdout, stderr) {
                      if (error) return end(error, stdout, stderr);
                      WindowsWaitForStatus(instance,
                        function(error) {
                          if (error) return end(error);
                          WindowsResult(instance, end);
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

function WindowsElevate(instance, end) {
  // We used to use this for executing elevate.vbs:
  // var command = 'cscript.exe //NoLogo "' + instance.pathElevate + '"';
  var command = [];
  command.push('powershell.exe');
  command.push('Start-Process');
  command.push('-FilePath');
  // Escape characters for cmd using double quotes:
  // Escape characters for PowerShell using single quotes:
  // Escape single quotes for PowerShell using backtick:
  // See: https://ss64.com/ps/syntax-esc.html
  command.push('"\'' + instance.pathExecute.replace(/'/g, "`'") + '\'"');
  command.push('-WindowStyle hidden');
  command.push('-Verb runAs');
  command = command.join(' ');
  var child = Node.child.exec(command, { encoding: 'utf-8' },
    function(error, stdout, stderr) {
      // We used to return PERMISSION_DENIED only for error messages containing
      // the string 'canceled by the user'. However, Windows internationalizes
      // error messages (issue 96) so now we must assume all errors here are
      // permission errors. This seems reasonable, given that we already run the
      // user's command in a subshell.
      if (error) return end(new Error(PERMISSION_DENIED), stdout, stderr);
      end();
    }
  );
  child.stdin.end(); // Otherwise PowerShell waits indefinitely on Windows 7.
}

function WindowsResult(instance, end) {
  Node.fs.readFile(instance.pathStatus, 'utf-8',
    function(error, code) {
      if (error) return end(error);
      Node.fs.readFile(instance.pathStdout, 'utf-8',
        function(error, stdout) {
          if (error) return end(error);
          Node.fs.readFile(instance.pathStderr, 'utf-8',
            function(error, stderr) {
              if (error) return end(error);
              code = parseInt(code.trim(), 10);
              if (code === 0) {
                end(undefined, stdout, stderr);
              } else {
                error = new Error(
                  'Command failed: ' + instance.command + '\r\n' + stderr
                );
                error.code = code;
                end(error, stdout, stderr);
              }
            }
          );
        }
      );
    }
  );
}

function WindowsWaitForStatus(instance, end) {
  // VBScript cannot wait for the elevated process to finish so we have to poll.
  // VBScript cannot return error code if user does not grant permission.
  // PowerShell can be used to elevate and wait on Windows 10.
  // PowerShell can be used to elevate on Windows 7 but it cannot wait.
  // powershell.exe Start-Process cmd.exe -Verb runAs -Wait
  Node.fs.stat(instance.pathStatus,
    function(error, stats) {
      if ((error && error.code === 'ENOENT') || stats.size < 2) {
        // Retry if file does not exist or is not finished writing.
        // We expect a file size of 2. That should cover at least "0\r".
        // We use a 1 second timeout to keep a light footprint for long-lived
        // sudo-prompt processes.
        setTimeout(
          function() {
            // If administrator has no password and user clicks Yes, then
            // PowerShell returns no error and execute (and command) never runs.
            // We check that command output has been redirected to stdout file:
            Node.fs.stat(instance.pathStdout,
              function(error) {
                if (error) return end(new Error(PERMISSION_DENIED));
                WindowsWaitForStatus(instance, end);
              }
            );
          },
          1000
        );
      } else if (error) {
        end(error);
      } else {
        end();
      }
    }
  );
}

function WindowsWriteCommandScript(instance, end) {
  var cwd = Node.process.cwd();
  if (/"/.test(cwd)) {
    // We expect double quotes to be reserved on Windows.
    // Even so, we test for this and abort if they are present.
    return end(new Error('process.cwd() cannot contain double-quotes.'));
  }
  var script = [];
  script.push('@echo off');
  // Set code page to UTF-8:
  script.push('chcp 65001>nul');
  // Preserve current working directory:
  // We pass /d as an option in case the cwd is on another drive (issue 70).
  script.push('cd /d "' + cwd + '"');
  // Export environment variables:
  for (var key in instance.options.env) {
    // "The characters <, >, |, &, ^ are special command shell characters, and
    // they must be preceded by the escape character (^) or enclosed in
    // quotation marks. If you use quotation marks to enclose a string that
    // contains one of the special characters, the quotation marks are set as
    // part of the environment variable value."
    // In other words, Windows assigns everything that follows the equals sign
    // to the value of the variable, whereas Unix systems ignore double quotes.
    var value = instance.options.env[key];
    script.push('set ' + key + '=' + value.replace(/([<>\\|&^])/g, '^$1'));
  }
  script.push(instance.command);
  script = script.join('\r\n');
  Node.fs.writeFile(instance.pathCommand, script, 'utf-8', end);
}

function WindowsWriteElevateScript(instance, end) {
  // We do not use VBScript to elevate since it does not return an error if
  // the user does not grant permission. This is here for reference.
  // var script = [];
  // script.push('Set objShell = CreateObject("Shell.Application")');
  // script.push(
  // 'objShell.ShellExecute "' + instance.pathExecute + '", "", "", "runas", 0'
  // );
  // script = script.join('\r\n');
  // Node.fs.writeFile(instance.pathElevate, script, 'utf-8', end);
}

function WindowsWriteExecuteScript(instance, end) {
  var script = [];
  script.push('@echo off');
  script.push(
    'call "' + instance.pathCommand + '"' +
    ' > "' + instance.pathStdout + '" 2> "' + instance.pathStderr + '"'
  );
  script.push('(echo %ERRORLEVEL%) > "' + instance.pathStatus + '"');
  script = script.join('\r\n');
  Node.fs.writeFile(instance.pathExecute, script, 'utf-8', end);
}

module.exports.exec = Exec;

// We used to expect that applet.app would be included with this module.
// This could not be copied when sudo-prompt was packaged within an asar file.
// We now store applet.app as a zip file in base64 within index.js instead.
// To recreate: "zip -r ../applet.zip Contents" (with applet.app as CWD).
// The zip file must not include applet.app as the root directory so that we
// can extract it directly to the target app directory.
var APPLET = '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';

var PERMISSION_DENIED = 'User did not grant permission.';
var NO_POLKIT_AGENT = 'No polkit authentication agent found.';

// See issue 66:
var MAX_BUFFER = 134217728;


/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./src/common/SettingsItems.ts":
/*!*************************************!*\
  !*** ./src/common/SettingsItems.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultValues": () => (/* binding */ DefaultValues)
/* harmony export */ });
const DefaultValues = {
    enableColorPicker: true,
    enableMediaControls: true,
    enableRunOnLogin: true,
    enableClipboardSync: false,
    azureStorageAccount: "",
    azureSASToken: "",
    azureTableName: "",
};


/***/ }),

/***/ "./src/common/utils.ts":
/*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESOURCES_PATH": () => (/* binding */ RESOURCES_PATH),
/* harmony export */   "dirSize": () => (/* binding */ dirSize),
/* harmony export */   "getAssetPath": () => (/* binding */ getAssetPath),
/* harmony export */   "handleCommand": () => (/* binding */ handleCommand),
/* harmony export */   "resolveHtmlPath": () => (/* binding */ resolveHtmlPath)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);




const dirSize = (directory) => {
    const files = fs__WEBPACK_IMPORTED_MODULE_2___default().readdirSync(directory);
    return files.reduce((accumulator, file) => {
        const stats = fs__WEBPACK_IMPORTED_MODULE_2___default().statSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(directory, file));
        return stats.isFile()
            ? accumulator + stats.size
            : accumulator + dirSize(path__WEBPACK_IMPORTED_MODULE_1___default().join(directory, file));
    }, 0);
};
const handleCommand = (command, args) => new Promise((res, rej) => {
    const proc = child_process__WEBPACK_IMPORTED_MODULE_0___default().spawn(command, args);
    let buffer = [];
    proc.stdout.on("data", (data) => {
        buffer.push(data);
    });
    proc.on("close", () => {
        const finalStdout = buffer.join("");
        res(finalStdout);
    });
});
const resolveHtmlPath = (htmlFileName, search = "") => {
    if (true) {
        console.log("INDEVV");
        const port = process.env.PORT || 1212;
        const url = new URL(`http://localhost:${port}`);
        url.pathname = htmlFileName;
        url.search = search;
        return url.href;
    }
    console.log("NONDEVV");
    return `file://${path__WEBPACK_IMPORTED_MODULE_1___default().resolve(__dirname, '../renderer/', htmlFileName)}${search}`;
};
const RESOURCES_PATH = electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged
    ? path__WEBPACK_IMPORTED_MODULE_1___default().join(process.resourcesPath, 'assets')
    : path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, '../../assets');
const getAssetPath = (...paths) => {
    return path__WEBPACK_IMPORTED_MODULE_1___default().join(RESOURCES_PATH, ...paths);
};


/***/ }),

/***/ "./src/main/bootstrap.ts":
/*!*******************************!*\
  !*** ./src/main/bootstrap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var robotjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! robotjs */ "robotjs");
/* harmony import */ var robotjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(robotjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings */ "./src/main/settings.ts");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clipboard */ "./src/main/clipboard.ts");
/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./login */ "./src/main/login.ts");
/* harmony import */ var _messageHandlers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./messageHandlers */ "./src/main/messageHandlers.ts");
/* harmony import */ var _trays__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./trays */ "./src/main/trays.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");









let ignoreSingleCopy = false;
const startListeningToClipboard = () => {
    const tableClient = (0,_clipboard__WEBPACK_IMPORTED_MODULE_4__.getTableClient)();
    (0,_clipboard__WEBPACK_IMPORTED_MODULE_4__.startClipboardListener)(async () => {
        if (electron__WEBPACK_IMPORTED_MODULE_3__.clipboard.availableFormats().includes("text/plain")) {
            if (ignoreSingleCopy) {
                ignoreSingleCopy = false;
                return;
            }
            const text = electron__WEBPACK_IMPORTED_MODULE_3__.clipboard.readText();
            if (text.replace("\r", "").replace(" ", "").replace("\n", "").length > 0) {
                await tableClient.createEntity({
                    partitionKey: "pc",
                    rowKey: Date.now().toString(),
                    text: electron__WEBPACK_IMPORTED_MODULE_3__.clipboard.readText()
                });
                mainWindow?.webContents.send('clipboard:change');
            }
        }
    });
};
const stopListeningToClibpoard = () => {
    (0,_clipboard__WEBPACK_IMPORTED_MODULE_4__.stopClipboardListener)();
};
// enable clipboard listener, then register to settings change
if ((0,_settings__WEBPACK_IMPORTED_MODULE_2__.getSettingValue)("enableClipboardSync"))
    startListeningToClipboard();
_settings__WEBPACK_IMPORTED_MODULE_2__.settingsChangeEmitter.on("enableClipboardSync", (value) => {
    if (value)
        startListeningToClipboard();
    else
        stopListeningToClibpoard();
});
// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
/** @type BrowserWindow */
let mainWindow;
/** @type BrowserWindow */
let clipboardWindow;
let windowsByWebcontentsId = {};
const colorPickerKeyCombo = 'super+control+x';
const registerColorPicker = () => {
    electron__WEBPACK_IMPORTED_MODULE_3__.globalShortcut.register(colorPickerKeyCombo, () => {
        try {
            const { x, y } = robotjs__WEBPACK_IMPORTED_MODULE_1___default().getMousePos();
            electron__WEBPACK_IMPORTED_MODULE_3__.clipboard.writeText(robotjs__WEBPACK_IMPORTED_MODULE_1___default().getPixelColor(x, y));
        }
        catch (e) { }
    });
};
const unregisterColorPicker = () => {
    electron__WEBPACK_IMPORTED_MODULE_3__.globalShortcut.unregister(colorPickerKeyCombo);
};
const createClipboardWindow = () => {
    const cursorPoint = electron__WEBPACK_IMPORTED_MODULE_3__.screen.getCursorScreenPoint();
    clipboardWindow = new electron__WEBPACK_IMPORTED_MODULE_3__.BrowserWindow({
        show: false,
        skipTaskbar: true,
        width: 400,
        height: 400,
        resizable: false,
        backgroundColor: electron__WEBPACK_IMPORTED_MODULE_3__.nativeTheme.shouldUseDarkColors ? "#1a1b1e" : undefined,
        titleBarStyle: "hidden",
        x: cursorPoint.x,
        y: cursorPoint.y,
        webPreferences: {
            preload: path__WEBPACK_IMPORTED_MODULE_0___default().join(__dirname, 'preload.js'),
            devTools: !electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged,
            webSecurity: false
        }
    });
    windowsByWebcontentsId[clipboardWindow.webContents.id] = clipboardWindow;
    clipboardWindow.removeMenu();
    clipboardWindow.loadURL((0,_common_utils__WEBPACK_IMPORTED_MODULE_8__.resolveHtmlPath)('index.html', "?page=clipboard"));
    clipboardWindow.on("blur", () => {
        clipboardWindow.close();
    });
    clipboardWindow.on('close', () => {
        delete windowsByWebcontentsId[clipboardWindow.webContents.id];
        clipboardWindow = null;
    });
};
const showOrCreateMainWindow = () => {
    if (mainWindow) {
        mainWindow.focus();
    }
    else {
        createMainWindow();
    }
};
const createMainWindow = () => {
    console.log("PROVA DEL NOVE\n\n\n\n\UO");
    // Create the browser window.
    mainWindow = new electron__WEBPACK_IMPORTED_MODULE_3__.BrowserWindow({
        show: false,
        width: 800,
        height: 600,
        minHeight: 400,
        minWidth: 600,
        backgroundColor: electron__WEBPACK_IMPORTED_MODULE_3__.nativeTheme.shouldUseDarkColors ? "#1a1b1e" : undefined,
        titleBarStyle: "hidden",
        titleBarOverlay: {
            color: electron__WEBPACK_IMPORTED_MODULE_3__.nativeTheme.shouldUseDarkColors ? "#1a1b1e" : undefined,
            symbolColor: electron__WEBPACK_IMPORTED_MODULE_3__.nativeTheme.shouldUseDarkColors ? "white" : undefined,
            height: 40
        },
        webPreferences: {
            preload: path__WEBPACK_IMPORTED_MODULE_0___default().join(__dirname, 'preload.js'),
            devTools: !electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged,
            webSecurity: false,
            sandbox: true,
        }
    });
    windowsByWebcontentsId[mainWindow.webContents.id] = mainWindow;
    mainWindow.removeMenu();
    // Open the DevTools.
    mainWindow.loadURL((0,_common_utils__WEBPACK_IMPORTED_MODULE_8__.resolveHtmlPath)('index.html'));
    if (!electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged)
        mainWindow.webContents.openDevTools();
    mainWindow.on('close', () => {
        delete windowsByWebcontentsId[mainWindow.webContents.id];
        mainWindow = null;
    });
};
const onReady = () => {
    if (electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged) {
        _settings__WEBPACK_IMPORTED_MODULE_2__.settingsChangeEmitter.on("enableRunOnLogin", (value) => {
            if (value)
                (0,_login__WEBPACK_IMPORTED_MODULE_5__.registerAtLogin)();
            else
                (0,_login__WEBPACK_IMPORTED_MODULE_5__.unregisterAtLogin)();
        });
    }
    (0,_trays__WEBPACK_IMPORTED_MODULE_7__.createMainTray)(() => showOrCreateMainWindow(), () => electron__WEBPACK_IMPORTED_MODULE_3__.app.quit());
    electron__WEBPACK_IMPORTED_MODULE_3__.app.on("second-instance", () => {
        showOrCreateMainWindow();
    });
    // enable media tray icons, then register on setting change
    if ((0,_settings__WEBPACK_IMPORTED_MODULE_2__.getSettingValue)("enableMediaControls"))
        (0,_trays__WEBPACK_IMPORTED_MODULE_7__.createMediaTrays)();
    _settings__WEBPACK_IMPORTED_MODULE_2__.settingsChangeEmitter.on("enableMediaControls", (value) => {
        if (value)
            (0,_trays__WEBPACK_IMPORTED_MODULE_7__.createMediaTrays)();
        else
            (0,_trays__WEBPACK_IMPORTED_MODULE_7__.destroyMediaTrays)();
    });
    // enable color picker, then register on setting change
    if ((0,_settings__WEBPACK_IMPORTED_MODULE_2__.getSettingValue)("enableColorPicker"))
        registerColorPicker();
    _settings__WEBPACK_IMPORTED_MODULE_2__.settingsChangeEmitter.on("enableColorPicker", (value) => {
        if (value)
            registerColorPicker();
        else
            unregisterColorPicker();
    });
    electron__WEBPACK_IMPORTED_MODULE_3__.globalShortcut.register("super+control+b", () => {
        console.log("hello?");
        if (!clipboardWindow) {
            console.log("anyone?");
            createClipboardWindow();
        }
    });
    (0,_messageHandlers__WEBPACK_IMPORTED_MODULE_6__["default"])();
    electron__WEBPACK_IMPORTED_MODULE_3__.ipcMain.on("clipboard:paste", (ev, text) => {
        ignoreSingleCopy = true;
        electron__WEBPACK_IMPORTED_MODULE_3__.clipboard.writeText(text);
    });
    // make sure window are shown when React has rendered
    // how it works: every window has a webcontents id,
    // the same webcontents id is in every event emitted by the window
    // so we show the window by finding it in a dictionary
    electron__WEBPACK_IMPORTED_MODULE_3__.ipcMain.on("render:readyToShow", (ev) => {
        const window = windowsByWebcontentsId[ev.sender.id];
        window.show();
    });
    if (!(0,_login__WEBPACK_IMPORTED_MODULE_5__.isLogin)()) {
        createMainWindow();
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onReady);


/***/ }),

/***/ "./src/main/clipboard.ts":
/*!*******************************!*\
  !*** ./src/main/clipboard.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTableClient": () => (/* binding */ getTableClient),
/* harmony export */   "startClipboardListener": () => (/* binding */ startClipboardListener),
/* harmony export */   "stopClipboardListener": () => (/* binding */ stopClipboardListener)
/* harmony export */ });
/* harmony import */ var _azure_data_tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @azure/data-tables */ "./node_modules/@azure/data-tables/dist-esm/src/TableClient.js");
/* harmony import */ var _azure_data_tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @azure/data-tables */ "./node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js");
/* harmony import */ var _azure_data_tables__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @azure/data-tables */ "./node_modules/@azure/data-tables/dist-esm/src/odata.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ "./src/main/settings.ts");
/* harmony import */ var clipboard_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clipboard-event */ "./node_modules/clipboard-event/index.js");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);




const getTableClient = () => {
    const account = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettingValue)("azureStorageAccount");
    const SASToken = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettingValue)("azureSASToken");
    const tableName = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettingValue)("azureTableName");
    return new _azure_data_tables__WEBPACK_IMPORTED_MODULE_3__.TableClient(`https://${account}.table.core.windows.net`, tableName, new _azure_data_tables__WEBPACK_IMPORTED_MODULE_4__.AzureSASCredential(SASToken));
};
const startClipboardListener = (callback) => {
    clipboard_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('change', callback);
    clipboard_event__WEBPACK_IMPORTED_MODULE_1__["default"].startListening();
};
const stopClipboardListener = () => {
    clipboard_event__WEBPACK_IMPORTED_MODULE_1__["default"].removeAllListeners();
    clipboard_event__WEBPACK_IMPORTED_MODULE_1__["default"].stopListening();
};
const fetchClips = async (filter) => {
    const data = [];
    const tableClient = getTableClient();
    const days = filter == "today" ? 1 :
        filter == "this week" ? 7 :
            filter == "this month" ? 30 : 100000;
    const filterDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000); // 1 days ago
    for await (const entity of tableClient.listEntities({
        queryOptions: {
            filter: _azure_data_tables__WEBPACK_IMPORTED_MODULE_5__.odata `Timestamp ge ${filterDate}`,
        }
    })) {
        data.push({
            date: entity.timestamp,
            id: entity.rowKey,
            source: entity.partitionKey,
            text: entity.text
        });
    }
    return data.sort((a, b) => a.date > b.date ? -1 : 1);
};
electron__WEBPACK_IMPORTED_MODULE_2__.ipcMain.handle('clipboard:fetchClips', async (ev, filter) => {
    return await fetchClips(filter);
});



/***/ }),

/***/ "./src/main/getWifiPassword.ts":
/*!*************************************!*\
  !*** ./src/main/getWifiPassword.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (async (ssid) => {
    const cmd = 'netsh';
    const args = ['wlan', 'show', 'profile', `name=${ssid}`, 'key=clear'];
    const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_0__.handleCommand)(cmd, args);
    let ret;
    ret = /^\s*Contenuto chiave\s*: (.+)\s*$/gm.exec(stdout);
    ret = ret && ret.length ? ret[1] : null;
    if (!ret) {
        throw new Error('Could not get password');
    }
    return ret;
});


/***/ }),

/***/ "./src/main/getWifiSSID.ts":
/*!*********************************!*\
  !*** ./src/main/getWifiSSID.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (async () => {
    const cmd = 'netsh';
    const args = ['wlan', 'show', 'interface'];
    const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_0__.handleCommand)(cmd, args);
    let ret;
    ret = /^\s*SSID\s*: (.+)\s*$/gm.exec(stdout);
    ret = ret && ret.length ? ret[1] : null;
    if (!ret) {
        throw new Error('Could not get SSID');
    }
    return ret;
});


/***/ }),

/***/ "./src/main/hypervisor.ts":
/*!********************************!*\
  !*** ./src/main/hypervisor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getHypervisor": () => (/* binding */ getHypervisor),
/* harmony export */   "setHypervisor": () => (/* binding */ setHypervisor)
/* harmony export */ });
/* harmony import */ var sudo_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sudo-prompt */ "./node_modules/sudo-prompt/index.js");

const onString = "Auto";
const offString = "Off";
const setHypervisor = (enabled) => {
    const launchType = enabled ? onString : offString;
    return new Promise((res, rej) => {
        sudo_prompt__WEBPACK_IMPORTED_MODULE_0__.exec(`bcdedit /set hypervisorlaunchtype ${launchType}`, { name: "lb toolkit" }, (error) => {
            if (!error)
                res();
            else
                rej(error);
        });
    });
};
const getHypervisor = () => {
    return new Promise((res, rej) => {
        sudo_prompt__WEBPACK_IMPORTED_MODULE_0__.exec(`bcdedit /enum`, { name: "lb toolkit" }, (error, stdout) => {
            if (!error) {
                let ret = /^\s*hypervisorlaunchtype\s* (.+)\s*$/gm.exec(stdout.toString());
                res(ret[1] == onString ? true : false);
            }
            else
                rej(error);
        });
    });
};



/***/ }),

/***/ "./src/main/login.ts":
/*!***************************!*\
  !*** ./src/main/login.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isLogin": () => (/* binding */ isLogin),
/* harmony export */   "registerAtLogin": () => (/* binding */ registerAtLogin),
/* harmony export */   "unregisterAtLogin": () => (/* binding */ unregisterAtLogin)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);

const atLoginFlag = "--login";
const isLogin = () => process.argv.includes(atLoginFlag);
const registerAtLogin = () => {
    electron__WEBPACK_IMPORTED_MODULE_0__.app.setLoginItemSettings({ openAtLogin: true, args: [atLoginFlag] });
};
const unregisterAtLogin = () => {
    electron__WEBPACK_IMPORTED_MODULE_0__.app.setLoginItemSettings({ openAtLogin: false });
};



/***/ }),

/***/ "./src/main/messageHandlers.ts":
/*!*************************************!*\
  !*** ./src/main/messageHandlers.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _getWifiPassword__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWifiPassword */ "./src/main/getWifiPassword.ts");
/* harmony import */ var _getWifiSSID__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWifiSSID */ "./src/main/getWifiSSID.ts");
/* harmony import */ var _hypervisor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hypervisor */ "./src/main/hypervisor.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./settings */ "./src/main/settings.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");
/* harmony import */ var sudo_prompt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! sudo-prompt */ "./node_modules/sudo-prompt/index.js");
/* harmony import */ var empty_trash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! empty-trash */ "./node_modules/empty-trash/index.js");








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('cmd:fetchUpdates', async () => {
        const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)("winget", ["upgrade", "--include-unknown"]);
        return stdout.substring(stdout.indexOf("Nome"));
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('cmd:updatePackage', async (ev, packageName) => {
        const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)("winget", ["upgrade", packageName]);
        return stdout;
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('cmd:retrieveHypervisorState', async () => {
        return await (0,_hypervisor__WEBPACK_IMPORTED_MODULE_3__.getHypervisor)();
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('cmd:executeHypervisorCommand', async (ev, value) => {
        return await (0,_hypervisor__WEBPACK_IMPORTED_MODULE_3__.setHypervisor)(value);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('settings:getSettingValue', (ev, setting) => {
        return (0,_settings__WEBPACK_IMPORTED_MODULE_4__.getSettingValue)(setting);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('settings:setSettingValue', (ev, setting, value) => {
        return (0,_settings__WEBPACK_IMPORTED_MODULE_4__.setSettingValue)(setting, value);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('fs:appGetPath', async (ev, name) => {
        return electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath(name);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('fs:calculateFolderSize', async (ev, path) => {
        return new Promise((res, rej) => {
            sudo_prompt__WEBPACK_IMPORTED_MODULE_6__.exec(`powershell -noprofile -command "(ls ${path} -r | measure -sum Length).Sum"`, { name: "lbtoolkit" }, (error, stdout) => {
                if (error)
                    rej(error.message);
                const number = (Number.parseInt(stdout.toString()) / 1000000);
                res(Number.isNaN(number) ? 0 : number);
            });
        });
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('fs:getEnvironmentVariable', async (ev, variable) => {
        return process.env[variable];
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('fs:deleteFolder', async (ev, path) => {
        // special case for the recycle bin: it's not a real folder
        if (path == "shell:RecycleBinFolder") {
            return (0,empty_trash__WEBPACK_IMPORTED_MODULE_7__["default"])();
        }
        return new Promise((res, rej) => {
            sudo_prompt__WEBPACK_IMPORTED_MODULE_6__.exec(`powershell -noprofile -command "Get-ChildItem ${path} | Remove-Item –recurse -Force"`, { name: "lbtoolkit" }, (error) => {
                if (error)
                    rej(error.message);
                res();
            });
        });
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("fs:openFolder", async (ev, path) => {
        // special case for the recycle bin: it's not a real folder
        if (path == "shell:RecycleBinFolder") {
            await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)("explorer", ["shell:RecycleBinFolder"]);
        }
        electron__WEBPACK_IMPORTED_MODULE_0__.shell.showItemInFolder(path);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('wifi:retrieveConnectionDetails', async () => {
        const ssid = await (0,_getWifiSSID__WEBPACK_IMPORTED_MODULE_2__["default"])();
        const password = await (0,_getWifiPassword__WEBPACK_IMPORTED_MODULE_1__["default"])(ssid);
        return { ssid, password };
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('display:currentRefreshRate', async () => {
        const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)((0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.getAssetPath)("bin\\refreshtool\\refreshtool.exe"), ["current"]);
        return stdout.replace("\r\n", "");
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('display:listRefreshRates', async () => {
        const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)((0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.getAssetPath)("bin\\refreshtool\\refreshtool.exe"), ["list"]);
        return stdout.split("\r\n").filter(el => el != "");
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('display:setRefreshRate', async (ev, value) => {
        const stdout = await (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.handleCommand)((0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.getAssetPath)("bin\\refreshtool\\refreshtool.exe"), ["change", value]);
    });
    electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('app:getVersion', async () => {
        return electron__WEBPACK_IMPORTED_MODULE_0__.app.getVersion();
    });
});


/***/ }),

/***/ "./src/main/settings.ts":
/*!******************************!*\
  !*** ./src/main/settings.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSettingValue": () => (/* binding */ getSettingValue),
/* harmony export */   "setSettingValue": () => (/* binding */ setSettingValue),
/* harmony export */   "settingsChangeEmitter": () => (/* binding */ settingsChangeEmitter)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _common_SettingsItems__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/SettingsItems */ "./src/common/SettingsItems.ts");





const settingsFileName = "settings.json";
const settingsFilePath = path__WEBPACK_IMPORTED_MODULE_2___default().join(electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath("userData"), settingsFileName);
const file = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(settingsFilePath, { flag: "a+" });
let data;
try {
    data = JSON.parse(file.toString());
}
catch (e) {
    data = { ..._common_SettingsItems__WEBPACK_IMPORTED_MODULE_4__.DefaultValues };
    fs__WEBPACK_IMPORTED_MODULE_1___default().writeFileSync(settingsFilePath, JSON.stringify(data));
}
const settingsChangeEmitter = new stream__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
const getSettingValue = (setting) => data[setting];
const setSettingValue = (setting, value) => {
    data[setting] = value;
    fs__WEBPACK_IMPORTED_MODULE_1___default().writeFileSync(settingsFilePath, JSON.stringify(data));
    settingsChangeEmitter.emit(setting, value);
};



/***/ }),

/***/ "./src/main/trays.ts":
/*!***************************!*\
  !*** ./src/main/trays.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMainTray": () => (/* binding */ createMainTray),
/* harmony export */   "createMediaTrays": () => (/* binding */ createMediaTrays),
/* harmony export */   "destroyMediaTrays": () => (/* binding */ destroyMediaTrays)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var robotjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! robotjs */ "robotjs");
/* harmony import */ var robotjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(robotjs__WEBPACK_IMPORTED_MODULE_2__);



let next;
let prev;
let playPause;
let mainIcon;
const createMediaTrays = () => {
    next = new electron__WEBPACK_IMPORTED_MODULE_0__.Tray(getAssetPath("next.ico"));
    next.addListener("click", () => {
        robotjs__WEBPACK_IMPORTED_MODULE_2___default().keyTap("audio_next");
    });
    prev = new electron__WEBPACK_IMPORTED_MODULE_0__.Tray(getAssetPath("back.ico"));
    prev.addListener("click", () => {
        robotjs__WEBPACK_IMPORTED_MODULE_2___default().keyTap("audio_prev");
    });
    playPause = new electron__WEBPACK_IMPORTED_MODULE_0__.Tray(getAssetPath("play.ico"));
    playPause.addListener("click", () => {
        robotjs__WEBPACK_IMPORTED_MODULE_2___default().keyTap("audio_play");
    });
};
const destroyMediaTrays = () => {
    next.destroy();
    prev.destroy();
    playPause.destroy();
};
const RESOURCES_PATH = electron__WEBPACK_IMPORTED_MODULE_0__.app.isPackaged
    ? path__WEBPACK_IMPORTED_MODULE_1___default().join(process.resourcesPath, 'assets')
    : path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, '../../assets');
const getAssetPath = (...paths) => {
    return path__WEBPACK_IMPORTED_MODULE_1___default().join(RESOURCES_PATH, ...paths);
};
const createMainTray = (showCallback, quitCallback) => {
    mainIcon = new electron__WEBPACK_IMPORTED_MODULE_0__.Tray(getAssetPath("favicon.ico"));
    mainIcon.addListener("click", () => {
        showCallback();
    });
    mainIcon.setContextMenu(electron__WEBPACK_IMPORTED_MODULE_0__.Menu.buildFromTemplate([
        {
            label: 'Show',
            click: () => {
                showCallback();
            }
        },
        {
            label: 'Quit',
            click: () => {
                quitCallback(); // actually quit the app.
            }
        },
    ]));
};



/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ "./node_modules/user-home/index.js":
/*!*****************************************!*\
  !*** ./node_modules/user-home/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! os-homedir */ "./node_modules/os-homedir/index.js")();


/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/regex.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/regex.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/rng.js":
/*!************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/rng.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/stringify.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/stringify.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-node/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v4.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v4.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-node/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-node/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/validate.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/validate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-node/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/which/which.js":
/*!*************************************!*\
  !*** ./node_modules/which/which.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(/*! path */ "path")
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(/*! isexe */ "./node_modules/isexe/index.js")

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "./node_modules/xdg-basedir/index.js":
/*!*******************************************!*\
  !*** ./node_modules/xdg-basedir/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");

const homeDirectory = os.homedir();
const {env} = process;

exports.data = env.XDG_DATA_HOME ||
	(homeDirectory ? path.join(homeDirectory, '.local', 'share') : undefined);

exports.config = env.XDG_CONFIG_HOME ||
	(homeDirectory ? path.join(homeDirectory, '.config') : undefined);

exports.cache = env.XDG_CACHE_HOME || (homeDirectory ? path.join(homeDirectory, '.cache') : undefined);

exports.runtime = env.XDG_RUNTIME_DIR || undefined;

exports.dataDirs = (env.XDG_DATA_DIRS || '/usr/local/share/:/usr/share/').split(':');

if (exports.data) {
	exports.dataDirs.unshift(exports.data);
}

exports.configDirs = (env.XDG_CONFIG_DIRS || '/etc/xdg').split(':');

if (exports.config) {
	exports.configDirs.unshift(exports.config);
}


/***/ }),

/***/ "./node_modules/xdg-trashdir/index.js":
/*!********************************************!*\
  !*** ./node_modules/xdg-trashdir/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = (__webpack_require__(/*! fs */ "fs").promises);
const path = __webpack_require__(/*! path */ "path");
const df = __webpack_require__(/*! @sindresorhus/df */ "./node_modules/@sindresorhus/df/index.js");
const mountPoint = __webpack_require__(/*! mount-point */ "./node_modules/mount-point/index.js");
const userHome = __webpack_require__(/*! user-home */ "./node_modules/user-home/index.js");
const xdgBasedir = __webpack_require__(/*! xdg-basedir */ "./node_modules/xdg-basedir/index.js");

const check = async filePath => {
	const topuid = `${filePath}-${process.getuid()}`;
	const stickyBitMode = 17407;

	try {
		const stats = await fs.lstat(filePath);

		if (stats.isSymbolicLink() || stats.mode !== stickyBitMode) {
			return topuid;
		}

		return path.join(filePath, String(process.getuid()));
	} catch (error) {
		if (error.code === 'ENOENT') {
			return topuid;
		}

		return path.join(xdgBasedir.data, 'Trash');
	}
};

module.exports = async filePath => {
	if (process.platform !== 'linux') {
		return Promise.reject(new Error('Only Linux systems are supported'));
	}

	if (!filePath) {
		return Promise.resolve(path.join(xdgBasedir.data, 'Trash'));
	}

	const [homeMountPoint, fileMountPoint] = await Promise.all([
		mountPoint(userHome),
		// Ignore errors in case `file` is a dangling symlink
		mountPoint(filePath).catch(() => {})
	]);

	if (!fileMountPoint || fileMountPoint === homeMountPoint) {
		return path.join(xdgBasedir.data, 'Trash');
	}

	return check(path.join(fileMountPoint, '.Trash'));
};

module.exports.all = async () => {
	if (process.platform !== 'linux') {
		return Promise.reject(new Error('Only Linux systems are supported'));
	}

	return Promise.all((await df()).map(fileSystem => {
		if (fileSystem.mountpoint === '/') {
			return path.join(xdgBasedir.data, 'Trash');
		}

		return check(path.join(fileSystem.mountpoint, '.Trash'));
	}));
};


/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/yallist/iterator.js")(Yallist)
} catch (er) {}


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:child_process":
/*!*************************************!*\
  !*** external "node:child_process" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:fs/promises":
/*!***********************************!*\
  !*** external "node:fs/promises" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "robotjs":
/*!**************************!*\
  !*** external "robotjs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_robotjs__;

/***/ }),

/***/ "./node_modules/clipboard-event/index.js":
/*!***********************************************!*\
  !*** ./node_modules/clipboard-event/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ "node:url");




const __dirname = path__WEBPACK_IMPORTED_MODULE_1__.dirname((0,node_url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)("file:///C:/Users/LorenzoBartolini/source/lb-toolkit-next/node_modules/clipboard-event/index.js"))

class ClipboardEventListener extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor() {
    super();
    this.child = null;
  }

  startListening() {

    const { platform } = process;
    if (platform === 'win32') {
      this.child = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.execFile)(path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,'platform/clipboard-event-handler-win32.exe'));
    }
    else if (platform === 'linux') {
      this.child = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.execFile)(path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,'platform/clipboard-event-handler-linux'));
    }
    else if (platform === 'darwin') {
      this.child = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.execFile)(path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,'platform/clipboard-event-handler-mac'));
    }
    else {
      throw 'Not yet supported';
    }

    this.child.stdout.on('data', (data) => {
      if (data.trim() === 'CLIPBOARD_CHANGE') {
        this.emit('change');
      }
    });

  }

  stopListening() {
    const res = this.child.kill();
    return res;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new ClipboardEventListener());

// Sample usage
/*
import clipboardListener from 'clipboard-event'

// To start listening
clipboardListener.startListening();

clipboardListener.on('change', () => {
  console.log('Clipboard changed');
});

// To stop listening
clipboardListener.stopListening();
*/


/***/ }),

/***/ "./node_modules/crypto-random-string/index.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-random-string/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ "crypto");



const randomBytesAsync = (0,util__WEBPACK_IMPORTED_MODULE_0__.promisify)(crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes);

const urlSafeCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~'.split('');
const numericCharacters = '0123456789'.split('');
const distinguishableCharacters = 'CDEHKMPRTUWXY012458'.split('');
const asciiPrintableCharacters = '!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'.split('');
const alphanumericCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');

const generateForCustomCharacters = (length, characters) => {
	// Generating entropy is faster than complex math operations, so we use the simplest way
	const characterCount = characters.length;
	const maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division
	const entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low
	let string = '';
	let stringLength = 0;

	while (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it
		const entropy = crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(entropyLength);
		let entropyPosition = 0;

		while (entropyPosition < entropyLength && stringLength < length) {
			const entropyValue = entropy.readUInt16LE(entropyPosition);
			entropyPosition += 2;
			if (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division
				continue;
			}

			string += characters[entropyValue % characterCount];
			stringLength++;
		}
	}

	return string;
};

const generateForCustomCharactersAsync = async (length, characters) => {
	// Generating entropy is faster than complex math operations, so we use the simplest way
	const characterCount = characters.length;
	const maxValidSelector = (Math.floor(0x10000 / characterCount) * characterCount) - 1; // Using values above this will ruin distribution when using modular division
	const entropyLength = 2 * Math.ceil(1.1 * length); // Generating a bit more than required so chances we need more than one pass will be really low
	let string = '';
	let stringLength = 0;

	while (stringLength < length) { // In case we had many bad values, which may happen for character sets of size above 0x8000 but close to it
		const entropy = await randomBytesAsync(entropyLength); // eslint-disable-line no-await-in-loop
		let entropyPosition = 0;

		while (entropyPosition < entropyLength && stringLength < length) {
			const entropyValue = entropy.readUInt16LE(entropyPosition);
			entropyPosition += 2;
			if (entropyValue > maxValidSelector) { // Skip values which will ruin distribution when using modular division
				continue;
			}

			string += characters[entropyValue % characterCount];
			stringLength++;
		}
	}

	return string;
};

const generateRandomBytes = (byteLength, type, length) => crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(byteLength).toString(type).slice(0, length);

const generateRandomBytesAsync = async (byteLength, type, length) => {
	const buffer = await randomBytesAsync(byteLength);
	return buffer.toString(type).slice(0, length);
};

const allowedTypes = new Set([
	undefined,
	'hex',
	'base64',
	'url-safe',
	'numeric',
	'distinguishable',
	'ascii-printable',
	'alphanumeric'
]);

const createGenerator = (generateForCustomCharacters, generateRandomBytes) => ({length, type, characters}) => {
	if (!(length >= 0 && Number.isFinite(length))) {
		throw new TypeError('Expected a `length` to be a non-negative finite number');
	}

	if (type !== undefined && characters !== undefined) {
		throw new TypeError('Expected either `type` or `characters`');
	}

	if (characters !== undefined && typeof characters !== 'string') {
		throw new TypeError('Expected `characters` to be string');
	}

	if (!allowedTypes.has(type)) {
		throw new TypeError(`Unknown type: ${type}`);
	}

	if (type === undefined && characters === undefined) {
		type = 'hex';
	}

	if (type === 'hex' || (type === undefined && characters === undefined)) {
		return generateRandomBytes(Math.ceil(length * 0.5), 'hex', length); // Need 0.5 byte entropy per character
	}

	if (type === 'base64') {
		return generateRandomBytes(Math.ceil(length * 0.75), 'base64', length); // Need 0.75 byte of entropy per character
	}

	if (type === 'url-safe') {
		return generateForCustomCharacters(length, urlSafeCharacters);
	}

	if (type === 'numeric') {
		return generateForCustomCharacters(length, numericCharacters);
	}

	if (type === 'distinguishable') {
		return generateForCustomCharacters(length, distinguishableCharacters);
	}

	if (type === 'ascii-printable') {
		return generateForCustomCharacters(length, asciiPrintableCharacters);
	}

	if (type === 'alphanumeric') {
		return generateForCustomCharacters(length, alphanumericCharacters);
	}

	if (characters.length === 0) {
		throw new TypeError('Expected `characters` string length to be greater than or equal to 1');
	}

	if (characters.length > 0x10000) {
		throw new TypeError('Expected `characters` string length to be less or equal to 65536');
	}

	return generateForCustomCharacters(length, characters.split(''));
};

const cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);

cryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cryptoRandomString);


/***/ }),

/***/ "./node_modules/empty-trash/index.js":
/*!*******************************************!*\
  !*** ./node_modules/empty-trash/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ emptyTrash)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:child_process */ "node:child_process");
/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:fs/promises */ "node:fs/promises");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var run_jxa__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! run-jxa */ "./node_modules/run-jxa/index.js");
/* harmony import */ var xdg_trashdir__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! xdg-trashdir */ "./node_modules/xdg-trashdir/index.js");
/* harmony import */ var path_exists__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! path-exists */ "./node_modules/empty-trash/node_modules/path-exists/index.js");
/* harmony import */ var p_filter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! p-filter */ "./node_modules/p-filter/index.js");











const __dirname = node_path__WEBPACK_IMPORTED_MODULE_4__.dirname((0,node_url__WEBPACK_IMPORTED_MODULE_5__.fileURLToPath)("file:///C:/Users/LorenzoBartolini/source/lb-toolkit-next/node_modules/empty-trash/index.js"));
const execFileP = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_child_process__WEBPACK_IMPORTED_MODULE_2__.execFile);

const windowBinaryPath = node_path__WEBPACK_IMPORTED_MODULE_4__.join(__dirname, 'lib/empty-recycle-bin.exe');

const linuxEmptyTrash = async directory => {
	const files = await node_fs_promises__WEBPACK_IMPORTED_MODULE_3__.readdir(directory);
	await Promise.all(files.map(file => node_fs_promises__WEBPACK_IMPORTED_MODULE_3__.rm(node_path__WEBPACK_IMPORTED_MODULE_4__.join(directory, file), {recursive: true})));
};

const linuxEmptyTrashes = async () => {
	const directories = await (0,p_filter__WEBPACK_IMPORTED_MODULE_9__["default"])(await xdg_trashdir__WEBPACK_IMPORTED_MODULE_7__.all(), path_exists__WEBPACK_IMPORTED_MODULE_8__.pathExists);
	await Promise.all(directories.map(directory => linuxEmptyTrash(directory)));
};

async function emptyTrash() {
	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'darwin') {
		await (0,run_jxa__WEBPACK_IMPORTED_MODULE_6__.runJxa)(`
			const finder = Application('Finder');

			if (finder.trash.items.length > 0) {
				finder.empty();
			}
		`);
		return;
	}

	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32') {
		await execFileP(windowBinaryPath);
		return;
	}

	await linuxEmptyTrashes();
}


/***/ }),

/***/ "./node_modules/empty-trash/node_modules/path-exists/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/empty-trash/node_modules/path-exists/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pathExists": () => (/* binding */ pathExists),
/* harmony export */   "pathExistsSync": () => (/* binding */ pathExistsSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ "node:fs");


async function pathExists(path) {
	try {
		await node_fs__WEBPACK_IMPORTED_MODULE_0__.promises.access(path);
		return true;
	} catch {
		return false;
	}
}

function pathExistsSync(path) {
	try {
		node_fs__WEBPACK_IMPORTED_MODULE_0__.accessSync(path);
		return true;
	} catch {
		return false;
	}
}


/***/ }),

/***/ "./node_modules/macos-version/index.js":
/*!*********************************************!*\
  !*** ./node_modules/macos-version/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assertMacOS": () => (/* binding */ assertMacOS),
/* harmony export */   "assertMacOSVersion": () => (/* binding */ assertMacOSVersion),
/* harmony export */   "assertMacOSVersionGreaterThanOrEqualTo": () => (/* binding */ assertMacOSVersionGreaterThanOrEqualTo),
/* harmony export */   "isMacOS": () => (/* binding */ isMacOS),
/* harmony export */   "isMacOSVersion": () => (/* binding */ isMacOSVersion),
/* harmony export */   "isMacOSVersionGreaterThanOrEqualTo": () => (/* binding */ isMacOSVersionGreaterThanOrEqualTo),
/* harmony export */   "macOSVersion": () => (/* binding */ macOSVersion)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ "./node_modules/macos-version/node_modules/semver/index.js");




const isMacOS = node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'darwin';

let version;

const clean = version => {
	const {length} = version.split('.');

	if (length === 1) {
		return `${version}.0.0`;
	}

	if (length === 2) {
		return `${version}.0`;
	}

	return version;
};

const parseVersion = plist => {
	const matches = /<key>ProductVersion<\/key>\s*<string>([\d.]+)<\/string>/.exec(plist);
	if (!matches) {
		return;
	}

	return matches[1].replace('10.16', '11');
};

function macOSVersion() {
	if (!isMacOS) {
		return;
	}

	if (!version) {
		const file = node_fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync('/System/Library/CoreServices/SystemVersion.plist', 'utf8');
		const matches = parseVersion(file);

		if (!matches) {
			return;
		}

		version = clean(matches);
	}

	return version;
}

if (false) {}

function isMacOSVersion(semverRange) {
	if (!isMacOS) {
		return false;
	}

	semverRange = semverRange.replace('10.16', '11');

	return semver__WEBPACK_IMPORTED_MODULE_2__.satisfies(macOSVersion(), clean(semverRange));
}

function isMacOSVersionGreaterThanOrEqualTo(version) {
	if (!isMacOS) {
		return false;
	}

	version = version.replace('10.16', '11');

	return semver__WEBPACK_IMPORTED_MODULE_2__.gte(macOSVersion(), clean(version));
}

function assertMacOSVersion(semverRange) {
	semverRange = semverRange.replace('10.16', '11');

	if (!isMacOSVersion(semverRange)) {
		throw new Error(`Requires macOS ${semverRange}`);
	}
}

function assertMacOSVersionGreaterThanOrEqualTo(version) {
	version = version.replace('10.16', '11');

	if (!isMacOSVersionGreaterThanOrEqualTo(version)) {
		throw new Error(`Requires macOS ${version} or later`);
	}
}

function assertMacOS() {
	if (!isMacOS) {
		throw new Error('Requires macOS');
	}
}


/***/ }),

/***/ "./node_modules/p-filter/index.js":
/*!****************************************!*\
  !*** ./node_modules/p-filter/index.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pFilter)
/* harmony export */ });
/* harmony import */ var p_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-map */ "./node_modules/p-filter/node_modules/p-map/index.js");


async function pFilter(iterable, filterer, options) {
	const values = await (0,p_map__WEBPACK_IMPORTED_MODULE_0__["default"])(
		iterable,
		(element, index) => Promise.all([filterer(element, index), element]),
		options,
	);

	return values.filter(value => Boolean(value[0])).map(value => value[1]);
}


/***/ }),

/***/ "./node_modules/p-filter/node_modules/aggregate-error/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/p-filter/node_modules/aggregate-error/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AggregateError)
/* harmony export */ });
/* harmony import */ var indent_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! indent-string */ "./node_modules/p-filter/node_modules/indent-string/index.js");
/* harmony import */ var clean_stack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clean-stack */ "./node_modules/p-filter/node_modules/clean-stack/index.js");



const cleanInternalStack = stack => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, '');

class AggregateError extends Error {
	#errors;

	name = 'AggregateError';

	constructor(errors) {
		if (!Array.isArray(errors)) {
			throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
		}

		errors = errors.map(error => {
			if (error instanceof Error) {
				return error;
			}

			if (error !== null && typeof error === 'object') {
				// Handle plain error objects with message property and/or possibly other metadata
				return Object.assign(new Error(error.message), error);
			}

			return new Error(error);
		});

		let message = errors
			.map(error => {
				// The `stack` property is not standardized, so we can't assume it exists
				return typeof error.stack === 'string' && error.stack.length > 0 ? cleanInternalStack((0,clean_stack__WEBPACK_IMPORTED_MODULE_1__["default"])(error.stack)) : String(error);
			})
			.join('\n');
		message = '\n' + (0,indent_string__WEBPACK_IMPORTED_MODULE_0__["default"])(message, 4);
		super(message);

		this.#errors = errors;
	}

	get errors() {
		return this.#errors.slice();
	}
}


/***/ }),

/***/ "./node_modules/p-filter/node_modules/clean-stack/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/p-filter/node_modules/clean-stack/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cleanStack)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! escape-string-regexp */ "./node_modules/p-filter/node_modules/escape-string-regexp/index.js");



const extractPathRegex = /\s+at.*[(\s](.*)\)?/;
const pathRegex = /^(?:(?:(?:node|node:[\w/]+|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/;
const homeDir = typeof os__WEBPACK_IMPORTED_MODULE_0__.homedir === 'undefined' ? '' : os__WEBPACK_IMPORTED_MODULE_0__.homedir().replace(/\\/g, '/');

function cleanStack(stack, {pretty = false, basePath} = {}) {
	const basePathRegex = basePath && new RegExp(`(at | \\()${(0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_1__["default"])(basePath.replace(/\\/g, '/'))}`, 'g');

	if (typeof stack !== 'string') {
		return undefined;
	}

	return stack.replace(/\\/g, '/')
		.split('\n')
		.filter(line => {
			const pathMatches = line.match(extractPathRegex);
			if (pathMatches === null || !pathMatches[1]) {
				return true;
			}

			const match = pathMatches[1];

			// Electron
			if (
				match.includes('.app/Contents/Resources/electron.asar') ||
				match.includes('.app/Contents/Resources/default_app.asar') ||
				match.includes('node_modules/electron/dist/resources/electron.asar') ||
				match.includes('node_modules/electron/dist/resources/default_app.asar')
			) {
				return false;
			}

			return !pathRegex.test(match);
		})
		.filter(line => line.trim() !== '')
		.map(line => {
			if (basePathRegex) {
				line = line.replace(basePathRegex, '$1');
			}

			if (pretty) {
				line = line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')));
			}

			return line;
		})
		.join('\n');
}


/***/ }),

/***/ "./node_modules/p-filter/node_modules/escape-string-regexp/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/p-filter/node_modules/escape-string-regexp/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ escapeStringRegexp)
/* harmony export */ });
function escapeStringRegexp(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
}


/***/ }),

/***/ "./node_modules/p-filter/node_modules/indent-string/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/p-filter/node_modules/indent-string/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ indentString)
/* harmony export */ });
function indentString(string, count = 1, options = {}) {
	const {
		indent = ' ',
		includeEmptyLines = false
	} = options;

	if (typeof string !== 'string') {
		throw new TypeError(
			`Expected \`input\` to be a \`string\`, got \`${typeof string}\``
		);
	}

	if (typeof count !== 'number') {
		throw new TypeError(
			`Expected \`count\` to be a \`number\`, got \`${typeof count}\``
		);
	}

	if (count < 0) {
		throw new RangeError(
			`Expected \`count\` to be at least 0, got \`${count}\``
		);
	}

	if (typeof indent !== 'string') {
		throw new TypeError(
			`Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``
		);
	}

	if (count === 0) {
		return string;
	}

	const regex = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;

	return string.replace(regex, indent.repeat(count));
}


/***/ }),

/***/ "./node_modules/p-filter/node_modules/p-map/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/p-filter/node_modules/p-map/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortError": () => (/* binding */ AbortError),
/* harmony export */   "default": () => (/* binding */ pMap),
/* harmony export */   "pMapSkip": () => (/* binding */ pMapSkip)
/* harmony export */ });
/* harmony import */ var aggregate_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aggregate-error */ "./node_modules/p-filter/node_modules/aggregate-error/index.js");


/**
An error to be thrown when the request is aborted by AbortController.
DOMException is thrown instead of this Error when DOMException is available.
*/
class AbortError extends Error {
	constructor(message) {
		super();
		this.name = 'AbortError';
		this.message = message;
	}
}

/**
TODO: Remove AbortError and just throw DOMException when targeting Node 18.
*/
const getDOMException = errorMessage => globalThis.DOMException === undefined
	? new AbortError(errorMessage)
	: new DOMException(errorMessage);

/**
TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.
*/
const getAbortedReason = signal => {
	const reason = signal.reason === undefined
		? getDOMException('This operation was aborted.')
		: signal.reason;

	return reason instanceof Error ? reason : getDOMException(reason);
};

async function pMap(
	iterable,
	mapper,
	{
		concurrency = Number.POSITIVE_INFINITY,
		stopOnError = true,
		signal,
	} = {},
) {
	return new Promise((resolve, reject_) => {
		if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {
			throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
		}

		if (typeof mapper !== 'function') {
			throw new TypeError('Mapper function is required');
		}

		if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {
			throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
		}

		const result = [];
		const errors = [];
		const skippedIndexesMap = new Map();
		let isRejected = false;
		let isResolved = false;
		let isIterableDone = false;
		let resolvingCount = 0;
		let currentIndex = 0;
		const iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();

		const reject = reason => {
			isRejected = true;
			isResolved = true;
			reject_(reason);
		};

		if (signal) {
			if (signal.aborted) {
				reject(getAbortedReason(signal));
			}

			signal.addEventListener('abort', () => {
				reject(getAbortedReason(signal));
			});
		}

		const next = async () => {
			if (isResolved) {
				return;
			}

			const nextItem = await iterator.next();

			const index = currentIndex;
			currentIndex++;

			// Note: `iterator.next()` can be called many times in parallel.
			// This can cause multiple calls to this `next()` function to
			// receive a `nextItem` with `done === true`.
			// The shutdown logic that rejects/resolves must be protected
			// so it runs only one time as the `skippedIndex` logic is
			// non-idempotent.
			if (nextItem.done) {
				isIterableDone = true;

				if (resolvingCount === 0 && !isResolved) {
					if (!stopOnError && errors.length > 0) {
						reject(new aggregate_error__WEBPACK_IMPORTED_MODULE_0__["default"](errors));
						return;
					}

					isResolved = true;

					if (skippedIndexesMap.size === 0) {
						resolve(result);
						return;
					}

					const pureResult = [];

					// Support multiple `pMapSkip`'s.
					for (const [index, value] of result.entries()) {
						if (skippedIndexesMap.get(index) === pMapSkip) {
							continue;
						}

						pureResult.push(value);
					}

					resolve(pureResult);
				}

				return;
			}

			resolvingCount++;

			// Intentionally detached
			(async () => {
				try {
					const element = await nextItem.value;

					if (isResolved) {
						return;
					}

					const value = await mapper(element, index);

					// Use Map to stage the index of the element.
					if (value === pMapSkip) {
						skippedIndexesMap.set(index, value);
					}

					result[index] = value;

					resolvingCount--;
					await next();
				} catch (error) {
					if (stopOnError) {
						reject(error);
					} else {
						errors.push(error);
						resolvingCount--;

						// In that case we can't really continue regardless of `stopOnError` state
						// since an iterable is likely to continue throwing after it throws once.
						// If we continue calling `next()` indefinitely we will likely end up
						// in an infinite loop of failed iteration.
						try {
							await next();
						} catch (error) {
							reject(error);
						}
					}
				}
			})();
		};

		// Create the concurrent runners in a detached (non-awaited)
		// promise. We need this so we can await the `next()` calls
		// to stop creating runners before hitting the concurrency limit
		// if the iterable has already been marked as done.
		// NOTE: We *must* do this for async iterators otherwise we'll spin up
		// infinite `next()` calls by default and never start the event loop.
		(async () => {
			for (let index = 0; index < concurrency; index++) {
				try {
					// eslint-disable-next-line no-await-in-loop
					await next();
				} catch (error) {
					reject(error);
					break;
				}

				if (isIterableDone || isRejected) {
					break;
				}
			}
		})();
	});
}

const pMapSkip = Symbol('skip');


/***/ }),

/***/ "./node_modules/run-jxa/index.js":
/*!***************************************!*\
  !*** ./node_modules/run-jxa/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runJxa": () => (/* binding */ runJxa),
/* harmony export */   "runJxaSync": () => (/* binding */ runJxaSync)
/* harmony export */ });
/* harmony import */ var execa__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! execa */ "./node_modules/execa/index.js");
/* harmony import */ var subsume__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! subsume */ "./node_modules/subsume/index.js");
/* harmony import */ var macos_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! macos-version */ "./node_modules/macos-version/index.js");




const subsume = new subsume__WEBPACK_IMPORTED_MODULE_1__["default"]();
const commandArguments = ['-l', 'JavaScript'];

const prepareOptions = (input, arguments_) => {
	const stringTemplate = `function(){const args=[].slice.call(arguments);\n${input}\n}`;
	const functionString = typeof input === 'function' ? input.toString() : stringTemplate;
	const argsString = (arguments_ || []).map(argument => JSON.stringify(argument)).join(',');
	const functionCall = `(${functionString})(${argsString})`;
	const output = `JSON.stringify({data: ${functionCall}})`;
	const script = `console.log('${subsume.prefix}' + ${output} + '${subsume.postfix}');`;
	return {input: script};
};

const handleOutput = string => {
	const result = subsume.parse(string);
	const log = result.rest.slice(0, -1);

	if (log.length > 0) {
		console.log(log);
	}

	return result.data && JSON.parse(result.data).data;
};

async function runJxa(input, arguments_) {
	(0,macos_version__WEBPACK_IMPORTED_MODULE_2__.assertMacOSVersionGreaterThanOrEqualTo)('10.10');
	const {stderr} = await execa__WEBPACK_IMPORTED_MODULE_0__('osascript', commandArguments, prepareOptions(input, arguments_));
	return handleOutput(stderr);
}

function runJxaSync(input, arguments_) {
	(0,macos_version__WEBPACK_IMPORTED_MODULE_2__.assertMacOSVersionGreaterThanOrEqualTo)('10.10');
	const {stderr} = execa__WEBPACK_IMPORTED_MODULE_0__.sync('osascript', commandArguments, prepareOptions(input, arguments_));
	return handleOutput(stderr);
}


/***/ }),

/***/ "./node_modules/subsume/index.js":
/*!***************************************!*\
  !*** ./node_modules/subsume/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Subsume)
/* harmony export */ });
/* harmony import */ var unique_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unique-string */ "./node_modules/unique-string/index.js");
/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! escape-string-regexp */ "./node_modules/subsume/node_modules/escape-string-regexp/index.js");



class Subsume {
	static parse(text, id) {
		return (new Subsume(id)).parse(text);
	}

	static parseAll(text, ids) {
		if (ids && !Array.isArray(ids)) {
			throw new TypeError('IDs is supposed to be an array');
		}

		const result = {data: new Map(), rest: text};
		const idList = ids ? ids : Subsume._extractIDs(text);

		if (!ids) {
			try {
				Subsume._checkIntegrity(text);
			} catch (error) {
				throw new Error(`Could not parse because the string's integrity is compromised: ${error.message}`);
			}
		}

		for (const id of idList) {
			if (result.data.get(id)) {
				throw new Error('IDs aren\'t supposed to be repeated at the same level in a string');
			}

			const parseResult = Subsume.parse(result.rest, id);
			result.data.set(id, parseResult.data);
			result.rest = parseResult.rest;
		}

		return result;
	}

	static _extractIDs(text) {
		try {
			Subsume._checkIntegrity(text);
		} catch (error) {
			throw new Error(`Could not extract IDs because the string's integrity is compromised: ${error.message}`);
		}

		const idRegex = /@@\[(.{32})]@@.*##\[\1]##/g;
		const idList = [];
		let match;

		do {
			match = idRegex.exec(text);
			if (match) {
				const [, id] = match;
				idList.push(id);
			}
		} while (match);

		return idList;
	}

	static _checkIntegrity(text) {
		const delimiterRegex = /([#|@])\1\[(.{32})]\1{2}/g;
		const ids = new Map();
		const idStack = [];
		let match;

		do {
			match = delimiterRegex.exec(text);

			if (match) {
				const [, embedToken, id] = match;

				if (embedToken === '@') {
					let map = ids;
					for (const element of idStack) {
						map = map.get(element);
					}

					if (map.get(id)) {
						throw new Error('There are duplicate IDs in the same scope.');
					}

					map.set(id, new Map());

					idStack.push(id);
				} else {
					idStack.pop();
				}
			}
		} while (match);

		if (idStack.length > 0) {
			throw new Error('There is a mismatch between prefixes and suffixes');
		}

		return ids;
	}

	constructor(id) {
		if (id && (id.includes('@@[') || id.includes('##['))) {
			throw new Error('`@@[` and `##[` cannot be used in the ID');
		}

		this.id = id ? id : (0,unique_string__WEBPACK_IMPORTED_MODULE_0__["default"])();
		this.prefix = `@@[${this.id}]@@`;
		this.postfix = `##[${this.id}]##`;
		this.regex = new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_1__["default"])(this.prefix) + '([\\S\\s]*)' + (0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_1__["default"])(this.postfix), 'g');
	}

	compose(text) {
		return this.prefix + text + this.postfix;
	}

	parse(text) {
		try {
			Subsume._checkIntegrity(text);
		} catch (error) {
			throw new Error(`Could not extract IDs because the string's integrity is compromised: ${error.message}`);
		}

		const returnValue = {};

		returnValue.rest = text.replace(this.regex, (m, p1) => {
			if (p1) {
				returnValue.data = p1;
			}

			return '';
		});

		return returnValue;
	}
}


/***/ }),

/***/ "./node_modules/subsume/node_modules/escape-string-regexp/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/subsume/node_modules/escape-string-regexp/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ escapeStringRegexp)
/* harmony export */ });
function escapeStringRegexp(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
}


/***/ }),

/***/ "./node_modules/unique-string/index.js":
/*!*********************************************!*\
  !*** ./node_modules/unique-string/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueString)
/* harmony export */ });
/* harmony import */ var crypto_random_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-random-string */ "./node_modules/crypto-random-string/index.js");


function uniqueString() {
	return (0,crypto_random_string__WEBPACK_IMPORTED_MODULE_0__["default"])({length: 32});
}


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bootstrap */ "./src/main/bootstrap.ts");

// import { isSquirrel } from './squirrel'

// Module to create native browser window.
let canLoad = true;
// // this package checks if we are in install mode and executes the install scripts
// if (isSquirrel()) {
//     canLoad = false
//     app.quit()
// }
// // make sure we are the only instance running, otherwise quit
if (!electron__WEBPACK_IMPORTED_MODULE_0__.app.requestSingleInstanceLock()) {
    canLoad = false;
    electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();
}
if (canLoad) {
    console.log("ciao");
    electron__WEBPACK_IMPORTED_MODULE_0__.app.whenReady().then(() => (0,_bootstrap__WEBPACK_IMPORTED_MODULE_1__["default"])());
    electron__WEBPACK_IMPORTED_MODULE_0__.app.on('window-all-closed', (ev) => {
        // leaving this empty prevents the default action
    });
}

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixxREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFXO0FBQ3RDLGlDQUFpQyxxREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xIQTtBQUNBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksbUVBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRCwrRUFBK0UsV0FBVyxHQUFHLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ2xGLDBCQUEwQiw2REFBcUI7QUFDL0MsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BRQTtBQUNBO0FBQ2tEO0FBQ1A7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwrREFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3REFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQix3SEFBd0gsSUFBSTtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZLDBDQUEwQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtREFBbUQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2x6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUk7QUFDOUg7QUFDUDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksNERBQXFCO0FBQ2pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksbUVBQTRCO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNK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QUNBO0FBQ0EsZUFBZSxvRkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUIsS0FBSyxZQUFZLFNBQVMsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSUE7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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aUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtB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QUFxQjs7QUFFckI7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyw2R0FBMkI7QUFDeEQsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLDJGQUFr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Q0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQzdEO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUJBQXFCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUUsc0JBQXNCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUJBQW1COztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBMEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqcUJhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFVOztBQUVsQyxPQUFPLEtBQUs7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdElPLE1BQU0sYUFBYSxHQUFHO0lBQ3pCLGlCQUFpQixFQUFFLElBQUk7SUFDdkIsbUJBQW1CLEVBQUUsSUFBSTtJQUN6QixnQkFBZ0IsRUFBRSxJQUFJO0lBQ3RCLG1CQUFtQixFQUFFLEtBQUs7SUFDMUIsbUJBQW1CLEVBQUUsRUFBRTtJQUN2QixhQUFhLEVBQUUsRUFBRTtJQUNqQixjQUFjLEVBQUUsRUFBRTtDQUNyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1J1QztBQUNqQjtBQUNKO0FBQ1c7QUFFdkIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxTQUFpQixFQUFFLEVBQUU7SUFDekMsTUFBTSxLQUFLLEdBQUcscURBQWMsQ0FBQyxTQUFTLENBQUM7SUFFdkMsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxFQUFFO1FBQ3RDLE1BQU0sS0FBSyxHQUFHLGtEQUFXLENBQUMsZ0RBQVMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDckQsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFO1lBQ2pCLENBQUMsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLElBQUk7WUFDMUIsQ0FBQyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsZ0RBQVMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDM0QsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNULENBQUM7QUFFTSxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFTLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0lBQzdFLE1BQU0sSUFBSSxHQUFHLDBEQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7SUFFOUMsSUFBSSxNQUFNLEdBQUcsRUFBRTtJQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1FBRTVCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUNsQixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNuQyxHQUFHLENBQUMsV0FBVyxDQUFDO0lBQ3BCLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQztBQUVLLE1BQU0sZUFBZSxHQUFHLENBQUMsWUFBb0IsRUFBRSxTQUFpQixFQUFFLEVBQUUsRUFBRTtJQUN6RSxJQUFJLElBQXNDLEVBQUU7UUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7UUFDckIsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSTtRQUNyQyxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxvQkFBb0IsSUFBSSxFQUFFLENBQUM7UUFDL0MsR0FBRyxDQUFDLFFBQVEsR0FBRyxZQUFZO1FBQzNCLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTTtRQUNuQixPQUFPLEdBQUcsQ0FBQyxJQUFJO0tBQ2xCO0lBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUM7SUFDdEIsT0FBTyxVQUFVLG1EQUFZLENBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxZQUFZLENBQUMsR0FBRyxNQUFNLEVBQUU7QUFDckYsQ0FBQztBQUVNLE1BQU0sY0FBYyxHQUFHLG9EQUFjO0lBQ3hDLENBQUMsQ0FBQyxnREFBUyxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDO0lBQzVDLENBQUMsQ0FBQyxnREFBUyxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUM7QUFFbkMsTUFBTSxZQUFZLEdBQUcsQ0FBQyxHQUFHLEtBQWUsRUFBVSxFQUFFO0lBQ3ZELE9BQU8sZ0RBQVMsQ0FBQyxjQUFjLEVBQUUsR0FBRyxLQUFLLENBQUM7QUFDOUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEZ0M7QUFDTjtBQUN3QztBQUNtQztBQUNYO0FBQ3RCO0FBQ2xCO0FBQzBCO0FBQzVCO0FBRWpELElBQUksZ0JBQWdCLEdBQUcsS0FBSztBQUU1QixNQUFNLHlCQUF5QixHQUFHLEdBQUcsRUFBRTtJQUVuQyxNQUFNLFdBQVcsR0FBRywwREFBYyxFQUFFO0lBRXBDLGtFQUFzQixDQUFDLEtBQUssSUFBSSxFQUFFO1FBQzlCLElBQUksZ0VBQTBCLEVBQUUsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDckQsSUFBSSxnQkFBZ0IsRUFBRTtnQkFDbEIsZ0JBQWdCLEdBQUcsS0FBSztnQkFDeEIsT0FBTTthQUNUO1lBRUQsTUFBTSxJQUFJLEdBQUcsd0RBQWtCLEVBQUU7WUFFakMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDdEUsTUFBTSxXQUFXLENBQUMsWUFBWSxDQUFDO29CQUMzQixZQUFZLEVBQUUsSUFBSTtvQkFDbEIsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUU7b0JBQzdCLElBQUksRUFBRSx3REFBa0IsRUFBRTtpQkFDN0IsQ0FBQztnQkFDRixVQUFVLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQzthQUNuRDtTQUNKO0lBQ0wsQ0FBQyxDQUFDO0FBRU4sQ0FBQztBQUVELE1BQU0sd0JBQXdCLEdBQUcsR0FBRyxFQUFFO0lBQ2xDLGlFQUFxQixFQUFFO0FBQzNCLENBQUM7QUFFRCw4REFBOEQ7QUFDOUQsSUFBSSwwREFBZSxDQUFDLHFCQUFxQixDQUFDO0lBQ3RDLHlCQUF5QixFQUFFO0FBRS9CLCtEQUF3QixDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7SUFDdEQsSUFBSSxLQUFLO1FBQ0wseUJBQXlCLEVBQUU7O1FBRTNCLHdCQUF3QixFQUFFO0FBQ2xDLENBQUMsQ0FBQztBQUlGLDhFQUE4RTtBQUM5RSwyRUFBMkU7QUFFM0UsMEJBQTBCO0FBQzFCLElBQUksVUFBVTtBQUNkLDBCQUEwQjtBQUMxQixJQUFJLGVBQWU7QUFFbkIsSUFBSSxzQkFBc0IsR0FBRyxFQUFFO0FBRS9CLE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCO0FBRTdDLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxFQUFFO0lBQzdCLDZEQUF1QixDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRTtRQUM5QyxJQUFJO1lBQ0EsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRywwREFBaUIsRUFBRTtZQUNwQyx5REFBbUIsQ0FBQyw0REFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDakQ7UUFBQyxPQUFPLENBQUMsRUFBRSxHQUFHO0lBQ25CLENBQUMsQ0FBQztBQUNOLENBQUM7QUFFRCxNQUFNLHFCQUFxQixHQUFHLEdBQUcsRUFBRTtJQUMvQiwrREFBeUIsQ0FBQyxtQkFBbUIsQ0FBQztBQUNsRCxDQUFDO0FBRUQsTUFBTSxxQkFBcUIsR0FBRyxHQUFHLEVBQUU7SUFFL0IsTUFBTSxXQUFXLEdBQUcsaUVBQTJCLEVBQUU7SUFFakQsZUFBZSxHQUFHLElBQUksbURBQWEsQ0FBQztRQUNoQyxJQUFJLEVBQUUsS0FBSztRQUNYLFdBQVcsRUFBRSxJQUFJO1FBQ2pCLEtBQUssRUFBRSxHQUFHO1FBQ1YsTUFBTSxFQUFFLEdBQUc7UUFDWCxTQUFTLEVBQUUsS0FBSztRQUNoQixlQUFlLEVBQUUscUVBQStCLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUztRQUN4RSxhQUFhLEVBQUUsUUFBUTtRQUN2QixDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDaEIsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ2hCLGNBQWMsRUFBRTtZQUNaLE9BQU8sRUFBRSxnREFBUyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUM7WUFDM0MsUUFBUSxFQUFFLENBQUMsb0RBQWM7WUFDekIsV0FBVyxFQUFFLEtBQUs7U0FDckI7S0FDSixDQUFDO0lBRUYsc0JBQXNCLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlO0lBRXhFLGVBQWUsQ0FBQyxVQUFVLEVBQUU7SUFDNUIsZUFBZSxDQUFDLE9BQU8sQ0FBQyw4REFBZSxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBR3pFLGVBQWUsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtRQUM1QixlQUFlLENBQUMsS0FBSyxFQUFFO0lBQzNCLENBQUMsQ0FBQztJQUVGLGVBQWUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUM3QixPQUFPLHNCQUFzQixDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDO1FBQzdELGVBQWUsR0FBRyxJQUFJO0lBQzFCLENBQUMsQ0FBQztBQUVOLENBQUM7QUFFRCxNQUFNLHNCQUFzQixHQUFHLEdBQUcsRUFBRTtJQUNoQyxJQUFJLFVBQVUsRUFBRTtRQUNaLFVBQVUsQ0FBQyxLQUFLLEVBQUU7S0FDckI7U0FBTTtRQUNILGdCQUFnQixFQUFFO0tBQ3JCO0FBQ0wsQ0FBQztBQUVELE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxFQUFFO0lBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLENBQUM7SUFDeEMsNkJBQTZCO0lBQzdCLFVBQVUsR0FBRyxJQUFJLG1EQUFhLENBQUM7UUFDM0IsSUFBSSxFQUFFLEtBQUs7UUFDWCxLQUFLLEVBQUUsR0FBRztRQUNWLE1BQU0sRUFBRSxHQUFHO1FBQ1gsU0FBUyxFQUFFLEdBQUc7UUFDZCxRQUFRLEVBQUUsR0FBRztRQUNiLGVBQWUsRUFBRSxxRUFBK0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ3hFLGFBQWEsRUFBRSxRQUFRO1FBQ3ZCLGVBQWUsRUFBRTtZQUNiLEtBQUssRUFBRSxxRUFBK0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQzlELFdBQVcsRUFBRSxxRUFBK0IsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQ2xFLE1BQU0sRUFBRSxFQUFFO1NBQ2I7UUFDRCxjQUFjLEVBQUU7WUFDWixPQUFPLEVBQUUsZ0RBQVMsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDO1lBQzNDLFFBQVEsRUFBRSxDQUFDLG9EQUFjO1lBQ3pCLFdBQVcsRUFBRSxLQUFLO1lBQ2xCLE9BQU8sRUFBRSxJQUFJO1NBQ2hCO0tBQ0osQ0FBQztJQUVGLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVTtJQUU5RCxVQUFVLENBQUMsVUFBVSxFQUFFO0lBRXZCLHFCQUFxQjtJQUNyQixVQUFVLENBQUMsT0FBTyxDQUFDLDhEQUFlLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLG9EQUFjO1FBQ2YsVUFBVSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUU7SUFFekMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1FBQ3hCLE9BQU8sc0JBQXNCLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDeEQsVUFBVSxHQUFHLElBQUk7SUFDckIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELE1BQU0sT0FBTyxHQUFHLEdBQUcsRUFBRTtJQUNqQixJQUFJLG9EQUFjLEVBQUU7UUFDaEIsK0RBQXdCLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNuRCxJQUFJLEtBQUs7Z0JBQ0wsdURBQWUsRUFBRTs7Z0JBRWpCLHlEQUFpQixFQUFFO1FBQzNCLENBQUMsQ0FBQztLQUNMO0lBRUQsc0RBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLDhDQUFRLEVBQUUsQ0FBQztJQUVoRSw0Q0FBTSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtRQUMzQixzQkFBc0IsRUFBRTtJQUM1QixDQUFDLENBQUM7SUFFRiwyREFBMkQ7SUFDM0QsSUFBSSwwREFBZSxDQUFDLHFCQUFxQixDQUFDO1FBQ3RDLHdEQUFnQixFQUFFO0lBRXRCLCtEQUF3QixDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7UUFDdEQsSUFBSSxLQUFLO1lBQ0wsd0RBQWdCLEVBQUU7O1lBRWxCLHlEQUFpQixFQUFFO0lBQzNCLENBQUMsQ0FBQztJQUVGLHVEQUF1RDtJQUN2RCxJQUFJLDBEQUFlLENBQUMsbUJBQW1CLENBQUM7UUFDcEMsbUJBQW1CLEVBQUU7SUFFekIsK0RBQXdCLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUNwRCxJQUFJLEtBQUs7WUFDTCxtQkFBbUIsRUFBRTs7WUFFckIscUJBQXFCLEVBQUU7SUFDL0IsQ0FBQyxDQUFDO0lBRUYsNkRBQXVCLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFO1FBQzVDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDbEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUM7WUFDdEIscUJBQXFCLEVBQUU7U0FDMUI7SUFDTCxDQUFDLENBQUM7SUFFRiw0REFBbUIsRUFBRTtJQUNyQixnREFBVSxDQUFDLGlCQUFpQixFQUFFLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFO1FBQ3ZDLGdCQUFnQixHQUFHLElBQUk7UUFDdkIseURBQW1CLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUMsQ0FBQztJQUVGLHFEQUFxRDtJQUNyRCxtREFBbUQ7SUFDbkQsa0VBQWtFO0lBQ2xFLHNEQUFzRDtJQUN0RCxnREFBVSxDQUFDLG9CQUFvQixFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUU7UUFDcEMsTUFBTSxNQUFNLEdBQUcsc0JBQXNCLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDbkQsTUFBTSxDQUFDLElBQUksRUFBRTtJQUNqQixDQUFDLENBQUM7SUFFRixJQUFJLENBQUMsK0NBQU8sRUFBRSxFQUFFO1FBRVosZ0JBQWdCLEVBQUU7S0FDckI7QUFFTCxDQUFDO0FBRUQsaUVBQWUsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pPcUQ7QUFDL0I7QUFDRztBQUNiO0FBRWxDLE1BQU0sY0FBYyxHQUFHLEdBQUcsRUFBRTtJQUN4QixNQUFNLE9BQU8sR0FBRywwREFBZSxDQUFDLHFCQUFxQixDQUFDO0lBQ3RELE1BQU0sUUFBUSxHQUFHLDBEQUFlLENBQUMsZUFBZSxDQUFDO0lBQ2pELE1BQU0sU0FBUyxHQUFHLDBEQUFlLENBQUMsZ0JBQWdCLENBQUM7SUFDbkQsT0FBTyxJQUFJLDJEQUFXLENBQ2xCLFdBQVcsT0FBTyx5QkFBeUIsRUFDM0MsU0FBUyxFQUNULElBQUksa0VBQWtCLENBQUMsUUFBUSxDQUFDLENBQ25DO0FBRUwsQ0FBQztBQUVELE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRTtJQUN4QywwREFBb0IsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDO0lBQ3hDLHNFQUFnQyxFQUFFO0FBQ3RDLENBQUM7QUFFRCxNQUFNLHFCQUFxQixHQUFHLEdBQUcsRUFBRTtJQUMvQiwwRUFBb0MsRUFBRTtJQUN0QyxxRUFBK0IsRUFBRTtBQUNyQyxDQUFDO0FBR0QsTUFBTSxVQUFVLEdBQUcsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFO0lBQ2hDLE1BQU0sSUFBSSxHQUFHLEVBQUU7SUFDZixNQUFNLFdBQVcsR0FBRyxjQUFjLEVBQUU7SUFDcEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEMsTUFBTSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNO0lBQzVDLE1BQU0sVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUMsYUFBYTtJQUNsRixJQUFJLEtBQUssRUFBRSxNQUFNLE1BQU0sSUFBSSxXQUFXLENBQUMsWUFBWSxDQUFDO1FBQ2hELFlBQVksRUFBRTtZQUNWLE1BQU0sRUFBRSxxREFBSyxpQkFBZ0IsVUFBVSxFQUFFO1NBQzVDO0tBQ0osQ0FBQyxFQUFFO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNOLElBQUksRUFBRSxNQUFNLENBQUMsU0FBUztZQUN0QixFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU07WUFDakIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxZQUFZO1lBQzNCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtTQUNwQixDQUFDO0tBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVELG9EQUFjLENBQUMsc0JBQXNCLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRTtJQUN4RCxPQUFPLE1BQU0sVUFBVSxDQUFDLE1BQU0sQ0FBQztBQUNuQyxDQUFDLENBQUM7QUFFc0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkR6QjtBQUUvQyxpRUFBZSxLQUFLLEVBQUUsSUFBWSxFQUFFLEVBQUU7SUFDckMsTUFBTSxHQUFHLEdBQUcsT0FBTztJQUNuQixNQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsSUFBSSxFQUFFLEVBQUUsV0FBVyxDQUFDO0lBRXJFLE1BQU0sTUFBTSxHQUFHLE1BQU0sNERBQWEsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFXO0lBQ3ZELElBQUksR0FBRztJQUVQLEdBQUcsR0FBRyxxQ0FBcUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3hELEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO0lBRXZDLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDO0tBQ3pDO0lBRUQsT0FBTyxHQUFhO0FBQ3JCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakI4QztBQUUvQyxpRUFBZSxLQUFLLElBQUksRUFBRTtJQUN6QixNQUFNLEdBQUcsR0FBRyxPQUFPO0lBQ25CLE1BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUM7SUFFMUMsTUFBTSxNQUFNLEdBQUcsTUFBTSw0REFBYSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUM7SUFDN0MsSUFBSSxHQUFHO0lBRVAsR0FBRyxHQUFHLHlCQUF5QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDNUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7SUFFdkMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUM7S0FDckM7SUFFRCxPQUFPLEdBQWE7QUFDckIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakI2QjtBQUM5QixNQUFNLFFBQVEsR0FBRyxNQUFNO0FBQ3ZCLE1BQU0sU0FBUyxHQUFHLEtBQUs7QUFFdkIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFnQixFQUFpQixFQUFFO0lBQ3RELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTO0lBQ2pELE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDbEMsNkNBQVMsQ0FBQyxxQ0FBcUMsVUFBVSxFQUFFLEVBQ3ZELEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxFQUN0QixDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ04sSUFBSSxDQUFDLEtBQUs7Z0JBQ04sR0FBRyxFQUFFOztnQkFFTCxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ2xCLENBQUMsQ0FDSjtJQUNMLENBQUMsQ0FBQztBQUNOLENBQUM7QUFFRCxNQUFNLGFBQWEsR0FBRyxHQUFxQixFQUFFO0lBQ3pDLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDNUIsNkNBQVMsQ0FBQyxlQUFlLEVBQ3JCLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxFQUN0QixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNkLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1IsSUFBSSxHQUFHLEdBQUcsd0NBQXdDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDMUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO2FBQ3pDOztnQkFFRyxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ2xCLENBQUMsQ0FDSjtJQUNMLENBQUMsQ0FBQztBQUNOLENBQUM7QUFFc0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNUO0FBRTlCLE1BQU0sV0FBVyxHQUFHLFNBQVM7QUFFN0IsTUFBTSxPQUFPLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO0FBRXhELE1BQU0sZUFBZSxHQUFHLEdBQUcsRUFBRTtJQUN6Qiw4REFBd0IsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQztBQUN4RSxDQUFDO0FBRUQsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7SUFDM0IsOERBQXdCLENBQUMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDcEQsQ0FBQztBQUVxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2RSO0FBQ0M7QUFDUjtBQUNvQjtBQUNFO0FBQ0E7QUFDL0I7QUFDTTtBQUVwQyxpRUFBZSxHQUFHLEVBQUU7SUFDaEIsb0RBQWMsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLElBQUksRUFBRTtRQUUxQyxNQUFNLE1BQU0sR0FBRyxNQUFNLDREQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDLENBQVc7UUFDeEYsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFbkQsQ0FBQyxDQUFDO0lBRUYsb0RBQWMsQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFO1FBQzFELE1BQU0sTUFBTSxHQUFHLE1BQU0sNERBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDdEUsT0FBTyxNQUFNO0lBRWpCLENBQUMsQ0FBQztJQUVGLG9EQUFjLENBQUMsNkJBQTZCLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDckQsT0FBTyxNQUFNLDBEQUFhLEVBQUU7SUFDaEMsQ0FBQyxDQUFDO0lBRUYsb0RBQWMsQ0FBQyw4QkFBOEIsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQy9ELE9BQU8sTUFBTSwwREFBYSxDQUFDLEtBQUssQ0FBQztJQUNyQyxDQUFDLENBQUM7SUFFRixvREFBYyxDQUFDLDBCQUEwQixFQUFFLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFO1FBQ3ZELE9BQU8sMERBQWUsQ0FBQyxPQUFPLENBQUM7SUFDbkMsQ0FBQyxDQUFDO0lBRUYsb0RBQWMsQ0FBQywwQkFBMEIsRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDOUQsT0FBTywwREFBZSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7SUFDMUMsQ0FBQyxDQUFDO0lBRUYsb0RBQWMsQ0FBQyxlQUFlLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUMvQyxPQUFPLGlEQUFXLENBQUMsSUFBSSxDQUFDO0lBQzVCLENBQUMsQ0FBQztJQUdGLG9EQUFjLENBQUMsd0JBQXdCLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUN4RCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQzVCLDZDQUFTLENBQUMsdUNBQXVDLElBQUksaUNBQWlDLEVBQ2xGLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUNyQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDZCxJQUFJLEtBQUs7b0JBQ0wsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7Z0JBRXRCLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxPQUFTLENBQUM7Z0JBQy9ELEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUMxQyxDQUFDLENBQUM7UUFDVixDQUFDLENBQUM7SUFDTixDQUFDLENBQUM7SUFFRixvREFBYyxDQUFDLDJCQUEyQixFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUU7UUFDL0QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztJQUNoQyxDQUFDLENBQUM7SUFFRixvREFBYyxDQUFDLGlCQUFpQixFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7UUFFakQsMkRBQTJEO1FBQzNELElBQUksSUFBSSxJQUFJLHdCQUF3QixFQUFFO1lBQ2xDLE9BQU8sdURBQVUsRUFBRTtTQUN0QjtRQUVELE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDbEMsNkNBQVMsQ0FBQyxpREFBaUQsSUFBSSxpQ0FBaUMsRUFDNUYsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQ3JCLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ04sSUFBSSxLQUFLO29CQUNMLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUN0QixHQUFHLEVBQUU7WUFDVCxDQUFDLENBQUM7UUFDVixDQUFDLENBQUM7SUFDTixDQUFDLENBQUM7SUFFRixnREFBVSxDQUFDLGVBQWUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFO1FBRTNDLDJEQUEyRDtRQUMzRCxJQUFJLElBQUksSUFBSSx3QkFBd0IsRUFBRTtZQUNsQyxNQUFNLDREQUFhLENBQUMsVUFBVSxFQUFFLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUM5RDtRQUVELDREQUFzQixDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDLENBQUM7SUFFRixvREFBYyxDQUFDLGdDQUFnQyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3hELE1BQU0sSUFBSSxHQUFHLE1BQU0sd0RBQVcsRUFBRTtRQUNoQyxNQUFNLFFBQVEsR0FBRyxNQUFNLDREQUFlLENBQUMsSUFBSSxDQUFDO1FBRTVDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQzdCLENBQUMsQ0FBQztJQUVGLG9EQUFjLENBQUMsNEJBQTRCLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDcEQsTUFBTSxNQUFNLEdBQUcsTUFBTSw0REFBYSxDQUFDLDJEQUFZLENBQUMsbUNBQW1DLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xHLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO0lBQ3JDLENBQUMsQ0FBQztJQUVGLG9EQUFjLENBQUMsMEJBQTBCLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDbEQsTUFBTSxNQUFNLEdBQUcsTUFBTSw0REFBYSxDQUFDLDJEQUFZLENBQUMsbUNBQW1DLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQy9GLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3RELENBQUMsQ0FBQztJQUVGLG9EQUFjLENBQUMsd0JBQXdCLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUN6RCxNQUFNLE1BQU0sR0FBRyxNQUFNLDREQUFhLENBQUMsMkRBQVksQ0FBQyxtQ0FBbUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzVHLENBQUMsQ0FBQztJQUdGLG9EQUFjLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDeEMsT0FBTyxvREFBYyxFQUFFO0lBQzNCLENBQUMsQ0FBQztBQUVOLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BINkI7QUFDWDtBQUNJO0FBQ2M7QUFDNEI7QUFFakUsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlO0FBRXhDLE1BQU0sZ0JBQWdCLEdBQUcsZ0RBQVMsQ0FBQyxpREFBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFLGdCQUFnQixDQUFDO0FBRTdFLE1BQU0sSUFBSSxHQUFHLHNEQUFlLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDOUQsSUFBSSxJQUFjO0FBRWxCLElBQUk7SUFDQSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQWE7Q0FDakQ7QUFBQyxPQUFPLENBQUMsRUFBRTtJQUNSLElBQUksR0FBRyxFQUFFLEdBQUcsZ0VBQWEsRUFBRTtJQUMzQix1REFBZ0IsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQzNEO0FBT0QsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLGdEQUFZLEVBQTBCO0FBRXhFLE1BQU0sZUFBZSxHQUFHLENBQTJCLE9BQVUsRUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUU1RixNQUFNLGVBQWUsR0FBRyxDQUEyQixPQUFVLEVBQUUsS0FBa0IsRUFBRSxFQUFFO0lBQ2pGLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLO0lBQ3JCLHVEQUFnQixDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEQscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFDOUMsQ0FBQztBQUVpRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkN4QjtBQUNuQjtBQUNJO0FBRTNCLElBQUksSUFBVTtBQUVkLElBQUksSUFBVTtBQUVkLElBQUksU0FBZTtBQUVuQixJQUFJLFFBQWM7QUFFbEIsTUFBTSxnQkFBZ0IsR0FBRyxHQUFHLEVBQUU7SUFDMUIsSUFBSSxHQUFHLElBQUksMENBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1FBQzNCLHFEQUFZLENBQUMsWUFBWSxDQUFDO0lBQzlCLENBQUMsQ0FBQztJQUVGLElBQUksR0FBRyxJQUFJLDBDQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUMzQixxREFBWSxDQUFDLFlBQVksQ0FBQztJQUM5QixDQUFDLENBQUM7SUFFRixTQUFTLEdBQUcsSUFBSSwwQ0FBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QyxTQUFTLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7UUFDaEMscURBQVksQ0FBQyxZQUFZLENBQUM7SUFDOUIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELE1BQU0saUJBQWlCLEdBQUcsR0FBRyxFQUFFO0lBQzNCLElBQUksQ0FBQyxPQUFPLEVBQUU7SUFDZCxJQUFJLENBQUMsT0FBTyxFQUFFO0lBQ2QsU0FBUyxDQUFDLE9BQU8sRUFBRTtBQUN2QixDQUFDO0FBRUQsTUFBTSxjQUFjLEdBQUcsb0RBQWM7SUFDakMsQ0FBQyxDQUFDLGdEQUFTLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUM7SUFDNUMsQ0FBQyxDQUFDLGdEQUFTLENBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQztBQUUxQyxNQUFNLFlBQVksR0FBRyxDQUFDLEdBQUcsS0FBZSxFQUFVLEVBQUU7SUFDaEQsT0FBTyxnREFBUyxDQUFDLGNBQWMsRUFBRSxHQUFHLEtBQUssQ0FBQztBQUM5QyxDQUFDO0FBRUQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLEVBQUU7SUFHbEQsUUFBUSxHQUFHLElBQUksMENBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDaEQsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1FBQy9CLFlBQVksRUFBRTtJQUNsQixDQUFDLENBQUM7SUFFRixRQUFRLENBQUMsY0FBYyxDQUFDLDREQUFzQixDQUFDO1FBQzNDO1lBQ0ksS0FBSyxFQUFFLE1BQU07WUFDYixLQUFLLEVBQUUsR0FBRyxFQUFFO2dCQUNSLFlBQVksRUFBRTtZQUNsQixDQUFDO1NBQ0o7UUFDRDtZQUNJLEtBQUssRUFBRSxNQUFNO1lBQ2IsS0FBSyxFQUFFLEdBQUcsRUFBRTtnQkFDUixZQUFZLEVBQUUsRUFBQyx5QkFBeUI7WUFDNUMsQ0FBQztTQUNKO0tBQ0osQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQUU2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25FOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsNkNBQTZDLFVBQVUsc0RBQXNELGNBQWM7QUFDNUksMEJBQTBCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGtCQUFrQjtBQUM3STtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QztBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdlBhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEckMsaUVBQWUsY0FBYyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLHlDQUF5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBeEc7QUFDNUIsdUNBQXVDOztBQUV2QztBQUNlO0FBQ2Y7QUFDQSxJQUFJLDREQUFxQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Z0JBQTRnQjtBQUM1Z0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVCRztBQUNZOztBQUV2QztBQUNBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHlEQUFTO0FBQ2xCOztBQUVBLGlFQUFlLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QmM7O0FBRS9CO0FBQ0EscUNBQXFDLHNEQUFVO0FBQy9DOztBQUVBLGlFQUFlLFFBQVE7Ozs7Ozs7Ozs7QUNOdkI7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiw0QkFBNEI7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLDRDQUFPOztBQUU3QjtBQUNBLHdDQUF3QyxJQUFJLE1BQU0sZ0JBQWdCOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLLEtBQUs7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwrQkFBK0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLCtCQUErQjtBQUN6Qzs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0EsT0FBTyxLQUFLOztBQUVaLFlBQVk7QUFDWjs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUEsYUFBYTs7QUFFYixlQUFlOztBQUVmLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYixXQUFXLDhDQUFzQjtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGtFQUFrQjtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVztBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBYTs7QUFFeEM7QUFDQSxtQkFBbUIsU0FBUyxHQUFHLGlCQUFpQjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7Ozs7Ozs7Ozs7O0FDL0RZO0FBQ1o7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSiwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMEJBQTBCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJCQUEyQjtBQUMzRTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLDhCQUE4QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHlEQUFlO0FBQ3pCLEVBQUU7Ozs7Ozs7Ozs7OztBQ3phRjs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FzQztBQUNmO0FBQ2tCO0FBQ0Y7QUFDdkMsa0JBQWtCLHlDQUFZLENBQUMsdURBQWEsQ0FBQyxnR0FBZTtBQUM1RDtBQUNBLHFDQUFxQyxnREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLG1CQUFtQix1REFBUSxDQUFDLHNDQUFTO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVEsQ0FBQyxzQ0FBUztBQUNyQztBQUNBO0FBQ0EsbUJBQW1CLHVEQUFRLENBQUMsc0NBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLDRCQUE0QixFQUFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RCtCO0FBQ0g7O0FBRTVCLHlCQUF5QiwrQ0FBUyxDQUFDLCtDQUFrQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlFQUFpRSxFQUFFO0FBQ2pJOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RixvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsa0JBQWtCLCtDQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RixvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELCtDQUFrQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGLHlCQUF5QjtBQUN6RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpRUFBZSxrQkFBa0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSkM7QUFDQztBQUNVO0FBQ1o7QUFDTDtBQUNVO0FBQ1I7QUFDUTtBQUNBO0FBQ1I7O0FBRS9CLGtCQUFrQiw4Q0FBWSxDQUFDLHVEQUFhLENBQUMsNEZBQWU7QUFDNUQsa0JBQWtCLG9EQUFTLENBQUMsd0RBQXFCOztBQUVqRCx5QkFBeUIsMkNBQVM7O0FBRWxDO0FBQ0EscUJBQXFCLHFEQUFVO0FBQy9CLHFDQUFxQyxnREFBSyxDQUFDLDJDQUFTLG9CQUFvQixnQkFBZ0I7QUFDeEY7O0FBRUE7QUFDQSwyQkFBMkIsb0RBQU8sT0FBTyw2Q0FBZSxJQUFJLG1EQUFVO0FBQ3RFO0FBQ0E7O0FBRWU7QUFDZixLQUFLLGtEQUFnQjtBQUNyQixRQUFRLCtDQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssa0RBQWdCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q21EOztBQUU1QztBQUNQO0FBQ0EsUUFBUSxvREFBaUI7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxFQUFFLCtDQUFhO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJtQztBQUNWO0FBQ0c7O0FBRXJCLGdCQUFnQixrREFBZ0I7O0FBRXZDOztBQUVBO0FBQ0EsUUFBUSxRQUFROztBQUVoQjtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaURBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLEtBQStCLEVBQUUsRUFFcEM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSw2Q0FBZ0I7QUFDeEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSx1Q0FBVTtBQUNsQjs7QUFFTztBQUNQOztBQUVBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlGeUI7O0FBRVY7QUFDZixzQkFBc0IsaURBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVnlDO0FBQ0o7O0FBRXJDOztBQUVlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsdURBQVU7QUFDcEcsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLHlEQUFZO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDb0I7QUFDa0M7O0FBRXREO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQVUsd0JBQXdCLHVDQUFVOztBQUVwRCw0QkFBNEIsMEJBQTBCLElBQUk7QUFDekUsMkRBQTJELGdFQUFrQiwrQkFBK0I7O0FBRTVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZlLHFEQUFxRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckM2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxnQkFBZ0I7QUFDckg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUdBQXlHLFlBQVksTUFBTSxtQkFBbUI7QUFDOUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix1REFBYztBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcE1tQjtBQUNJO0FBQ3VDOztBQUVyRSxvQkFBb0IsK0NBQU87QUFDM0I7O0FBRUE7QUFDQSxvQ0FBb0Msb0NBQW9DLElBQUksTUFBTSxHQUFHO0FBQ3JGO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxJQUFJLFdBQVc7QUFDeEQsaUNBQWlDLFFBQVEsY0FBYztBQUN2RCxnQ0FBZ0MsZUFBZSxNQUFNLFFBQVEsS0FBSyxnQkFBZ0IsR0FBRztBQUNyRixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1AsQ0FBQyxxRkFBc0M7QUFDdkMsUUFBUSxRQUFRLFFBQVEsa0NBQUs7QUFDN0I7QUFDQTs7QUFFTztBQUNQLENBQUMscUZBQXNDO0FBQ3ZDLFFBQVEsUUFBUSxFQUFFLHVDQUFVO0FBQzVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDeUM7QUFDYTs7QUFFdkM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRkFBc0YsY0FBYztBQUNwRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDJGQUEyRixjQUFjO0FBQ3pHOztBQUVBLDBCQUEwQixHQUFHO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUcsS0FBSyxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IseURBQVk7QUFDbEMsc0JBQXNCLFFBQVE7QUFDOUIsdUJBQXVCLFFBQVE7QUFDL0IsMEJBQTBCLGdFQUFrQixnQ0FBZ0MsZ0VBQWtCO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkZBQTJGLGNBQWM7QUFDekc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25JZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWc0Q7O0FBRXZDO0FBQ2YsUUFBUSxnRUFBa0IsRUFBRSxXQUFXO0FBQ3ZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7VUNKQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FDTjhCO0FBQzlCLDBDQUEwQztBQUNUO0FBQ2pDLDBDQUEwQztBQUUxQyxJQUFJLE9BQU8sR0FBRyxJQUFJO0FBRWxCLG9GQUFvRjtBQUNwRixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixJQUFJO0FBRUosZ0VBQWdFO0FBQ2hFLElBQUksQ0FBQyxtRUFBNkIsRUFBRSxFQUFFO0lBQ2xDLE9BQU8sR0FBRyxLQUFLO0lBQ2YsOENBQVEsRUFBRTtDQUNiO0FBRUQsSUFBSSxPQUFPLEVBQUU7SUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztJQUNuQixtREFBYSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLHNEQUFPLEVBQUUsQ0FBQyxDQUFDO0lBRXRDLDRDQUFNLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRTtRQUMvQixpREFBaUQ7SUFDckQsQ0FBQyxDQUFDO0NBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvYWJvcnQtY29udHJvbGxlci9kaXN0LWVzbS9zcmMvQWJvcnRDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvYWJvcnQtY29udHJvbGxlci9kaXN0LWVzbS9zcmMvQWJvcnRTaWduYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWF1dGgvZGlzdC1lc20vc3JjL2F6dXJlTmFtZWRLZXlDcmVkZW50aWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1hdXRoL2Rpc3QtZXNtL3NyYy9henVyZVNBU0NyZWRlbnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWF1dGgvZGlzdC1lc20vc3JjL3Rva2VuQ3JlZGVudGlhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtYXV0aC9kaXN0LWVzbS9zcmMvdHlwZWd1YXJkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtY2xpZW50L2Rpc3QtZXNtL3NyYy9hdXRob3JpemVSZXF1ZXN0T25UZW5hbnRDaGFsbGVuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWNsaWVudC9kaXN0LWVzbS9zcmMvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1jbGllbnQvZGlzdC1lc20vc3JjL2Rlc2VyaWFsaXphdGlvblBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtY2xpZW50L2Rpc3QtZXNtL3NyYy9odHRwQ2xpZW50Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWNsaWVudC9kaXN0LWVzbS9zcmMvaW50ZXJmYWNlSGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtY2xpZW50L2Rpc3QtZXNtL3NyYy9pbnRlcmZhY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1jbGllbnQvZGlzdC1lc20vc3JjL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtY2xpZW50L2Rpc3QtZXNtL3NyYy9vcGVyYXRpb25IZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1jbGllbnQvZGlzdC1lc20vc3JjL3BpcGVsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1jbGllbnQvZGlzdC1lc20vc3JjL3NlcmlhbGl6YXRpb25Qb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWNsaWVudC9kaXN0LWVzbS9zcmMvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtY2xpZW50L2Rpc3QtZXNtL3NyYy9zZXJ2aWNlQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1jbGllbnQvZGlzdC1lc20vc3JjL3VybEhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLWNsaWVudC9kaXN0LWVzbS9zcmMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXBhZ2luZy9kaXN0LWVzbS9zcmMvZ2V0UGFnZWRBc3luY0l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1wYWdpbmcvZGlzdC1lc20vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1wYWdpbmcvZGlzdC1lc20vc3JjL21vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9jcmVhdGVQaXBlbGluZUZyb21PcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9kZWZhdWx0SHR0cENsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvaHR0cEhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvbm9kZUh0dHBDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3BpcGVsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9waXBlbGluZVJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3BvbGljaWVzL2JlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3BvbGljaWVzL2RlY29tcHJlc3NSZXNwb25zZVBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvcG9saWNpZXMvZGVmYXVsdFJldHJ5UG9saWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9wb2xpY2llcy9mb3JtRGF0YVBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvcG9saWNpZXMvbG9nUG9saWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9wb2xpY2llcy9wcm94eVBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvcG9saWNpZXMvcmVkaXJlY3RQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3BvbGljaWVzL3JldHJ5UG9saWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9wb2xpY2llcy9zZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3BvbGljaWVzL3Rsc1BvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvcG9saWNpZXMvdHJhY2luZ1BvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvcG9saWNpZXMvdXNlckFnZW50UG9saWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy9yZXN0RXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3JldHJ5U3RyYXRlZ2llcy9leHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3JldHJ5U3RyYXRlZ2llcy90aHJvdHRsaW5nUmV0cnlTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvdXRpbC9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy91dGlsL2luc3BlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmUvZGlzdC1lc20vc3JjL3V0aWwvc2FuaXRpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy91dGlsL3Rva2VuQ3ljbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lL2Rpc3QtZXNtL3NyYy91dGlsL3VzZXJBZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvdXRpbC91c2VyQWdlbnRQbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZS9kaXN0LWVzbS9zcmMvdXRpbC91dWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS10cmFjaW5nL2Rpc3QtZXNtL3NyYy9pbnN0cnVtZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXRyYWNpbmcvZGlzdC1lc20vc3JjL3RyYWNpbmdDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXRyYWNpbmcvZGlzdC1lc20vc3JjL3RyYWNpbmdDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS11dGlsL2Rpc3QtZXNtL3NyYy9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUtdXRpbC9kaXN0LWVzbS9zcmMvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS11dGlsL2Rpc3QtZXNtL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9jb3JlLXV0aWwvZGlzdC1lc20vc3JjL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2NvcmUteG1sL2Rpc3QtZXNtL3NyYy94bWwuY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvY29yZS14bWwvZGlzdC1lc20vc3JjL3htbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9UYWJsZUNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9UYWJsZVBvbGljaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvZGF0YS10YWJsZXMvZGlzdC1lc20vc3JjL1RhYmxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvY29zbW9zUGF0aFBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9nZW5lcmF0ZWQvZ2VuZXJhdGVkQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvZGF0YS10YWJsZXMvZGlzdC1lc20vc3JjL2dlbmVyYXRlZC9tb2RlbHMvbWFwcGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9nZW5lcmF0ZWQvbW9kZWxzL3BhcmFtZXRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvZ2VuZXJhdGVkL29wZXJhdGlvbnMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9nZW5lcmF0ZWQvb3BlcmF0aW9ucy90YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvb2RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvc2VyaWFsaXphdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy90YWJsZXNOYW1lZENyZWRlbnRpYWxQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdGFibGVzU0FTVG9rZW5Qb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvYWNjb3VudENvbm5lY3Rpb25TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvYXBpVmVyc2lvblBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9iYXNlVHJhbnNhY3Rpb25IZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvZGF0YS10YWJsZXMvZGlzdC1lc20vc3JjL3V0aWxzL2J1ZmZlclNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvY2hhbGxlbmdlQXV0aGVudGljYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9jb21wdXRlSE1BQ1NIQTI1Ni5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9jb25uZWN0aW9uU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvZGF0YS10YWJsZXMvZGlzdC1lc20vc3JjL3V0aWxzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9jb250aW51YXRpb25Ub2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9lcnJvckhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvaXNDb3Ntb3NFbmRwb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy9pc0NyZWRlbnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvdHJhY2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2RhdGEtdGFibGVzL2Rpc3QtZXNtL3NyYy91dGlscy90cmFuc2FjdGlvbkhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvdHJhbnNhY3Rpb25IZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvZGF0YS10YWJsZXMvZGlzdC1lc20vc3JjL3V0aWxzL3RydW5jYXRlSVNPODA2MURhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9kYXRhLXRhYmxlcy9kaXN0LWVzbS9zcmMvdXRpbHMvdXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF6dXJlL2xvZ2dlci9kaXN0LWVzbS9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9sb2dnZXIvZGlzdC1lc20vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbG9nZ2VyL2Rpc3QtZXNtL3NyYy9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW5kcmVzb3JodXMvZGYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW5kcmVzb3JodXMvZGYvbm9kZV9tb2R1bGVzL2V4ZWNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2luZHJlc29yaHVzL2RmL25vZGVfbW9kdWxlcy9leGVjYS9saWIvY29tbWFuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbmRyZXNvcmh1cy9kZi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2luZHJlc29yaHVzL2RmL25vZGVfbW9kdWxlcy9leGVjYS9saWIva2lsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbmRyZXNvcmh1cy9kZi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW5kcmVzb3JodXMvZGYvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdGRpby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbmRyZXNvcmh1cy9kZi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbmRyZXNvcmh1cy9kZi9ub2RlX21vZHVsZXMvbnBtLXJ1bi1wYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdG9vdGFsbG5hdGUvb25jZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3Qvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3Qvc3JjL3Byb21pc2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9hYm9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvbGliL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvZGVmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9pdGVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi90ZXJtaW5hdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9wYXJhbGxlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvc2VyaWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9zZXJpYWxPcmRlcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21iaW5lZC1zdHJlYW0vbGliL2NvbWJpbmVkX3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi9lbm9lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvdXRpbC9yZWFkU2hlYmFuZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvcmVzb2x2ZUNvbW1hbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWxheWVkLXN0cmVhbS9saWIvZGVsYXllZF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZC1vZi1zdHJlYW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4ZWNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leGVjYS9saWIvY29tbWFuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leGVjYS9saWIva2lsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdGRpby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlY2Evbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vYnVmZmVyLXN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlY2Evbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvZnhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbGJ1aWxkZXIvanNvbjJ4bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1sYnVpbGRlci9vcmRlcmVkSnMyWG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9Eb2NUeXBlUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9PcHRpb25zQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9ub2RlMmpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL3htbE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvZm9ybV9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZXQtc3RyZWFtL2J1ZmZlci1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odHRwLXByb3h5LWFnZW50L2Rpc3QvYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0dHAtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvcmVhbHRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h1bWFuLXNpZ25hbHMvYnVpbGQvc3JjL3NpZ25hbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNleGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzZXhlL21vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzZXhlL3dpbmRvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWlub3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjb3MtdmVyc2lvbi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi12ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWNvcy12ZXJzaW9uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXJnZS1zdHJlYW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbWUtZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbWUtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb3VudC1wb2ludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW91bnQtcG9pbnQvbm9kZV9tb2R1bGVzL0BzaW5kcmVzb3JodXMvZGYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdW50LXBvaW50L25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnBtLXJ1bi1wYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29zLWhvbWVkaXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AtZmluYWxseS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1rZXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BpbmtpZS1wcm9taXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waW5raWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoZWJhbmctY29tbWFuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hlYmFuZy1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L3NpZ25hbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmlwLWZpbmFsLW5ld2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cm51bS9zdHJudW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N1ZG8tcHJvbXB0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL1NldHRpbmdzSXRlbXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9ib290c3RyYXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vY2xpcGJvYXJkLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL2dldFdpZmlQYXNzd29yZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9nZXRXaWZpU1NJRC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9oeXBlcnZpc29yLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL2xvZ2luLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL21lc3NhZ2VIYW5kbGVycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9zZXR0aW5ncy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi90cmF5cy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91c2VyLWhvbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3doaWNoL3doaWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94ZGctYmFzZWRpci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveGRnLXRyYXNoZGlyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImJ1ZmZlclwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY3J5cHRvXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJlbGVjdHJvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTpjaGlsZF9wcm9jZXNzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJub2RlOmZzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJub2RlOmZzL3Byb21pc2VzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJub2RlOnBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6cHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTp1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6dXRpbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidGxzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ0dHlcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiemxpYlwiIiwid2VicGFjazovLy9leHRlcm5hbCB1bWQgXCJyb2JvdGpzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC1ldmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3J5cHRvLXJhbmRvbS1zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VtcHR5LXRyYXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbXB0eS10cmFzaC9ub2RlX21vZHVsZXMvcGF0aC1leGlzdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hY29zLXZlcnNpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AtZmlsdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wLWZpbHRlci9ub2RlX21vZHVsZXMvYWdncmVnYXRlLWVycm9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wLWZpbHRlci9ub2RlX21vZHVsZXMvY2xlYW4tc3RhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AtZmlsdGVyL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcC1maWx0ZXIvbm9kZV9tb2R1bGVzL2luZGVudC1zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AtZmlsdGVyL25vZGVfbW9kdWxlcy9wLW1hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnVuLWp4YS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3Vic3VtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3Vic3VtZS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaXF1ZS1zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy8uL3NyYy9tYWluL21haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicm9ib3Rqc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyb2JvdGpzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJyb2JvdGpzXCIpKSA6IGZhY3Rvcnkocm9vdFtcInJvYm90anNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoZ2xvYmFsLCAoX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yb2JvdGpzX18pID0+IHtcbnJldHVybiAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IEFib3J0U2lnbmFsLCBhYm9ydFNpZ25hbCB9IGZyb20gXCIuL0Fib3J0U2lnbmFsXCI7XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBoYXMgYmVlbiBhYm9ydGVkLlxuICogQ2hlY2sgZm9yIHRoaXMgZXJyb3IgYnkgdGVzdGluZyB0aGUgYG5hbWVgIHRoYXQgdGhlIG5hbWUgcHJvcGVydHkgb2YgdGhlXG4gKiBlcnJvciBtYXRjaGVzIGBcIkFib3J0RXJyb3JcImAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICogY29udHJvbGxlci5hYm9ydCgpO1xuICogdHJ5IHtcbiAqICAgZG9Bc3luY1dvcmsoY29udHJvbGxlci5zaWduYWwpXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICogICAgIC8vIGhhbmRsZSBhYm9ydCBlcnJvciBoZXJlLlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBBYm9ydENvbnRyb2xsZXIgcHJvdmlkZXMgYW4gQWJvcnRTaWduYWwgYW5kIHRoZSBhc3NvY2lhdGVkIGNvbnRyb2xzIHRvIHNpZ25hbFxuICogdGhhdCBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uIHNob3VsZCBiZSBhYm9ydGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBYm9ydCBhbiBvcGVyYXRpb24gd2hlbiBhbm90aGVyIGV2ZW50IGZpcmVzXG4gKiBgYGB0c1xuICogY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAqIGNvbnN0IHNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICogZG9Bc3luY1dvcmsoc2lnbmFsKTtcbiAqIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogU2hhcmUgYWJvcnRlciBjcm9zcyBtdWx0aXBsZSBvcGVyYXRpb25zIGluIDMwc1xuICogYGBgdHNcbiAqIC8vIFVwbG9hZCB0aGUgc2FtZSBkYXRhIHRvIDIgZGlmZmVyZW50IGRhdGEgY2VudGVycyBhdCB0aGUgc2FtZSB0aW1lLFxuICogLy8gYWJvcnQgYW5vdGhlciB3aGVuIGFueSBvZiB0aGVtIGlzIGZpbmlzaGVkXG4gKiBjb25zdCBjb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyLndpdGhUaW1lb3V0KDMwICogMTAwMCk7XG4gKiBkb0FzeW5jV29yayhjb250cm9sbGVyLnNpZ25hbCkudGhlbihjb250cm9sbGVyLmFib3J0KTtcbiAqIGRvQXN5bmNXb3JrKGNvbnRyb2xsZXIuc2lnbmFsKS50aGVuKGNvbnRyb2xsZXIuYWJvcnQpO1xuICpgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogQ2FzY2FkZWQgYWJvcnRpbmdcbiAqIGBgYHRzXG4gKiAvLyBBbGwgb3BlcmF0aW9ucyBjYW4ndCB0YWtlIG1vcmUgdGhhbiAzMCBzZWNvbmRzXG4gKiBjb25zdCBhYm9ydGVyID0gQWJvcnRlci50aW1lb3V0KDMwICogMTAwMCk7XG4gKlxuICogLy8gRm9sbG93aW5nIDIgb3BlcmF0aW9ucyBjYW4ndCB0YWtlIG1vcmUgdGhhbiAyNSBzZWNvbmRzXG4gKiBhd2FpdCBkb0FzeW5jV29yayhhYm9ydGVyLndpdGhUaW1lb3V0KDI1ICogMTAwMCkpO1xuICogYXdhaXQgZG9Bc3luY1dvcmsoYWJvcnRlci53aXRoVGltZW91dCgyNSAqIDEwMDApKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNpZ25hbHMpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsID0gbmV3IEFib3J0U2lnbmFsKCk7XG4gICAgICAgIGlmICghcGFyZW50U2lnbmFscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvZXJjZSBwYXJlbnRTaWduYWxzIGludG8gYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmVudFNpZ25hbHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBwYXJlbnRTaWduYWxzID0gYXJndW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFyZW50U2lnbmFsIG9mIHBhcmVudFNpZ25hbHMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgc2lnbmFsIGhhcyBhbHJlYWR5IGhhZCBhYm9ydCgpIGNhbGxlZCxcbiAgICAgICAgICAgIC8vIHRoZW4gY2FsbCBhYm9ydCBvbiB0aGlzIHNpZ25hbCBhcyB3ZWxsLlxuICAgICAgICAgICAgaWYgKHBhcmVudFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgcGFyZW50IHNpZ25hbCBhYm9ydHMsIHRoaXMgc2lnbmFsIHNob3VsZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHBhcmVudFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEFib3J0U2lnbmFsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2xsZXIgdGhhdCB3aWxsIHNpZ25hbCBhYm9ydGVkXG4gICAgICogd2hlbiB0aGUgYWJvcnQgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgdGhhdCBhbnkgb3BlcmF0aW9ucyBwYXNzZWQgdGhpcyBjb250cm9sbGVyJ3MgYXNzb2NpYXRlZCBhYm9ydCBzaWduYWxcbiAgICAgKiB0byBjYW5jZWwgYW55IHJlbWFpbmluZyB3b3JrIGFuZCB0aHJvdyBhbiBgQWJvcnRFcnJvcmAuXG4gICAgICovXG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGFib3J0U2lnbmFsKHRoaXMuX3NpZ25hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQWJvcnRTaWduYWwgaW5zdGFuY2UgdGhhdCB3aWxsIGFib3J0IGFmdGVyIHRoZSBwcm92aWRlZCBtcy5cbiAgICAgKiBAcGFyYW0gbXMgLSBFbGFwc2VkIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgYW4gYWJvcnQuXG4gICAgICovXG4gICAgc3RhdGljIHRpbWVvdXQobXMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gbmV3IEFib3J0U2lnbmFsKCk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChhYm9ydFNpZ25hbCwgbXMsIHNpZ25hbCk7XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGFjdGl2ZSBUaW1lciBmcm9tIGtlZXBpbmcgdGhlIE5vZGUuanMgZXZlbnQgbG9vcCBhY3RpdmUuXG4gICAgICAgIGlmICh0eXBlb2YgdGltZXIudW5yZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmFsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFib3J0Q29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9zaGltcy1wdWJsaWMuZC50c1wiIC8+XG5jb25zdCBsaXN0ZW5lcnNNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgYWJvcnRlZE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFuIGFib3J0ZXIgaW5zdGFuY2UgaW1wbGVtZW50cyBBYm9ydFNpZ25hbCBpbnRlcmZhY2UsIGNhbiBhYm9ydCBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIC0gQ2FsbCBBYm9ydFNpZ25hbC5ub25lIHRvIGNyZWF0ZSBhIG5ldyBBYm9ydFNpZ25hbCBpbnN0YW5jZSB0aGF0IGNhbm5vdCBiZSBjYW5jZWxsZWQuXG4gKiBVc2UgYEFib3J0U2lnbmFsLm5vbmVgIHdoZW4geW91IGFyZSByZXF1aXJlZCB0byBwYXNzIGEgY2FuY2VsbGF0aW9uIHRva2VuIGJ1dCB0aGUgb3BlcmF0aW9uXG4gKiBjYW5ub3Qgb3Igd2lsbCBub3QgZXZlciBiZSBjYW5jZWxsZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFib3J0IHdpdGhvdXQgdGltZW91dFxuICogYGBgdHNcbiAqIGF3YWl0IGRvQXN5bmNXb3JrKEFib3J0U2lnbmFsLm5vbmUpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbmFib3J0IGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmFib3J0ID0gbnVsbDtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBbXSk7XG4gICAgICAgIGFib3J0ZWRNYXAuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdHVzIG9mIHdoZXRoZXIgYWJvcnRlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgaWYgKCFhYm9ydGVkTWFwLmhhcyh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGB0aGlzYCB0byBiZSBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFib3J0ZWRNYXAuZ2V0KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFib3J0U2lnbmFsIGluc3RhbmNlIHRoYXQgd2lsbCBuZXZlciBiZSBhYm9ydGVkLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgc3RhdGljIGdldCBub25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFib3J0U2lnbmFsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZGVkIG5ldyBcImFib3J0XCIgZXZlbnQgbGlzdGVuZXIsIG9ubHkgc3VwcG9ydCBcImFib3J0XCIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX3R5cGUgLSBPbmx5IHN1cHBvcnQgXCJhYm9ydFwiIGV2ZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHRvIGJlIGFkZGVkXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgIF90eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIWxpc3RlbmVyc01hcC5oYXModGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgdGhpc2AgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcC5nZXQodGhpcyk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFwiYWJvcnRcIiBldmVudCBsaXN0ZW5lciwgb25seSBzdXBwb3J0IFwiYWJvcnRcIiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfdHlwZSAtIE9ubHkgc3VwcG9ydCBcImFib3J0XCIgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICBfdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnNNYXAuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYHRoaXNgIHRvIGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KHRoaXMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGhlIEFib3J0U2lnbmFsLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoX2V2ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXMgYSBzdHViIGRpc3BhdGNoRXZlbnQgaW1wbGVtZW50YXRpb24gdGhhdCBzaG91bGQgbm90IGJlIHVzZWQuICBJdCBvbmx5IGV4aXN0cyBmb3IgdHlwZS1jaGVja2luZyBwdXJwb3Nlcy5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gdHJpZ2dlciBhbiBhYm9ydCBldmVudCBpbW1lZGlhdGVseSwgdGhlIG9uYWJvcnQgYW5kIGFsbCBhYm9ydCBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gKiBXaWxsIHRyeSB0byB0cmlnZ2VyIGFib3J0IGV2ZW50IGZvciBhbGwgbGlua2VkIEFib3J0U2lnbmFsIG5vZGVzLlxuICpcbiAqIC0gSWYgdGhlcmUgaXMgYSB0aW1lb3V0LCB0aGUgdGltZXIgd2lsbCBiZSBjYW5jZWxsZWQuXG4gKiAtIElmIGFib3J0ZWQgaXMgdHJ1ZSwgbm90aGluZyB3aWxsIGhhcHBlbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhenVyZS9henVyZS1zZGsvdHMtdXNlLWludGVyZmFjZS1wYXJhbWV0ZXJzXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNpZ25hbC5vbmFib3J0KSB7XG4gICAgICAgIHNpZ25hbC5vbmFib3J0LmNhbGwoc2lnbmFsKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwLmdldChzaWduYWwpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiBsaXN0ZW5lcnMgc28gbXV0YXRpb25zIHRvIHRoZSBhcnJheVxuICAgICAgICAvLyAoZS5nLiB2aWEgcmVtb3ZlTGlzdGVuZXIgY2FsbHMpIGRvbid0IGFmZmVjdCB0aGUgbGlzdGVuZXJzXG4gICAgICAgIC8vIHdlIGludm9rZS5cbiAgICAgICAgbGlzdGVuZXJzLnNsaWNlKCkuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoc2lnbmFsLCB7IHR5cGU6IFwiYWJvcnRcIiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0ZWRNYXAuc2V0KHNpZ25hbCwgdHJ1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYm9ydFNpZ25hbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGlzT2JqZWN0V2l0aFByb3BlcnRpZXMgfSBmcm9tIFwiLi90eXBlZ3VhcmRzXCI7XG4vKipcbiAqIEEgc3RhdGljIG5hbWUva2V5LWJhc2VkIGNyZWRlbnRpYWwgdGhhdCBzdXBwb3J0cyB1cGRhdGluZ1xuICogdGhlIHVuZGVybHlpbmcgbmFtZSBhbmQga2V5IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwgZm9yIHVzZVxuICAgICAqIHdpdGggYSBzZXJ2aWNlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIG5hbWUgdG8gdXNlIGluIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUga2V5IHRvIHVzZSBpbiBhdXRoZW50aWNhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBrZXkpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8ICFrZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuYW1lIGFuZCBrZXkgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGtleSB0byBiZSB1c2VkIGluIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqL1xuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgbmFtZSB0byBiZSB1c2VkIGluIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUga2V5LlxuICAgICAqXG4gICAgICogVXBkYXRlcyB3aWxsIHRha2UgZWZmZWN0IHVwb24gdGhlIG5leHQgcmVxdWVzdCBhZnRlclxuICAgICAqIHVwZGF0aW5nIHRoZSBrZXkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3TmFtZSAtIFRoZSBuZXcgbmFtZSB2YWx1ZSB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBuZXdLZXkgLSBUaGUgbmV3IGtleSB2YWx1ZSB0byBiZSB1c2VkLlxuICAgICAqL1xuICAgIHVwZGF0ZShuZXdOYW1lLCBuZXdLZXkpIHtcbiAgICAgICAgaWYgKCFuZXdOYW1lIHx8ICFuZXdLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZXdOYW1lIGFuZCBuZXdLZXkgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gbmV3S2V5O1xuICAgIH1cbn1cbi8qKlxuICogVGVzdHMgYW4gb2JqZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGl0IGltcGxlbWVudHMgTmFtZWRLZXlDcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGFzc3VtZWQgTmFtZWRLZXlDcmVkZW50aWFsIHRvIGJlIHRlc3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmFtZWRLZXlDcmVkZW50aWFsKGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0V2l0aFByb3BlcnRpZXMoY3JlZGVudGlhbCwgW1wibmFtZVwiLCBcImtleVwiXSkgJiZcbiAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWwua2V5ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHR5cGVvZiBjcmVkZW50aWFsLm5hbWUgPT09IFwic3RyaW5nXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXp1cmVOYW1lZEtleUNyZWRlbnRpYWwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBpc09iamVjdFdpdGhQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vdHlwZWd1YXJkc1wiO1xuLyoqXG4gKiBBIHN0YXRpYy1zaWduYXR1cmUtYmFzZWQgY3JlZGVudGlhbCB0aGF0IHN1cHBvcnRzIHVwZGF0aW5nXG4gKiB0aGUgdW5kZXJseWluZyBzaWduYXR1cmUgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBenVyZVNBU0NyZWRlbnRpYWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBBenVyZVNBU0NyZWRlbnRpYWwgZm9yIHVzZVxuICAgICAqIHdpdGggYSBzZXJ2aWNlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2hhcmVkIGFjY2VzcyBzaWduYXR1cmUgdG8gdXNlIGluIGF1dGhlbnRpY2F0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgYWNjZXNzIHNpZ25hdHVyZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc2hhcmVkIGFjY2VzcyBzaWduYXR1cmUgdG8gYmUgdXNlZCBpbiBhdXRoZW50aWNhdGlvblxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIFVwZGF0ZXMgd2lsbCB0YWtlIGVmZmVjdCB1cG9uIHRoZSBuZXh0IHJlcXVlc3QgYWZ0ZXJcbiAgICAgKiB1cGRhdGluZyB0aGUgc2lnbmF0dXJlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1NpZ25hdHVyZSAtIFRoZSBuZXcgc2hhcmVkIGFjY2VzcyBzaWduYXR1cmUgdmFsdWUgdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIHVwZGF0ZShuZXdTaWduYXR1cmUpIHtcbiAgICAgICAgaWYgKCFuZXdTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYXJlZCBhY2Nlc3Mgc2lnbmF0dXJlIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZSA9IG5ld1NpZ25hdHVyZTtcbiAgICB9XG59XG4vKipcbiAqIFRlc3RzIGFuIG9iamVjdCB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpbXBsZW1lbnRzIFNBU0NyZWRlbnRpYWwuXG4gKlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXNzdW1lZCBTQVNDcmVkZW50aWFsIHRvIGJlIHRlc3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU0FTQ3JlZGVudGlhbChjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIChpc09iamVjdFdpdGhQcm9wZXJ0aWVzKGNyZWRlbnRpYWwsIFtcInNpZ25hdHVyZVwiXSkgJiYgdHlwZW9mIGNyZWRlbnRpYWwuc2lnbmF0dXJlID09PSBcInN0cmluZ1wiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF6dXJlU0FTQ3JlZGVudGlhbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8qKlxuICogVGVzdHMgYW4gb2JqZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGl0IGltcGxlbWVudHMgVG9rZW5DcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGFzc3VtZWQgVG9rZW5DcmVkZW50aWFsIHRvIGJlIHRlc3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5DcmVkZW50aWFsKGNyZWRlbnRpYWwpIHtcbiAgICAvLyBDaGVjayBmb3IgYW4gb2JqZWN0IHdpdGggYSAnZ2V0VG9rZW4nIGZ1bmN0aW9uIGFuZCBwb3NzaWJseSB3aXRoXG4gICAgLy8gYSAnc2lnblJlcXVlc3QnIGZ1bmN0aW9uLiAgV2UgZG8gdGhpcyBjaGVjayB0byBtYWtlIHN1cmUgdGhhdFxuICAgIC8vIGEgU2VydmljZUNsaWVudENyZWRlbnRpYWxzIGltcGxlbWVudG9yIChsaWtlIFRva2VuQ2xpZW50Q3JlZGVudGlhbHNcbiAgICAvLyBpbiBtcy1yZXN0LW5vZGVhdXRoKSBkb2Vzbid0IGdldCBtaXN0YWtlbiBmb3IgYSBUb2tlbkNyZWRlbnRpYWwgaWZcbiAgICAvLyBpdCBkb2Vzbid0IGFjdHVhbGx5IGltcGxlbWVudCBUb2tlbkNyZWRlbnRpYWwgYWxzby5cbiAgICBjb25zdCBjYXN0Q3JlZGVudGlhbCA9IGNyZWRlbnRpYWw7XG4gICAgcmV0dXJuIChjYXN0Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgY2FzdENyZWRlbnRpYWwuZ2V0VG9rZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAoY2FzdENyZWRlbnRpYWwuc2lnblJlcXVlc3QgPT09IHVuZGVmaW5lZCB8fCBjYXN0Q3JlZGVudGlhbC5nZXRUb2tlbi5sZW5ndGggPiAwKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbkNyZWRlbnRpYWwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIEhlbHBlciBUeXBlR3VhcmQgdGhhdCBjaGVja3MgaWYgc29tZXRoaW5nIGlzIGRlZmluZWQgb3Igbm90LlxuICogQHBhcmFtIHRoaW5nIC0gQW55dGhpbmdcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaW5nICE9PSBudWxsO1xufVxuLyoqXG4gKiBIZWxwZXIgVHlwZUd1YXJkIHRoYXQgY2hlY2tzIGlmIHRoZSBpbnB1dCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBOb3RlOiBUaGUgcHJvcGVydGllcyBtYXkgYmUgaW5oZXJpdGVkLlxuICogQHBhcmFtIHRoaW5nIC0gQW55dGhpbmcuXG4gKiBAcGFyYW0gcHJvcGVydGllcyAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGFwcGVhciBpbiB0aGUgb2JqZWN0LlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdFdpdGhQcm9wZXJ0aWVzKHRoaW5nLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodGhpbmcpIHx8IHR5cGVvZiB0aGluZyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgICAgICBpZiAoIW9iamVjdEhhc1Byb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogSGVscGVyIFR5cGVHdWFyZCB0aGF0IGNoZWNrcyBpZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqIE5vdGU6IFRoZSBwcm9wZXJ0eSBtYXkgYmUgaW5oZXJpdGVkLlxuICogQHBhcmFtIHRoaW5nIC0gQW55IG9iamVjdC5cbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBhcHBlYXIgaW4gdGhlIG9iamVjdC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBvYmplY3RIYXNQcm9wZXJ0eSh0aGluZywgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHByb3BlcnR5IGluIHRoaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWd1YXJkcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8qKlxuICogQSBzZXQgb2YgY29uc3RhbnRzIHVzZWQgaW50ZXJuYWxseSB3aGVuIHByb2Nlc3NpbmcgcmVxdWVzdHMuXG4gKi9cbmNvbnN0IENvbnN0YW50cyA9IHtcbiAgICBEZWZhdWx0U2NvcGU6IFwiLy5kZWZhdWx0XCIsXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjb25zdGFudHMgZm9yIHVzZSB3aXRoIEhUVFAgaGVhZGVycy5cbiAgICAgKi9cbiAgICBIZWFkZXJDb25zdGFudHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBBdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIEFVVEhPUklaQVRJT046IFwiYXV0aG9yaXphdGlvblwiLFxuICAgIH0sXG59O1xuLyoqXG4gKiBEZWZpbmVzIGEgY2FsbGJhY2sgdG8gaGFuZGxlIGF1dGggY2hhbGxlbmdlIGZvciBTdG9yYWdlIEFQSXMuXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIGJlYXJlciBjaGFsbGVuZ2UgcHJvY2VzcyBkZXNjcmliZWQgaGVyZTogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vcmVzdC9hcGkvc3RvcmFnZXNlcnZpY2VzL2F1dGhvcml6ZS13aXRoLWF6dXJlLWFjdGl2ZS1kaXJlY3RvcnkjYmVhcmVyLWNoYWxsZW5nZVxuICogSGFuZGxpbmcgaGFzIHNwZWNpZmljIGZlYXR1cmVzIGZvciBzdG9yYWdlIHRoYXQgZGVwYXJ0cyB0byB0aGUgZ2VuZXJhbCBBQUQgY2hhbGxlbmdlIGRvY3MuXG4gKiovXG5leHBvcnQgY29uc3QgYXV0aG9yaXplUmVxdWVzdE9uVGVuYW50Q2hhbGxlbmdlID0gYXN5bmMgKGNoYWxsZW5nZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3RUb09wdGlvbnMoY2hhbGxlbmdlT3B0aW9ucy5yZXF1ZXN0KTtcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBnZXRDaGFsbGVuZ2UoY2hhbGxlbmdlT3B0aW9ucy5yZXNwb25zZSk7XG4gICAgaWYgKGNoYWxsZW5nZSkge1xuICAgICAgICBjb25zdCBjaGFsbGVuZ2VJbmZvID0gcGFyc2VDaGFsbGVuZ2UoY2hhbGxlbmdlKTtcbiAgICAgICAgY29uc3QgY2hhbGxlbmdlU2NvcGVzID0gYnVpbGRTY29wZXMoY2hhbGxlbmdlT3B0aW9ucywgY2hhbGxlbmdlSW5mbyk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gZXh0cmFjdFRlbmFudElkKGNoYWxsZW5nZUluZm8pO1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IGNoYWxsZW5nZU9wdGlvbnMuZ2V0QWNjZXNzVG9rZW4oY2hhbGxlbmdlU2NvcGVzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RPcHRpb25zKSwgeyB0ZW5hbnRJZCB9KSk7XG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFsbGVuZ2VPcHRpb25zLnJlcXVlc3QuaGVhZGVycy5zZXQoQ29uc3RhbnRzLkhlYWRlckNvbnN0YW50cy5BVVRIT1JJWkFUSU9OLCBgQmVhcmVyICR7YWNjZXNzVG9rZW4udG9rZW59YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdGVuYW50IGlkIGZyb20gdGhlIGNoYWxsZW5nZSBpbmZvcm1hdGlvblxuICogVGhlIHRlbmFudCBpZCBpcyBjb250YWluZWQgaW4gdGhlIGF1dGhvcml6YXRpb25fdXJpIGFzIHRoZSBmaXJzdFxuICogcGF0aCBwYXJ0LlxuICovXG5mdW5jdGlvbiBleHRyYWN0VGVuYW50SWQoY2hhbGxlbmdlSW5mbykge1xuICAgIGNvbnN0IHBhcnNlZEF1dGhVcmkgPSBuZXcgVVJMKGNoYWxsZW5nZUluZm8uYXV0aG9yaXphdGlvbl91cmkpO1xuICAgIGNvbnN0IHBhdGhTZWdtZW50cyA9IHBhcnNlZEF1dGhVcmkucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IHRlbmFudElkID0gcGF0aFNlZ21lbnRzWzFdO1xuICAgIHJldHVybiB0ZW5hbnRJZDtcbn1cbi8qKlxuICogQnVpbGRzIHRoZSBhdXRoZW50aWNhdGlvbiBzY29wZXMgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIHRoYXQgY29tZXMgaW4gdGhlXG4gKiBjaGFsbGVuZ2UgaW5mb3JtYXRpb24uIFNjb3BlcyB1cmwgaXMgcHJlc2VudCBpbiB0aGUgcmVzb3VyY2VfaWQsIGlmIGl0IGlzIGVtcHR5XG4gKiB3ZSBrZWVwIHVzaW5nIHRoZSBvcmlnaW5hbCBzY29wZXMuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2NvcGVzKGNoYWxsZW5nZU9wdGlvbnMsIGNoYWxsZW5nZUluZm8pIHtcbiAgICBpZiAoIWNoYWxsZW5nZUluZm8ucmVzb3VyY2VfdXJpKSB7XG4gICAgICAgIHJldHVybiBjaGFsbGVuZ2VPcHRpb25zLnNjb3BlcztcbiAgICB9XG4gICAgY29uc3QgY2hhbGxlbmdlU2NvcGVzID0gbmV3IFVSTChjaGFsbGVuZ2VJbmZvLnJlc291cmNlX3VyaSk7XG4gICAgY2hhbGxlbmdlU2NvcGVzLnBhdGhuYW1lID0gQ29uc3RhbnRzLkRlZmF1bHRTY29wZTtcbiAgICByZXR1cm4gW2NoYWxsZW5nZVNjb3Blcy50b1N0cmluZygpXTtcbn1cbi8qKlxuICogV2Ugd2lsbCByZXRyaWV2ZSB0aGUgY2hhbGxlbmdlIG9ubHkgaWYgdGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlIHdhcyA0MDEsXG4gKiBhbmQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCB0aGUgaGVhZGVyIFwiV1dXLUF1dGhlbnRpY2F0ZVwiIHdpdGggYSBub24tZW1wdHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldENoYWxsZW5nZShyZXNwb25zZSkge1xuICAgIGNvbnN0IGNoYWxsZW5nZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiV1dXLUF1dGhlbnRpY2F0ZVwiKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgJiYgY2hhbGxlbmdlKSB7XG4gICAgICAgIHJldHVybiBjaGFsbGVuZ2U7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydHM6IGBCZWFyZXIgYT1cImJcIiBjPVwiZFwiYC5cbiAqIEludG86IGBbIHsgYTogJ2InLCBjOiAnZCcgfV1gLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwYXJzZUNoYWxsZW5nZShjaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBiZWFyZXJDaGFsbGVuZ2UgPSBjaGFsbGVuZ2Uuc2xpY2UoXCJCZWFyZXIgXCIubGVuZ3RoKTtcbiAgICBjb25zdCBjaGFsbGVuZ2VQYXJ0cyA9IGAke2JlYXJlckNoYWxsZW5nZS50cmltKCl9IGAuc3BsaXQoXCIgXCIpLmZpbHRlcigoeCkgPT4geCk7XG4gICAgY29uc3Qga2V5VmFsdWVQYWlycyA9IGNoYWxsZW5nZVBhcnRzLm1hcCgoa2V5VmFsdWUpID0+ICgoW2tleSwgdmFsdWVdKSA9PiAoeyBba2V5XTogdmFsdWUgfSkpKGtleVZhbHVlLnRyaW0oKS5zcGxpdChcIj1cIikpKTtcbiAgICAvLyBLZXktdmFsdWUgcGFpcnMgdG8gcGxhaW4gb2JqZWN0OlxuICAgIHJldHVybiBrZXlWYWx1ZVBhaXJzLnJlZHVjZSgoYSwgYikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYSksIGIpKSwge30pO1xufVxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgb3B0aW9ucyBmb3JtIGEgUGlwZWxpbmUgUmVxdWVzdCBmb3IgbGF0ZXIgcmUtdXNlXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RUb09wdGlvbnMocmVxdWVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0U2lnbmFsOiByZXF1ZXN0LmFib3J0U2lnbmFsLFxuICAgICAgICByZXF1ZXN0T3B0aW9uczoge1xuICAgICAgICAgICAgdGltZW91dDogcmVxdWVzdC50aW1lb3V0LFxuICAgICAgICB9LFxuICAgICAgICB0cmFjaW5nT3B0aW9uczogcmVxdWVzdC50cmFjaW5nT3B0aW9ucyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXplUmVxdWVzdE9uVGVuYW50Q2hhbGxlbmdlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIGluIGJhc2U2NCBmb3JtYXQuXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIGVuY29kZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYnl0ZSBhcnJheSBpbiBiYXNlNjQgZm9ybWF0LlxuICogQHBhcmFtIHZhbHVlIC0gdGhlIFVpbnQ4QXJheSB0byBlbmNvZGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQnl0ZUFycmF5KHZhbHVlKSB7XG4gICAgLy8gQnVmZmVyLmZyb20gYWNjZXB0cyA8QXJyYXlCdWZmZXI+IHwgPFNoYXJlZEFycmF5QnVmZmVyPi0tIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gaXMgb2ZmIGhlcmVcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI2J1ZmZlcl9jbGFzc19tZXRob2RfYnVmZmVyX2Zyb21fYXJyYXlidWZmZXJfYnl0ZW9mZnNldF9sZW5ndGhcbiAgICBjb25zdCBidWZmZXJWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIpO1xuICAgIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgYmFzZTY0IHN0cmluZyB0byBkZWNvZGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgaW50byBhIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBiYXNlNjQgc3RyaW5nIHRvIGRlY29kZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmdUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IFhNTF9DSEFSS0VZLCB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFJlc3RFcnJvciwgfSBmcm9tIFwiQGF6dXJlL2NvcmUtcmVzdC1waXBlbGluZVwiO1xuaW1wb3J0IHsgTWFwcGVyVHlwZU5hbWVzIH0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUmVxdWVzdEluZm8gfSBmcm9tIFwiLi9vcGVyYXRpb25IZWxwZXJzXCI7XG5jb25zdCBkZWZhdWx0SnNvbkNvbnRlbnRUeXBlcyA9IFtcImFwcGxpY2F0aW9uL2pzb25cIiwgXCJ0ZXh0L2pzb25cIl07XG5jb25zdCBkZWZhdWx0WG1sQ29udGVudFR5cGVzID0gW1wiYXBwbGljYXRpb24veG1sXCIsIFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIl07XG4vKipcbiAqIFRoZSBwcm9ncmFtbWF0aWMgaWRlbnRpZmllciBvZiB0aGUgZGVzZXJpYWxpemF0aW9uUG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgZGVzZXJpYWxpemF0aW9uUG9saWN5TmFtZSA9IFwiZGVzZXJpYWxpemF0aW9uUG9saWN5XCI7XG4vKipcbiAqIFRoaXMgcG9saWN5IGhhbmRsZXMgcGFyc2luZyBvdXQgcmVzcG9uc2VzIGFjY29yZGluZyB0byBPcGVyYXRpb25TcGVjcyBvbiB0aGUgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXphdGlvblBvbGljeShvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgY29uc3QganNvbkNvbnRlbnRUeXBlcyA9IChfYiA9IChfYSA9IG9wdGlvbnMuZXhwZWN0ZWRDb250ZW50VHlwZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qc29uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0SnNvbkNvbnRlbnRUeXBlcztcbiAgICBjb25zdCB4bWxDb250ZW50VHlwZXMgPSAoX2QgPSAoX2MgPSBvcHRpb25zLmV4cGVjdGVkQ29udGVudFR5cGVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueG1sKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0WG1sQ29udGVudFR5cGVzO1xuICAgIGNvbnN0IHBhcnNlWE1MID0gb3B0aW9ucy5wYXJzZVhNTDtcbiAgICBjb25zdCBzZXJpYWxpemVyT3B0aW9ucyA9IG9wdGlvbnMuc2VyaWFsaXplck9wdGlvbnM7XG4gICAgY29uc3QgdXBkYXRlZE9wdGlvbnMgPSB7XG4gICAgICAgIHhtbDoge1xuICAgICAgICAgICAgcm9vdE5hbWU6IChfZSA9IHNlcmlhbGl6ZXJPcHRpb25zID09PSBudWxsIHx8IHNlcmlhbGl6ZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpYWxpemVyT3B0aW9ucy54bWwucm9vdE5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFwiXCIsXG4gICAgICAgICAgICBpbmNsdWRlUm9vdDogKF9mID0gc2VyaWFsaXplck9wdGlvbnMgPT09IG51bGwgfHwgc2VyaWFsaXplck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcmlhbGl6ZXJPcHRpb25zLnhtbC5pbmNsdWRlUm9vdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2UsXG4gICAgICAgICAgICB4bWxDaGFyS2V5OiAoX2cgPSBzZXJpYWxpemVyT3B0aW9ucyA9PT0gbnVsbCB8fCBzZXJpYWxpemVyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VyaWFsaXplck9wdGlvbnMueG1sLnhtbENoYXJLZXkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFhNTF9DSEFSS0VZLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGVzZXJpYWxpemF0aW9uUG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuZXh0KHJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplUmVzcG9uc2VCb2R5KGpzb25Db250ZW50VHlwZXMsIHhtbENvbnRlbnRUeXBlcywgcmVzcG9uc2UsIHVwZGF0ZWRPcHRpb25zLCBwYXJzZVhNTCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblJlc3BvbnNlTWFwKHBhcnNlZFJlc3BvbnNlKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyc2VkUmVzcG9uc2UucmVxdWVzdDtcbiAgICBjb25zdCBvcGVyYXRpb25JbmZvID0gZ2V0T3BlcmF0aW9uUmVxdWVzdEluZm8ocmVxdWVzdCk7XG4gICAgY29uc3Qgb3BlcmF0aW9uU3BlYyA9IG9wZXJhdGlvbkluZm8gPT09IG51bGwgfHwgb3BlcmF0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlcmF0aW9uSW5mby5vcGVyYXRpb25TcGVjO1xuICAgIGlmIChvcGVyYXRpb25TcGVjKSB7XG4gICAgICAgIGlmICghKG9wZXJhdGlvbkluZm8gPT09IG51bGwgfHwgb3BlcmF0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlcmF0aW9uSW5mby5vcGVyYXRpb25SZXNwb25zZUdldHRlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdGlvblNwZWMucmVzcG9uc2VzW3BhcnNlZFJlc3BvbnNlLnN0YXR1c107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvcGVyYXRpb25JbmZvID09PSBudWxsIHx8IG9wZXJhdGlvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZXJhdGlvbkluZm8ub3BlcmF0aW9uUmVzcG9uc2VHZXR0ZXIob3BlcmF0aW9uU3BlYywgcGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaG91bGREZXNlcmlhbGl6ZVJlc3BvbnNlKHBhcnNlZFJlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHBhcnNlZFJlc3BvbnNlLnJlcXVlc3Q7XG4gICAgY29uc3Qgb3BlcmF0aW9uSW5mbyA9IGdldE9wZXJhdGlvblJlcXVlc3RJbmZvKHJlcXVlc3QpO1xuICAgIGNvbnN0IHNob3VsZERlc2VyaWFsaXplID0gb3BlcmF0aW9uSW5mbyA9PT0gbnVsbCB8fCBvcGVyYXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVyYXRpb25JbmZvLnNob3VsZERlc2VyaWFsaXplO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHNob3VsZERlc2VyaWFsaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNob3VsZERlc2VyaWFsaXplID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXN1bHQgPSBzaG91bGREZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNob3VsZERlc2VyaWFsaXplKHBhcnNlZFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlc2VyaWFsaXplUmVzcG9uc2VCb2R5KGpzb25Db250ZW50VHlwZXMsIHhtbENvbnRlbnRUeXBlcywgcmVzcG9uc2UsIG9wdGlvbnMsIHBhcnNlWE1MKSB7XG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCBwYXJzZShqc29uQ29udGVudFR5cGVzLCB4bWxDb250ZW50VHlwZXMsIHJlc3BvbnNlLCBvcHRpb25zLCBwYXJzZVhNTCk7XG4gICAgaWYgKCFzaG91bGREZXNlcmlhbGl6ZVJlc3BvbnNlKHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VkUmVzcG9uc2U7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvbkluZm8gPSBnZXRPcGVyYXRpb25SZXF1ZXN0SW5mbyhwYXJzZWRSZXNwb25zZS5yZXF1ZXN0KTtcbiAgICBjb25zdCBvcGVyYXRpb25TcGVjID0gb3BlcmF0aW9uSW5mbyA9PT0gbnVsbCB8fCBvcGVyYXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVyYXRpb25JbmZvLm9wZXJhdGlvblNwZWM7XG4gICAgaWYgKCFvcGVyYXRpb25TcGVjIHx8ICFvcGVyYXRpb25TcGVjLnJlc3BvbnNlcykge1xuICAgICAgICByZXR1cm4gcGFyc2VkUmVzcG9uc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlU3BlYyA9IGdldE9wZXJhdGlvblJlc3BvbnNlTWFwKHBhcnNlZFJlc3BvbnNlKTtcbiAgICBjb25zdCB7IGVycm9yLCBzaG91bGRSZXR1cm5SZXNwb25zZSB9ID0gaGFuZGxlRXJyb3JSZXNwb25zZShwYXJzZWRSZXNwb25zZSwgb3BlcmF0aW9uU3BlYywgcmVzcG9uc2VTcGVjKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNob3VsZFJldHVyblJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWRSZXNwb25zZTtcbiAgICB9XG4gICAgLy8gQW4gb3BlcmF0aW9uIHJlc3BvbnNlIHNwZWMgZG9lcyBleGlzdCBmb3IgY3VycmVudCBzdGF0dXMgY29kZSwgc29cbiAgICAvLyB1c2UgaXQgdG8gZGVzZXJpYWxpemUgdGhlIHJlc3BvbnNlLlxuICAgIGlmIChyZXNwb25zZVNwZWMpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlU3BlYy5ib2R5TWFwcGVyKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWVUb0Rlc2VyaWFsaXplID0gcGFyc2VkUmVzcG9uc2UucGFyc2VkQm9keTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb25TcGVjLmlzWE1MICYmIHJlc3BvbnNlU3BlYy5ib2R5TWFwcGVyLnR5cGUubmFtZSA9PT0gTWFwcGVyVHlwZU5hbWVzLlNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUb0Rlc2VyaWFsaXplID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlVG9EZXNlcmlhbGl6ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVRvRGVzZXJpYWxpemVbcmVzcG9uc2VTcGVjLmJvZHlNYXBwZXIueG1sRWxlbWVudE5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZS5wYXJzZWRCb2R5ID0gb3BlcmF0aW9uU3BlYy5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3BvbnNlU3BlYy5ib2R5TWFwcGVyLCB2YWx1ZVRvRGVzZXJpYWxpemUsIFwib3BlcmF0aW9uUmVzLnBhcnNlZEJvZHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZGVzZXJpYWxpemVFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RFcnJvciA9IG5ldyBSZXN0RXJyb3IoYEVycm9yICR7ZGVzZXJpYWxpemVFcnJvcn0gb2NjdXJyZWQgaW4gZGVzZXJpYWxpemluZyB0aGUgcmVzcG9uc2VCb2R5IC0gJHtwYXJzZWRSZXNwb25zZS5ib2R5QXNUZXh0fWAsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcGFyc2VkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwYXJzZWRSZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcGFyc2VkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvblNwZWMuaHR0cE1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIC8vIGhlYWQgbWV0aG9kcyBuZXZlciBoYXZlIGEgYm9keSwgYnV0IHdlIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLnBhcnNlZEJvZHkgPSByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VTcGVjLmhlYWRlcnNNYXBwZXIpIHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLnBhcnNlZEhlYWRlcnMgPSBvcGVyYXRpb25TcGVjLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzcG9uc2VTcGVjLmhlYWRlcnNNYXBwZXIsIHBhcnNlZFJlc3BvbnNlLmhlYWRlcnMudG9KU09OKCksIFwib3BlcmF0aW9uUmVzLnBhcnNlZEhlYWRlcnNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFJlc3BvbnNlO1xufVxuZnVuY3Rpb24gaXNPcGVyYXRpb25TcGVjRW1wdHkob3BlcmF0aW9uU3BlYykge1xuICAgIGNvbnN0IGV4cGVjdGVkU3RhdHVzQ29kZXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb25TcGVjLnJlc3BvbnNlcyk7XG4gICAgcmV0dXJuIChleHBlY3RlZFN0YXR1c0NvZGVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAoZXhwZWN0ZWRTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRTdGF0dXNDb2Rlc1swXSA9PT0gXCJkZWZhdWx0XCIpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yUmVzcG9uc2UocGFyc2VkUmVzcG9uc2UsIG9wZXJhdGlvblNwZWMsIHJlc3BvbnNlU3BlYykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpc1N1Y2Nlc3NCeVN0YXR1cyA9IDIwMCA8PSBwYXJzZWRSZXNwb25zZS5zdGF0dXMgJiYgcGFyc2VkUmVzcG9uc2Uuc3RhdHVzIDwgMzAwO1xuICAgIGNvbnN0IGlzRXhwZWN0ZWRTdGF0dXNDb2RlID0gaXNPcGVyYXRpb25TcGVjRW1wdHkob3BlcmF0aW9uU3BlYylcbiAgICAgICAgPyBpc1N1Y2Nlc3NCeVN0YXR1c1xuICAgICAgICA6ICEhcmVzcG9uc2VTcGVjO1xuICAgIGlmIChpc0V4cGVjdGVkU3RhdHVzQ29kZSkge1xuICAgICAgICBpZiAocmVzcG9uc2VTcGVjKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlU3BlYy5pc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwsIHNob3VsZFJldHVyblJlc3BvbnNlOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwsIHNob3VsZFJldHVyblJlc3BvbnNlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yUmVzcG9uc2VTcGVjID0gcmVzcG9uc2VTcGVjICE9PSBudWxsICYmIHJlc3BvbnNlU3BlYyAhPT0gdm9pZCAwID8gcmVzcG9uc2VTcGVjIDogb3BlcmF0aW9uU3BlYy5yZXNwb25zZXMuZGVmYXVsdDtcbiAgICBjb25zdCBpbml0aWFsRXJyb3JNZXNzYWdlID0gKChfYSA9IHBhcnNlZFJlc3BvbnNlLnJlcXVlc3Quc3RyZWFtUmVzcG9uc2VTdGF0dXNDb2RlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhwYXJzZWRSZXNwb25zZS5zdGF0dXMpKVxuICAgICAgICA/IGBVbmV4cGVjdGVkIHN0YXR1cyBjb2RlOiAke3BhcnNlZFJlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgIDogcGFyc2VkUmVzcG9uc2UuYm9keUFzVGV4dDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBSZXN0RXJyb3IoaW5pdGlhbEVycm9yTWVzc2FnZSwge1xuICAgICAgICBzdGF0dXNDb2RlOiBwYXJzZWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlcXVlc3Q6IHBhcnNlZFJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICAgIHJlc3BvbnNlOiBwYXJzZWRSZXNwb25zZSxcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgaXRlbSBmYWlsZWQgYnV0IHRoZXJlJ3Mgbm8gZXJyb3Igc3BlYyBvciBkZWZhdWx0IHNwZWMgdG8gZGVzZXJpYWxpemUgdGhlIGVycm9yLFxuICAgIC8vIHdlIHNob3VsZCBmYWlsIHNvIHdlIGp1c3QgdGhyb3cgdGhlIHBhcnNlZCByZXNwb25zZVxuICAgIGlmICghZXJyb3JSZXNwb25zZVNwZWMpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRCb2R5TWFwcGVyID0gZXJyb3JSZXNwb25zZVNwZWMuYm9keU1hcHBlcjtcbiAgICBjb25zdCBkZWZhdWx0SGVhZGVyc01hcHBlciA9IGVycm9yUmVzcG9uc2VTcGVjLmhlYWRlcnNNYXBwZXI7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgZXJyb3IgcmVzcG9uc2UgaGFzIGEgYm9keSwgdHJ5IHRvIGRlc2VyaWFsaXplIGl0IHVzaW5nIGRlZmF1bHQgYm9keSBtYXBwZXIuXG4gICAgICAgIC8vIFRoZW4gdHJ5IHRvIGV4dHJhY3QgZXJyb3IgY29kZSAmIG1lc3NhZ2UgZnJvbSBpdFxuICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UucGFyc2VkQm9keSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQm9keSA9IHBhcnNlZFJlc3BvbnNlLnBhcnNlZEJvZHk7XG4gICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkRXJyb3I7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdEJvZHlNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVUb0Rlc2VyaWFsaXplID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uU3BlYy5pc1hNTCAmJiBkZWZhdWx0Qm9keU1hcHBlci50eXBlLm5hbWUgPT09IE1hcHBlclR5cGVOYW1lcy5TZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvRGVzZXJpYWxpemUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBkZWZhdWx0Qm9keU1hcHBlci54bWxFbGVtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSBcIm9iamVjdFwiICYmIGVsZW1lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvRGVzZXJpYWxpemUgPSBwYXJzZWRCb2R5W2VsZW1lbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRFcnJvciA9IG9wZXJhdGlvblNwZWMuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShkZWZhdWx0Qm9keU1hcHBlciwgdmFsdWVUb0Rlc2VyaWFsaXplLCBcImVycm9yLnJlc3BvbnNlLnBhcnNlZEJvZHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbEVycm9yID0gcGFyc2VkQm9keS5lcnJvciB8fCBkZXNlcmlhbGl6ZWRFcnJvciB8fCBwYXJzZWRCb2R5O1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IGludGVybmFsRXJyb3IuY29kZTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbEVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gaW50ZXJuYWxFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmF1bHRCb2R5TWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UucGFyc2VkQm9keSA9IGRlc2VyaWFsaXplZEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVycm9yIHJlc3BvbnNlIGhhcyBoZWFkZXJzLCB0cnkgdG8gZGVzZXJpYWxpemUgaXQgdXNpbmcgZGVmYXVsdCBoZWFkZXIgbWFwcGVyXG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5oZWFkZXJzICYmIGRlZmF1bHRIZWFkZXJzTWFwcGVyKSB7XG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZS5wYXJzZWRIZWFkZXJzID1cbiAgICAgICAgICAgICAgICBvcGVyYXRpb25TcGVjLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoZGVmYXVsdEhlYWRlcnNNYXBwZXIsIHBhcnNlZFJlc3BvbnNlLmhlYWRlcnMudG9KU09OKCksIFwib3BlcmF0aW9uUmVzLnBhcnNlZEhlYWRlcnNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGRlZmF1bHRFcnJvcikge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gYEVycm9yIFwiJHtkZWZhdWx0RXJyb3IubWVzc2FnZX1cIiBvY2N1cnJlZCBpbiBkZXNlcmlhbGl6aW5nIHRoZSByZXNwb25zZUJvZHkgLSBcIiR7cGFyc2VkUmVzcG9uc2UuYm9keUFzVGV4dH1cIiBmb3IgdGhlIGRlZmF1bHQgcmVzcG9uc2UuYDtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHNob3VsZFJldHVyblJlc3BvbnNlOiBmYWxzZSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2UoanNvbkNvbnRlbnRUeXBlcywgeG1sQ29udGVudFR5cGVzLCBvcGVyYXRpb25SZXNwb25zZSwgb3B0cywgcGFyc2VYTUwpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoKF9hID0gb3BlcmF0aW9uUmVzcG9uc2UucmVxdWVzdC5zdHJlYW1SZXNwb25zZVN0YXR1c0NvZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKG9wZXJhdGlvblJlc3BvbnNlLnN0YXR1cykpICYmXG4gICAgICAgIG9wZXJhdGlvblJlc3BvbnNlLmJvZHlBc1RleHQpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG9wZXJhdGlvblJlc3BvbnNlLmJvZHlBc1RleHQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gb3BlcmF0aW9uUmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgY29udGVudENvbXBvbmVudHMgPSAhY29udGVudFR5cGVcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogY29udGVudFR5cGUuc3BsaXQoXCI7XCIpLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY29udGVudENvbXBvbmVudHMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAgICAgY29udGVudENvbXBvbmVudHMuc29tZSgoY29tcG9uZW50KSA9PiBqc29uQ29udGVudFR5cGVzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uUmVzcG9uc2UucGFyc2VkQm9keSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudENvbXBvbmVudHMuc29tZSgoY29tcG9uZW50KSA9PiB4bWxDb250ZW50VHlwZXMuaW5kZXhPZihjb21wb25lbnQpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNpbmcgWE1MIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcGFyc2VYTUwodGV4dCwgb3B0cy54bWwpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3BvbnNlLnBhcnNlZEJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25SZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXJyb3IgXCIke2Vycn1cIiBvY2N1cnJlZCB3aGlsZSBwYXJzaW5nIHRoZSByZXNwb25zZSBib2R5IC0gJHtvcGVyYXRpb25SZXNwb25zZS5ib2R5QXNUZXh0fS5gO1xuICAgICAgICAgICAgY29uc3QgZXJyQ29kZSA9IGVyci5jb2RlIHx8IFJlc3RFcnJvci5QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgUmVzdEVycm9yKG1zZywge1xuICAgICAgICAgICAgICAgIGNvZGU6IGVyckNvZGUsXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogb3BlcmF0aW9uUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IG9wZXJhdGlvblJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG9wZXJhdGlvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXNwb25zZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlc2VyaWFsaXphdGlvblBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZURlZmF1bHRIdHRwQ2xpZW50IH0gZnJvbSBcIkBhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmVcIjtcbmxldCBjYWNoZWRIdHRwQ2xpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlZERlZmF1bHRIdHRwQ2xpZW50KCkge1xuICAgIGlmICghY2FjaGVkSHR0cENsaWVudCkge1xuICAgICAgICBjYWNoZWRIdHRwQ2xpZW50ID0gY3JlYXRlRGVmYXVsdEh0dHBDbGllbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEh0dHBDbGllbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwQ2xpZW50Q2FjaGUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBNYXBwZXJUeXBlTmFtZXMgfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG4vKipcbiAqIEdldHMgdGhlIGxpc3Qgb2Ygc3RhdHVzIGNvZGVzIGZvciBzdHJlYW1pbmcgcmVzcG9uc2VzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJlYW1pbmdSZXNwb25zZVN0YXR1c0NvZGVzKG9wZXJhdGlvblNwZWMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBzdGF0dXNDb2RlIGluIG9wZXJhdGlvblNwZWMucmVzcG9uc2VzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvblJlc3BvbnNlID0gb3BlcmF0aW9uU3BlYy5yZXNwb25zZXNbc3RhdHVzQ29kZV07XG4gICAgICAgIGlmIChvcGVyYXRpb25SZXNwb25zZS5ib2R5TWFwcGVyICYmXG4gICAgICAgICAgICBvcGVyYXRpb25SZXNwb25zZS5ib2R5TWFwcGVyLnR5cGUubmFtZSA9PT0gTWFwcGVyVHlwZU5hbWVzLlN0cmVhbSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChOdW1iZXIoc3RhdHVzQ29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldCB0aGUgcGF0aCB0byB0aGlzIHBhcmFtZXRlcidzIHZhbHVlIGFzIGEgZG90dGVkIHN0cmluZyAoYS5iLmMpLlxuICogQHBhcmFtIHBhcmFtZXRlciAtIFRoZSBwYXJhbWV0ZXIgdG8gZ2V0IHRoZSBwYXRoIHN0cmluZyBmb3IuXG4gKiBAcmV0dXJucyBUaGUgcGF0aCB0byB0aGlzIHBhcmFtZXRlcidzIHZhbHVlIGFzIGEgZG90dGVkIHN0cmluZy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aFN0cmluZ0Zyb21QYXJhbWV0ZXIocGFyYW1ldGVyKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJQYXRoLCBtYXBwZXIgfSA9IHBhcmFtZXRlcjtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyUGF0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQgPSBwYXJhbWV0ZXJQYXRoO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlclBhdGgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcmFtZXRlclBhdGguam9pbihcIi5cIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtYXBwZXIuc2VyaWFsaXplZE5hbWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2VIZWxwZXJzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBEZWZhdWx0IGtleSB1c2VkIHRvIGFjY2VzcyB0aGUgWE1MIGF0dHJpYnV0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBYTUxfQVRUUktFWSA9IFwiJFwiO1xuLyoqXG4gKiBEZWZhdWx0IGtleSB1c2VkIHRvIGFjY2VzcyB0aGUgWE1MIHZhbHVlIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBYTUxfQ0hBUktFWSA9IFwiX1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudExvZ2dlciB9IGZyb20gXCJAYXp1cmUvbG9nZ2VyXCI7XG5leHBvcnQgY29uc3QgbG9nZ2VyID0gY3JlYXRlQ2xpZW50TG9nZ2VyKFwiY29yZS1jbGllbnRcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogUmV0cmlldmVzIHRoZSB2YWx1ZSB0byB1c2UgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uIGFyZ3VtZW50XG4gKiBAcGFyYW0gb3BlcmF0aW9uQXJndW1lbnRzIC0gVGhlIGFyZ3VtZW50cyBwYXNzZWQgZnJvbSB0aGUgZ2VuZXJhdGVkIGNsaWVudFxuICogQHBhcmFtIHBhcmFtZXRlciAtIFRoZSBwYXJhbWV0ZXIgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSBmYWxsYmFja09iamVjdCAtIElmIHNvbWV0aGluZyBpc24ndCBmb3VuZCBpbiB0aGUgYXJndW1lbnRzIGJhZywgbG9vayBoZXJlLlxuICogIEdlbmVyYWxseSB1c2VkIHRvIGxvb2sgYXQgdGhlIHNlcnZpY2UgY2xpZW50IHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIHBhcmFtZXRlciwgZmFsbGJhY2tPYmplY3QpIHtcbiAgICBsZXQgcGFyYW1ldGVyUGF0aCA9IHBhcmFtZXRlci5wYXJhbWV0ZXJQYXRoO1xuICAgIGNvbnN0IHBhcmFtZXRlck1hcHBlciA9IHBhcmFtZXRlci5tYXBwZXI7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyUGF0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXJhbWV0ZXJQYXRoID0gW3BhcmFtZXRlclBhdGhdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJQYXRoKSkge1xuICAgICAgICBpZiAocGFyYW1ldGVyUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyTWFwcGVyLmlzQ29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtZXRlck1hcHBlci5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlTZWFyY2hSZXN1bHQgPSBnZXRQcm9wZXJ0eUZyb21QYXJhbWV0ZXJQYXRoKG9wZXJhdGlvbkFyZ3VtZW50cywgcGFyYW1ldGVyUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVNlYXJjaFJlc3VsdC5wcm9wZXJ0eUZvdW5kICYmIGZhbGxiYWNrT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5U2VhcmNoUmVzdWx0ID0gZ2V0UHJvcGVydHlGcm9tUGFyYW1ldGVyUGF0aChmYWxsYmFja09iamVjdCwgcGFyYW1ldGVyUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB1c2VEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5U2VhcmNoUmVzdWx0LnByb3BlcnR5Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlRGVmYXVsdFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlck1hcHBlci5yZXF1aXJlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXJhbWV0ZXJQYXRoWzBdID09PSBcIm9wdGlvbnNcIiAmJiBwYXJhbWV0ZXJQYXRoLmxlbmd0aCA9PT0gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdXNlRGVmYXVsdFZhbHVlID8gcGFyYW1ldGVyTWFwcGVyLmRlZmF1bHRWYWx1ZSA6IHByb3BlcnR5U2VhcmNoUmVzdWx0LnByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJNYXBwZXIucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gcGFyYW1ldGVyUGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlNYXBwZXIgPSBwYXJhbWV0ZXJNYXBwZXIudHlwZS5tb2RlbFByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IHBhcmFtZXRlclBhdGhbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJQYXRoOiBwcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgICAgICAgbWFwcGVyOiBwcm9wZXJ0eU1hcHBlcixcbiAgICAgICAgICAgIH0sIGZhbGxiYWNrT2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5RnJvbVBhcmFtZXRlclBhdGgocGFyZW50LCBwYXJhbWV0ZXJQYXRoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyBwcm9wZXJ0eUZvdW5kOiBmYWxzZSB9O1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHBhcmFtZXRlclBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyUGF0aFBhcnQgPSBwYXJhbWV0ZXJQYXRoW2ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gY2hlY2sgaW5oZXJpdGVkIHByb3BlcnRpZXMgdG9vLCBzbyBkb24ndCB1c2UgaGFzT3duUHJvcGVydHkoKS5cbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJhbWV0ZXJQYXRoUGFydCBpbiBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtwYXJhbWV0ZXJQYXRoUGFydF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gcGFyYW1ldGVyUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnByb3BlcnR5VmFsdWUgPSBwYXJlbnQ7XG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0eUZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG9wZXJhdGlvblJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvblJlcXVlc3RJbmZvKHJlcXVlc3QpIHtcbiAgICBsZXQgaW5mbyA9IG9wZXJhdGlvblJlcXVlc3RNYXAuZ2V0KHJlcXVlc3QpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICAgIG9wZXJhdGlvblJlcXVlc3RNYXAuc2V0KHJlcXVlc3QsIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbkhlbHBlcnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBkZXNlcmlhbGl6YXRpb25Qb2xpY3kgfSBmcm9tIFwiLi9kZXNlcmlhbGl6YXRpb25Qb2xpY3lcIjtcbmltcG9ydCB7IGJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3ksIGNyZWF0ZVBpcGVsaW5lRnJvbU9wdGlvbnMsIH0gZnJvbSBcIkBhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmVcIjtcbmltcG9ydCB7IHNlcmlhbGl6YXRpb25Qb2xpY3kgfSBmcm9tIFwiLi9zZXJpYWxpemF0aW9uUG9saWN5XCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUGlwZWxpbmUgZm9yIHVzZSB3aXRoIGEgU2VydmljZSBDbGllbnQuXG4gKiBBZGRzIGluIGRlc2VyaWFsaXphdGlvblBvbGljeSBieSBkZWZhdWx0LlxuICogQWxzbyBhZGRzIGluIGJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3kgaWYgcGFzc2VkIGEgVG9rZW5DcmVkZW50aWFsLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGN1c3RvbWl6ZSB0aGUgY3JlYXRlZCBwaXBlbGluZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudFBpcGVsaW5lKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBpcGVsaW5lID0gY3JlYXRlUGlwZWxpbmVGcm9tT3B0aW9ucyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbE9wdGlvbnMpIHtcbiAgICAgICAgcGlwZWxpbmUuYWRkUG9saWN5KGJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3koe1xuICAgICAgICAgICAgY3JlZGVudGlhbDogb3B0aW9ucy5jcmVkZW50aWFsT3B0aW9ucy5jcmVkZW50aWFsLFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLmNyZWRlbnRpYWxPcHRpb25zLmNyZWRlbnRpYWxTY29wZXMsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KHNlcmlhbGl6YXRpb25Qb2xpY3kob3B0aW9ucy5zZXJpYWxpemF0aW9uT3B0aW9ucyksIHsgcGhhc2U6IFwiU2VyaWFsaXplXCIgfSk7XG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KGRlc2VyaWFsaXphdGlvblBvbGljeShvcHRpb25zLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMpLCB7XG4gICAgICAgIHBoYXNlOiBcIkRlc2VyaWFsaXplXCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBpcGVsaW5lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZWxpbmUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBYTUxfQVRUUktFWSwgWE1MX0NIQVJLRVksIH0gZnJvbSBcIi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uQXJndW1lbnRWYWx1ZUZyb21QYXJhbWV0ZXIsIGdldE9wZXJhdGlvblJlcXVlc3RJbmZvLCB9IGZyb20gXCIuL29wZXJhdGlvbkhlbHBlcnNcIjtcbmltcG9ydCB7IE1hcHBlclR5cGVOYW1lcyB9IGZyb20gXCIuL3NlcmlhbGl6ZXJcIjtcbmltcG9ydCB7IGdldFBhdGhTdHJpbmdGcm9tUGFyYW1ldGVyIH0gZnJvbSBcIi4vaW50ZXJmYWNlSGVscGVyc1wiO1xuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIHNlcmlhbGl6YXRpb25Qb2xpY3kuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXJpYWxpemF0aW9uUG9saWN5TmFtZSA9IFwic2VyaWFsaXphdGlvblBvbGljeVwiO1xuLyoqXG4gKiBUaGlzIHBvbGljeSBoYW5kbGVzIGFzc2VtYmxpbmcgdGhlIHJlcXVlc3QgYm9keSBhbmQgaGVhZGVycyB1c2luZ1xuICogYW4gT3BlcmF0aW9uU3BlYyBhbmQgT3BlcmF0aW9uQXJndW1lbnRzIG9uIHRoZSByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXphdGlvblBvbGljeShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdHJpbmdpZnlYTUwgPSBvcHRpb25zLnN0cmluZ2lmeVhNTDtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzZXJpYWxpemF0aW9uUG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uSW5mbyA9IGdldE9wZXJhdGlvblJlcXVlc3RJbmZvKHJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uU3BlYyA9IG9wZXJhdGlvbkluZm8gPT09IG51bGwgfHwgb3BlcmF0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlcmF0aW9uSW5mby5vcGVyYXRpb25TcGVjO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uQXJndW1lbnRzID0gb3BlcmF0aW9uSW5mbyA9PT0gbnVsbCB8fCBvcGVyYXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVyYXRpb25JbmZvLm9wZXJhdGlvbkFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb25TcGVjICYmIG9wZXJhdGlvbkFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUhlYWRlcnMocmVxdWVzdCwgb3BlcmF0aW9uQXJndW1lbnRzLCBvcGVyYXRpb25TcGVjKTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVSZXF1ZXN0Qm9keShyZXF1ZXN0LCBvcGVyYXRpb25Bcmd1bWVudHMsIG9wZXJhdGlvblNwZWMsIHN0cmluZ2lmeVhNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUhlYWRlcnMocmVxdWVzdCwgb3BlcmF0aW9uQXJndW1lbnRzLCBvcGVyYXRpb25TcGVjKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAob3BlcmF0aW9uU3BlYy5oZWFkZXJQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyUGFyYW1ldGVyIG9mIG9wZXJhdGlvblNwZWMuaGVhZGVyUGFyYW1ldGVycykge1xuICAgICAgICAgICAgbGV0IGhlYWRlclZhbHVlID0gZ2V0T3BlcmF0aW9uQXJndW1lbnRWYWx1ZUZyb21QYXJhbWV0ZXIob3BlcmF0aW9uQXJndW1lbnRzLCBoZWFkZXJQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgaWYgKChoZWFkZXJWYWx1ZSAhPT0gbnVsbCAmJiBoZWFkZXJWYWx1ZSAhPT0gdW5kZWZpbmVkKSB8fCBoZWFkZXJQYXJhbWV0ZXIubWFwcGVyLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyVmFsdWUgPSBvcGVyYXRpb25TcGVjLnNlcmlhbGl6ZXIuc2VyaWFsaXplKGhlYWRlclBhcmFtZXRlci5tYXBwZXIsIGhlYWRlclZhbHVlLCBnZXRQYXRoU3RyaW5nRnJvbVBhcmFtZXRlcihoZWFkZXJQYXJhbWV0ZXIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJDb2xsZWN0aW9uUHJlZml4ID0gaGVhZGVyUGFyYW1ldGVyLm1hcHBlclxuICAgICAgICAgICAgICAgICAgICAuaGVhZGVyQ29sbGVjdGlvblByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyQ29sbGVjdGlvblByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoaGVhZGVyQ29sbGVjdGlvblByZWZpeCArIGtleSwgaGVhZGVyVmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoaGVhZGVyUGFyYW1ldGVyLm1hcHBlci5zZXJpYWxpemVkTmFtZSB8fCBnZXRQYXRoU3RyaW5nRnJvbVBhcmFtZXRlcihoZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbUhlYWRlcnMgPSAoX2IgPSAoX2EgPSBvcGVyYXRpb25Bcmd1bWVudHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcXVlc3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VzdG9tSGVhZGVycztcbiAgICBpZiAoY3VzdG9tSGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbUhlYWRlck5hbWUgb2YgT2JqZWN0LmtleXMoY3VzdG9tSGVhZGVycykpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoY3VzdG9tSGVhZGVyTmFtZSwgY3VzdG9tSGVhZGVyc1tjdXN0b21IZWFkZXJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUmVxdWVzdEJvZHkocmVxdWVzdCwgb3BlcmF0aW9uQXJndW1lbnRzLCBvcGVyYXRpb25TcGVjLCBzdHJpbmdpZnlYTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWE1MIHNlcmlhbGl6YXRpb24gdW5zdXBwb3J0ZWQhXCIpO1xufSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgc2VyaWFsaXplck9wdGlvbnMgPSAoX2EgPSBvcGVyYXRpb25Bcmd1bWVudHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmlhbGl6ZXJPcHRpb25zO1xuICAgIGNvbnN0IHVwZGF0ZWRPcHRpb25zID0ge1xuICAgICAgICB4bWw6IHtcbiAgICAgICAgICAgIHJvb3ROYW1lOiAoX2IgPSBzZXJpYWxpemVyT3B0aW9ucyA9PT0gbnVsbCB8fCBzZXJpYWxpemVyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VyaWFsaXplck9wdGlvbnMueG1sLnJvb3ROYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiLFxuICAgICAgICAgICAgaW5jbHVkZVJvb3Q6IChfYyA9IHNlcmlhbGl6ZXJPcHRpb25zID09PSBudWxsIHx8IHNlcmlhbGl6ZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpYWxpemVyT3B0aW9ucy54bWwuaW5jbHVkZVJvb3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxuICAgICAgICAgICAgeG1sQ2hhcktleTogKF9kID0gc2VyaWFsaXplck9wdGlvbnMgPT09IG51bGwgfHwgc2VyaWFsaXplck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcmlhbGl6ZXJPcHRpb25zLnhtbC54bWxDaGFyS2V5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBYTUxfQ0hBUktFWSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IHhtbENoYXJLZXkgPSB1cGRhdGVkT3B0aW9ucy54bWwueG1sQ2hhcktleTtcbiAgICBpZiAob3BlcmF0aW9uU3BlYy5yZXF1ZXN0Qm9keSAmJiBvcGVyYXRpb25TcGVjLnJlcXVlc3RCb2R5Lm1hcHBlcikge1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIG9wZXJhdGlvblNwZWMucmVxdWVzdEJvZHkpO1xuICAgICAgICBjb25zdCBib2R5TWFwcGVyID0gb3BlcmF0aW9uU3BlYy5yZXF1ZXN0Qm9keS5tYXBwZXI7XG4gICAgICAgIGNvbnN0IHsgcmVxdWlyZWQsIHNlcmlhbGl6ZWROYW1lLCB4bWxOYW1lLCB4bWxFbGVtZW50TmFtZSwgeG1sTmFtZXNwYWNlLCB4bWxOYW1lc3BhY2VQcmVmaXgsIG51bGxhYmxlLCB9ID0gYm9keU1hcHBlcjtcbiAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBib2R5TWFwcGVyLnR5cGUubmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgocmVxdWVzdC5ib2R5ICE9PSB1bmRlZmluZWQgJiYgcmVxdWVzdC5ib2R5ICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIChudWxsYWJsZSAmJiByZXF1ZXN0LmJvZHkgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keVBhcmFtZXRlclBhdGhTdHJpbmcgPSBnZXRQYXRoU3RyaW5nRnJvbVBhcmFtZXRlcihvcGVyYXRpb25TcGVjLnJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSBvcGVyYXRpb25TcGVjLnNlcmlhbGl6ZXIuc2VyaWFsaXplKGJvZHlNYXBwZXIsIHJlcXVlc3QuYm9keSwgcmVxdWVzdEJvZHlQYXJhbWV0ZXJQYXRoU3RyaW5nLCB1cGRhdGVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlTmFtZSA9PT0gTWFwcGVyVHlwZU5hbWVzLlN0cmVhbTtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uU3BlYy5pc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4bWxuc0tleSA9IHhtbE5hbWVzcGFjZVByZWZpeCA/IGB4bWxuczoke3htbE5hbWVzcGFjZVByZWZpeH1gIDogXCJ4bWxuc1wiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFhtbFZhbHVlV2l0aE5hbWVzcGFjZSh4bWxOYW1lc3BhY2UsIHhtbG5zS2V5LCB0eXBlTmFtZSwgcmVxdWVzdC5ib2R5LCB1cGRhdGVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gTWFwcGVyVHlwZU5hbWVzLlNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSBzdHJpbmdpZnlYTUwocHJlcGFyZVhNTFJvb3RMaXN0KHZhbHVlLCB4bWxFbGVtZW50TmFtZSB8fCB4bWxOYW1lIHx8IHNlcmlhbGl6ZWROYW1lLCB4bWxuc0tleSwgeG1sTmFtZXNwYWNlKSwgeyByb290TmFtZTogeG1sTmFtZSB8fCBzZXJpYWxpemVkTmFtZSwgeG1sQ2hhcktleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHN0cmluZ2lmeVhNTCh2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3ROYW1lOiB4bWxOYW1lIHx8IHNlcmlhbGl6ZWROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbENoYXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlTmFtZSA9PT0gTWFwcGVyVHlwZU5hbWVzLlN0cmluZyAmJlxuICAgICAgICAgICAgICAgICAgICAoKChfZSA9IG9wZXJhdGlvblNwZWMuY29udGVudFR5cGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5tYXRjaChcInRleHQvcGxhaW5cIikpIHx8IG9wZXJhdGlvblNwZWMubWVkaWFUeXBlID09PSBcInRleHRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIFN0cmluZyBzZXJpYWxpemVyIGhhcyB2YWxpZGF0ZWQgdGhhdCByZXF1ZXN0IGJvZHkgaXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc28ganVzdCBzZW5kIHRoZSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBcIiR7ZXJyb3IubWVzc2FnZX1cIiBvY2N1cnJlZCBpbiBzZXJpYWxpemluZyB0aGUgcGF5bG9hZCAtICR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZE5hbWUsIHVuZGVmaW5lZCwgXCIgIFwiKX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uU3BlYy5mb3JtRGF0YVBhcmFtZXRlcnMgJiYgb3BlcmF0aW9uU3BlYy5mb3JtRGF0YVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXF1ZXN0LmZvcm1EYXRhID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZm9ybURhdGFQYXJhbWV0ZXIgb2Ygb3BlcmF0aW9uU3BlYy5mb3JtRGF0YVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhUGFyYW1ldGVyVmFsdWUgPSBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIGZvcm1EYXRhUGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGlmIChmb3JtRGF0YVBhcmFtZXRlclZhbHVlICE9PSB1bmRlZmluZWQgJiYgZm9ybURhdGFQYXJhbWV0ZXJWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhUGFyYW1ldGVyUHJvcGVydHlOYW1lID0gZm9ybURhdGFQYXJhbWV0ZXIubWFwcGVyLnNlcmlhbGl6ZWROYW1lIHx8IGdldFBhdGhTdHJpbmdGcm9tUGFyYW1ldGVyKGZvcm1EYXRhUGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmZvcm1EYXRhW2Zvcm1EYXRhUGFyYW1ldGVyUHJvcGVydHlOYW1lXSA9IG9wZXJhdGlvblNwZWMuc2VyaWFsaXplci5zZXJpYWxpemUoZm9ybURhdGFQYXJhbWV0ZXIubWFwcGVyLCBmb3JtRGF0YVBhcmFtZXRlclZhbHVlLCBnZXRQYXRoU3RyaW5nRnJvbVBhcmFtZXRlcihmb3JtRGF0YVBhcmFtZXRlciksIHVwZGF0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQWRkcyBhbiB4bWwgbmFtZXNwYWNlIHRvIHRoZSB4bWwgc2VyaWFsaXplZCBvYmplY3QgaWYgbmVlZGVkLCBvdGhlcndpc2UgaXQganVzdCByZXR1cm5zIHRoZSB2YWx1ZSBpdHNlbGZcbiAqL1xuZnVuY3Rpb24gZ2V0WG1sVmFsdWVXaXRoTmFtZXNwYWNlKHhtbE5hbWVzcGFjZSwgeG1sbnNLZXksIHR5cGVOYW1lLCBzZXJpYWxpemVkVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBDb21wb3NpdGUgYW5kIFNlcXVlbmNlIHNjaGVtYXMgYWxyZWFkeSBnb3QgdGhlaXIgcm9vdCBuYW1lc3BhY2Ugc2V0IGR1cmluZyBzZXJpYWxpemF0aW9uXG4gICAgLy8gV2UganVzdCBuZWVkIHRvIGFkZCB4bWxucyB0byB0aGUgb3RoZXIgc2NoZW1hIHR5cGVzXG4gICAgaWYgKHhtbE5hbWVzcGFjZSAmJiAhW1wiQ29tcG9zaXRlXCIsIFwiU2VxdWVuY2VcIiwgXCJEaWN0aW9uYXJ5XCJdLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W29wdGlvbnMueG1sLnhtbENoYXJLZXldID0gc2VyaWFsaXplZFZhbHVlO1xuICAgICAgICByZXN1bHRbWE1MX0FUVFJLRVldID0geyBbeG1sbnNLZXldOiB4bWxOYW1lc3BhY2UgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVYTUxSb290TGlzdChvYmosIGVsZW1lbnROYW1lLCB4bWxOYW1lc3BhY2VLZXksIHhtbE5hbWVzcGFjZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iaiA9IFtvYmpdO1xuICAgIH1cbiAgICBpZiAoIXhtbE5hbWVzcGFjZUtleSB8fCAheG1sTmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB7IFtlbGVtZW50TmFtZV06IG9iaiB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IFtlbGVtZW50TmFtZV06IG9iaiB9O1xuICAgIHJlc3VsdFtYTUxfQVRUUktFWV0gPSB7IFt4bWxOYW1lc3BhY2VLZXldOiB4bWxOYW1lc3BhY2UgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvblBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCAqIGFzIGJhc2U2NCBmcm9tIFwiLi9iYXNlNjRcIjtcbmltcG9ydCB7IFhNTF9BVFRSS0VZLCBYTUxfQ0hBUktFWSwgfSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBpc0R1cmF0aW9uLCBpc1ZhbGlkVXVpZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5jbGFzcyBTZXJpYWxpemVySW1wbCB7XG4gICAgY29uc3RydWN0b3IobW9kZWxNYXBwZXJzID0ge30sIGlzWE1MID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tb2RlbE1hcHBlcnMgPSBtb2RlbE1hcHBlcnM7XG4gICAgICAgIHRoaXMuaXNYTUwgPSBpc1hNTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVtb3ZpbmcgdGhlIGNvbnN0cmFpbnRzIHZhbGlkYXRpb24gb24gY2xpZW50IHNpZGUuXG4gICAgICovXG4gICAgdmFsaWRhdGVDb25zdHJhaW50cyhtYXBwZXIsIHZhbHVlLCBvYmplY3ROYW1lKSB7XG4gICAgICAgIGNvbnN0IGZhaWxWYWxpZGF0aW9uID0gKGNvbnN0cmFpbnROYW1lLCBjb25zdHJhaW50VmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke29iamVjdE5hbWV9XCIgd2l0aCB2YWx1ZSBcIiR7dmFsdWV9XCIgc2hvdWxkIHNhdGlzZnkgdGhlIGNvbnN0cmFpbnQgXCIke2NvbnN0cmFpbnROYW1lfVwiOiAke2NvbnN0cmFpbnRWYWx1ZX0uYCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXBwZXIuY29uc3RyYWludHMgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyBFeGNsdXNpdmVNYXhpbXVtLCBFeGNsdXNpdmVNaW5pbXVtLCBJbmNsdXNpdmVNYXhpbXVtLCBJbmNsdXNpdmVNaW5pbXVtLCBNYXhJdGVtcywgTWF4TGVuZ3RoLCBNaW5JdGVtcywgTWluTGVuZ3RoLCBNdWx0aXBsZU9mLCBQYXR0ZXJuLCBVbmlxdWVJdGVtcywgfSA9IG1hcHBlci5jb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmIChFeGNsdXNpdmVNYXhpbXVtICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gRXhjbHVzaXZlTWF4aW11bSkge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiRXhjbHVzaXZlTWF4aW11bVwiLCBFeGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChFeGNsdXNpdmVNaW5pbXVtICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPD0gRXhjbHVzaXZlTWluaW11bSkge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiRXhjbHVzaXZlTWluaW11bVwiLCBFeGNsdXNpdmVNaW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJbmNsdXNpdmVNYXhpbXVtICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiBJbmNsdXNpdmVNYXhpbXVtKSB7XG4gICAgICAgICAgICAgICAgZmFpbFZhbGlkYXRpb24oXCJJbmNsdXNpdmVNYXhpbXVtXCIsIEluY2x1c2l2ZU1heGltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEluY2x1c2l2ZU1pbmltdW0gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8IEluY2x1c2l2ZU1pbmltdW0pIHtcbiAgICAgICAgICAgICAgICBmYWlsVmFsaWRhdGlvbihcIkluY2x1c2l2ZU1pbmltdW1cIiwgSW5jbHVzaXZlTWluaW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF4SXRlbXMgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPiBNYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiTWF4SXRlbXNcIiwgTWF4SXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1heExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA+IE1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiTWF4TGVuZ3RoXCIsIE1heExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWluSXRlbXMgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPCBNaW5JdGVtcykge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiTWluSXRlbXNcIiwgTWluSXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA8IE1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiTWluTGVuZ3RoXCIsIE1pbkxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTXVsdGlwbGVPZiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICUgTXVsdGlwbGVPZiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZhaWxWYWxpZGF0aW9uKFwiTXVsdGlwbGVPZlwiLCBNdWx0aXBsZU9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiBQYXR0ZXJuID09PSBcInN0cmluZ1wiID8gbmV3IFJlZ0V4cChQYXR0ZXJuKSA6IFBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5tYXRjaChwYXR0ZXJuKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsVmFsaWRhdGlvbihcIlBhdHRlcm5cIiwgUGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFVuaXF1ZUl0ZW1zICYmXG4gICAgICAgICAgICAgICAgdmFsdWUuc29tZSgoaXRlbSwgaSwgYXIpID0+IGFyLmluZGV4T2YoaXRlbSkgIT09IGkpKSB7XG4gICAgICAgICAgICAgICAgZmFpbFZhbGlkYXRpb24oXCJVbmlxdWVJdGVtc1wiLCBVbmlxdWVJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBnaXZlbiBvYmplY3QgYmFzZWQgb24gaXRzIG1ldGFkYXRhIGRlZmluZWQgaW4gdGhlIG1hcHBlclxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcHBlciAtIFRoZSBtYXBwZXIgd2hpY2ggZGVmaW5lcyB0aGUgbWV0YWRhdGEgb2YgdGhlIHNlcmlhbGl6YWJsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBIHZhbGlkIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmplY3ROYW1lIC0gTmFtZSBvZiB0aGUgc2VyaWFsaXplZCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zIHRvIHNlcmlhbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWQgc2VyaWFsaXplZCBKYXZhc2NyaXB0IG9iamVjdFxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShtYXBwZXIsIG9iamVjdCwgb2JqZWN0TmFtZSwgb3B0aW9ucyA9IHsgeG1sOiB7fSB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHhtbDoge1xuICAgICAgICAgICAgICAgIHJvb3ROYW1lOiAoX2EgPSBvcHRpb25zLnhtbC5yb290TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIixcbiAgICAgICAgICAgICAgICBpbmNsdWRlUm9vdDogKF9iID0gb3B0aW9ucy54bWwuaW5jbHVkZVJvb3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHhtbENoYXJLZXk6IChfYyA9IG9wdGlvbnMueG1sLnhtbENoYXJLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFhNTF9DSEFSS0VZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgbWFwcGVyVHlwZSA9IG1hcHBlci50eXBlLm5hbWU7XG4gICAgICAgIGlmICghb2JqZWN0TmFtZSkge1xuICAgICAgICAgICAgb2JqZWN0TmFtZSA9IG1hcHBlci5zZXJpYWxpemVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXlNlcXVlbmNlJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBwZXIuaXNDb25zdGFudCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gbWFwcGVyLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRhYmxlIG9mIGFsbG93ZWQgdmFsdWVzIHNob3VsZCBoZWxwIGV4cGxhaW5cbiAgICAgICAgLy8gdGhlIG1hcHBlci5yZXF1aXJlZCBhbmQgbWFwcGVyLm51bGxhYmxlIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFggbWVhbnMgXCJuZWl0aGVyIHVuZGVmaW5lZCBvciBudWxsIGFyZSBhbGxvd2VkXCIuXG4gICAgICAgIC8vICAgICAgICAgICB8fCByZXF1aXJlZFxuICAgICAgICAvLyAgICAgICAgICAgfHwgdHJ1ZSAgICAgIHwgZmFsc2VcbiAgICAgICAgLy8gIG51bGxhYmxlIHx8ID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vICAgICAgdHJ1ZSB8fCBudWxsICAgICAgfCB1bmRlZmluZWQvbnVsbFxuICAgICAgICAvLyAgICAgZmFsc2UgfHwgWCAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgIC8vIHVuZGVmaW5lZCB8fCBYICAgICAgICAgfCB1bmRlZmluZWQvbnVsbFxuICAgICAgICBjb25zdCB7IHJlcXVpcmVkLCBudWxsYWJsZSB9ID0gbWFwcGVyO1xuICAgICAgICBpZiAocmVxdWlyZWQgJiYgbnVsbGFibGUgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBjYW5ub3QgYmUgdW5kZWZpbmVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1aXJlZCAmJiAhbnVsbGFibGUgJiYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXF1aXJlZCAmJiBudWxsYWJsZSA9PT0gZmFsc2UgJiYgb2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqZWN0TmFtZX0gY2Fubm90IGJlIG51bGwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eYW55JC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBvYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eKE51bWJlcnxTdHJpbmd8Qm9vbGVhbnxPYmplY3R8U3RyZWFtfFV1aWQpJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBzZXJpYWxpemVCYXNpY1R5cGVzKG1hcHBlclR5cGUsIG9iamVjdE5hbWUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eRW51bSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnVtTWFwcGVyID0gbWFwcGVyO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBzZXJpYWxpemVFbnVtVHlwZShvYmplY3ROYW1lLCBlbnVtTWFwcGVyLnR5cGUuYWxsb3dlZFZhbHVlcywgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlclR5cGUubWF0Y2goL14oRGF0ZXxEYXRlVGltZXxUaW1lU3BhbnxEYXRlVGltZVJmYzExMjN8VW5peFRpbWUpJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBzZXJpYWxpemVEYXRlVHlwZXMobWFwcGVyVHlwZSwgb2JqZWN0LCBvYmplY3ROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlclR5cGUubWF0Y2goL15CeXRlQXJyYXkkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHNlcmlhbGl6ZUJ5dGVBcnJheVR5cGUob2JqZWN0TmFtZSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlclR5cGUubWF0Y2goL15CYXNlNjRVcmwkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHNlcmlhbGl6ZUJhc2U2NFVybFR5cGUob2JqZWN0TmFtZSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlclR5cGUubWF0Y2goL15TZXF1ZW5jZSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gc2VyaWFsaXplU2VxdWVuY2VUeXBlKHRoaXMsIG1hcHBlciwgb2JqZWN0LCBvYmplY3ROYW1lLCBCb29sZWFuKHRoaXMuaXNYTUwpLCB1cGRhdGVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eRGljdGlvbmFyeSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gc2VyaWFsaXplRGljdGlvbmFyeVR5cGUodGhpcywgbWFwcGVyLCBvYmplY3QsIG9iamVjdE5hbWUsIEJvb2xlYW4odGhpcy5pc1hNTCksIHVwZGF0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlclR5cGUubWF0Y2goL15Db21wb3NpdGUkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHNlcmlhbGl6ZUNvbXBvc2l0ZVR5cGUodGhpcywgbWFwcGVyLCBvYmplY3QsIG9iamVjdE5hbWUsIEJvb2xlYW4odGhpcy5pc1hNTCksIHVwZGF0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgdGhlIGdpdmVuIG9iamVjdCBiYXNlZCBvbiBpdHMgbWV0YWRhdGEgZGVmaW5lZCBpbiB0aGUgbWFwcGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwcGVyIC0gVGhlIG1hcHBlciB3aGljaCBkZWZpbmVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgc2VyaWFsaXphYmxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3BvbnNlQm9keSAtIEEgdmFsaWQgSmF2YXNjcmlwdCBlbnRpdHkgdG8gYmUgZGVzZXJpYWxpemVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0TmFtZSAtIE5hbWUgb2YgdGhlIGRlc2VyaWFsaXplZCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29udHJvbHMgYmVoYXZpb3Igb2YgWE1MIHBhcnNlciBhbmQgYnVpbGRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWQgZGVzZXJpYWxpemVkIEphdmFzY3JpcHQgb2JqZWN0XG4gICAgICovXG4gICAgZGVzZXJpYWxpemUobWFwcGVyLCByZXNwb25zZUJvZHksIG9iamVjdE5hbWUsIG9wdGlvbnMgPSB7IHhtbDoge30gfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdXBkYXRlZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICB4bWw6IHtcbiAgICAgICAgICAgICAgICByb290TmFtZTogKF9hID0gb3B0aW9ucy54bWwucm9vdE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVJvb3Q6IChfYiA9IG9wdGlvbnMueG1sLmluY2x1ZGVSb290KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB4bWxDaGFyS2V5OiAoX2MgPSBvcHRpb25zLnhtbC54bWxDaGFyS2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBYTUxfQ0hBUktFWSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXNwb25zZUJvZHkgPT09IHVuZGVmaW5lZCB8fCByZXNwb25zZUJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzWE1MICYmIG1hcHBlci50eXBlLm5hbWUgPT09IFwiU2VxdWVuY2VcIiAmJiAhbWFwcGVyLnhtbElzV3JhcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSBmb3IgZW1wdHkgWE1MIG5vbi13cmFwcGVkIGxpc3RzLiB4bWwyanMgY2FuJ3QgZGlzdGluZ3Vpc2hcbiAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHRoZSBsaXN0IGJlaW5nIGVtcHR5IHZlcnN1cyBiZWluZyBtaXNzaW5nLFxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGRvIHRoZSBtb3JlIHVzZXItZnJpZW5kbHkgdGhpbmcgYW5kIHJldHVybiBhbiBlbXB0eSBsaXN0LlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGNoZWNrIGZvciB1bmRlZmluZWQgYXMgZGVmYXVsdCB2YWx1ZSBjYW4gYmUgYSBmYWxzZXkgdmFsdWUgYDAsIFwiXCIsIGZhbHNlLCBudWxsYFxuICAgICAgICAgICAgaWYgKG1hcHBlci5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IG1hcHBlci5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgICBjb25zdCBtYXBwZXJUeXBlID0gbWFwcGVyLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKCFvYmplY3ROYW1lKSB7XG4gICAgICAgICAgICBvYmplY3ROYW1lID0gbWFwcGVyLnNlcmlhbGl6ZWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eQ29tcG9zaXRlJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IGRlc2VyaWFsaXplQ29tcG9zaXRlVHlwZSh0aGlzLCBtYXBwZXIsIHJlc3BvbnNlQm9keSwgb2JqZWN0TmFtZSwgdXBkYXRlZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNYTUwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4bWxDaGFyS2V5ID0gdXBkYXRlZE9wdGlvbnMueG1sLnhtbENoYXJLZXk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIG1hcHBlciBzcGVjaWZpZXMgdGhpcyBhcyBhIG5vbi1jb21wb3NpdGUgdHlwZSB2YWx1ZSBidXQgdGhlIHJlc3BvbnNlQm9keSBjb250YWluc1xuICAgICAgICAgICAgICAgICAqIGJvdGggaGVhZGVyIChcIiRcIiBpLmUuLCBYTUxfQVRUUktFWSkgYW5kIGJvZHkgKFwiI1wiIGkuZS4sIFhNTF9DSEFSS0VZKSBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAqIHRoZW4ganVzdCByZWR1Y2UgdGhlIHJlc3BvbnNlQm9keSB2YWx1ZSB0byB0aGUgYm9keSAoXCIjXCIgaS5lLiwgWE1MX0NIQVJLRVkpIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJvZHlbWE1MX0FUVFJLRVldICE9PSB1bmRlZmluZWQgJiYgcmVzcG9uc2VCb2R5W3htbENoYXJLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5W3htbENoYXJLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eTnVtYmVyJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBwYXJzZUZsb2F0KHJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSByZXNwb25zZUJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXkJvb2xlYW4kL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQm9keSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlQm9keSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSByZXNwb25zZUJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXihTdHJpbmd8RW51bXxPYmplY3R8U3RyZWFtfFV1aWR8VGltZVNwYW58YW55KSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gcmVzcG9uc2VCb2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXihEYXRlfERhdGVUaW1lfERhdGVUaW1lUmZjMTEyMykkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IG5ldyBEYXRlKHJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eVW5peFRpbWUkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHVuaXhUaW1lVG9EYXRlKHJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eQnl0ZUFycmF5JC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBiYXNlNjQuZGVjb2RlU3RyaW5nKHJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXBwZXJUeXBlLm1hdGNoKC9eQmFzZTY0VXJsJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBiYXNlNjRVcmxUb0J5dGVBcnJheShyZXNwb25zZUJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXlNlcXVlbmNlJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBkZXNlcmlhbGl6ZVNlcXVlbmNlVHlwZSh0aGlzLCBtYXBwZXIsIHJlc3BvbnNlQm9keSwgb2JqZWN0TmFtZSwgdXBkYXRlZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyVHlwZS5tYXRjaCgvXkRpY3Rpb25hcnkkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IGRlc2VyaWFsaXplRGljdGlvbmFyeVR5cGUodGhpcywgbWFwcGVyLCByZXNwb25zZUJvZHksIG9iamVjdE5hbWUsIHVwZGF0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwcGVyLmlzQ29uc3RhbnQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBtYXBwZXIuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbn1cbi8qKlxuICogTWV0aG9kIHRoYXQgY3JlYXRlcyBhbmQgcmV0dXJucyBhIFNlcmlhbGl6ZXIuXG4gKiBAcGFyYW0gbW9kZWxNYXBwZXJzIC0gS25vd24gbW9kZWxzIHRvIG1hcFxuICogQHBhcmFtIGlzWE1MIC0gSWYgWE1MIHNob3VsZCBiZSBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIobW9kZWxNYXBwZXJzID0ge30sIGlzWE1MID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IFNlcmlhbGl6ZXJJbXBsKG1vZGVsTWFwcGVycywgaXNYTUwpO1xufVxuZnVuY3Rpb24gdHJpbUVuZChzdHIsIGNoKSB7XG4gICAgbGV0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbiAtIDEgPj0gMCAmJiBzdHJbbGVuIC0gMV0gPT09IGNoKSB7XG4gICAgICAgIC0tbGVuO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBsZW4pO1xufVxuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjRVcmwoYnVmZmVyKSB7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgcHJvdmlkZSBhbiBpbnB1dCBvZiB0eXBlIFVpbnQ4QXJyYXkgZm9yIGNvbnZlcnRpbmcgdG8gQmFzZTY0VXJsLmApO1xuICAgIH1cbiAgICAvLyBVaW50OEFycmF5IHRvIEJhc2U2NC5cbiAgICBjb25zdCBzdHIgPSBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KGJ1ZmZlcik7XG4gICAgLy8gQmFzZTY0IHRvIEJhc2U2NFVybC5cbiAgICByZXR1cm4gdHJpbUVuZChzdHIsIFwiPVwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG59XG5mdW5jdGlvbiBiYXNlNjRVcmxUb0J5dGVBcnJheShzdHIpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc3RyICYmIHR5cGVvZiBzdHIudmFsdWVPZigpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGFuIGlucHV0IG9mIHR5cGUgc3RyaW5nIGZvciBjb252ZXJ0aW5nIHRvIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIC8vIEJhc2U2NFVybCB0byBCYXNlNjQuXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIC8vIEJhc2U2NCB0byBVaW50OEFycmF5LlxuICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0cik7XG59XG5mdW5jdGlvbiBzcGxpdFNlcmlhbGl6ZU5hbWUocHJvcCkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICBsZXQgcGFydGlhbGNsYXNzID0gXCJcIjtcbiAgICBpZiAocHJvcCkge1xuICAgICAgICBjb25zdCBzdWJ3b3JkcyA9IHByb3Auc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3Vid29yZHMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxjbGFzcyArPSBpdGVtLnN1YnN0cigwLCBpdGVtLmxlbmd0aCAtIDEpICsgXCIuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsY2xhc3MgKz0gaXRlbTtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2gocGFydGlhbGNsYXNzKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsY2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFzc2VzO1xufVxuZnVuY3Rpb24gZGF0ZVRvVW5peFRpbWUoZCkge1xuICAgIGlmICghZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGQudmFsdWVPZigpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZC5nZXRUaW1lKCkgLyAxMDAwKTtcbn1cbmZ1bmN0aW9uIHVuaXhUaW1lVG9EYXRlKG4pIHtcbiAgICBpZiAoIW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKG4gKiAxMDAwKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJhc2ljVHlwZXModHlwZU5hbWUsIG9iamVjdE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVOYW1lLm1hdGNoKC9eTnVtYmVyJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSB3aXRoIHZhbHVlICR7dmFsdWV9IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZU5hbWUubWF0Y2goL15TdHJpbmckL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSB3aXRoIHZhbHVlIFwiJHt2YWx1ZX1cIiBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVOYW1lLm1hdGNoKC9eVXVpZCQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZS52YWx1ZU9mKCkgPT09IFwic3RyaW5nXCIgJiYgaXNWYWxpZFV1aWQodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSB3aXRoIHZhbHVlIFwiJHt2YWx1ZX1cIiBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nIGFuZCBhIHZhbGlkIHV1aWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZU5hbWUubWF0Y2goL15Cb29sZWFuJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqZWN0TmFtZX0gd2l0aCB2YWx1ZSAke3ZhbHVlfSBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlTmFtZS5tYXRjaCgvXlN0cmVhbSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAob2JqZWN0VHlwZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5waXBlICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAvLyBGaWxlIG9iamVjdHMgY291bnQgYXMgYSB0eXBlIG9mIEJsb2IsIHNvIHdlIHdhbnQgdG8gdXNlIGluc3RhbmNlb2YgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICEoKHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIEJsb2IgPT09IFwib2JqZWN0XCIpICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqZWN0TmFtZX0gbXVzdCBiZSBhIHN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIEFycmF5QnVmZmVyVmlldywgb3IgTm9kZUpTLlJlYWRhYmxlU3RyZWFtLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVudW1UeXBlKG9iamVjdE5hbWUsIGFsbG93ZWRWYWx1ZXMsIHZhbHVlKSB7XG4gICAgaWYgKCFhbGxvd2VkVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIHByb3ZpZGUgYSBzZXQgb2YgYWxsb3dlZFZhbHVlcyB0byB2YWxpZGF0ZSAke29iamVjdE5hbWV9IGFzIGFuIEVudW0gVHlwZS5gKTtcbiAgICB9XG4gICAgY29uc3QgaXNQcmVzZW50ID0gYWxsb3dlZFZhbHVlcy5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS52YWx1ZU9mKCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmICghaXNQcmVzZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yICR7b2JqZWN0TmFtZX0uIFRoZSB2YWxpZCB2YWx1ZXMgYXJlOiAke0pTT04uc3RyaW5naWZ5KGFsbG93ZWRWYWx1ZXMpfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQnl0ZUFycmF5VHlwZShvYmplY3ROYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBtdXN0IGJlIG9mIHR5cGUgVWludDhBcnJheS5gKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCYXNlNjRVcmxUeXBlKG9iamVjdE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29iamVjdE5hbWV9IG11c3QgYmUgb2YgdHlwZSBVaW50OEFycmF5LmApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYnVmZmVyVG9CYXNlNjRVcmwodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEYXRlVHlwZXModHlwZU5hbWUsIHZhbHVlLCBvYmplY3ROYW1lKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVOYW1lLm1hdGNoKC9eRGF0ZSQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWVPZigpID09PSBcInN0cmluZ1wiICYmICFpc05hTihEYXRlLnBhcnNlKHZhbHVlKSkpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBtdXN0IGJlIGFuIGluc3RhbmNlb2YgRGF0ZSBvciBhIHN0cmluZyBpbiBJU084NjAxIGZvcm1hdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGVcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVOYW1lLm1hdGNoKC9eRGF0ZVRpbWUkL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSA9PT0gXCJzdHJpbmdcIiAmJiAhaXNOYU4oRGF0ZS5wYXJzZSh2YWx1ZSkpKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqZWN0TmFtZX0gbXVzdCBiZSBhbiBpbnN0YW5jZW9mIERhdGUgb3IgYSBzdHJpbmcgaW4gSVNPODYwMSBmb3JtYXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLnRvSVNPU3RyaW5nKCkgOiBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlTmFtZS5tYXRjaCgvXkRhdGVUaW1lUmZjMTEyMyQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWVPZigpID09PSBcInN0cmluZ1wiICYmICFpc05hTihEYXRlLnBhcnNlKHZhbHVlKSkpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBtdXN0IGJlIGFuIGluc3RhbmNlb2YgRGF0ZSBvciBhIHN0cmluZyBpbiBSRkMtMTEyMyBmb3JtYXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLnRvVVRDU3RyaW5nKCkgOiBuZXcgRGF0ZSh2YWx1ZSkudG9VVENTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlTmFtZS5tYXRjaCgvXlVuaXhUaW1lJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZS52YWx1ZU9mKCkgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKERhdGUucGFyc2UodmFsdWUpKSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29iamVjdE5hbWV9IG11c3QgYmUgYW4gaW5zdGFuY2VvZiBEYXRlIG9yIGEgc3RyaW5nIGluIFJGQy0xMTIzL0lTTzg2MDEgZm9ybWF0IGAgK1xuICAgICAgICAgICAgICAgICAgICBgZm9yIGl0IHRvIGJlIHNlcmlhbGl6ZWQgaW4gVW5peFRpbWUvRXBvY2ggZm9ybWF0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBkYXRlVG9Vbml4VGltZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZU5hbWUubWF0Y2goL15UaW1lU3BhbiQvaSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghaXNEdXJhdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqZWN0TmFtZX0gbXVzdCBiZSBhIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQuIEluc3RlYWQgd2FzIFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTZXF1ZW5jZVR5cGUoc2VyaWFsaXplciwgbWFwcGVyLCBvYmplY3QsIG9iamVjdE5hbWUsIGlzWG1sLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBtdXN0IGJlIG9mIHR5cGUgQXJyYXkuYCk7XG4gICAgfVxuICAgIGxldCBlbGVtZW50VHlwZSA9IG1hcHBlci50eXBlLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50VHlwZSB8fCB0eXBlb2YgZWxlbWVudFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbGVtZW50XCIgbWV0YWRhdGEgZm9yIGFuIEFycmF5IG11c3QgYmUgZGVmaW5lZCBpbiB0aGUgYCArXG4gICAgICAgICAgICBgbWFwcGVyIGFuZCBpdCBtdXN0IG9mIHR5cGUgXCJvYmplY3RcIiBpbiAke29iamVjdE5hbWV9LmApO1xuICAgIH1cbiAgICAvLyBRdWlyazogQ29tcG9zaXRlIG1hcHBlcnMgcmVmZXJlbmNlZCBieSBgZWxlbWVudGAgbWlnaHRcbiAgICAvLyBub3QgaGF2ZSAqYWxsKiBwcm9wZXJ0aWVzIGRlY2xhcmVkIChsaWtlIHViZXJQYXJlbnQpLFxuICAgIC8vIHNvIGxldCdzIHRyeSB0byBsb29rIHVwIHRoZSBmdWxsIGRlZmluaXRpb24gYnkgbmFtZS5cbiAgICBpZiAoZWxlbWVudFR5cGUudHlwZS5uYW1lID09PSBcIkNvbXBvc2l0ZVwiICYmIGVsZW1lbnRUeXBlLnR5cGUuY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW1lbnRUeXBlID0gKF9hID0gc2VyaWFsaXplci5tb2RlbE1hcHBlcnNbZWxlbWVudFR5cGUudHlwZS5jbGFzc05hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbGVtZW50VHlwZTtcbiAgICB9XG4gICAgY29uc3QgdGVtcEFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gc2VyaWFsaXplci5zZXJpYWxpemUoZWxlbWVudFR5cGUsIG9iamVjdFtpXSwgb2JqZWN0TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChpc1htbCAmJiBlbGVtZW50VHlwZS54bWxOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHhtbG5zS2V5ID0gZWxlbWVudFR5cGUueG1sTmFtZXNwYWNlUHJlZml4XG4gICAgICAgICAgICAgICAgPyBgeG1sbnM6JHtlbGVtZW50VHlwZS54bWxOYW1lc3BhY2VQcmVmaXh9YFxuICAgICAgICAgICAgICAgIDogXCJ4bWxuc1wiO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlLnR5cGUubmFtZSA9PT0gXCJDb21wb3NpdGVcIikge1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheVtpXSA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmlhbGl6ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5W2ldW1hNTF9BVFRSS0VZXSA9IHsgW3htbG5zS2V5XTogZWxlbWVudFR5cGUueG1sTmFtZXNwYWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbaV0gPSB7fTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbaV1bb3B0aW9ucy54bWwueG1sQ2hhcktleV0gPSBzZXJpYWxpemVkVmFsdWU7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5W2ldW1hNTF9BVFRSS0VZXSA9IHsgW3htbG5zS2V5XTogZWxlbWVudFR5cGUueG1sTmFtZXNwYWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wQXJyYXlbaV0gPSBzZXJpYWxpemVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXBBcnJheTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZURpY3Rpb25hcnlUeXBlKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0LCBvYmplY3ROYW1lLCBpc1htbCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmplY3ROYW1lfSBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0LmApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBtYXBwZXIudHlwZS52YWx1ZTtcbiAgICBpZiAoIXZhbHVlVHlwZSB8fCB0eXBlb2YgdmFsdWVUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJ2YWx1ZVwiIG1ldGFkYXRhIGZvciBhIERpY3Rpb25hcnkgbXVzdCBiZSBkZWZpbmVkIGluIHRoZSBgICtcbiAgICAgICAgICAgIGBtYXBwZXIgYW5kIGl0IG11c3Qgb2YgdHlwZSBcIm9iamVjdFwiIGluICR7b2JqZWN0TmFtZX0uYCk7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBEaWN0aW9uYXJ5ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZVR5cGUsIG9iamVjdFtrZXldLCBvYmplY3ROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbmVlZHMgYW4gWE1MIG5hbWVzcGFjZSB3ZSBuZWVkIHRvIGFkZCBpdCB3aXRoaW4gdGhlICQgcHJvcGVydHlcbiAgICAgICAgdGVtcERpY3Rpb25hcnlba2V5XSA9IGdldFhtbE9iamVjdFZhbHVlKHZhbHVlVHlwZSwgc2VyaWFsaXplZFZhbHVlLCBpc1htbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgbmFtZXNwYWNlIHRvIHRoZSByb290IGVsZW1lbnQgaWYgbmVlZGVkXG4gICAgaWYgKGlzWG1sICYmIG1hcHBlci54bWxOYW1lc3BhY2UpIHtcbiAgICAgICAgY29uc3QgeG1sbnNLZXkgPSBtYXBwZXIueG1sTmFtZXNwYWNlUHJlZml4ID8gYHhtbG5zOiR7bWFwcGVyLnhtbE5hbWVzcGFjZVByZWZpeH1gIDogXCJ4bWxuc1wiO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0ZW1wRGljdGlvbmFyeTtcbiAgICAgICAgcmVzdWx0W1hNTF9BVFRSS0VZXSA9IHsgW3htbG5zS2V5XTogbWFwcGVyLnhtbE5hbWVzcGFjZSB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGVtcERpY3Rpb25hcnk7XG59XG4vKipcbiAqIFJlc29sdmVzIHRoZSBhZGRpdGlvbmFsUHJvcGVydGllcyBwcm9wZXJ0eSBmcm9tIGEgcmVmZXJlbmNlZCBtYXBwZXJcbiAqIEBwYXJhbSBzZXJpYWxpemVyIC0gdGhlIHNlcmlhbGl6ZXIgY29udGFpbmluZyB0aGUgZW50aXJlIHNldCBvZiBtYXBwZXJzXG4gKiBAcGFyYW0gbWFwcGVyIC0gdGhlIGNvbXBvc2l0ZSBtYXBwZXIgdG8gcmVzb2x2ZVxuICogQHBhcmFtIG9iamVjdE5hbWUgLSBuYW1lIG9mIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXplZFxuICovXG5mdW5jdGlvbiByZXNvbHZlQWRkaXRpb25hbFByb3BlcnRpZXMoc2VyaWFsaXplciwgbWFwcGVyLCBvYmplY3ROYW1lKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBtYXBwZXIudHlwZS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICBpZiAoIWFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmIG1hcHBlci50eXBlLmNsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBtb2RlbE1hcHBlciA9IHJlc29sdmVSZWZlcmVuY2VkTWFwcGVyKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0TmFtZSk7XG4gICAgICAgIHJldHVybiBtb2RlbE1hcHBlciA9PT0gbnVsbCB8fCBtb2RlbE1hcHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWxNYXBwZXIudHlwZS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICB9XG4gICAgcmV0dXJuIGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbWFwcGVyIHJlZmVyZW5jZWQgYnkgY2xhc3NOYW1lXG4gKiBAcGFyYW0gc2VyaWFsaXplciAtIHRoZSBzZXJpYWxpemVyIGNvbnRhaW5pbmcgdGhlIGVudGlyZSBzZXQgb2YgbWFwcGVyc1xuICogQHBhcmFtIG1hcHBlciAtIHRoZSBjb21wb3NpdGUgbWFwcGVyIHRvIHJlc29sdmVcbiAqIEBwYXJhbSBvYmplY3ROYW1lIC0gbmFtZSBvZiB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGl6ZWRcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZWRNYXBwZXIoc2VyaWFsaXplciwgbWFwcGVyLCBvYmplY3ROYW1lKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gbWFwcGVyLnR5cGUuY2xhc3NOYW1lO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhc3MgbmFtZSBmb3IgbW9kZWwgXCIke29iamVjdE5hbWV9XCIgaXMgbm90IHByb3ZpZGVkIGluIHRoZSBtYXBwZXIgXCIke0pTT04uc3RyaW5naWZ5KG1hcHBlciwgdW5kZWZpbmVkLCAyKX1cIi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIubW9kZWxNYXBwZXJzW2NsYXNzTmFtZV07XG59XG4vKipcbiAqIFJlc29sdmVzIGEgY29tcG9zaXRlIG1hcHBlcidzIG1vZGVsUHJvcGVydGllcy5cbiAqIEBwYXJhbSBzZXJpYWxpemVyIC0gdGhlIHNlcmlhbGl6ZXIgY29udGFpbmluZyB0aGUgZW50aXJlIHNldCBvZiBtYXBwZXJzXG4gKiBAcGFyYW0gbWFwcGVyIC0gdGhlIGNvbXBvc2l0ZSBtYXBwZXIgdG8gcmVzb2x2ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlTW9kZWxQcm9wZXJ0aWVzKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0TmFtZSkge1xuICAgIGxldCBtb2RlbFByb3BzID0gbWFwcGVyLnR5cGUubW9kZWxQcm9wZXJ0aWVzO1xuICAgIGlmICghbW9kZWxQcm9wcykge1xuICAgICAgICBjb25zdCBtb2RlbE1hcHBlciA9IHJlc29sdmVSZWZlcmVuY2VkTWFwcGVyKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0TmFtZSk7XG4gICAgICAgIGlmICghbW9kZWxNYXBwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwcGVyKCkgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGZvciBtb2RlbCBcIiR7bWFwcGVyLnR5cGUuY2xhc3NOYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsUHJvcHMgPSBtb2RlbE1hcHBlciA9PT0gbnVsbCB8fCBtb2RlbE1hcHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWxNYXBwZXIudHlwZS5tb2RlbFByb3BlcnRpZXM7XG4gICAgICAgIGlmICghbW9kZWxQcm9wcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtb2RlbFByb3BlcnRpZXMgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGluIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgbWFwcGVyIFwiJHtKU09OLnN0cmluZ2lmeShtb2RlbE1hcHBlcil9XCIgb2YgdHlwZSBcIiR7bWFwcGVyLnR5cGUuY2xhc3NOYW1lfVwiIGZvciBvYmplY3QgXCIke29iamVjdE5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsUHJvcHM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVDb21wb3NpdGVUeXBlKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0LCBvYmplY3ROYW1lLCBpc1htbCwgb3B0aW9ucykge1xuICAgIGlmIChnZXRQb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3JSZWN1cnNpdmVseShzZXJpYWxpemVyLCBtYXBwZXIpKSB7XG4gICAgICAgIG1hcHBlciA9IGdldFBvbHltb3JwaGljTWFwcGVyKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0LCBcImNsaWVudE5hbWVcIik7XG4gICAgfVxuICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCBtb2RlbFByb3BzID0gcmVzb2x2ZU1vZGVsUHJvcGVydGllcyhzZXJpYWxpemVyLCBtYXBwZXIsIG9iamVjdE5hbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtb2RlbFByb3BzKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlNYXBwZXIgPSBtb2RlbFByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAocHJvcGVydHlNYXBwZXIucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm9wTmFtZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnRPYmplY3QgPSBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZXIuaXNYTUwpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlNYXBwZXIueG1sSXNXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcGVydHlNYXBwZXIueG1sTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcGVydHlNYXBwZXIueG1sRWxlbWVudE5hbWUgfHwgcHJvcGVydHlNYXBwZXIueG1sTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IHNwbGl0U2VyaWFsaXplTmFtZShwcm9wZXJ0eU1hcHBlci5zZXJpYWxpemVkTmFtZSk7XG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgPSBwYXRocy5wb3AoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGhOYW1lIG9mIHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGFyZW50T2JqZWN0W3BhdGhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjaGlsZE9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkT2JqZWN0ID09PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChvYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdFtrZXldICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TWFwcGVyLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0W3BhdGhOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdCA9IHBhcmVudE9iamVjdFtwYXRoTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudE9iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1htbCAmJiBtYXBwZXIueG1sTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhtbG5zS2V5ID0gbWFwcGVyLnhtbE5hbWVzcGFjZVByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgeG1sbnM6JHttYXBwZXIueG1sTmFtZXNwYWNlUHJlZml4fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJ4bWxuc1wiO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3RbWE1MX0FUVFJLRVldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRPYmplY3RbWE1MX0FUVFJLRVldKSwgeyBbeG1sbnNLZXldOiBtYXBwZXIueG1sTmFtZXNwYWNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU9iamVjdE5hbWUgPSBwcm9wZXJ0eU1hcHBlci5zZXJpYWxpemVkTmFtZSAhPT0gXCJcIlxuICAgICAgICAgICAgICAgICAgICA/IG9iamVjdE5hbWUgKyBcIi5cIiArIHByb3BlcnR5TWFwcGVyLnNlcmlhbGl6ZWROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogb2JqZWN0TmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgdG9TZXJpYWxpemUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3IgPSBnZXRQb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3JSZWN1cnNpdmVseShzZXJpYWxpemVyLCBtYXBwZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yLmNsaWVudE5hbWUgPT09IGtleSAmJlxuICAgICAgICAgICAgICAgICAgICAodG9TZXJpYWxpemUgPT09IHVuZGVmaW5lZCB8fCB0b1NlcmlhbGl6ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9TZXJpYWxpemUgPSBtYXBwZXIuc2VyaWFsaXplZE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKHByb3BlcnR5TWFwcGVyLCB0b1NlcmlhbGl6ZSwgcHJvcGVydHlPYmplY3ROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcE5hbWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFhtbE9iamVjdFZhbHVlKHByb3BlcnR5TWFwcGVyLCBzZXJpYWxpemVkVmFsdWUsIGlzWG1sLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWG1sICYmIHByb3BlcnR5TWFwcGVyLnhtbElzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYTUxfQVRUUktFWSwgaS5lLiwgJCBpcyB0aGUga2V5IGF0dHJpYnV0ZXMgYXJlIGtlcHQgdW5kZXIgaW4geG1sMmpzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBrZWVwcyB0aGluZ3Mgc2ltcGxlIHdoaWxlIHByZXZlbnRpbmcgbmFtZSBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggbmFtZXMgaW4gdXNlciBkb2N1bWVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3RbWE1MX0FUVFJLRVldID0gcGFyZW50T2JqZWN0W1hNTF9BVFRSS0VZXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdFtYTUxfQVRUUktFWV1bcHJvcE5hbWVdID0gc2VyaWFsaXplZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzWG1sICYmIHByb3BlcnR5TWFwcGVyLnhtbElzV3JhcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0W3Byb3BOYW1lXSA9IHsgW3Byb3BlcnR5TWFwcGVyLnhtbEVsZW1lbnROYW1lXTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc01hcHBlciA9IHJlc29sdmVBZGRpdGlvbmFsUHJvcGVydGllcyhzZXJpYWxpemVyLCBtYXBwZXIsIG9iamVjdE5hbWUpO1xuICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXNNYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1vZGVsUHJvcHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbGllbnRQcm9wTmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FkZGl0aW9uYWxQcm9wZXJ0eSA9IHByb3BOYW1lcy5ldmVyeSgocG4pID0+IHBuICE9PSBjbGllbnRQcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWRkaXRpb25hbFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRbY2xpZW50UHJvcE5hbWVdID0gc2VyaWFsaXplci5zZXJpYWxpemUoYWRkaXRpb25hbFByb3BlcnRpZXNNYXBwZXIsIG9iamVjdFtjbGllbnRQcm9wTmFtZV0sIG9iamVjdE5hbWUgKyAnW1wiJyArIGNsaWVudFByb3BOYW1lICsgJ1wiXScsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFhtbE9iamVjdFZhbHVlKHByb3BlcnR5TWFwcGVyLCBzZXJpYWxpemVkVmFsdWUsIGlzWG1sLCBvcHRpb25zKSB7XG4gICAgaWYgKCFpc1htbCB8fCAhcHJvcGVydHlNYXBwZXIueG1sTmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHhtbG5zS2V5ID0gcHJvcGVydHlNYXBwZXIueG1sTmFtZXNwYWNlUHJlZml4XG4gICAgICAgID8gYHhtbG5zOiR7cHJvcGVydHlNYXBwZXIueG1sTmFtZXNwYWNlUHJlZml4fWBcbiAgICAgICAgOiBcInhtbG5zXCI7XG4gICAgY29uc3QgeG1sTmFtZXNwYWNlID0geyBbeG1sbnNLZXldOiBwcm9wZXJ0eU1hcHBlci54bWxOYW1lc3BhY2UgfTtcbiAgICBpZiAoW1wiQ29tcG9zaXRlXCJdLmluY2x1ZGVzKHByb3BlcnR5TWFwcGVyLnR5cGUubmFtZSkpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRWYWx1ZVtYTUxfQVRUUktFWV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBzZXJpYWxpemVkVmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0W1hNTF9BVFRSS0VZXSA9IHhtbE5hbWVzcGFjZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0W29wdGlvbnMueG1sLnhtbENoYXJLZXldID0gc2VyaWFsaXplZFZhbHVlO1xuICAgIHJlc3VsdFtYTUxfQVRUUktFWV0gPSB4bWxOYW1lc3BhY2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzU3BlY2lhbFhtbFByb3BlcnR5KHByb3BlcnR5TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBbWE1MX0FUVFJLRVksIG9wdGlvbnMueG1sLnhtbENoYXJLZXldLmluY2x1ZGVzKHByb3BlcnR5TmFtZSk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUNvbXBvc2l0ZVR5cGUoc2VyaWFsaXplciwgbWFwcGVyLCByZXNwb25zZUJvZHksIG9iamVjdE5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGdldFBvbHltb3JwaGljRGlzY3JpbWluYXRvclJlY3Vyc2l2ZWx5KHNlcmlhbGl6ZXIsIG1hcHBlcikpIHtcbiAgICAgICAgbWFwcGVyID0gZ2V0UG9seW1vcnBoaWNNYXBwZXIoc2VyaWFsaXplciwgbWFwcGVyLCByZXNwb25zZUJvZHksIFwic2VyaWFsaXplZE5hbWVcIik7XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsUHJvcHMgPSByZXNvbHZlTW9kZWxQcm9wZXJ0aWVzKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0TmFtZSk7XG4gICAgbGV0IGluc3RhbmNlID0ge307XG4gICAgY29uc3QgaGFuZGxlZFByb3BlcnR5TmFtZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtb2RlbFByb3BzKSkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU1hcHBlciA9IG1vZGVsUHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBzcGxpdFNlcmlhbGl6ZU5hbWUobW9kZWxQcm9wc1trZXldLnNlcmlhbGl6ZWROYW1lKTtcbiAgICAgICAgaGFuZGxlZFByb3BlcnR5TmFtZXMucHVzaChwYXRoc1swXSk7XG4gICAgICAgIGNvbnN0IHsgc2VyaWFsaXplZE5hbWUsIHhtbE5hbWUsIHhtbEVsZW1lbnROYW1lIH0gPSBwcm9wZXJ0eU1hcHBlcjtcbiAgICAgICAgbGV0IHByb3BlcnR5T2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XG4gICAgICAgIGlmIChzZXJpYWxpemVkTmFtZSAhPT0gXCJcIiAmJiBzZXJpYWxpemVkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eU9iamVjdE5hbWUgPSBvYmplY3ROYW1lICsgXCIuXCIgKyBzZXJpYWxpemVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJDb2xsZWN0aW9uUHJlZml4ID0gcHJvcGVydHlNYXBwZXIuaGVhZGVyQ29sbGVjdGlvblByZWZpeDtcbiAgICAgICAgaWYgKGhlYWRlckNvbGxlY3Rpb25QcmVmaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyS2V5IG9mIE9iamVjdC5rZXlzKHJlc3BvbnNlQm9keSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyS2V5LnN0YXJ0c1dpdGgoaGVhZGVyQ29sbGVjdGlvblByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGljdGlvbmFyeVtoZWFkZXJLZXkuc3Vic3RyaW5nKGhlYWRlckNvbGxlY3Rpb25QcmVmaXgubGVuZ3RoKV0gPSBzZXJpYWxpemVyLmRlc2VyaWFsaXplKHByb3BlcnR5TWFwcGVyLnR5cGUudmFsdWUsIHJlc3BvbnNlQm9keVtoZWFkZXJLZXldLCBwcm9wZXJ0eU9iamVjdE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVkUHJvcGVydHlOYW1lcy5wdXNoKGhlYWRlcktleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZVtrZXldID0gZGljdGlvbmFyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXJpYWxpemVyLmlzWE1MKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlNYXBwZXIueG1sSXNBdHRyaWJ1dGUgJiYgcmVzcG9uc2VCb2R5W1hNTF9BVFRSS0VZXSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlW2tleV0gPSBzZXJpYWxpemVyLmRlc2VyaWFsaXplKHByb3BlcnR5TWFwcGVyLCByZXNwb25zZUJvZHlbWE1MX0FUVFJLRVldW3htbE5hbWVdLCBwcm9wZXJ0eU9iamVjdE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0geG1sRWxlbWVudE5hbWUgfHwgeG1sTmFtZSB8fCBzZXJpYWxpemVkTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlNYXBwZXIueG1sSXNXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGEgbGlzdCBvZiA8eG1sRWxlbWVudE5hbWU+IHdyYXBwZWQgYnkgPHhtbE5hbWU+XG4gICAgICAgICAgICAgICAgICAgICAgRm9yIHRoZSB4bWwgZXhhbXBsZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPENvcnM+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxDb3JzUnVsZT4uLi48L0NvcnNSdWxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Q29yc1J1bGU+Li4uPC9Db3JzUnVsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ29ycz5cbiAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVzcG9uc2VCb2R5IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBDb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29yc1J1bGU6IFt7Li4ufSwgey4uLn1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB4bWxOYW1lIGlzIFwiQ29yc1wiIGFuZCB4bWxFbGVtZW50TmFtZSBpc1wiQ29yc1J1bGVcIi5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHJlc3BvbnNlQm9keVt4bWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudExpc3QgPSAoX2EgPSB3cmFwcGVkID09PSBudWxsIHx8IHdyYXBwZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZWRbeG1sRWxlbWVudE5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocHJvcGVydHlNYXBwZXIsIGVsZW1lbnRMaXN0LCBwcm9wZXJ0eU9iamVjdE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSByZXNwb25zZUJvZHlbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocHJvcGVydHlNYXBwZXIsIHByb3BlcnR5LCBwcm9wZXJ0eU9iamVjdE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlc2VyaWFsaXplIHRoZSBwcm9wZXJ0eSBpZiBpdCBpcyBwcmVzZW50IGluIHRoZSBwcm92aWRlZCByZXNwb25zZUJvZHkgaW5zdGFuY2VcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eUluc3RhbmNlO1xuICAgICAgICAgICAgbGV0IHJlcyA9IHJlc3BvbnNlQm9keTtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNpbmcgdGhlIG9iamVjdCBzdGVwIGJ5IHN0ZXAuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGF0aHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzW2l0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydHlJbnN0YW5jZSA9IHJlcztcbiAgICAgICAgICAgIGNvbnN0IHBvbHltb3JwaGljRGlzY3JpbWluYXRvciA9IG1hcHBlci50eXBlLnBvbHltb3JwaGljRGlzY3JpbWluYXRvcjtcbiAgICAgICAgICAgIC8vIGNoZWNraW5nIHRoYXQgdGhlIG1vZGVsIHByb3BlcnR5IG5hbWUgKGtleSkoZXg6IFwiZmlzaHR5cGVcIikgYW5kIHRoZVxuICAgICAgICAgICAgLy8gY2xpZW50TmFtZSBvZiB0aGUgcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yIHttZXRhZGF0YX0gKGV4OiBcImZpc2h0eXBlXCIpXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBzZXJpYWxpemVkTmFtZSBvZiB0aGUgcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yIChleDogXCJmaXNoLnR5cGVcIilcbiAgICAgICAgICAgIC8vIGlzIGEgYmV0dGVyIGFwcHJvYWNoLiBUaGUgZ2VuZXJhdG9yIGlzIG5vdCBjb25zaXN0ZW50IHdpdGggZXNjYXBpbmcgJ1xcLicgaW4gdGhlXG4gICAgICAgICAgICAvLyBzZXJpYWxpemVkTmFtZSBvZiB0aGUgcHJvcGVydHkgKGV4OiBcImZpc2hcXC50eXBlXCIpIHRoYXQgaXMgbWFya2VkIGFzIHBvbHltb3JwaGljIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgc2VyaWFsaXplZE5hbWUgb2YgdGhlIG1ldGFkYXRhIHBvbHltb3JwaGljRGlzY3JpbWluYXRvciAoZXg6IFwiZmlzaC50eXBlXCIpLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gdGhlIGNsaWVudE5hbWUgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHBvbHltb3JwaGljRGlzY3JpbWluYXRvciAoZXg6IFwiZmlzaHR5cGVcIikgYW5kXG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgbW9kZWwgcHJvcGVydHkgbmFtZSAoZXg6IFwiZmlzaHR5cGVcIikgaXMgZG9uZSBjb25zaXN0ZW50bHkuXG4gICAgICAgICAgICAvLyBIZW5jZSwgaXQgaXMgYSBzYWZlciBiZXQgdG8gcmVseSBvbiB0aGUgY2xpZW50TmFtZSBvZiB0aGUgcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yLlxuICAgICAgICAgICAgaWYgKHBvbHltb3JwaGljRGlzY3JpbWluYXRvciAmJlxuICAgICAgICAgICAgICAgIGtleSA9PT0gcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yLmNsaWVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAocHJvcGVydHlJbnN0YW5jZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnR5SW5zdGFuY2UgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlJbnN0YW5jZSA9IG1hcHBlci5zZXJpYWxpemVkTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXJpYWxpemVkVmFsdWU7XG4gICAgICAgICAgICAvLyBwYWdpbmdcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlQm9keVtrZXldKSAmJiBtb2RlbFByb3BzW2tleV0uc2VyaWFsaXplZE5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUluc3RhbmNlID0gcmVzcG9uc2VCb2R5W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlJbnN0YW5jZSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocHJvcGVydHlNYXBwZXIsIHByb3BlcnR5SW5zdGFuY2UsIHByb3BlcnR5T2JqZWN0TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIGFueSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWQgaW50byB0aGUgaW5zdGFuY2UsIHdoZXJlIHRoZXkgZG9cbiAgICAgICAgICAgICAgICAvLyBub3QgZXhpc3Qgb24gdGhlIG5ld2x5IGRlLXNlcmlhbGl6ZWQgYXJyYXlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyYXlJbnN0YW5jZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5SW5zdGFuY2Vba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gYXJyYXlJbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5SW5zdGFuY2UgIT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0eU1hcHBlci5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRWYWx1ZSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocHJvcGVydHlNYXBwZXIsIHByb3BlcnR5SW5zdGFuY2UsIHByb3BlcnR5T2JqZWN0TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHNlcmlhbGl6ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc01hcHBlciA9IG1hcHBlci50eXBlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChhZGRpdGlvbmFsUHJvcGVydGllc01hcHBlcikge1xuICAgICAgICBjb25zdCBpc0FkZGl0aW9uYWxQcm9wZXJ0eSA9IChyZXNwb25zZVByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsaWVudFByb3BOYW1lIGluIG1vZGVsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IHNwbGl0U2VyaWFsaXplTmFtZShtb2RlbFByb3BzW2NsaWVudFByb3BOYW1lXS5zZXJpYWxpemVkTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhzWzBdID09PSByZXNwb25zZVByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCByZXNwb25zZVByb3BOYW1lIGluIHJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgaWYgKGlzQWRkaXRpb25hbFByb3BlcnR5KHJlc3BvbnNlUHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbcmVzcG9uc2VQcm9wTmFtZV0gPSBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGFkZGl0aW9uYWxQcm9wZXJ0aWVzTWFwcGVyLCByZXNwb25zZUJvZHlbcmVzcG9uc2VQcm9wTmFtZV0sIG9iamVjdE5hbWUgKyAnW1wiJyArIHJlc3BvbnNlUHJvcE5hbWUgKyAnXCJdJywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3BvbnNlQm9keSkpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhaGFuZGxlZFByb3BlcnR5TmFtZXMuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgICAgICFpc1NwZWNpYWxYbWxQcm9wZXJ0eShrZXksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHJlc3BvbnNlQm9keVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRGljdGlvbmFyeVR5cGUoc2VyaWFsaXplciwgbWFwcGVyLCByZXNwb25zZUJvZHksIG9iamVjdE5hbWUsIG9wdGlvbnMpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgY29uc3QgdmFsdWUgPSBtYXBwZXIudHlwZS52YWx1ZTtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwidmFsdWVcIiBtZXRhZGF0YSBmb3IgYSBEaWN0aW9uYXJ5IG11c3QgYmUgZGVmaW5lZCBpbiB0aGUgYCArXG4gICAgICAgICAgICBgbWFwcGVyIGFuZCBpdCBtdXN0IG9mIHR5cGUgXCJvYmplY3RcIiBpbiAke29iamVjdE5hbWV9YCk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgY29uc3QgdGVtcERpY3Rpb25hcnkgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzcG9uc2VCb2R5KSkge1xuICAgICAgICAgICAgdGVtcERpY3Rpb25hcnlba2V5XSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUodmFsdWUsIHJlc3BvbnNlQm9keVtrZXldLCBvYmplY3ROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcERpY3Rpb25hcnk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVNlcXVlbmNlVHlwZShzZXJpYWxpemVyLCBtYXBwZXIsIHJlc3BvbnNlQm9keSwgb2JqZWN0TmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZWxlbWVudCA9IG1hcHBlci50eXBlLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50IHx8IHR5cGVvZiBlbGVtZW50ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZWxlbWVudFwiIG1ldGFkYXRhIGZvciBhbiBBcnJheSBtdXN0IGJlIGRlZmluZWQgaW4gdGhlIGAgK1xuICAgICAgICAgICAgYG1hcHBlciBhbmQgaXQgbXVzdCBvZiB0eXBlIFwib2JqZWN0XCIgaW4gJHtvYmplY3ROYW1lfWApO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwb25zZUJvZHkpKSB7XG4gICAgICAgICAgICAvLyB4bWwyanMgd2lsbCBpbnRlcnByZXQgYSBzaW5nbGUgZWxlbWVudCBhcnJheSBhcyBqdXN0IHRoZSBlbGVtZW50LCBzbyBmb3JjZSBpdCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gW3Jlc3BvbnNlQm9keV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVpcms6IENvbXBvc2l0ZSBtYXBwZXJzIHJlZmVyZW5jZWQgYnkgYGVsZW1lbnRgIG1pZ2h0XG4gICAgICAgIC8vIG5vdCBoYXZlICphbGwqIHByb3BlcnRpZXMgZGVjbGFyZWQgKGxpa2UgdWJlclBhcmVudCksXG4gICAgICAgIC8vIHNvIGxldCdzIHRyeSB0byBsb29rIHVwIHRoZSBmdWxsIGRlZmluaXRpb24gYnkgbmFtZS5cbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZS5uYW1lID09PSBcIkNvbXBvc2l0ZVwiICYmIGVsZW1lbnQudHlwZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAoX2EgPSBzZXJpYWxpemVyLm1vZGVsTWFwcGVyc1tlbGVtZW50LnR5cGUuY2xhc3NOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZUJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBBcnJheVtpXSA9IHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoZWxlbWVudCwgcmVzcG9uc2VCb2R5W2ldLCBgJHtvYmplY3ROYW1lfVske2l9XWAsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wQXJyYXk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XG59XG5mdW5jdGlvbiBnZXRJbmRleERpc2NyaW1pbmF0b3IoZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSwgdHlwZU5hbWUpIHtcbiAgICBjb25zdCB0eXBlTmFtZXNUb0NoZWNrID0gW3R5cGVOYW1lXTtcbiAgICB3aGlsZSAodHlwZU5hbWVzVG9DaGVjay5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE5hbWUgPSB0eXBlTmFtZXNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGluZGV4RGlzY3JpbWluYXRvciA9IGRpc2NyaW1pbmF0b3JWYWx1ZSA9PT0gY3VycmVudE5hbWVcbiAgICAgICAgICAgID8gZGlzY3JpbWluYXRvclZhbHVlXG4gICAgICAgICAgICA6IGN1cnJlbnROYW1lICsgXCIuXCIgKyBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGlzY3JpbWluYXRvcnMsIGluZGV4RGlzY3JpbWluYXRvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNjcmltaW5hdG9yc1tpbmRleERpc2NyaW1pbmF0b3JdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgbWFwcGVyXSBvZiBPYmplY3QuZW50cmllcyhkaXNjcmltaW5hdG9ycykpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lICsgXCIuXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlci50eXBlLnViZXJQYXJlbnQgPT09IGN1cnJlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlci50eXBlLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZXNUb0NoZWNrLnB1c2gobWFwcGVyLnR5cGUuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldFBvbHltb3JwaGljTWFwcGVyKHNlcmlhbGl6ZXIsIG1hcHBlciwgb2JqZWN0LCBwb2x5bW9ycGhpY1Byb3BlcnR5TmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3IgPSBnZXRQb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3JSZWN1cnNpdmVseShzZXJpYWxpemVyLCBtYXBwZXIpO1xuICAgIGlmIChwb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgbGV0IGRpc2NyaW1pbmF0b3JOYW1lID0gcG9seW1vcnBoaWNEaXNjcmltaW5hdG9yW3BvbHltb3JwaGljUHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JOYW1lKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2VyaWFsaXplZE5hbWUgbWlnaHQgaGF2ZSBcXFxcLCB3aGljaCB3ZSBqdXN0IHdhbnQgdG8gaWdub3JlXG4gICAgICAgICAgICBpZiAocG9seW1vcnBoaWNQcm9wZXJ0eU5hbWUgPT09IFwic2VyaWFsaXplZE5hbWVcIikge1xuICAgICAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JOYW1lID0gZGlzY3JpbWluYXRvck5hbWUucmVwbGFjZSgvXFxcXC9naSwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBvYmplY3RbZGlzY3JpbWluYXRvck5hbWVdO1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSAoX2EgPSBtYXBwZXIudHlwZS51YmVyUGFyZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtYXBwZXIudHlwZS5jbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpc2NyaW1pbmF0b3JWYWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHltb3JwaGljTWFwcGVyID0gZ2V0SW5kZXhEaXNjcmltaW5hdG9yKHNlcmlhbGl6ZXIubW9kZWxNYXBwZXJzLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yVmFsdWUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocG9seW1vcnBoaWNNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVyID0gcG9seW1vcnBoaWNNYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwZXI7XG59XG5mdW5jdGlvbiBnZXRQb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3JSZWN1cnNpdmVseShzZXJpYWxpemVyLCBtYXBwZXIpIHtcbiAgICByZXR1cm4gKG1hcHBlci50eXBlLnBvbHltb3JwaGljRGlzY3JpbWluYXRvciB8fFxuICAgICAgICBnZXRQb2x5bW9ycGhpY0Rpc2NyaW1pbmF0b3JTYWZlbHkoc2VyaWFsaXplciwgbWFwcGVyLnR5cGUudWJlclBhcmVudCkgfHxcbiAgICAgICAgZ2V0UG9seW1vcnBoaWNEaXNjcmltaW5hdG9yU2FmZWx5KHNlcmlhbGl6ZXIsIG1hcHBlci50eXBlLmNsYXNzTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0UG9seW1vcnBoaWNEaXNjcmltaW5hdG9yU2FmZWx5KHNlcmlhbGl6ZXIsIHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuICh0eXBlTmFtZSAmJlxuICAgICAgICBzZXJpYWxpemVyLm1vZGVsTWFwcGVyc1t0eXBlTmFtZV0gJiZcbiAgICAgICAgc2VyaWFsaXplci5tb2RlbE1hcHBlcnNbdHlwZU5hbWVdLnR5cGUucG9seW1vcnBoaWNEaXNjcmltaW5hdG9yKTtcbn1cbi8qKlxuICogS25vd24gdHlwZXMgb2YgTWFwcGVyc1xuICovXG5leHBvcnQgY29uc3QgTWFwcGVyVHlwZU5hbWVzID0ge1xuICAgIEJhc2U2NFVybDogXCJCYXNlNjRVcmxcIixcbiAgICBCb29sZWFuOiBcIkJvb2xlYW5cIixcbiAgICBCeXRlQXJyYXk6IFwiQnl0ZUFycmF5XCIsXG4gICAgQ29tcG9zaXRlOiBcIkNvbXBvc2l0ZVwiLFxuICAgIERhdGU6IFwiRGF0ZVwiLFxuICAgIERhdGVUaW1lOiBcIkRhdGVUaW1lXCIsXG4gICAgRGF0ZVRpbWVSZmMxMTIzOiBcIkRhdGVUaW1lUmZjMTEyM1wiLFxuICAgIERpY3Rpb25hcnk6IFwiRGljdGlvbmFyeVwiLFxuICAgIEVudW06IFwiRW51bVwiLFxuICAgIE51bWJlcjogXCJOdW1iZXJcIixcbiAgICBPYmplY3Q6IFwiT2JqZWN0XCIsXG4gICAgU2VxdWVuY2U6IFwiU2VxdWVuY2VcIixcbiAgICBTdHJpbmc6IFwiU3RyaW5nXCIsXG4gICAgU3RyZWFtOiBcIlN0cmVhbVwiLFxuICAgIFRpbWVTcGFuOiBcIlRpbWVTcGFuXCIsXG4gICAgVW5peFRpbWU6IFwiVW5peFRpbWVcIixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgY3JlYXRlUGlwZWxpbmVSZXF1ZXN0LCB9IGZyb20gXCJAYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lXCI7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRQaXBlbGluZSB9IGZyb20gXCIuL3BpcGVsaW5lXCI7XG5pbXBvcnQgeyBmbGF0dGVuUmVzcG9uc2UgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVkRGVmYXVsdEh0dHBDbGllbnQgfSBmcm9tIFwiLi9odHRwQ2xpZW50Q2FjaGVcIjtcbmltcG9ydCB7IGdldE9wZXJhdGlvblJlcXVlc3RJbmZvIH0gZnJvbSBcIi4vb3BlcmF0aW9uSGVscGVyc1wiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdFVybCB9IGZyb20gXCIuL3VybEhlbHBlcnNcIjtcbmltcG9ydCB7IGdldFN0cmVhbWluZ1Jlc3BvbnNlU3RhdHVzQ29kZXMgfSBmcm9tIFwiLi9pbnRlcmZhY2VIZWxwZXJzXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi9sb2dcIjtcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNlcnZpY2VDbGllbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2aWNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgU2VydmljZUNsaWVudCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGNyZWRlbnRpYWxzIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHNlcnZpY2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2VydmljZSBjbGllbnQgb3B0aW9ucyB0aGF0IGdvdmVybiB0aGUgYmVoYXZpb3Igb2YgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5fcmVxdWVzdENvbnRlbnRUeXBlID0gb3B0aW9ucy5yZXF1ZXN0Q29udGVudFR5cGU7XG4gICAgICAgIHRoaXMuX2VuZHBvaW50ID0gKF9hID0gb3B0aW9ucy5lbmRwb2ludCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0aW9ucy5iYXNlVXJpO1xuICAgICAgICBpZiAob3B0aW9ucy5iYXNlVXJpKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybmluZyhcIlRoZSBiYXNlVXJpIG9wdGlvbiBmb3IgU0RLIENsaWVudHMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBlbmRwb2ludCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGxvd0luc2VjdXJlQ29ubmVjdGlvbiA9IG9wdGlvbnMuYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuX2h0dHBDbGllbnQgPSBvcHRpb25zLmh0dHBDbGllbnQgfHwgZ2V0Q2FjaGVkRGVmYXVsdEh0dHBDbGllbnQoKTtcbiAgICAgICAgdGhpcy5waXBlbGluZSA9IG9wdGlvbnMucGlwZWxpbmUgfHwgY3JlYXRlRGVmYXVsdFBpcGVsaW5lKG9wdGlvbnMpO1xuICAgICAgICBpZiAoKF9iID0gb3B0aW9ucy5hZGRpdGlvbmFsUG9saWNpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBwb2xpY3ksIHBvc2l0aW9uIH0gb2Ygb3B0aW9ucy5hZGRpdGlvbmFsUG9saWNpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduIGhhcHBlbnMgYWZ0ZXIgUmV0cnkgYW5kIGlzIGNvbW1vbmx5IG5lZWRlZCB0byBvY2N1clxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBwb2xpY2llcyB0aGF0IGludGVyY2VwdCBwb3N0LXJldHJ5LlxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUGhhc2UgPSBwb3NpdGlvbiA9PT0gXCJwZXJSZXRyeVwiID8gXCJTaWduXCIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5waXBlbGluZS5hZGRQb2xpY3kocG9saWN5LCB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUGhhc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgcHJvdmlkZWQgaHR0cFJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlbGluZS5zZW5kUmVxdWVzdCh0aGlzLl9odHRwQ2xpZW50LCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBIVFRQIHJlcXVlc3QgdGhhdCBpcyBwb3B1bGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIE9wZXJhdGlvblNwZWMuXG4gICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGVkIHJlc3VsdCBvZiB0aGUgcmVxdWVzdCwgYmFzZWQgb24gdGhlIE9wZXJhdGlvblNwZWMuXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbkFyZ3VtZW50cyAtIFRoZSBhcmd1bWVudHMgdGhhdCB0aGUgSFRUUCByZXF1ZXN0J3MgdGVtcGxhdGVkIHZhbHVlcyB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tLlxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25TcGVjIC0gVGhlIE9wZXJhdGlvblNwZWMgdG8gdXNlIHRvIHBvcHVsYXRlIHRoZSBodHRwUmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kT3BlcmF0aW9uUmVxdWVzdChvcGVyYXRpb25Bcmd1bWVudHMsIG9wZXJhdGlvblNwZWMpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBvcGVyYXRpb25TcGVjLmJhc2VVcmwgfHwgdGhpcy5fZW5kcG9pbnQ7XG4gICAgICAgIGlmICghZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG9wZXJhdGlvblNwZWMuYmFzZVVybCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBTZXJ2aWNlQ2xpZW50IG11c3QgaGF2ZSBhIGVuZHBvaW50IHN0cmluZyBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBiYXNlIFVSTCB0byB1c2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBsYXRpemVkIFVSTHMgc29tZXRpbWVzIHJlZmVyZW5jZSBwcm9wZXJ0aWVzIG9uIHRoZSBTZXJ2aWNlQ2xpZW50IGNoaWxkIGNsYXNzLFxuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIHBhc3MgYHRoaXNgIGJlbG93IGluIG9yZGVyIHRvIHNlYXJjaCB0aGVzZSBwcm9wZXJ0aWVzIGlmIHRoZXkncmVcbiAgICAgICAgLy8gbm90IHBhcnQgb2YgT3BlcmF0aW9uQXJndW1lbnRzXG4gICAgICAgIGNvbnN0IHVybCA9IGdldFJlcXVlc3RVcmwoZW5kcG9pbnQsIG9wZXJhdGlvblNwZWMsIG9wZXJhdGlvbkFyZ3VtZW50cywgdGhpcyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVQaXBlbGluZVJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSBvcGVyYXRpb25TcGVjLmh0dHBNZXRob2Q7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbkluZm8gPSBnZXRPcGVyYXRpb25SZXF1ZXN0SW5mbyhyZXF1ZXN0KTtcbiAgICAgICAgb3BlcmF0aW9uSW5mby5vcGVyYXRpb25TcGVjID0gb3BlcmF0aW9uU3BlYztcbiAgICAgICAgb3BlcmF0aW9uSW5mby5vcGVyYXRpb25Bcmd1bWVudHMgPSBvcGVyYXRpb25Bcmd1bWVudHM7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gb3BlcmF0aW9uU3BlYy5jb250ZW50VHlwZSB8fCB0aGlzLl9yZXF1ZXN0Q29udGVudFR5cGU7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBvcGVyYXRpb25TcGVjLnJlcXVlc3RCb2R5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gb3BlcmF0aW9uQXJndW1lbnRzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0T3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uVXBsb2FkUHJvZ3Jlc3MgPSByZXF1ZXN0T3B0aW9ucy5vblVwbG9hZFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMub25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25Eb3dubG9hZFByb2dyZXNzID0gcmVxdWVzdE9wdGlvbnMub25Eb3dubG9hZFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuc2hvdWxkRGVzZXJpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JbmZvLnNob3VsZERlc2VyaWFsaXplID0gcmVxdWVzdE9wdGlvbnMuc2hvdWxkRGVzZXJpYWxpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5hbGxvd0luc2VjdXJlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFsbG93SW5zZWN1cmVDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnRTaWduYWwgPSBvcHRpb25zLmFib3J0U2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJhY2luZ09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRyYWNpbmdPcHRpb25zID0gb3B0aW9ucy50cmFjaW5nT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0cmVhbVJlc3BvbnNlU3RhdHVzQ29kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zdHJlYW1SZXNwb25zZVN0YXR1c0NvZGVzID0gZ2V0U3RyZWFtaW5nUmVzcG9uc2VTdGF0dXNDb2RlcyhvcGVyYXRpb25TcGVjKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmF3UmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgZmxhdFJlc3BvbnNlID0gZmxhdHRlblJlc3BvbnNlKHJhd1Jlc3BvbnNlLCBvcGVyYXRpb25TcGVjLnJlc3BvbnNlc1tyYXdSZXNwb25zZS5zdGF0dXNdKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXNwb25zZShyYXdSZXNwb25zZSwgZmxhdFJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0UmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IucmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3UmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGF0UmVzcG9uc2UgPSBmbGF0dGVuUmVzcG9uc2UocmF3UmVzcG9uc2UsIG9wZXJhdGlvblNwZWMucmVzcG9uc2VzW2Vycm9yLnN0YXR1c0NvZGVdIHx8IG9wZXJhdGlvblNwZWMucmVzcG9uc2VzW1wiZGVmYXVsdFwiXSk7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGZsYXRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlc3BvbnNlKHJhd1Jlc3BvbnNlLCBmbGF0UmVzcG9uc2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRQaXBlbGluZShvcHRpb25zKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbFNjb3BlcyA9IGdldENyZWRlbnRpYWxTY29wZXMob3B0aW9ucyk7XG4gICAgY29uc3QgY3JlZGVudGlhbE9wdGlvbnMgPSBvcHRpb25zLmNyZWRlbnRpYWwgJiYgY3JlZGVudGlhbFNjb3Blc1xuICAgICAgICA/IHsgY3JlZGVudGlhbFNjb3BlcywgY3JlZGVudGlhbDogb3B0aW9ucy5jcmVkZW50aWFsIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudFBpcGVsaW5lKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgY3JlZGVudGlhbE9wdGlvbnMgfSkpO1xufVxuZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbFNjb3BlcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbFNjb3Blcykge1xuICAgICAgICBjb25zdCBzY29wZXMgPSBvcHRpb25zLmNyZWRlbnRpYWxTY29wZXM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNjb3BlcylcbiAgICAgICAgICAgID8gc2NvcGVzLm1hcCgoc2NvcGUpID0+IG5ldyBVUkwoc2NvcGUpLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICA6IG5ldyBVUkwoc2NvcGVzKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gYCR7b3B0aW9ucy5lbmRwb2ludH0vLmRlZmF1bHRgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iYXNlVXJpKSB7XG4gICAgICAgIHJldHVybiBgJHtvcHRpb25zLmJhc2VVcml9Ly5kZWZhdWx0YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbCAmJiAhb3B0aW9ucy5jcmVkZW50aWFsU2NvcGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2hlbiB1c2luZyBjcmVkZW50aWFscywgdGhlIFNlcnZpY2VDbGllbnRPcHRpb25zIG11c3QgY29udGFpbiBlaXRoZXIgYSBlbmRwb2ludCBvciBhIGNyZWRlbnRpYWxTY29wZXMuIFVuYWJsZSB0byBjcmVhdGUgYSBiZWFyZXJUb2tlbkF1dGhlbnRpY2F0aW9uUG9saWN5YCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlQ2xpZW50LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uQXJndW1lbnRWYWx1ZUZyb21QYXJhbWV0ZXIgfSBmcm9tIFwiLi9vcGVyYXRpb25IZWxwZXJzXCI7XG5pbXBvcnQgeyBnZXRQYXRoU3RyaW5nRnJvbVBhcmFtZXRlciB9IGZyb20gXCIuL2ludGVyZmFjZUhlbHBlcnNcIjtcbmNvbnN0IENvbGxlY3Rpb25Gb3JtYXRUb0RlbGltaXRlck1hcCA9IHtcbiAgICBDU1Y6IFwiLFwiLFxuICAgIFNTVjogXCIgXCIsXG4gICAgTXVsdGk6IFwiTXVsdGlcIixcbiAgICBUU1Y6IFwiXFx0XCIsXG4gICAgUGlwZXM6IFwifFwiLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1ZXN0VXJsKGJhc2VVcmksIG9wZXJhdGlvblNwZWMsIG9wZXJhdGlvbkFyZ3VtZW50cywgZmFsbGJhY2tPYmplY3QpIHtcbiAgICBjb25zdCB1cmxSZXBsYWNlbWVudHMgPSBjYWxjdWxhdGVVcmxSZXBsYWNlbWVudHMob3BlcmF0aW9uU3BlYywgb3BlcmF0aW9uQXJndW1lbnRzLCBmYWxsYmFja09iamVjdCk7XG4gICAgbGV0IGlzQWJzb2x1dGVQYXRoID0gZmFsc2U7XG4gICAgbGV0IHJlcXVlc3RVcmwgPSByZXBsYWNlQWxsKGJhc2VVcmksIHVybFJlcGxhY2VtZW50cyk7XG4gICAgaWYgKG9wZXJhdGlvblNwZWMucGF0aCkge1xuICAgICAgICBsZXQgcGF0aCA9IHJlcGxhY2VBbGwob3BlcmF0aW9uU3BlYy5wYXRoLCB1cmxSZXBsYWNlbWVudHMpO1xuICAgICAgICAvLyBRVUlSSzogc29tZXRpbWVzIHdlIGdldCBhIHBhdGggY29tcG9uZW50IGxpa2UgL3tuZXh0TGlua31cbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIGEgZnVsbHkgZm9ybWVkIFVSTCB3aXRoIGEgbGVhZGluZyAvLiBJbiB0aGF0IGNhc2UsIHdlIHNob3VsZFxuICAgICAgICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgL1xuICAgICAgICBpZiAob3BlcmF0aW9uU3BlYy5wYXRoID09PSBcIi97bmV4dExpbmt9XCIgJiYgcGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFFVSVJLOiBzb21ldGltZXMgd2UgZ2V0IGEgcGF0aCBjb21wb25lbnQgbGlrZSB7bmV4dExpbmt9XG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBhIGZ1bGx5IGZvcm1lZCBVUkwuIEluIHRoYXQgY2FzZSwgd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGUgYmFzZVVyaS5cbiAgICAgICAgaWYgKGlzQWJzb2x1dGVVcmwocGF0aCkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgPSBwYXRoO1xuICAgICAgICAgICAgaXNBYnNvbHV0ZVBhdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFVybCA9IGFwcGVuZFBhdGgocmVxdWVzdFVybCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBxdWVyeVBhcmFtcywgc2VxdWVuY2VQYXJhbXMgfSA9IGNhbGN1bGF0ZVF1ZXJ5UGFyYW1ldGVycyhvcGVyYXRpb25TcGVjLCBvcGVyYXRpb25Bcmd1bWVudHMsIGZhbGxiYWNrT2JqZWN0KTtcbiAgICAvKipcbiAgICAgKiBOb3RpY2UgdGhhdCB0aGlzIGNhbGwgc2V0cyB0aGUgYG5vT3ZlcndyaXRlYCBwYXJhbWV0ZXIgdG8gdHJ1ZSBpZiB0aGUgYHJlcXVlc3RVcmxgXG4gICAgICogaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBlbnN1cmVzIHRoYXQgZXhpc3RpbmcgcXVlcnkgcGFyYW1ldGVyIHZhbHVlcyBpbiBgcmVxdWVzdFVybGBcbiAgICAgKiBkbyBub3QgZ2V0IG92ZXJ3cml0dGVuLiBPbiB0aGUgb3RoZXIgaGFuZCB3aGVuIGByZXF1ZXN0VXJsYCBpcyBub3QgYWJzb2x1dGUgcGF0aCwgaXRcbiAgICAgKiBpcyBzdGlsbCBiZWluZyBidWlsdCBzbyB0aGVyZSBpcyBub3RoaW5nIHRvIG92ZXJ3cml0ZS5cbiAgICAgKi9cbiAgICByZXF1ZXN0VXJsID0gYXBwZW5kUXVlcnlQYXJhbXMocmVxdWVzdFVybCwgcXVlcnlQYXJhbXMsIHNlcXVlbmNlUGFyYW1zLCBpc0Fic29sdXRlUGF0aCk7XG4gICAgcmV0dXJuIHJlcXVlc3RVcmw7XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGlucHV0LCByZXBsYWNlbWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gICAgZm9yIChjb25zdCBbc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZV0gb2YgcmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zcGxpdChzZWFyY2hWYWx1ZSkuam9pbihyZXBsYWNlVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVXJsUmVwbGFjZW1lbnRzKG9wZXJhdGlvblNwZWMsIG9wZXJhdGlvbkFyZ3VtZW50cywgZmFsbGJhY2tPYmplY3QpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGlmICgoX2EgPSBvcGVyYXRpb25TcGVjLnVybFBhcmFtZXRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCB1cmxQYXJhbWV0ZXIgb2Ygb3BlcmF0aW9uU3BlYy51cmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBsZXQgdXJsUGFyYW1ldGVyVmFsdWUgPSBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIHVybFBhcmFtZXRlciwgZmFsbGJhY2tPYmplY3QpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyUGF0aFN0cmluZyA9IGdldFBhdGhTdHJpbmdGcm9tUGFyYW1ldGVyKHVybFBhcmFtZXRlcik7XG4gICAgICAgICAgICB1cmxQYXJhbWV0ZXJWYWx1ZSA9IG9wZXJhdGlvblNwZWMuc2VyaWFsaXplci5zZXJpYWxpemUodXJsUGFyYW1ldGVyLm1hcHBlciwgdXJsUGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlclBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKCF1cmxQYXJhbWV0ZXIuc2tpcEVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1ldGVyVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodXJsUGFyYW1ldGVyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNldChgeyR7dXJsUGFyYW1ldGVyLm1hcHBlci5zZXJpYWxpemVkTmFtZSB8fCBwYXJhbWV0ZXJQYXRoU3RyaW5nfX1gLCB1cmxQYXJhbWV0ZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmNsdWRlcyhcIjovL1wiKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFBhdGgodXJsLCBwYXRoVG9BcHBlbmQpIHtcbiAgICBpZiAoIXBhdGhUb0FwcGVuZCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgbGV0IG5ld1BhdGggPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgaWYgKCFuZXdQYXRoLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBuZXdQYXRoID0gYCR7bmV3UGF0aH0vYDtcbiAgICB9XG4gICAgaWYgKHBhdGhUb0FwcGVuZC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBwYXRoVG9BcHBlbmQgPSBwYXRoVG9BcHBlbmQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBjb25zdCBzZWFyY2hTdGFydCA9IHBhdGhUb0FwcGVuZC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoc2VhcmNoU3RhcnQgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXRoVG9BcHBlbmQuc3Vic3RyaW5nKDAsIHNlYXJjaFN0YXJ0KTtcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGF0aFRvQXBwZW5kLnN1YnN0cmluZyhzZWFyY2hTdGFydCArIDEpO1xuICAgICAgICBuZXdQYXRoID0gbmV3UGF0aCArIHBhdGg7XG4gICAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgICAgIHBhcnNlZFVybC5zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoID8gYCR7cGFyc2VkVXJsLnNlYXJjaH0mJHtzZWFyY2h9YCA6IHNlYXJjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmV3UGF0aCA9IG5ld1BhdGggKyBwYXRoVG9BcHBlbmQ7XG4gICAgfVxuICAgIHBhcnNlZFVybC5wYXRobmFtZSA9IG5ld1BhdGg7XG4gICAgcmV0dXJuIHBhcnNlZFVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUXVlcnlQYXJhbWV0ZXJzKG9wZXJhdGlvblNwZWMsIG9wZXJhdGlvbkFyZ3VtZW50cywgZmFsbGJhY2tPYmplY3QpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHNlcXVlbmNlUGFyYW1zID0gbmV3IFNldCgpO1xuICAgIGlmICgoX2EgPSBvcGVyYXRpb25TcGVjLnF1ZXJ5UGFyYW1ldGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5UGFyYW1ldGVyIG9mIG9wZXJhdGlvblNwZWMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbWV0ZXIubWFwcGVyLnR5cGUubmFtZSA9PT0gXCJTZXF1ZW5jZVwiICYmIHF1ZXJ5UGFyYW1ldGVyLm1hcHBlci5zZXJpYWxpemVkTmFtZSkge1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlUGFyYW1zLmFkZChxdWVyeVBhcmFtZXRlci5tYXBwZXIuc2VyaWFsaXplZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBnZXRPcGVyYXRpb25Bcmd1bWVudFZhbHVlRnJvbVBhcmFtZXRlcihvcGVyYXRpb25Bcmd1bWVudHMsIHF1ZXJ5UGFyYW1ldGVyLCBmYWxsYmFja09iamVjdCk7XG4gICAgICAgICAgICBpZiAoKHF1ZXJ5UGFyYW1ldGVyVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBxdWVyeVBhcmFtZXRlclZhbHVlICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyLm1hcHBlci5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBvcGVyYXRpb25TcGVjLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHF1ZXJ5UGFyYW1ldGVyLm1hcHBlciwgcXVlcnlQYXJhbWV0ZXJWYWx1ZSwgZ2V0UGF0aFN0cmluZ0Zyb21QYXJhbWV0ZXIocXVlcnlQYXJhbWV0ZXIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBxdWVyeVBhcmFtZXRlci5jb2xsZWN0aW9uRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgID8gQ29sbGVjdGlvbkZvcm1hdFRvRGVsaW1pdGVyTWFwW3F1ZXJ5UGFyYW1ldGVyLmNvbGxlY3Rpb25Gb3JtYXRdXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlclZhbHVlID0gcXVlcnlQYXJhbWV0ZXJWYWx1ZS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlQYXJhbWV0ZXIuY29sbGVjdGlvbkZvcm1hdCA9PT0gXCJNdWx0aVwiICYmIHF1ZXJ5UGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5UGFyYW1ldGVyVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIChxdWVyeVBhcmFtZXRlci5jb2xsZWN0aW9uRm9ybWF0ID09PSBcIlNTVlwiIHx8IHF1ZXJ5UGFyYW1ldGVyLmNvbGxlY3Rpb25Gb3JtYXQgPT09IFwiVFNWXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBxdWVyeVBhcmFtZXRlclZhbHVlLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeVBhcmFtZXRlci5za2lwRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBxdWVyeVBhcmFtZXRlclZhbHVlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQocXVlcnlQYXJhbWV0ZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSm9pbiBwaXBlcyBhbmQgQ1NWICphZnRlciogZW5jb2RpbmcsIG9yIHRoZSBzZXJ2ZXIgd2lsbCBiZSB1cHNldC5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtZXRlclZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAocXVlcnlQYXJhbWV0ZXIuY29sbGVjdGlvbkZvcm1hdCA9PT0gXCJDU1ZcIiB8fCBxdWVyeVBhcmFtZXRlci5jb2xsZWN0aW9uRm9ybWF0ID09PSBcIlBpcGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyVmFsdWUgPSBxdWVyeVBhcmFtZXRlclZhbHVlLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChxdWVyeVBhcmFtZXRlci5tYXBwZXIuc2VyaWFsaXplZE5hbWUgfHwgZ2V0UGF0aFN0cmluZ0Zyb21QYXJhbWV0ZXIocXVlcnlQYXJhbWV0ZXIpLCBxdWVyeVBhcmFtZXRlclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeVBhcmFtczogcmVzdWx0LFxuICAgICAgICBzZXF1ZW5jZVBhcmFtcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2ltcGxlUGFyc2VRdWVyeVBhcmFtcyhxdWVyeVN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBpZiAoIXF1ZXJ5U3RyaW5nIHx8IHF1ZXJ5U3RyaW5nWzBdICE9PSBcIj9cIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgP1xuICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcuc2xpY2UoMSk7XG4gICAgY29uc3QgcGFpcnMgPSBxdWVyeVN0cmluZy5zcGxpdChcIiZcIik7XG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBwYWlyLnNwbGl0KFwiPVwiLCAyKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHJlc3VsdC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG5hbWUsIFtleGlzdGluZ1ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRRdWVyeVBhcmFtcyh1cmwsIHF1ZXJ5UGFyYW1zLCBzZXF1ZW5jZVBhcmFtcywgbm9PdmVyd3JpdGUgPSBmYWxzZSkge1xuICAgIGlmIChxdWVyeVBhcmFtcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAvLyBRVUlSSzogcGFyc2VkVXJsLnNlYXJjaFBhcmFtcyB3aWxsIGhhdmUgdGhlaXIgbmFtZS92YWx1ZSBwYWlycyBkZWNvZGVkLCB3aGljaFxuICAgIC8vIGNhbiBjaGFuZ2UgdGhlaXIgbWVhbmluZyB0byB0aGUgc2VydmVyLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mIGEgU0FTIHNpZ25hdHVyZS5cbiAgICAvLyBUbyBhdm9pZCBhY2NpZGVudGFsbHkgdW4tZW5jb2RpbmcgYSBxdWVyeSBwYXJhbSwgd2UgcGFyc2UgdGhlIGtleS92YWx1ZXMgb3Vyc2VsdmVzXG4gICAgY29uc3QgY29tYmluZWRQYXJhbXMgPSBzaW1wbGVQYXJzZVF1ZXJ5UGFyYW1zKHBhcnNlZFVybC5zZWFyY2gpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gY29tYmluZWRQYXJhbXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZS5wdXNoKC4uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNldCA9IG5ldyBTZXQoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29tYmluZWRQYXJhbXMuc2V0KG5hbWUsIEFycmF5LmZyb20odmFsdWVTZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudW5zaGlmdChleGlzdGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcXVlbmNlUGFyYW1zLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkUGFyYW1zLnNldChuYW1lLCBbZXhpc3RpbmdWYWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9PdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFBhcmFtcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tYmluZWRQYXJhbXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWFyY2hQaWVjZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgY29tYmluZWRQYXJhbXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2VhcmNoUGllY2VzLnB1c2goYCR7bmFtZX09JHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gUVVJUks6IElmIHdlIGdldCBhbiBhcnJheSBvZiB2YWx1ZXMsIGluY2x1ZGUgbXVsdGlwbGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoUGllY2VzLnB1c2goYCR7bmFtZX09JHtzdWJWYWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlYXJjaFBpZWNlcy5wdXNoKGAke25hbWV9PSR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUVVJUks6IHdlIGhhdmUgdG8gc2V0IHNlYXJjaCBtYW51YWxseSBhcyBzZWFyY2hQYXJhbXMgd2lsbCBlbmNvZGUgY29tbWEgd2hlbiBpdCBzaG91bGRuJ3QuXG4gICAgcGFyc2VkVXJsLnNlYXJjaCA9IHNlYXJjaFBpZWNlcy5sZW5ndGggPyBgPyR7c2VhcmNoUGllY2VzLmpvaW4oXCImXCIpfWAgOiBcIlwiO1xuICAgIHJldHVybiBwYXJzZWRVcmwudG9TdHJpbmcoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybEhlbHBlcnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgYSBwcmltaXRpdmUgcmVzcG9uc2UgYm9keS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWl0aXZlQm9keSh2YWx1ZSwgbWFwcGVyVHlwZU5hbWUpIHtcbiAgICByZXR1cm4gKG1hcHBlclR5cGVOYW1lICE9PSBcIkNvbXBvc2l0ZVwiICYmXG4gICAgICAgIG1hcHBlclR5cGVOYW1lICE9PSBcIkRpY3Rpb25hcnlcIiAmJlxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgICAgIChtYXBwZXJUeXBlTmFtZSA9PT0gbnVsbCB8fCBtYXBwZXJUeXBlTmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwcGVyVHlwZU5hbWUubWF0Y2goL14oRGF0ZXxEYXRlVGltZXxEYXRlVGltZVJmYzExMjN8VW5peFRpbWV8Qnl0ZUFycmF5fEJhc2U2NFVybCkkL2kpKSAhPT1cbiAgICAgICAgICAgICAgICBudWxsIHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCkpO1xufVxuY29uc3QgdmFsaWRhdGVJU09EdXJhdGlvbiA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGluIElTTyA4NjAxIGZvcm1hdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQgZm9yIElTTyA4NjAxIGR1cmF0aW9uIGZvcm1hdC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZUlTT0R1cmF0aW9uLnRlc3QodmFsdWUpO1xufVxuY29uc3QgdmFsaWRVdWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezEyfSQvaTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCB1dWlkIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB1dWlkIC0gVGhlIHV1aWQgdGhhdCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVXVpZCh1dWlkKSB7XG4gICAgcmV0dXJuIHZhbGlkVXVpZFJlZ2V4LnRlc3QodXVpZCk7XG59XG4vKipcbiAqIE1hcHMgdGhlIHJlc3BvbnNlIGFzIGZvbGxvd3M6XG4gKiAtIHdyYXBzIHRoZSByZXNwb25zZSBib2R5IGlmIG5lZWRlZCAodHlwaWNhbGx5IGlmIGl0cyB0eXBlIGlzIHByaW1pdGl2ZSkuXG4gKiAtIHJldHVybnMgbnVsbCBpZiB0aGUgY29tYmluYXRpb24gb2YgdGhlIGhlYWRlcnMgYW5kIHRoZSBib2R5IGlzIGVtcHR5LlxuICogLSBvdGhlcndpc2UsIHJldHVybnMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBoZWFkZXJzIGFuZCB0aGUgYm9keS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2VPYmplY3QgLSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJzZWQgcmVzcG9uc2VcbiAqIEByZXR1cm5zIHRoZSByZXNwb25zZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIHVzZXIgd2hpY2ggY2FuIGJlIG51bGwgYW5kL29yIHdyYXBwZWRcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTnVsbGFibGVSZXNwb25zZUFuZFdyYXBwYWJsZUJvZHkocmVzcG9uc2VPYmplY3QpIHtcbiAgICBjb25zdCBjb21iaW5lZEhlYWRlcnNBbmRCb2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZU9iamVjdC5oZWFkZXJzKSwgcmVzcG9uc2VPYmplY3QuYm9keSk7XG4gICAgaWYgKHJlc3BvbnNlT2JqZWN0Lmhhc051bGxhYmxlVHlwZSAmJlxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb21iaW5lZEhlYWRlcnNBbmRCb2R5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0LnNob3VsZFdyYXBCb2R5ID8geyBib2R5OiBudWxsIH0gOiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0LnNob3VsZFdyYXBCb2R5XG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2VPYmplY3QuaGVhZGVycyksIHsgYm9keTogcmVzcG9uc2VPYmplY3QuYm9keSB9KSA6IGNvbWJpbmVkSGVhZGVyc0FuZEJvZHk7XG4gICAgfVxufVxuLyoqXG4gKiBUYWtlIGEgYEZ1bGxPcGVyYXRpb25SZXNwb25zZWAgYW5kIHR1cm4gaXQgaW50byBhIGZsYXRcbiAqIHJlc3BvbnNlIG9iamVjdCB0byBoYW5kIGJhY2sgdG8gdGhlIGNvbnN1bWVyLlxuICogQHBhcmFtIGZ1bGxSZXNwb25zZSAtIFRoZSBwcm9jZXNzZWQgcmVzcG9uc2UgZnJvbSB0aGUgb3BlcmF0aW9uIHJlcXVlc3RcbiAqIEBwYXJhbSByZXNwb25zZVNwZWMgLSBUaGUgcmVzcG9uc2UgbWFwIGZyb20gdGhlIE9wZXJhdGlvblNwZWNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5SZXNwb25zZShmdWxsUmVzcG9uc2UsIHJlc3BvbnNlU3BlYykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IGZ1bGxSZXNwb25zZS5wYXJzZWRIZWFkZXJzO1xuICAgIC8vIGhlYWQgbWV0aG9kcyBuZXZlciBoYXZlIGEgYm9keSwgYnV0IHdlIHJldHVybiBhIGJvb2xlYW4gc2V0IHRvIGJvZHkgcHJvcGVydHlcbiAgICAvLyB0byBpbmRpY2F0ZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSByZXNvdXJjZVxuICAgIGlmIChmdWxsUmVzcG9uc2UucmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEhlYWRlcnMpLCB7IGJvZHk6IGZ1bGxSZXNwb25zZS5wYXJzZWRCb2R5IH0pO1xuICAgIH1cbiAgICBjb25zdCBib2R5TWFwcGVyID0gcmVzcG9uc2VTcGVjICYmIHJlc3BvbnNlU3BlYy5ib2R5TWFwcGVyO1xuICAgIGNvbnN0IGlzTnVsbGFibGUgPSBCb29sZWFuKGJvZHlNYXBwZXIgPT09IG51bGwgfHwgYm9keU1hcHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keU1hcHBlci5udWxsYWJsZSk7XG4gICAgY29uc3QgZXhwZWN0ZWRCb2R5VHlwZU5hbWUgPSBib2R5TWFwcGVyID09PSBudWxsIHx8IGJvZHlNYXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlNYXBwZXIudHlwZS5uYW1lO1xuICAgIC8qKiBJZiB0aGUgYm9keSBpcyBhc2tlZCBmb3IsIHdlIGxvb2sgYXQgdGhlIGV4cGVjdGVkIGJvZHkgdHlwZSB0byBoYW5kbGUgaXQgKi9cbiAgICBpZiAoZXhwZWN0ZWRCb2R5VHlwZU5hbWUgPT09IFwiU3RyZWFtXCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkSGVhZGVycyksIHsgYmxvYkJvZHk6IGZ1bGxSZXNwb25zZS5ibG9iQm9keSwgcmVhZGFibGVTdHJlYW1Cb2R5OiBmdWxsUmVzcG9uc2UucmVhZGFibGVTdHJlYW1Cb2R5IH0pO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFByb3BlcnRpZXMgPSAoZXhwZWN0ZWRCb2R5VHlwZU5hbWUgPT09IFwiQ29tcG9zaXRlXCIgJiZcbiAgICAgICAgYm9keU1hcHBlci50eXBlLm1vZGVsUHJvcGVydGllcykgfHxcbiAgICAgICAge307XG4gICAgY29uc3QgaXNQYWdlYWJsZVJlc3BvbnNlID0gT2JqZWN0LmtleXMobW9kZWxQcm9wZXJ0aWVzKS5zb21lKChrKSA9PiBtb2RlbFByb3BlcnRpZXNba10uc2VyaWFsaXplZE5hbWUgPT09IFwiXCIpO1xuICAgIGlmIChleHBlY3RlZEJvZHlUeXBlTmFtZSA9PT0gXCJTZXF1ZW5jZVwiIHx8IGlzUGFnZWFibGVSZXNwb25zZSkge1xuICAgICAgICBjb25zdCBhcnJheVJlc3BvbnNlID0gKF9hID0gZnVsbFJlc3BvbnNlLnBhcnNlZEJvZHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtb2RlbFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxQcm9wZXJ0aWVzW2tleV0uc2VyaWFsaXplZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBhcnJheVJlc3BvbnNlW2tleV0gPSAoX2IgPSBmdWxsUmVzcG9uc2UucGFyc2VkQm9keSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZEhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlSZXNwb25zZVtrZXldID0gcGFyc2VkSGVhZGVyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc051bGxhYmxlICYmXG4gICAgICAgICAgICAhZnVsbFJlc3BvbnNlLnBhcnNlZEJvZHkgJiZcbiAgICAgICAgICAgICFwYXJzZWRIZWFkZXJzICYmXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbFByb3BlcnRpZXMpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGFycmF5UmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVOdWxsYWJsZVJlc3BvbnNlQW5kV3JhcHBhYmxlQm9keSh7XG4gICAgICAgIGJvZHk6IGZ1bGxSZXNwb25zZS5wYXJzZWRCb2R5LFxuICAgICAgICBoZWFkZXJzOiBwYXJzZWRIZWFkZXJzLFxuICAgICAgICBoYXNOdWxsYWJsZVR5cGU6IGlzTnVsbGFibGUsXG4gICAgICAgIHNob3VsZFdyYXBCb2R5OiBpc1ByaW1pdGl2ZUJvZHkoZnVsbFJlc3BvbnNlLnBhcnNlZEJvZHksIGV4cGVjdGVkQm9keVR5cGVOYW1lKSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgX19hc3luY0RlbGVnYXRvciwgX19hc3luY0dlbmVyYXRvciwgX19hc3luY1ZhbHVlcywgX19hd2FpdCB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciByZXN1bHRzLiBJdCBhbHNvIGhhcyBhIGBieVBhZ2VgXG4gKiBtZXRob2QgdGhhdCByZXR1cm5zIHBhZ2VzIG9mIGl0ZW1zIGF0IG9uY2UuXG4gKlxuICogQHBhcmFtIHBhZ2VkUmVzdWx0IC0gYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGhvdyB0byBnZXQgcGFnZXMuXG4gKiBAcmV0dXJucyBhIHBhZ2VkIGFzeW5jIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciByZXN1bHRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnZWRBc3luY0l0ZXJhdG9yKHBhZ2VkUmVzdWx0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGl0ZXIgPSBnZXRJdGVtQXN5bmNJdGVyYXRvcihwYWdlZFJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBieVBhZ2U6IChfYSA9IHBhZ2VkUmVzdWx0ID09PSBudWxsIHx8IHBhZ2VkUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYWdlZFJlc3VsdC5ieVBhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGludWF0aW9uVG9rZW4sIG1heFBhZ2VTaXplIH0gPSBzZXR0aW5ncyAhPT0gbnVsbCAmJiBzZXR0aW5ncyAhPT0gdm9pZCAwID8gc2V0dGluZ3MgOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQYWdlQXN5bmNJdGVyYXRvcihwYWdlZFJlc3VsdCwge1xuICAgICAgICAgICAgICAgIHBhZ2VMaW5rOiBjb250aW51YXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICBtYXhQYWdlU2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SXRlbUFzeW5jSXRlcmF0b3IocGFnZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBnZXRJdGVtQXN5bmNJdGVyYXRvcl8xKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgY29uc3QgcGFnZXMgPSBnZXRQYWdlQXN5bmNJdGVyYXRvcihwYWdlZFJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsID0geWllbGQgX19hd2FpdChwYWdlcy5uZXh0KCkpO1xuICAgICAgICAvLyBpZiB0aGUgcmVzdWx0IGRvZXMgbm90IGhhdmUgYW4gYXJyYXkgc2hhcGUsIGkuZS4gVFBhZ2UgPSBURWxlbWVudCwgdGhlbiB3ZSByZXR1cm4gaXQgYXMgaXNcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpcnN0VmFsLnZhbHVlKSkge1xuICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChmaXJzdFZhbC52YWx1ZSk7XG4gICAgICAgICAgICAvLyBgcGFnZXNgIGlzIG9mIHR5cGUgYEFzeW5jSXRlcmFibGVJdGVyYXRvcjxUUGFnZT5gIGJ1dCBUUGFnZSA9IFRFbGVtZW50IGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKHBhZ2VzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKGZpcnN0VmFsLnZhbHVlKSkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwYWdlc18xID0gX19hc3luY1ZhbHVlcyhwYWdlcyksIHBhZ2VzXzFfMTsgcGFnZXNfMV8xID0geWllbGQgX19hd2FpdChwYWdlc18xLm5leHQoKSksICFwYWdlc18xXzEuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhZ2VzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFnZXMgaXMgb2YgdHlwZSBgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFRQYWdlPmAgc28gYHBhZ2VgIGlzIG9mIHR5cGUgYFRQYWdlYC4gSW4gdGhpcyBicmFuY2gsXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IG11c3QgYmUgdGhlIGNhc2UgdGhhdCBgVFBhZ2UgPSBURWxlbWVudFtdYFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMocGFnZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VzXzFfMSAmJiAhcGFnZXNfMV8xLmRvbmUgJiYgKF9hID0gcGFnZXNfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9hLmNhbGwocGFnZXNfMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBhZ2VBc3luY0l0ZXJhdG9yKHBhZ2VkUmVzdWx0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBnZXRQYWdlQXN5bmNJdGVyYXRvcl8xKCkge1xuICAgICAgICBjb25zdCB7IHBhZ2VMaW5rLCBtYXhQYWdlU2l6ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChwYWdlZFJlc3VsdC5nZXRQYWdlKHBhZ2VMaW5rICE9PSBudWxsICYmIHBhZ2VMaW5rICE9PSB2b2lkIDAgPyBwYWdlTGluayA6IHBhZ2VkUmVzdWx0LmZpcnN0UGFnZUxpbmssIG1heFBhZ2VTaXplKSk7XG4gICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocmVzcG9uc2UucGFnZSk7XG4gICAgICAgIHdoaWxlIChyZXNwb25zZS5uZXh0UGFnZUxpbmspIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgX19hd2FpdChwYWdlZFJlc3VsdC5nZXRQYWdlKHJlc3BvbnNlLm5leHRQYWdlTGluaywgbWF4UGFnZVNpemUpKTtcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocmVzcG9uc2UucGFnZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFBhZ2VkQXN5bmNJdGVyYXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGVsc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZ2V0UGFnZWRBc3luY0l0ZXJhdG9yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVscy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmV4cG9ydCBjb25zdCBTREtfVkVSU0lPTiA9IFwiMS45LjJcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFVFJZX1BPTElDWV9DT1VOVCA9IDM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBsb2dQb2xpY3kgfSBmcm9tIFwiLi9wb2xpY2llcy9sb2dQb2xpY3lcIjtcbmltcG9ydCB7IGNyZWF0ZUVtcHR5UGlwZWxpbmUgfSBmcm9tIFwiLi9waXBlbGluZVwiO1xuaW1wb3J0IHsgcmVkaXJlY3RQb2xpY3kgfSBmcm9tIFwiLi9wb2xpY2llcy9yZWRpcmVjdFBvbGljeVwiO1xuaW1wb3J0IHsgdXNlckFnZW50UG9saWN5IH0gZnJvbSBcIi4vcG9saWNpZXMvdXNlckFnZW50UG9saWN5XCI7XG5pbXBvcnQgeyBkZWNvbXByZXNzUmVzcG9uc2VQb2xpY3kgfSBmcm9tIFwiLi9wb2xpY2llcy9kZWNvbXByZXNzUmVzcG9uc2VQb2xpY3lcIjtcbmltcG9ydCB7IGRlZmF1bHRSZXRyeVBvbGljeSB9IGZyb20gXCIuL3BvbGljaWVzL2RlZmF1bHRSZXRyeVBvbGljeVwiO1xuaW1wb3J0IHsgZm9ybURhdGFQb2xpY3kgfSBmcm9tIFwiLi9wb2xpY2llcy9mb3JtRGF0YVBvbGljeVwiO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSBcIkBhenVyZS9jb3JlLXV0aWxcIjtcbmltcG9ydCB7IHByb3h5UG9saWN5IH0gZnJvbSBcIi4vcG9saWNpZXMvcHJveHlQb2xpY3lcIjtcbmltcG9ydCB7IHNldENsaWVudFJlcXVlc3RJZFBvbGljeSB9IGZyb20gXCIuL3BvbGljaWVzL3NldENsaWVudFJlcXVlc3RJZFBvbGljeVwiO1xuaW1wb3J0IHsgdGxzUG9saWN5IH0gZnJvbSBcIi4vcG9saWNpZXMvdGxzUG9saWN5XCI7XG5pbXBvcnQgeyB0cmFjaW5nUG9saWN5IH0gZnJvbSBcIi4vcG9saWNpZXMvdHJhY2luZ1BvbGljeVwiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcGlwZWxpbmUgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIGN1c3RvbWl6YWJsZSBwb2xpY2llcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgYSBjdXN0b20gcGlwZWxpbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQaXBlbGluZUZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwaXBlbGluZSA9IGNyZWF0ZUVtcHR5UGlwZWxpbmUoKTtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRsc09wdGlvbnMpIHtcbiAgICAgICAgICAgIHBpcGVsaW5lLmFkZFBvbGljeSh0bHNQb2xpY3kob3B0aW9ucy50bHNPcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGlwZWxpbmUuYWRkUG9saWN5KHByb3h5UG9saWN5KG9wdGlvbnMucHJveHlPcHRpb25zKSk7XG4gICAgICAgIHBpcGVsaW5lLmFkZFBvbGljeShkZWNvbXByZXNzUmVzcG9uc2VQb2xpY3koKSk7XG4gICAgfVxuICAgIHBpcGVsaW5lLmFkZFBvbGljeShmb3JtRGF0YVBvbGljeSgpKTtcbiAgICBwaXBlbGluZS5hZGRQb2xpY3kodXNlckFnZW50UG9saWN5KG9wdGlvbnMudXNlckFnZW50T3B0aW9ucykpO1xuICAgIHBpcGVsaW5lLmFkZFBvbGljeShzZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3koKSk7XG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KGRlZmF1bHRSZXRyeVBvbGljeShvcHRpb25zLnJldHJ5T3B0aW9ucyksIHsgcGhhc2U6IFwiUmV0cnlcIiB9KTtcbiAgICBwaXBlbGluZS5hZGRQb2xpY3kodHJhY2luZ1BvbGljeShvcHRpb25zLnVzZXJBZ2VudE9wdGlvbnMpLCB7IGFmdGVyUGhhc2U6IFwiUmV0cnlcIiB9KTtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIC8vIEJvdGggWEhSIGFuZCBGZXRjaCBleHBlY3QgdG8gaGFuZGxlIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LFxuICAgICAgICAvLyBzbyBvbmx5IGluY2x1ZGUgdGhpcyBwb2xpY3kgd2hlbiB3ZSdyZSBpbiBOb2RlLlxuICAgICAgICBwaXBlbGluZS5hZGRQb2xpY3kocmVkaXJlY3RQb2xpY3kob3B0aW9ucy5yZWRpcmVjdE9wdGlvbnMpLCB7IGFmdGVyUGhhc2U6IFwiUmV0cnlcIiB9KTtcbiAgICB9XG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KGxvZ1BvbGljeShvcHRpb25zLmxvZ2dpbmdPcHRpb25zKSwgeyBhZnRlclBoYXNlOiBcIlNpZ25cIiB9KTtcbiAgICByZXR1cm4gcGlwZWxpbmU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVQaXBlbGluZUZyb21PcHRpb25zLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgY3JlYXRlTm9kZUh0dHBDbGllbnQgfSBmcm9tIFwiLi9ub2RlSHR0cENsaWVudFwiO1xuLyoqXG4gKiBDcmVhdGUgdGhlIGNvcnJlY3QgSHR0cENsaWVudCBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0SHR0cENsaWVudCgpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZUh0dHBDbGllbnQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRIdHRwQ2xpZW50LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uKiBoZWFkZXJJdGVyYXRvcihtYXApIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICB5aWVsZCBbZW50cnkubmFtZSwgZW50cnkudmFsdWVdO1xuICAgIH1cbn1cbmNsYXNzIEh0dHBIZWFkZXJzSW1wbCB7XG4gICAgY29uc3RydWN0b3IocmF3SGVhZGVycykge1xuICAgICAgICB0aGlzLl9oZWFkZXJzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAocmF3SGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIE9iamVjdC5rZXlzKHJhd0hlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaGVhZGVyTmFtZSwgcmF3SGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgaGVhZGVyIGluIHRoaXMgY29sbGVjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBuYW1lIGFuZCB2YWx1ZS4gVGhlIG5hbWUgaXNcbiAgICAgKiBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGhlYWRlciB0byBzZXQuIFRoaXMgdmFsdWUgaXMgY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGhlYWRlciB0byBzZXQuXG4gICAgICovXG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNNYXAuc2V0KG5vcm1hbGl6ZU5hbWUobmFtZSksIHsgbmFtZSwgdmFsdWU6IFN0cmluZyh2YWx1ZSkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgaGVhZGVyIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBubyBoZWFkZXIgZXhpc3RzIGluIHRoaXNcbiAgICAgKiBjb2xsZWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIG5hbWUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaGVhZGVyLiBUaGlzIHZhbHVlIGlzIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICovXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5faGVhZGVyc01hcC5nZXQobm9ybWFsaXplTmFtZShuYW1lKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZXRoZXIgb3Igbm90IHRoaXMgaGVhZGVyIGNvbGxlY3Rpb24gY29udGFpbnMgYSBoZWFkZXIgZW50cnkgZm9yIHRoZSBwcm92aWRlZCBoZWFkZXIgbmFtZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBoZWFkZXIgdG8gc2V0LiBUaGlzIHZhbHVlIGlzIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICovXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNNYXAuaGFzKG5vcm1hbGl6ZU5hbWUobmFtZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGhlYWRlciB3aXRoIHRoZSBwcm92aWRlZCBoZWFkZXJOYW1lLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGhlYWRlciB0byByZW1vdmUuXG4gICAgICovXG4gICAgZGVsZXRlKG5hbWUpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyc01hcC5kZWxldGUobm9ybWFsaXplTmFtZShuYW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBIVFRQIGhlYWRlciBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTihvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLnByZXNlcnZlQ2FzZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLl9oZWFkZXJzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VudHJ5Lm5hbWVdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtub3JtYWxpemVkTmFtZSwgZW50cnldIG9mIHRoaXMuX2hlYWRlcnNNYXApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbm9ybWFsaXplZE5hbWVdID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBIVFRQIGhlYWRlciBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oeyBwcmVzZXJ2ZUNhc2U6IHRydWUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgdHVwbGVzIG9mIGhlYWRlciBbbmFtZSwgdmFsdWVdIHBhaXJzLlxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gaGVhZGVySXRlcmF0b3IodGhpcy5faGVhZGVyc01hcCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHNhdGlzZmllcyB0aGUgYEh0dHBIZWFkZXJzYCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gcmF3SGVhZGVycyAtIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgaW5pdGlhbCBoZWFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIdHRwSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBIdHRwSGVhZGVyc0ltcGwocmF3SGVhZGVycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwSGVhZGVycy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudExvZ2dlciB9IGZyb20gXCJAYXp1cmUvbG9nZ2VyXCI7XG5leHBvcnQgY29uc3QgbG9nZ2VyID0gY3JlYXRlQ2xpZW50TG9nZ2VyKFwiY29yZS1yZXN0LXBpcGVsaW5lXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0ICogYXMgaHR0cCBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSBcImh0dHBzXCI7XG5pbXBvcnQgKiBhcyB6bGliIGZyb20gXCJ6bGliXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwic3RyZWFtXCI7XG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIsIEFib3J0RXJyb3IgfSBmcm9tIFwiQGF6dXJlL2Fib3J0LWNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IGNyZWF0ZUh0dHBIZWFkZXJzIH0gZnJvbSBcIi4vaHR0cEhlYWRlcnNcIjtcbmltcG9ydCB7IFJlc3RFcnJvciB9IGZyb20gXCIuL3Jlc3RFcnJvclwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vbG9nXCI7XG5jb25zdCBERUZBVUxUX1RMU19TRVRUSU5HUyA9IHt9O1xuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbShib2R5KSB7XG4gICAgcmV0dXJuIGJvZHkgJiYgdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNTdHJlYW1Db21wbGV0ZShzdHJlYW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3RyZWFtLm9uKFwiY2xvc2VcIiwgcmVzb2x2ZSk7XG4gICAgICAgIHN0cmVhbS5vbihcImVuZFwiLCByZXNvbHZlKTtcbiAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVzb2x2ZSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKGJvZHkpIHtcbiAgICByZXR1cm4gYm9keSAmJiB0eXBlb2YgYm9keS5ieXRlTGVuZ3RoID09PSBcIm51bWJlclwiO1xufVxuY2xhc3MgUmVwb3J0VHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9hZGVkQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIF90cmFuc2Zvcm0oY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5sb2FkZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2soeyBsb2FkZWRCeXRlczogdGhpcy5sb2FkZWRCeXRlcyB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIEh0dHBDbGllbnQgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIE5vZGUncyBcImh0dHBzXCIgbW9kdWxlIHRvIHNlbmQgSFRUUFMgcmVxdWVzdHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgTm9kZUh0dHBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhY2hlZEh0dHBzQWdlbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSByZXF1ZXN0IG92ZXIgYW4gdW5kZXJseWluZyB0cmFuc3BvcnQgbGF5ZXIgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gYmUgbWFkZS5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGxldCBhYm9ydExpc3RlbmVyO1xuICAgICAgICBpZiAocmVxdWVzdC5hYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYWJvcnRTaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhYm9ydExpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfSwgcmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NlcHRFbmNvZGluZyA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJBY2NlcHQtRW5jb2RpbmdcIik7XG4gICAgICAgIGNvbnN0IHNob3VsZERlY29tcHJlc3MgPSAoYWNjZXB0RW5jb2RpbmcgPT09IG51bGwgfHwgYWNjZXB0RW5jb2RpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjY2VwdEVuY29kaW5nLmluY2x1ZGVzKFwiZ3ppcFwiKSkgfHwgKGFjY2VwdEVuY29kaW5nID09PSBudWxsIHx8IGFjY2VwdEVuY29kaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY2NlcHRFbmNvZGluZy5pbmNsdWRlcyhcImRlZmxhdGVcIikpO1xuICAgICAgICBsZXQgYm9keSA9IHR5cGVvZiByZXF1ZXN0LmJvZHkgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3QuYm9keSgpIDogcmVxdWVzdC5ib2R5O1xuICAgICAgICBpZiAoYm9keSAmJiAhcmVxdWVzdC5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtTGVuZ3RoXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5TGVuZ3RoID0gZ2V0Qm9keUxlbmd0aChib2R5KTtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldChcIkNvbnRlbnQtTGVuZ3RoXCIsIGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZVN0cmVhbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChib2R5ICYmIHJlcXVlc3Qub25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uVXBsb2FkUHJvZ3Jlc3MgPSByZXF1ZXN0Lm9uVXBsb2FkUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVwb3J0U3RyZWFtID0gbmV3IFJlcG9ydFRyYW5zZm9ybShvblVwbG9hZFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB1cGxvYWRSZXBvcnRTdHJlYW0ub24oXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiB1cGxvYWQgcHJvZ3Jlc3NcIiwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5waXBlKHVwbG9hZFJlcG9ydFN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRSZXBvcnRTdHJlYW0uZW5kKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5ID0gdXBsb2FkUmVwb3J0U3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChyZXF1ZXN0LCBhYm9ydENvbnRyb2xsZXIsIGJvZHkpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGdldFJlc3BvbnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gKF9hID0gcmVzLnN0YXR1c0NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlc3BvbnNlcyB0byBIRUFEIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuICAgICAgICAgICAgLy8gSWYgdGhleSBkbyByZXR1cm4gYSBib2R5LCB0aGF0IGJvZHkgbXVzdCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgIHJlcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSBzaG91bGREZWNvbXByZXNzID8gZ2V0RGVjb2RlZFJlc3BvbnNlU3RyZWFtKHJlcywgaGVhZGVycykgOiByZXM7XG4gICAgICAgICAgICBjb25zdCBvbkRvd25sb2FkUHJvZ3Jlc3MgPSByZXF1ZXN0Lm9uRG93bmxvYWRQcm9ncmVzcztcbiAgICAgICAgICAgIGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFJlcG9ydFN0cmVhbSA9IG5ldyBSZXBvcnRUcmFuc2Zvcm0ob25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZFJlcG9ydFN0cmVhbS5vbihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGluIGRvd25sb2FkIHByb2dyZXNzXCIsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtLnBpcGUoZG93bmxvYWRSZXBvcnRTdHJlYW0pO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtID0gZG93bmxvYWRSZXBvcnRTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBWYWx1ZSBvZiBQT1NJVElWRV9JTkZJTklUWSBpbiBzdHJlYW1SZXNwb25zZVN0YXR1c0NvZGVzIGlzIGNvbnNpZGVyZWQgYXMgYW55IHN0YXR1cyBjb2RlXG4gICAgICAgICAgICAoKF9iID0gcmVxdWVzdC5zdHJlYW1SZXNwb25zZVN0YXR1c0NvZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpIHx8XG4gICAgICAgICAgICAgICAgKChfYyA9IHJlcXVlc3Quc3RyZWFtUmVzcG9uc2VTdGF0dXNDb2RlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmhhcyhyZXNwb25zZS5zdGF0dXMpKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlYWRhYmxlU3RyZWFtQm9keSA9IHJlc3BvbnNlU3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keUFzVGV4dCA9IGF3YWl0IHN0cmVhbVRvVGV4dChyZXNwb25zZVN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYWJvcnRTaWduYWwgJiYgYWJvcnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxldCB1cGxvYWRTdHJlYW1Eb25lID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkU3RyZWFtRG9uZSA9IGlzU3RyZWFtQ29tcGxldGUoYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkb3dubG9hZFN0cmVhbURvbmUgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbShyZXNwb25zZVN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRTdHJlYW1Eb25lID0gaXNTdHJlYW1Db21wbGV0ZShyZXNwb25zZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFt1cGxvYWRTdHJlYW1Eb25lLCBkb3dubG9hZFN0cmVhbURvbmVdKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gcmVxdWVzdC5hYm9ydFNpZ25hbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybmluZyhcIkVycm9yIHdoZW4gY2xlYW5pbmcgdXAgYWJvcnRMaXN0ZW5lciBvbiBodHRwUmVxdWVzdFwiLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlUmVxdWVzdChyZXF1ZXN0LCBhYm9ydENvbnRyb2xsZXIsIGJvZHkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgY29uc3QgaXNJbnNlY3VyZSA9IHVybC5wcm90b2NvbCAhPT0gXCJodHRwczpcIjtcbiAgICAgICAgaWYgKGlzSW5zZWN1cmUgJiYgIXJlcXVlc3QuYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbm5lY3QgdG8gJHtyZXF1ZXN0LnVybH0gd2hpbGUgYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb24gaXMgZmFsc2UuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnQgPSAoX2EgPSByZXF1ZXN0LmFnZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmdldE9yQ3JlYXRlQWdlbnQocmVxdWVzdCwgaXNJbnNlY3VyZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhZ2VudCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwYXRoOiBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAsXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMudG9KU09OKHsgcHJlc2VydmVDYXNlOiB0cnVlIH0pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gaXNJbnNlY3VyZSA/IGh0dHAucmVxdWVzdChvcHRpb25zLCByZXNvbHZlKSA6IGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgICAgICAgICByZXEub25jZShcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSZXN0RXJyb3IoZXJyLm1lc3NhZ2UsIHsgY29kZTogKF9hID0gZXJyLmNvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFJlc3RFcnJvci5SRVFVRVNUX1NFTkRfRVJST1IsIHJlcXVlc3QgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBBYm9ydEVycm9yKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7XG4gICAgICAgICAgICAgICAgcmVxLmRlc3Ryb3koYWJvcnRFcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYm9keSAmJiBpc1JlYWRhYmxlU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgYm9keS5waXBlKHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiIHx8IEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXEuZW5kKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5lbmQoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIpIDogQnVmZmVyLmZyb20oYm9keSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiVW5yZWNvZ25pemVkIGJvZHkgdHlwZVwiLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSZXN0RXJyb3IoXCJVbnJlY29nbml6ZWQgYm9keSB0eXBlXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJlYW1zIGRvbid0IGxpa2UgXCJ1bmRlZmluZWRcIiBiZWluZyBwYXNzZWQgYXMgZGF0YVxuICAgICAgICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9yQ3JlYXRlQWdlbnQocmVxdWVzdCwgaXNJbnNlY3VyZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRpc2FibGVLZWVwQWxpdmUgPSByZXF1ZXN0LmRpc2FibGVLZWVwQWxpdmU7XG4gICAgICAgIC8vIEhhbmRsZSBJbnNlY3VyZSByZXF1ZXN0cyBmaXJzdFxuICAgICAgICBpZiAoaXNJbnNlY3VyZSkge1xuICAgICAgICAgICAgaWYgKGRpc2FibGVLZWVwQWxpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwQWxpdmU6ZmFsc2UgaXMgdGhlIGRlZmF1bHQgc28gd2UgZG9uJ3QgbmVlZCBhIGN1c3RvbSBBZ2VudFxuICAgICAgICAgICAgICAgIHJldHVybiBodHRwLmdsb2JhbEFnZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlZEh0dHBBZ2VudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNhY2hlZCBhZ2VudCBjcmVhdGUgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSHR0cEFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpc2FibGVLZWVwQWxpdmUgJiYgIXJlcXVlc3QudGxzU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBubyB0bHNTZXR0aW5ncyBhbmQga2VlcEFsaXZlIGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCBhIGN1c3RvbSBhZ2VudFxuICAgICAgICAgICAgICAgIHJldHVybiBodHRwcy5nbG9iYWxBZ2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgdGxzU2V0dGluZ3MgdG8gaW5kZXggY2FjaGVkIGNsaWVudHNcbiAgICAgICAgICAgIGNvbnN0IHRsc1NldHRpbmdzID0gKF9hID0gcmVxdWVzdC50bHNTZXR0aW5ncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9UTFNfU0VUVElOR1M7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBhZ2VudCBvciBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcm92aWRlZCB2YWx1ZXMgZm9yIGtlZXBBbGl2ZSBhbmQgdGxzU2V0dGluZ3NcbiAgICAgICAgICAgIGxldCBhZ2VudCA9IHRoaXMuY2FjaGVkSHR0cHNBZ2VudHMuZ2V0KHRsc1NldHRpbmdzKTtcbiAgICAgICAgICAgIGlmIChhZ2VudCAmJiBhZ2VudC5vcHRpb25zLmtlZXBBbGl2ZSA9PT0gIWRpc2FibGVLZWVwQWxpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIk5vIGNhY2hlZCBUTFMgQWdlbnQgZXhpc3QsIGNyZWF0aW5nIGEgbmV3IEFnZW50XCIpO1xuICAgICAgICAgICAgYWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoT2JqZWN0LmFzc2lnbih7IFxuICAgICAgICAgICAgICAgIC8vIGtlZXBBbGl2ZSBpcyB0cnVlIGlmIGRpc2FibGVLZWVwQWxpdmUgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlOiAhZGlzYWJsZUtlZXBBbGl2ZSB9LCB0bHNTZXR0aW5ncykpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRIdHRwc0FnZW50cy5zZXQodGxzU2V0dGluZ3MsIGFnZW50KTtcbiAgICAgICAgICAgIHJldHVybiBhZ2VudDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVycyhyZXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlSHR0cEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhyZXMuaGVhZGVycykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoaGVhZGVyLCB2YWx1ZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0RGVjb2RlZFJlc3BvbnNlU3RyZWFtKHN0cmVhbSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGhlYWRlcnMuZ2V0KFwiQ29udGVudC1FbmNvZGluZ1wiKTtcbiAgICBpZiAoY29udGVudEVuY29kaW5nID09PSBcImd6aXBcIikge1xuICAgICAgICBjb25zdCB1bnppcCA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XG4gICAgICAgIHN0cmVhbS5waXBlKHVuemlwKTtcbiAgICAgICAgcmV0dXJuIHVuemlwO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50RW5jb2RpbmcgPT09IFwiZGVmbGF0ZVwiKSB7XG4gICAgICAgIGNvbnN0IGluZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcbiAgICAgICAgc3RyZWFtLnBpcGUoaW5mbGF0ZSk7XG4gICAgICAgIHJldHVybiBpbmZsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xufVxuZnVuY3Rpb24gc3RyZWFtVG9UZXh0KHN0cmVhbSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgICBzdHJlYW0ub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChCdWZmZXIuZnJvbShjaHVuaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZmZXIpLnRvU3RyaW5nKFwidXRmOFwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5uYW1lKSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFJlc3RFcnJvcihgRXJyb3IgcmVhZGluZyByZXNwb25zZSBhcyB0ZXh0OiAke2UubWVzc2FnZX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFJlc3RFcnJvci5QQVJTRV9FUlJPUixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvZHlMZW5ndGgoYm9keSkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBib2R5Lmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWFkYWJsZVN0cmVhbShib2R5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYm9keSkubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSHR0cENsaWVudCBpbnN0YW5jZSBmb3IgdGhlIE5vZGVKUyBlbnZpcm9ubWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZUh0dHBDbGllbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlSHR0cENsaWVudCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZUh0dHBDbGllbnQuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5jb25zdCBWYWxpZFBoYXNlTmFtZXMgPSBuZXcgU2V0KFtcIkRlc2VyaWFsaXplXCIsIFwiU2VyaWFsaXplXCIsIFwiUmV0cnlcIiwgXCJTaWduXCJdKTtcbi8qKlxuICogQSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIFBpcGVsaW5lLlxuICogRG8gbm90IGV4cG9ydCB0aGlzIGNsYXNzIGZyb20gdGhlIHBhY2thZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgSHR0cFBpcGVsaW5lIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2xpY2llcyA9IFtdKSB7XG4gICAgICAgIHRoaXMuX3BvbGljaWVzID0gW107XG4gICAgICAgIHRoaXMuX3BvbGljaWVzID0gcG9saWNpZXM7XG4gICAgICAgIHRoaXMuX29yZGVyZWRQb2xpY2llcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYWRkUG9saWN5KHBvbGljeSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBoYXNlICYmIG9wdGlvbnMuYWZ0ZXJQaGFzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9saWNpZXMgaW5zaWRlIGEgcGhhc2UgY2Fubm90IHNwZWNpZnkgYWZ0ZXJQaGFzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucGhhc2UgJiYgIVZhbGlkUGhhc2VOYW1lcy5oYXMob3B0aW9ucy5waGFzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwaGFzZSBuYW1lOiAke29wdGlvbnMucGhhc2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJQaGFzZSAmJiAhVmFsaWRQaGFzZU5hbWVzLmhhcyhvcHRpb25zLmFmdGVyUGhhc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWZ0ZXJQaGFzZSBuYW1lOiAke29wdGlvbnMuYWZ0ZXJQaGFzZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2xpY2llcy5wdXNoKHtcbiAgICAgICAgICAgIHBvbGljeSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vcmRlcmVkUG9saWNpZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbW92ZVBvbGljeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRQb2xpY2llcyA9IFtdO1xuICAgICAgICB0aGlzLl9wb2xpY2llcyA9IHRoaXMuX3BvbGljaWVzLmZpbHRlcigocG9saWN5RGVzY3JpcHRvcikgPT4ge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zLm5hbWUgJiYgcG9saWN5RGVzY3JpcHRvci5wb2xpY3kubmFtZSA9PT0gb3B0aW9ucy5uYW1lKSB8fFxuICAgICAgICAgICAgICAgIChvcHRpb25zLnBoYXNlICYmIHBvbGljeURlc2NyaXB0b3Iub3B0aW9ucy5waGFzZSA9PT0gb3B0aW9ucy5waGFzZSkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkUG9saWNpZXMucHVzaChwb2xpY3lEZXNjcmlwdG9yLnBvbGljeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vcmRlcmVkUG9saWNpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZW1vdmVkUG9saWNpZXM7XG4gICAgfVxuICAgIHNlbmRSZXF1ZXN0KGh0dHBDbGllbnQsIHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcG9saWNpZXMgPSB0aGlzLmdldE9yZGVyZWRQb2xpY2llcygpO1xuICAgICAgICBjb25zdCBwaXBlbGluZSA9IHBvbGljaWVzLnJlZHVjZVJpZ2h0KChuZXh0LCBwb2xpY3kpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvbGljeS5zZW5kUmVxdWVzdChyZXEsIG5leHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgKHJlcSkgPT4gaHR0cENsaWVudC5zZW5kUmVxdWVzdChyZXEpKTtcbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lKHJlcXVlc3QpO1xuICAgIH1cbiAgICBnZXRPcmRlcmVkUG9saWNpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3JkZXJlZFBvbGljaWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmRlcmVkUG9saWNpZXMgPSB0aGlzLm9yZGVyUG9saWNpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXJlZFBvbGljaWVzO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdHRwUGlwZWxpbmUodGhpcy5fcG9saWNpZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0dHBQaXBlbGluZSgpO1xuICAgIH1cbiAgICBvcmRlclBvbGljaWVzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdvYWwgb2YgdGhpcyBtZXRob2QgaXMgdG8gcmVsaWFibHkgb3JkZXIgcGlwZWxpbmUgcG9saWNpZXNcbiAgICAgICAgICogYmFzZWQgb24gdGhlaXIgZGVjbGFyZWQgcmVxdWlyZW1lbnRzIHdoZW4gdGhleSB3ZXJlIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPcmRlciBpcyBmaXJzdCBkZXRlcm1pbmVkIGJ5IHBoYXNlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAxLiBTZXJpYWxpemUgUGhhc2VcbiAgICAgICAgICogMi4gUG9saWNpZXMgbm90IGluIGEgcGhhc2VcbiAgICAgICAgICogMy4gRGVzZXJpYWxpemUgUGhhc2VcbiAgICAgICAgICogNC4gUmV0cnkgUGhhc2VcbiAgICAgICAgICogNS4gU2lnbiBQaGFzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoaW4gZWFjaCBwaGFzZSwgcG9saWNpZXMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlclxuICAgICAgICAgKiB0aGV5IHdlcmUgYWRkZWQgdW5sZXNzIHRoZXkgd2VyZSBzcGVjaWZpZWQgdG8gZXhlY3V0ZVxuICAgICAgICAgKiBiZWZvcmUvYWZ0ZXIgb3RoZXIgcG9saWNpZXMgb3IgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHBoYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBkZXRlcm1pbmUgdGhlIGZpbmFsIG9yZGVyLCB3ZSB3aWxsIHdhbGsgdGhlIHBvbGljeSBsaXN0XG4gICAgICAgICAqIGluIHBoYXNlIG9yZGVyIG11bHRpcGxlIHRpbWVzIHVudGlsIGFsbCBkZXBlbmRlbmNpZXMgYXJlXG4gICAgICAgICAqIHNhdGlzZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGFmdGVyUG9saWNpZXNgIGFyZSB0aGUgc2V0IG9mIHBvbGljaWVzIHRoYXQgbXVzdCBiZVxuICAgICAgICAgKiBleGVjdXRlZCBiZWZvcmUgYSBnaXZlbiBwb2xpY3kuIFRoaXMgcmVxdWlyZW1lbnQgaXNcbiAgICAgICAgICogY29uc2lkZXJlZCBzYXRpc2ZpZWQgd2hlbiBlYWNoIG9mIHRoZSBsaXN0ZWQgcG9saWNpZXNcbiAgICAgICAgICogaGF2ZSBiZWVuIHNjaGVkdWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGJlZm9yZVBvbGljaWVzYCBhcmUgdGhlIHNldCBvZiBwb2xpY2llcyB0aGF0IG11c3QgYmVcbiAgICAgICAgICogZXhlY3V0ZWQgYWZ0ZXIgYSBnaXZlbiBwb2xpY3kuIFNpbmNlIHRoaXMgZGVwZW5kZW5jeVxuICAgICAgICAgKiBjYW4gYmUgZXhwcmVzc2VkIGJ5IGNvbnZlcnRpbmcgaXQgaW50byBhIGVxdWl2YWxlbnRcbiAgICAgICAgICogYGFmdGVyUG9saWNpZXNgIGRlY2xhcmF0aW9ucywgdGhleSBhcmUgbm9ybWFsaXplZFxuICAgICAgICAgKiBpbnRvIHRoYXQgZm9ybSBmb3Igc2ltcGxpY2l0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW4gYGFmdGVyUGhhc2VgIGRlcGVuZGVuY3kgaXMgY29uc2lkZXJlZCBzYXRpc2ZpZWQgd2hlbiBhbGxcbiAgICAgICAgICogcG9saWNpZXMgaW4gdGhhdCBwaGFzZSBoYXZlIHNjaGVkdWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBUcmFjayBhbGwgcG9saWNpZXMgd2Uga25vdyBhYm91dC5cbiAgICAgICAgY29uc3QgcG9saWN5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQaGFzZShuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcG9saWNpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBoYXNSdW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhhc0FmdGVyUG9saWNpZXM6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayBwb2xpY2llcyBmb3IgZWFjaCBwaGFzZS5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplUGhhc2UgPSBjcmVhdGVQaGFzZShcIlNlcmlhbGl6ZVwiKTtcbiAgICAgICAgY29uc3Qgbm9QaGFzZSA9IGNyZWF0ZVBoYXNlKFwiTm9uZVwiKTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVQaGFzZSA9IGNyZWF0ZVBoYXNlKFwiRGVzZXJpYWxpemVcIik7XG4gICAgICAgIGNvbnN0IHJldHJ5UGhhc2UgPSBjcmVhdGVQaGFzZShcIlJldHJ5XCIpO1xuICAgICAgICBjb25zdCBzaWduUGhhc2UgPSBjcmVhdGVQaGFzZShcIlNpZ25cIik7XG4gICAgICAgIC8vIGEgbGlzdCBvZiBwaGFzZXMgaW4gb3JkZXJcbiAgICAgICAgY29uc3Qgb3JkZXJlZFBoYXNlcyA9IFtzZXJpYWxpemVQaGFzZSwgbm9QaGFzZSwgZGVzZXJpYWxpemVQaGFzZSwgcmV0cnlQaGFzZSwgc2lnblBoYXNlXTtcbiAgICAgICAgLy8gU21hbGwgaGVscGVyIGZ1bmN0aW9uIHRvIG1hcCBwaGFzZSBuYW1lIHRvIGVhY2ggUGhhc2VcbiAgICAgICAgZnVuY3Rpb24gZ2V0UGhhc2UocGhhc2UpIHtcbiAgICAgICAgICAgIGlmIChwaGFzZSA9PT0gXCJSZXRyeVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5UGhhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwaGFzZSA9PT0gXCJTZXJpYWxpemVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVQaGFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBoYXNlID09PSBcIkRlc2VyaWFsaXplXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVQaGFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBoYXNlID09PSBcIlNpZ25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduUGhhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9QaGFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCB3YWxrIGVhY2ggcG9saWN5IGFuZCBjcmVhdGUgYSBub2RlIHRvIHRyYWNrIG1ldGFkYXRhLlxuICAgICAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgdGhpcy5fcG9saWNpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbGljeSA9IGRlc2NyaXB0b3IucG9saWN5O1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRlc2NyaXB0b3Iub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHBvbGljeU5hbWUgPSBwb2xpY3kubmFtZTtcbiAgICAgICAgICAgIGlmIChwb2xpY3lNYXAuaGFzKHBvbGljeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIHBvbGljeSBuYW1lcyBub3QgYWxsb3dlZCBpbiBwaXBlbGluZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgcG9saWN5LFxuICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGRlcGVuZGFudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclBoYXNlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZnRlclBoYXNlID0gZ2V0UGhhc2Uob3B0aW9ucy5hZnRlclBoYXNlKTtcbiAgICAgICAgICAgICAgICBub2RlLmFmdGVyUGhhc2UuaGFzQWZ0ZXJQb2xpY2llcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xpY3lNYXAuc2V0KHBvbGljeU5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZShvcHRpb25zLnBoYXNlKTtcbiAgICAgICAgICAgIHBoYXNlLnBvbGljaWVzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgdGhhdCBlYWNoIHBvbGljeSBoYXMgYSBub2RlLCBjb25uZWN0IGRlcGVuZGVuY3kgcmVmZXJlbmNlcy5cbiAgICAgICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIHRoaXMuX3BvbGljaWVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBvbGljeSwgb3B0aW9ucyB9ID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGNvbnN0IHBvbGljeU5hbWUgPSBwb2xpY3kubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwb2xpY3lNYXAuZ2V0KHBvbGljeU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIG5vZGUgZm9yIHBvbGljeSAke3BvbGljeU5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclBvbGljaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZnRlclBvbGljeU5hbWUgb2Ygb3B0aW9ucy5hZnRlclBvbGljaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyTm9kZSA9IHBvbGljeU1hcC5nZXQoYWZ0ZXJQb2xpY3lOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua2luZyBpbiBib3RoIGRpcmVjdGlvbnMgaGVscHMgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2Ugd2FudCB0byBub3RpZnkgZGVwZW5kYW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVwZW5kc09uLmFkZChhZnRlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJOb2RlLmRlcGVuZGFudHMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlUG9saWNpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJlZm9yZVBvbGljeU5hbWUgb2Ygb3B0aW9ucy5iZWZvcmVQb2xpY2llcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVOb2RlID0gcG9saWN5TWFwLmdldChiZWZvcmVQb2xpY3lOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGV4ZWN1dGUgYmVmb3JlIGFub3RoZXIgbm9kZSwgbWFrZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVwZW5kIG9uIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVOb2RlLmRlcGVuZHNPbi5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlcGVuZGFudHMuYWRkKGJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdhbGtQaGFzZShwaGFzZSkge1xuICAgICAgICAgICAgcGhhc2UuaGFzUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFNldHMgaXRlcmF0ZSBpbiBpbnNlcnRpb24gb3JkZXJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwaGFzZS5wb2xpY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmFmdGVyUGhhc2UgJiYgKCFub2RlLmFmdGVyUGhhc2UuaGFzUnVuIHx8IG5vZGUuYWZ0ZXJQaGFzZS5wb2xpY2llcy5zaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIG5vZGUgaXMgd2FpdGluZyBvbiBhIHBoYXNlIHRvIGNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNraXAgaXQgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgcGhhc2UgaXMgZW1wdHksIHdlIHNob3VsZCB3YWl0IGZvciBpdFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSB3YWxrZWQgdG8gYXZvaWQgcmUtb3JkZXJpbmcgcG9saWNpZXMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kZXBlbmRzT24uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgZWxzZSB3ZSdyZSB3YWl0aW5nIGZvciwgd2UgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIHBvbGljeSB0byB0aGUgcmVzdWx0IGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUucG9saWN5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFueXRoaW5nIHRoYXQgZGVwZW5kcyBvbiB0aGlzIHBvbGljeSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwb2xpY3kgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGFudCBvZiBub2RlLmRlcGVuZGFudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGFudC5kZXBlbmRzT24uZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbGljeU1hcC5kZWxldGUobm9kZS5wb2xpY3kubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlLnBvbGljaWVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2Fsa1BoYXNlcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGhhc2Ugb2Ygb3JkZXJlZFBoYXNlcykge1xuICAgICAgICAgICAgICAgIHdhbGtQaGFzZShwaGFzZSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBoYXNlIGlzbid0IGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgaWYgKHBoYXNlLnBvbGljaWVzLnNpemUgPiAwICYmIHBoYXNlICE9PSBub1BoYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9QaGFzZS5oYXNSdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBydW5uaW5nIG5vUGhhc2UgdG8gc2VlIGlmIHRoYXQgdW5ibG9ja3MgdGhpcyBwaGFzZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYSBwaGFzZSB0aGF0IGhhcHBlbnMgYmVmb3JlIG5vUGhhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHdhaXRpbmcgb24gYSBub1BoYXNlIHBvbGljeSB0byBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtQaGFzZShub1BoYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBoYXNlIHVudGlsIHRoaXMgcGhhc2UgZmluaXNoZXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBoYXNlLmhhc0FmdGVyUG9saWNpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIGFueSBwb2xpY2llcyB1bmJsb2NrZWQgYnkgdGhpcyBwaGFzZVxuICAgICAgICAgICAgICAgICAgICB3YWxrUGhhc2Uobm9QaGFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgd2UndmUgcHV0IGV2ZXJ5IG5vZGUgaW4gdGhlIHJlc3VsdCBsaXN0LlxuICAgICAgICBsZXQgaXRlcmF0aW9uID0gMDtcbiAgICAgICAgd2hpbGUgKHBvbGljeU1hcC5zaXplID4gMCkge1xuICAgICAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUmVzdWx0TGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEtlZXAgd2Fsa2luZyBlYWNoIHBoYXNlIGluIG9yZGVyIHVudGlsIHdlIGNhbiBvcmRlciBldmVyeSBub2RlLlxuICAgICAgICAgICAgd2Fsa1BoYXNlcygpO1xuICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBsaXN0ICpzaG91bGQqIGdldCBhdCBsZWFzdCBvbmUgbGFyZ2VyIGVhY2ggdGltZVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGZpcnN0IGZ1bGwgcGFzcy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gbG9vcCBmb3JldmVyLlxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPD0gaW5pdGlhbFJlc3VsdExlbmd0aCAmJiBpdGVyYXRpb24gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNhdGlzZnkgcG9saWN5IGRlcGVuZGVuY2llcyBkdWUgdG8gcmVxdWlyZW1lbnRzIGN5Y2xlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRvdGFsbHkgZW1wdHkgcGlwZWxpbmUuXG4gKiBVc2VmdWwgZm9yIHRlc3Rpbmcgb3IgY3JlYXRpbmcgYSBjdXN0b20gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlQaXBlbGluZSgpIHtcbiAgICByZXR1cm4gSHR0cFBpcGVsaW5lLmNyZWF0ZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZWxpbmUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBjcmVhdGVIdHRwSGVhZGVycyB9IGZyb20gXCIuL2h0dHBIZWFkZXJzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVV1aWQgfSBmcm9tIFwiLi91dGlsL3V1aWRcIjtcbmNsYXNzIFBpcGVsaW5lUmVxdWVzdEltcGwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IChfYSA9IG9wdGlvbnMuaGVhZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3JlYXRlSHR0cEhlYWRlcnMoKTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSAoX2IgPSBvcHRpb25zLm1ldGhvZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJHRVRcIjtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gKF9jID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICB0aGlzLmZvcm1EYXRhID0gb3B0aW9ucy5mb3JtRGF0YTtcbiAgICAgICAgdGhpcy5kaXNhYmxlS2VlcEFsaXZlID0gKF9kID0gb3B0aW9ucy5kaXNhYmxlS2VlcEFsaXZlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm94eVNldHRpbmdzID0gb3B0aW9ucy5wcm94eVNldHRpbmdzO1xuICAgICAgICB0aGlzLnN0cmVhbVJlc3BvbnNlU3RhdHVzQ29kZXMgPSBvcHRpb25zLnN0cmVhbVJlc3BvbnNlU3RhdHVzQ29kZXM7XG4gICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gKF9lID0gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmFib3J0U2lnbmFsID0gb3B0aW9ucy5hYm9ydFNpZ25hbDtcbiAgICAgICAgdGhpcy50cmFjaW5nT3B0aW9ucyA9IG9wdGlvbnMudHJhY2luZ09wdGlvbnM7XG4gICAgICAgIHRoaXMub25VcGxvYWRQcm9ncmVzcyA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcztcbiAgICAgICAgdGhpcy5vbkRvd25sb2FkUHJvZ3Jlc3MgPSBvcHRpb25zLm9uRG93bmxvYWRQcm9ncmVzcztcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCBnZW5lcmF0ZVV1aWQoKTtcbiAgICAgICAgdGhpcy5hbGxvd0luc2VjdXJlQ29ubmVjdGlvbiA9IChfZiA9IG9wdGlvbnMuYWxsb3dJbnNlY3VyZUNvbm5lY3Rpb24pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZUJyb3dzZXJTdHJlYW1zID0gKF9nID0gb3B0aW9ucy5lbmFibGVCcm93c2VyU3RyZWFtcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHBpcGVsaW5lIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqIFRoaXMgbWV0aG9kIGlzIHRvIGFsbG93IGZvciB0aGUgZWFzeSBzZXR0aW5nIG9mIGRlZmF1bHQgdmFsdWVzIGFuZCBub3QgcmVxdWlyZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgcmVxdWVzdCB3aXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBpcGVsaW5lUmVxdWVzdEltcGwob3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlbGluZVJlcXVlc3QuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBjcmVhdGVUb2tlbkN5Y2xlciB9IGZyb20gXCIuLi91dGlsL3Rva2VuQ3ljbGVyXCI7XG5pbXBvcnQgeyBsb2dnZXIgYXMgY29yZUxvZ2dlciB9IGZyb20gXCIuLi9sb2dcIjtcbi8qKlxuICogVGhlIHByb2dyYW1tYXRpYyBpZGVudGlmaWVyIG9mIHRoZSBiZWFyZXJUb2tlbkF1dGhlbnRpY2F0aW9uUG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgYmVhcmVyVG9rZW5BdXRoZW50aWNhdGlvblBvbGljeU5hbWUgPSBcImJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3lcIjtcbi8qKlxuICogRGVmYXVsdCBhdXRob3JpemUgcmVxdWVzdCBoYW5kbGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRBdXRob3JpemVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNjb3BlcywgZ2V0QWNjZXNzVG9rZW4sIHJlcXVlc3QgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZ2V0VG9rZW5PcHRpb25zID0ge1xuICAgICAgICBhYm9ydFNpZ25hbDogcmVxdWVzdC5hYm9ydFNpZ25hbCxcbiAgICAgICAgdHJhY2luZ09wdGlvbnM6IHJlcXVlc3QudHJhY2luZ09wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IGdldEFjY2Vzc1Rva2VuKHNjb3BlcywgZ2V0VG9rZW5PcHRpb25zKTtcbiAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMuc2V0KFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7YWNjZXNzVG9rZW4udG9rZW59YCk7XG4gICAgfVxufVxuLyoqXG4gKiBXZSB3aWxsIHJldHJpZXZlIHRoZSBjaGFsbGVuZ2Ugb25seSBpZiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgd2FzIDQwMSxcbiAqIGFuZCBpZiB0aGUgcmVzcG9uc2UgY29udGFpbmVkIHRoZSBoZWFkZXIgXCJXV1ctQXV0aGVudGljYXRlXCIgd2l0aCBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhbGxlbmdlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2hhbGxlbmdlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJXV1ctQXV0aGVudGljYXRlXCIpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiBjaGFsbGVuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNoYWxsZW5nZTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBBIHBvbGljeSB0aGF0IGNhbiByZXF1ZXN0IGEgdG9rZW4gZnJvbSBhIFRva2VuQ3JlZGVudGlhbCBpbXBsZW1lbnRhdGlvbiBhbmRcbiAqIHRoZW4gYXBwbHkgaXQgdG8gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyIG9mIGEgcmVxdWVzdCBhcyBhIEJlYXJlciB0b2tlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3kob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNyZWRlbnRpYWwsIHNjb3BlcywgY2hhbGxlbmdlQ2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyIHx8IGNvcmVMb2dnZXI7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7IGF1dGhvcml6ZVJlcXVlc3Q6IChfYSA9IGNoYWxsZW5nZUNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjaGFsbGVuZ2VDYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYWxsZW5nZUNhbGxiYWNrcy5hdXRob3JpemVSZXF1ZXN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0QXV0aG9yaXplUmVxdWVzdCwgYXV0aG9yaXplUmVxdWVzdE9uQ2hhbGxlbmdlOiBjaGFsbGVuZ2VDYWxsYmFja3MgPT09IG51bGwgfHwgY2hhbGxlbmdlQ2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFsbGVuZ2VDYWxsYmFja3MuYXV0aG9yaXplUmVxdWVzdE9uQ2hhbGxlbmdlIH0sIGNoYWxsZW5nZUNhbGxiYWNrcyk7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgdGhlIGVudGlyZSBwcm9jZXNzIG9mIHJlbGlhYmx5IHJldHJpZXZpbmcgdGhlIHRva2VuXG4gICAgLy8gVGhlIG9wdGlvbnMgYXJlIGxlZnQgb3V0IG9mIHRoZSBwdWJsaWMgQVBJIHVudGlsIHRoZXJlJ3MgZGVtYW5kIHRvIGNvbmZpZ3VyZSB0aGlzLlxuICAgIC8vIFJlbWVtYmVyIHRvIGV4dGVuZCBgQmVhcmVyVG9rZW5BdXRoZW50aWNhdGlvblBvbGljeU9wdGlvbnNgIHdpdGggYFRva2VuQ3ljbGVyT3B0aW9uc2BcbiAgICAvLyBpbiBvcmRlciB0byBwYXNzIHRocm91Z2ggdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgY29uc3QgZ2V0QWNjZXNzVG9rZW4gPSBjcmVkZW50aWFsXG4gICAgICAgID8gY3JlYXRlVG9rZW5DeWNsZXIoY3JlZGVudGlhbCAvKiAsIG9wdGlvbnMgKi8pXG4gICAgICAgIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGJlYXJlclRva2VuQXV0aGVudGljYXRpb25Qb2xpY3lOYW1lLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUncyBubyBjaGFsbGVuZ2UgcGFyYW1ldGVyOlxuICAgICAgICAgKiAtIEl0IHdpbGwgdHJ5IHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY2FjaGUsIG9yIHRoZSBjcmVkZW50aWFsJ3MgZ2V0VG9rZW4uXG4gICAgICAgICAqIC0gVGhlbiBpdCB3aWxsIHRyeSB0aGUgbmV4dCBwb2xpY3kgd2l0aCBvciB3aXRob3V0IHRoZSByZXRyaWV2ZWQgdG9rZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHVzZXMgdGhlIGNoYWxsZW5nZSBwYXJhbWV0ZXJzIHRvOlxuICAgICAgICAgKiAtIFNraXAgYSBmaXJzdCBhdHRlbXB0IHRvIGdldCB0aGUgdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbCBpZiB0aGVyZSdzIG5vIGNhY2hlZCB0b2tlbixcbiAgICAgICAgICogICBzaW5jZSBpdCBleHBlY3RzIHRoZSB0b2tlbiB0byBiZSByZXRyaWV2YWJsZSBvbmx5IGFmdGVyIHRoZSBjaGFsbGVuZ2UuXG4gICAgICAgICAqIC0gUHJlcGFyZSB0aGUgb3V0Z29pbmcgcmVxdWVzdCBpZiB0aGUgYHByZXBhcmVSZXF1ZXN0YCBtZXRob2QgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICAgICAqIC0gU2VuZCBhbiBpbml0aWFsIHJlcXVlc3QgdG8gcmVjZWl2ZSB0aGUgY2hhbGxlbmdlIGlmIGl0IGZhaWxzLlxuICAgICAgICAgKiAtIFByb2Nlc3MgYSBjaGFsbGVuZ2UgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIGl0LlxuICAgICAgICAgKiAtIFJldHJpZXZlIGEgdG9rZW4gd2l0aCB0aGUgY2hhbGxlbmdlIGluZm9ybWF0aW9uLCB0aGVuIHJlLXNlbmQgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3QudXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmVhcmVyIHRva2VuIGF1dGhlbnRpY2F0aW9uIGlzIG5vdCBwZXJtaXR0ZWQgZm9yIG5vbi1UTFMgcHJvdGVjdGVkIChub24taHR0cHMpIFVSTHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLmF1dGhvcml6ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHNjb3BlczogQXJyYXkuaXNBcnJheShzY29wZXMpID8gc2NvcGVzIDogW3Njb3Blc10sXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBnZXRBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBuZXh0KHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5hdXRob3JpemVSZXF1ZXN0T25DaGFsbGVuZ2UgJiZcbiAgICAgICAgICAgICAgICAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cykgPT09IDQwMSAmJlxuICAgICAgICAgICAgICAgIGdldENoYWxsZW5nZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzZXMgY2hhbGxlbmdlXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2VuZFJlcXVlc3QgPSBhd2FpdCBjYWxsYmFja3MuYXV0aG9yaXplUmVxdWVzdE9uQ2hhbGxlbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiBBcnJheS5pc0FycmF5KHNjb3BlcykgPyBzY29wZXMgOiBbc2NvcGVzXSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNlbmRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWFyZXJUb2tlbkF1dGhlbnRpY2F0aW9uUG9saWN5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIGRlY29tcHJlc3NSZXNwb25zZVBvbGljeS5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29tcHJlc3NSZXNwb25zZVBvbGljeU5hbWUgPSBcImRlY29tcHJlc3NSZXNwb25zZVBvbGljeVwiO1xuLyoqXG4gKiBBIHBvbGljeSB0byBlbmFibGUgcmVzcG9uc2UgZGVjb21wcmVzc2lvbiBhY2NvcmRpbmcgdG8gQWNjZXB0LUVuY29kaW5nIGhlYWRlclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2VwdC1FbmNvZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1Jlc3BvbnNlUG9saWN5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlY29tcHJlc3NSZXNwb25zZVBvbGljeU5hbWUsXG4gICAgICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG5leHQpIHtcbiAgICAgICAgICAgIC8vIEhFQUQgcmVxdWVzdHMgaGF2ZSBubyBib2R5XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldChcIkFjY2VwdC1FbmNvZGluZ1wiLCBcImd6aXAsZGVmbGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0KHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvbXByZXNzUmVzcG9uc2VQb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBleHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgfSBmcm9tIFwiLi4vcmV0cnlTdHJhdGVnaWVzL2V4cG9uZW50aWFsUmV0cnlTdHJhdGVneVwiO1xuaW1wb3J0IHsgdGhyb3R0bGluZ1JldHJ5U3RyYXRlZ3kgfSBmcm9tIFwiLi4vcmV0cnlTdHJhdGVnaWVzL3Rocm90dGxpbmdSZXRyeVN0cmF0ZWd5XCI7XG5pbXBvcnQgeyByZXRyeVBvbGljeSB9IGZyb20gXCIuL3JldHJ5UG9saWN5XCI7XG5pbXBvcnQgeyBERUZBVUxUX1JFVFJZX1BPTElDWV9DT1VOVCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbi8qKlxuICogTmFtZSBvZiB0aGUge0BsaW5rIGRlZmF1bHRSZXRyeVBvbGljeX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRSZXRyeVBvbGljeU5hbWUgPSBcImRlZmF1bHRSZXRyeVBvbGljeVwiO1xuLyoqXG4gKiBBIHBvbGljeSB0aGF0IHJldHJpZXMgYWNjb3JkaW5nIHRvIHRocmVlIHN0cmF0ZWdpZXM6XG4gKiAtIFdoZW4gdGhlIHNlcnZlciBzZW5kcyBhIDQyOSByZXNwb25zZSB3aXRoIGEgUmV0cnktQWZ0ZXIgaGVhZGVyLlxuICogLSBXaGVuIHRoZXJlIGFyZSBlcnJvcnMgaW4gdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGxheWVyIChlLmcuIEROUyBsb29rdXAgZmFpbHVyZXMpLlxuICogLSBPciBvdGhlcndpc2UgaWYgdGhlIG91dGdvaW5nIHJlcXVlc3QgZmFpbHMsIGl0IHdpbGwgcmV0cnkgd2l0aCBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgZGVsYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmV0cnlQb2xpY3kob3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlZmF1bHRSZXRyeVBvbGljeU5hbWUsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiByZXRyeVBvbGljeShbdGhyb3R0bGluZ1JldHJ5U3RyYXRlZ3koKSwgZXhwb25lbnRpYWxSZXRyeVN0cmF0ZWd5KG9wdGlvbnMpXSwge1xuICAgICAgICAgICAgbWF4UmV0cmllczogKF9hID0gb3B0aW9ucy5tYXhSZXRyaWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1JFVFJZX1BPTElDWV9DT1VOVCxcbiAgICAgICAgfSkuc2VuZFJlcXVlc3QsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRSZXRyeVBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCBGb3JtRGF0YSBmcm9tIFwiZm9ybS1kYXRhXCI7XG4vKipcbiAqIFRoZSBwcm9ncmFtbWF0aWMgaWRlbnRpZmllciBvZiB0aGUgZm9ybURhdGFQb2xpY3kuXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtRGF0YVBvbGljeU5hbWUgPSBcImZvcm1EYXRhUG9saWN5XCI7XG4vKipcbiAqIEEgcG9saWN5IHRoYXQgZW5jb2RlcyBGb3JtRGF0YSBvbiB0aGUgcmVxdWVzdCBpbnRvIHRoZSBib2R5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybURhdGFQb2xpY3koKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZm9ybURhdGFQb2xpY3lOYW1lLFxuICAgICAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5mb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVxdWVzdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gd3d3Rm9ybVVybEVuY29kZShyZXF1ZXN0LmZvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5mb3JtRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVGb3JtRGF0YShyZXF1ZXN0LmZvcm1EYXRhLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gd3d3Rm9ybVVybEVuY29kZShmb3JtRGF0YSkge1xuICAgIGNvbnN0IHVybFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtRGF0YSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHN1YlZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmxTZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVGb3JtRGF0YShmb3JtRGF0YSwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RGb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9yIChjb25zdCBmb3JtS2V5IG9mIE9iamVjdC5rZXlzKGZvcm1EYXRhKSkge1xuICAgICAgICBjb25zdCBmb3JtVmFsdWUgPSBmb3JtRGF0YVtmb3JtS2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybVZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJWYWx1ZSBvZiBmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Rm9ybS5hcHBlbmQoZm9ybUtleSwgc3ViVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdEZvcm0uYXBwZW5kKGZvcm1LZXksIGZvcm1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5ib2R5ID0gcmVxdWVzdEZvcm07XG4gICAgcmVxdWVzdC5mb3JtRGF0YSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpICE9PSAtMSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke3JlcXVlc3RGb3JtLmdldEJvdW5kYXJ5KCl9YCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0Rm9ybS5nZXRMZW5ndGgoKGVyciwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoXCJDb250ZW50LUxlbmd0aFwiLCBjb250ZW50TGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlIHNldHRpbmcgdGhlIGxlbmd0aCBpZiB0aGlzIGZhaWxzXG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybURhdGFQb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBsb2dnZXIgYXMgY29yZUxvZ2dlciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IFNhbml0aXplciB9IGZyb20gXCIuLi91dGlsL3Nhbml0aXplclwiO1xuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIGxvZ1BvbGljeS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1BvbGljeU5hbWUgPSBcImxvZ1BvbGljeVwiO1xuLyoqXG4gKiBBIHBvbGljeSB0aGF0IGxvZ3MgYWxsIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uZmlndXJlIGxvZ1BvbGljeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ1BvbGljeShvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyID0gKF9hID0gb3B0aW9ucy5sb2dnZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvcmVMb2dnZXIuaW5mbztcbiAgICBjb25zdCBzYW5pdGl6ZXIgPSBuZXcgU2FuaXRpemVyKHtcbiAgICAgICAgYWRkaXRpb25hbEFsbG93ZWRIZWFkZXJOYW1lczogb3B0aW9ucy5hZGRpdGlvbmFsQWxsb3dlZEhlYWRlck5hbWVzLFxuICAgICAgICBhZGRpdGlvbmFsQWxsb3dlZFF1ZXJ5UGFyYW1ldGVyczogb3B0aW9ucy5hZGRpdGlvbmFsQWxsb3dlZFF1ZXJ5UGFyYW1ldGVycyxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBsb2dQb2xpY3lOYW1lLFxuICAgICAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWxvZ2dlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIoYFJlcXVlc3Q6ICR7c2FuaXRpemVyLnNhbml0aXplKHJlcXVlc3QpfWApO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuZXh0KHJlcXVlc3QpO1xuICAgICAgICAgICAgbG9nZ2VyKGBSZXNwb25zZSBzdGF0dXMgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICBsb2dnZXIoYEhlYWRlcnM6ICR7c2FuaXRpemVyLnNhbml0aXplKHJlc3BvbnNlLmhlYWRlcnMpfWApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dQb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBIdHRwc1Byb3h5QWdlbnQgfSBmcm9tIFwiaHR0cHMtcHJveHktYWdlbnRcIjtcbmltcG9ydCB7IEh0dHBQcm94eUFnZW50IH0gZnJvbSBcImh0dHAtcHJveHktYWdlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9sb2dcIjtcbmNvbnN0IEhUVFBTX1BST1hZID0gXCJIVFRQU19QUk9YWVwiO1xuY29uc3QgSFRUUF9QUk9YWSA9IFwiSFRUUF9QUk9YWVwiO1xuY29uc3QgQUxMX1BST1hZID0gXCJBTExfUFJPWFlcIjtcbmNvbnN0IE5PX1BST1hZID0gXCJOT19QUk9YWVwiO1xuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIHByb3h5UG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgcHJveHlQb2xpY3lOYW1lID0gXCJwcm94eVBvbGljeVwiO1xuLyoqXG4gKiBTdG9yZXMgdGhlIHBhdHRlcm5zIHNwZWNpZmllZCBpbiBOT19QUk9YWSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgZ2xvYmFsTm9Qcm94eUxpc3QgPSBbXTtcbmxldCBub1Byb3h5TGlzdExvYWRlZCA9IGZhbHNlO1xuLyoqIEEgY2FjaGUgb2Ygd2hldGhlciBhIGhvc3Qgc2hvdWxkIGJ5cGFzcyB0aGUgcHJveHkuICovXG5jb25zdCBnbG9iYWxCeXBhc3NlZE1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFsdWUobmFtZSkge1xuICAgIGlmIChwcm9jZXNzLmVudltuYW1lXSkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbmFtZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52W25hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52W25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBsb2FkRW52aXJvbm1lbnRQcm94eVZhbHVlKCkge1xuICAgIGlmICghcHJvY2Vzcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBodHRwc1Byb3h5ID0gZ2V0RW52aXJvbm1lbnRWYWx1ZShIVFRQU19QUk9YWSk7XG4gICAgY29uc3QgYWxsUHJveHkgPSBnZXRFbnZpcm9ubWVudFZhbHVlKEFMTF9QUk9YWSk7XG4gICAgY29uc3QgaHR0cFByb3h5ID0gZ2V0RW52aXJvbm1lbnRWYWx1ZShIVFRQX1BST1hZKTtcbiAgICByZXR1cm4gaHR0cHNQcm94eSB8fCBhbGxQcm94eSB8fCBodHRwUHJveHk7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGhvc3Qgb2YgYSBnaXZlbiBgdXJpYCBtYXRjaGVzIGFueSBwYXR0ZXJuIGluIHRoZSBubyBwcm94eSBsaXN0LlxuICogSWYgdGhlcmUncyBhIG1hdGNoLCBhbnkgcmVxdWVzdCBzZW50IHRvIHRoZSBzYW1lIGhvc3Qgc2hvdWxkbid0IGhhdmUgdGhlIHByb3h5IHNldHRpbmdzIHNldC5cbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYSBwb3J0IG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9BenVyZS9henVyZS1zZGstZm9yLW5ldC9ibG9iLzhjY2E4MTEzNzExNTllNTI3MTU5YzdlYjY1NjAyNDc3ODk4NjgzZTIvc2RrL2NvcmUvQXp1cmUuQ29yZS9zcmMvUGlwZWxpbmUvSW50ZXJuYWwvSHR0cEVudmlyb25tZW50UHJveHkuY3MjTDIxMFxuICovXG5mdW5jdGlvbiBpc0J5cGFzc2VkKHVyaSwgbm9Qcm94eUxpc3QsIGJ5cGFzc2VkTWFwKSB7XG4gICAgaWYgKG5vUHJveHlMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhvc3QgPSBuZXcgVVJMKHVyaSkuaG9zdG5hbWU7XG4gICAgaWYgKGJ5cGFzc2VkTWFwID09PSBudWxsIHx8IGJ5cGFzc2VkTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBieXBhc3NlZE1hcC5oYXMoaG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIGJ5cGFzc2VkTWFwLmdldChob3N0KTtcbiAgICB9XG4gICAgbGV0IGlzQnlwYXNzZWRGbGFnID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIG5vUHJveHlMaXN0KSB7XG4gICAgICAgIGlmIChwYXR0ZXJuWzBdID09PSBcIi5cIikge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggZWl0aGVyIGRvbWFpbiBpdCBzZWxmIG9yIGFueSBzdWJkb21haW4gb3IgaG9zdFxuICAgICAgICAgICAgLy8gLmZvby5jb20gd2lsbCBtYXRjaCBmb28uY29tIGl0IHNlbGYgb3IgKi5mb28uY29tXG4gICAgICAgICAgICBpZiAoaG9zdC5lbmRzV2l0aChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlzQnlwYXNzZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChob3N0Lmxlbmd0aCA9PT0gcGF0dGVybi5sZW5ndGggLSAxICYmIGhvc3QgPT09IHBhdHRlcm4uc2xpY2UoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCeXBhc3NlZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChob3N0ID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaXNCeXBhc3NlZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGJ5cGFzc2VkTWFwID09PSBudWxsIHx8IGJ5cGFzc2VkTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBieXBhc3NlZE1hcC5zZXQoaG9zdCwgaXNCeXBhc3NlZEZsYWcpO1xuICAgIHJldHVybiBpc0J5cGFzc2VkRmxhZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTm9Qcm94eSgpIHtcbiAgICBjb25zdCBub1Byb3h5ID0gZ2V0RW52aXJvbm1lbnRWYWx1ZShOT19QUk9YWSk7XG4gICAgbm9Qcm94eUxpc3RMb2FkZWQgPSB0cnVlO1xuICAgIGlmIChub1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5XG4gICAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgICAubWFwKChpdGVtKSA9PiBpdGVtLnRyaW0oKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyBhIHByb3h5IHVybCBpbnRvIGBQcm94eVNldHRpbmdzYCBmb3IgdXNlIHdpdGggUHJveHlQb2xpY3kuXG4gKiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgaXQgYXR0ZW1wdHMgdG8gcGFyc2UgYSBwcm94eSBVUkwgZnJvbSB0aGUgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlcyBgSFRUUFNfUFJPWFlgIG9yIGBIVFRQX1BST1hZYC5cbiAqIEBwYXJhbSBwcm94eVVybCAtIFRoZSB1cmwgb2YgdGhlIHByb3h5IHRvIHVzZS4gTWF5IGNvbnRhaW4gYXV0aGVudGljYXRpb24gaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UHJveHlTZXR0aW5ncyhwcm94eVVybCkge1xuICAgIGlmICghcHJveHlVcmwpIHtcbiAgICAgICAgcHJveHlVcmwgPSBsb2FkRW52aXJvbm1lbnRQcm94eVZhbHVlKCk7XG4gICAgICAgIGlmICghcHJveHlVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChwcm94eVVybCk7XG4gICAgY29uc3Qgc2NoZW1hID0gcGFyc2VkVXJsLnByb3RvY29sID8gcGFyc2VkVXJsLnByb3RvY29sICsgXCIvL1wiIDogXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBob3N0OiBzY2hlbWEgKyBwYXJzZWRVcmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IE51bWJlci5wYXJzZUludChwYXJzZWRVcmwucG9ydCB8fCBcIjgwXCIpLFxuICAgICAgICB1c2VybmFtZTogcGFyc2VkVXJsLnVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZDogcGFyc2VkVXJsLnBhc3N3b3JkLFxuICAgIH07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJveHlBZ2VudE9wdGlvbnMocHJveHlTZXR0aW5ncywgeyBoZWFkZXJzLCB0bHNTZXR0aW5ncyB9KSB7XG4gICAgbGV0IHBhcnNlZFByb3h5VXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFByb3h5VXJsID0gbmV3IFVSTChwcm94eVNldHRpbmdzLmhvc3QpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIGEgdmFsaWQgaG9zdCBzdHJpbmcgaW4gcHJveHkgc2V0dGluZ3MsIGJ1dCBmb3VuZCBcIiR7cHJveHlTZXR0aW5ncy5ob3N0fVwiLmApO1xuICAgIH1cbiAgICBpZiAodGxzU2V0dGluZ3MpIHtcbiAgICAgICAgbG9nZ2VyLndhcm5pbmcoXCJUTFMgc2V0dGluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBjdXN0b20gUHJveHksIGNlcnRpZmljYXRlcyBwcm92aWRlZCB0byB0aGUgY2xpZW50IHdpbGwgYmUgaWdub3JlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5QWdlbnRPcHRpb25zID0ge1xuICAgICAgICBob3N0bmFtZTogcGFyc2VkUHJveHlVcmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHByb3h5U2V0dGluZ3MucG9ydCxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnNlZFByb3h5VXJsLnByb3RvY29sLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLnRvSlNPTigpLFxuICAgIH07XG4gICAgaWYgKHByb3h5U2V0dGluZ3MudXNlcm5hbWUgJiYgcHJveHlTZXR0aW5ncy5wYXNzd29yZCkge1xuICAgICAgICBwcm94eUFnZW50T3B0aW9ucy5hdXRoID0gYCR7cHJveHlTZXR0aW5ncy51c2VybmFtZX06JHtwcm94eVNldHRpbmdzLnBhc3N3b3JkfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3h5U2V0dGluZ3MudXNlcm5hbWUpIHtcbiAgICAgICAgcHJveHlBZ2VudE9wdGlvbnMuYXV0aCA9IGAke3Byb3h5U2V0dGluZ3MudXNlcm5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5QWdlbnRPcHRpb25zO1xufVxuZnVuY3Rpb24gc2V0UHJveHlBZ2VudE9uUmVxdWVzdChyZXF1ZXN0LCBjYWNoZWRBZ2VudHMpIHtcbiAgICAvLyBDdXN0b20gQWdlbnQgc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBzbyBpZiBvbmUgaXMgcHJlc2VudFxuICAgIC8vIHdlIHNob3VsZCBza2lwIHRvIGF2b2lkIG92ZXJ3cml0aW5nIGl0LlxuICAgIGlmIChyZXF1ZXN0LmFnZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgY29uc3QgaXNJbnNlY3VyZSA9IHVybC5wcm90b2NvbCAhPT0gXCJodHRwczpcIjtcbiAgICBjb25zdCBwcm94eVNldHRpbmdzID0gcmVxdWVzdC5wcm94eVNldHRpbmdzO1xuICAgIGlmIChwcm94eVNldHRpbmdzKSB7XG4gICAgICAgIGlmIChpc0luc2VjdXJlKSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlZEFnZW50cy5odHRwUHJveHlBZ2VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5QWdlbnRPcHRpb25zID0gZ2V0UHJveHlBZ2VudE9wdGlvbnMocHJveHlTZXR0aW5ncywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgY2FjaGVkQWdlbnRzLmh0dHBQcm94eUFnZW50ID0gbmV3IEh0dHBQcm94eUFnZW50KHByb3h5QWdlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QuYWdlbnQgPSBjYWNoZWRBZ2VudHMuaHR0cFByb3h5QWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlZEFnZW50cy5odHRwc1Byb3h5QWdlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eUFnZW50T3B0aW9ucyA9IGdldFByb3h5QWdlbnRPcHRpb25zKHByb3h5U2V0dGluZ3MsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGNhY2hlZEFnZW50cy5odHRwc1Byb3h5QWdlbnQgPSBuZXcgSHR0cHNQcm94eUFnZW50KHByb3h5QWdlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QuYWdlbnQgPSBjYWNoZWRBZ2VudHMuaHR0cHNQcm94eUFnZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHBvbGljeSB0aGF0IGFsbG93cyBvbmUgdG8gYXBwbHkgcHJveHkgc2V0dGluZ3MgdG8gYWxsIHJlcXVlc3RzLlxuICogSWYgbm90IHBhc3NlZCBzdGF0aWMgc2V0dGluZ3MsIHRoZXkgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgSFRUUFNfUFJPWFlcbiAqIG9yIEhUVFBfUFJPWFkgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICogQHBhcmFtIHByb3h5U2V0dGluZ3MgLSBQcm94eVNldHRpbmdzIHRvIHVzZSBvbiBlYWNoIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgc2V0dGluZ3MsIGZvciBleGFtcGxlLCBjdXN0b20gTk9fUFJPWFkgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5UG9saWN5KHByb3h5U2V0dGluZ3MgPSBnZXREZWZhdWx0UHJveHlTZXR0aW5ncygpLCBvcHRpb25zKSB7XG4gICAgaWYgKCFub1Byb3h5TGlzdExvYWRlZCkge1xuICAgICAgICBnbG9iYWxOb1Byb3h5TGlzdC5wdXNoKC4uLmxvYWROb1Byb3h5KCkpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRBZ2VudHMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBwcm94eVBvbGljeU5hbWUsXG4gICAgICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG5leHQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdC5wcm94eVNldHRpbmdzICYmXG4gICAgICAgICAgICAgICAgIWlzQnlwYXNzZWQocmVxdWVzdC51cmwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jdXN0b21Ob1Byb3h5TGlzdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2xvYmFsTm9Qcm94eUxpc3QsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY3VzdG9tTm9Qcm94eUxpc3QpID8gdW5kZWZpbmVkIDogZ2xvYmFsQnlwYXNzZWRNYXApKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wcm94eVNldHRpbmdzID0gcHJveHlTZXR0aW5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnByb3h5U2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm94eUFnZW50T25SZXF1ZXN0KHJlcXVlc3QsIGNhY2hlZEFnZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHlQb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIFRoZSBwcm9ncmFtbWF0aWMgaWRlbnRpZmllciBvZiB0aGUgcmVkaXJlY3RQb2xpY3kuXG4gKi9cbmV4cG9ydCBjb25zdCByZWRpcmVjdFBvbGljeU5hbWUgPSBcInJlZGlyZWN0UG9saWN5XCI7XG4vKipcbiAqIE1ldGhvZHMgdGhhdCBhcmUgYWxsb3dlZCB0byBmb2xsb3cgcmVkaXJlY3RzIDMwMSBhbmQgMzAyXG4gKi9cbmNvbnN0IGFsbG93ZWRSZWRpcmVjdCA9IFtcIkdFVFwiLCBcIkhFQURcIl07XG4vKipcbiAqIEEgcG9saWN5IHRvIGZvbGxvdyBMb2NhdGlvbiBoZWFkZXJzIGZyb20gdGhlIHNlcnZlciBpbiBvcmRlclxuICogdG8gc3VwcG9ydCBzZXJ2ZXItc2lkZSByZWRpcmVjdGlvbi5cbiAqIEluIHRoZSBicm93c2VyLCB0aGlzIHBvbGljeSBpcyBub3QgdXNlZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb250cm9sIHBvbGljeSBiZWhhdmlvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZGlyZWN0UG9saWN5KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcyA9IDIwIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHJlZGlyZWN0UG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuZXh0KHJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlZGlyZWN0KG5leHQsIHJlc3BvbnNlLCBtYXhSZXRyaWVzKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVkaXJlY3QobmV4dCwgcmVzcG9uc2UsIG1heFJldHJpZXMsIGN1cnJlbnRSZXRyaWVzID0gMCkge1xuICAgIGNvbnN0IHsgcmVxdWVzdCwgc3RhdHVzLCBoZWFkZXJzIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBsb2NhdGlvbkhlYWRlciA9IGhlYWRlcnMuZ2V0KFwibG9jYXRpb25cIik7XG4gICAgaWYgKGxvY2F0aW9uSGVhZGVyICYmXG4gICAgICAgIChzdGF0dXMgPT09IDMwMCB8fFxuICAgICAgICAgICAgKHN0YXR1cyA9PT0gMzAxICYmIGFsbG93ZWRSZWRpcmVjdC5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpIHx8XG4gICAgICAgICAgICAoc3RhdHVzID09PSAzMDIgJiYgYWxsb3dlZFJlZGlyZWN0LmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSkgfHxcbiAgICAgICAgICAgIChzdGF0dXMgPT09IDMwMyAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJQT1NUXCIpIHx8XG4gICAgICAgICAgICBzdGF0dXMgPT09IDMwNykgJiZcbiAgICAgICAgY3VycmVudFJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobG9jYXRpb25IZWFkZXIsIHJlcXVlc3QudXJsKTtcbiAgICAgICAgcmVxdWVzdC51cmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gUE9TVCByZXF1ZXN0IHdpdGggU3RhdHVzIGNvZGUgMzAzIHNob3VsZCBiZSBjb252ZXJ0ZWQgaW50byBhXG4gICAgICAgIC8vIHJlZGlyZWN0ZWQgR0VUIHJlcXVlc3QgaWYgdGhlIHJlZGlyZWN0IHVybCBpcyBwcmVzZW50IGluIHRoZSBsb2NhdGlvbiBoZWFkZXJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMzAzKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKFwiQ29udGVudC1MZW5ndGhcIik7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJBdXRob3JpemF0aW9uXCIpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBuZXh0KHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVkaXJlY3QobmV4dCwgcmVzLCBtYXhSZXRyaWVzLCBjdXJyZW50UmV0cmllcyArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRpcmVjdFBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGRlbGF5IH0gZnJvbSBcIi4uL3V0aWwvaGVscGVyc1wiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50TG9nZ2VyIH0gZnJvbSBcIkBhenVyZS9sb2dnZXJcIjtcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tIFwiQGF6dXJlL2Fib3J0LWNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IERFRkFVTFRfUkVUUllfUE9MSUNZX0NPVU5UIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuY29uc3QgcmV0cnlQb2xpY3lMb2dnZXIgPSBjcmVhdGVDbGllbnRMb2dnZXIoXCJjb3JlLXJlc3QtcGlwZWxpbmUgcmV0cnlQb2xpY3lcIik7XG4vKipcbiAqIFRoZSBwcm9ncmFtbWF0aWMgaWRlbnRpZmllciBvZiB0aGUgcmV0cnlQb2xpY3kuXG4gKi9cbmNvbnN0IHJldHJ5UG9saWN5TmFtZSA9IFwicmV0cnlQb2xpY3lcIjtcbi8qKlxuICogcmV0cnlQb2xpY3kgaXMgYSBnZW5lcmljIHBvbGljeSB0byBlbmFibGUgcmV0cnlpbmcgcmVxdWVzdHMgd2hlbiBjZXJ0YWluIGNvbmRpdGlvbnMgYXJlIG1ldFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlQb2xpY3koc3RyYXRlZ2llcywgb3B0aW9ucyA9IHsgbWF4UmV0cmllczogREVGQVVMVF9SRVRSWV9QT0xJQ1lfQ09VTlQgfSkge1xuICAgIGNvbnN0IGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyIHx8IHJldHJ5UG9saWN5TG9nZ2VyO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHJldHJ5UG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgIGxldCByZXNwb25zZUVycm9yO1xuICAgICAgICAgICAgbGV0IHJldHJ5Q291bnQgPSAtMTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICAgIHJldHJ5UmVxdWVzdDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXRyeUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgUmV0cnkgJHtyZXRyeUNvdW50fTogQXR0ZW1wdGluZyB0byBzZW5kIHJlcXVlc3RgLCByZXF1ZXN0LnJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFJldHJ5ICR7cmV0cnlDb3VudH06IFJlY2VpdmVkIGEgcmVzcG9uc2UgZnJvbSByZXF1ZXN0YCwgcmVxdWVzdC5yZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJldHJ5ICR7cmV0cnlDb3VudH06IFJlY2VpdmVkIGFuIGVycm9yIGZyb20gcmVxdWVzdGAsIHJlcXVlc3QucmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdEVycm9ycyBhcmUgdmFsaWQgdGFyZ2V0cyBmb3IgdGhlIHJldHJ5IHN0cmF0ZWdpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIHJldHJ5IHN0cmF0ZWdpZXMgY2FuIHdvcmsgd2l0aCB0aGVtLCB0aGV5IHdpbGwgYmUgdGhyb3duIGxhdGVyIGluIHRoaXMgcG9saWN5LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVjZWl2ZWQgZXJyb3IgaXMgbm90IGEgUmVzdEVycm9yLCBpdCBpcyBpbW1lZGlhdGVseSB0aHJvd24uXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgcmVzcG9uc2VFcnJvci5uYW1lICE9PSBcIlJlc3RFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VFcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlcXVlc3QuYWJvcnRTaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmV0cnkgJHtyZXRyeUNvdW50fTogUmVxdWVzdCBhYm9ydGVkLmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gKChfYiA9IG9wdGlvbnMubWF4UmV0cmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9SRVRSWV9QT0xJQ1lfQ09VTlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBSZXRyeSAke3JldHJ5Q291bnR9OiBNYXhpbXVtIHJldHJpZXMgcmVhY2hlZC4gUmV0dXJuaW5nIHRoZSBsYXN0IHJlY2VpdmVkIHJlc3BvbnNlLCBvciB0aHJvd2luZyB0aGUgbGFzdCByZWNlaXZlZCBlcnJvci5gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heGltdW0gcmV0cmllcyByZWFjaGVkIHdpdGggbm8gcmVzcG9uc2Ugb3IgZXJyb3IgdG8gdGhyb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFJldHJ5ICR7cmV0cnlDb3VudH06IFByb2Nlc3NpbmcgJHtzdHJhdGVnaWVzLmxlbmd0aH0gcmV0cnkgc3RyYXRlZ2llcy5gKTtcbiAgICAgICAgICAgICAgICBzdHJhdGVnaWVzTG9vcDogZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5TG9nZ2VyID0gc3RyYXRlZ3kubG9nZ2VyIHx8IHJldHJ5UG9saWN5TG9nZ2VyO1xuICAgICAgICAgICAgICAgICAgICBzdHJhdGVneUxvZ2dlci5pbmZvKGBSZXRyeSAke3JldHJ5Q291bnR9OiBQcm9jZXNzaW5nIHJldHJ5IHN0cmF0ZWd5ICR7c3RyYXRlZ3kubmFtZX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IHN0cmF0ZWd5LnJldHJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnNraXBTdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3lMb2dnZXIuaW5mbyhgUmV0cnkgJHtyZXRyeUNvdW50fTogU2tpcHBlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHN0cmF0ZWdpZXNMb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JUb1Rocm93LCByZXRyeUFmdGVySW5NcywgcmVkaXJlY3RUbyB9ID0gbW9kaWZpZXJzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JUb1Rocm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJhdGVneUxvZ2dlci5lcnJvcihgUmV0cnkgJHtyZXRyeUNvdW50fTogUmV0cnkgc3RyYXRlZ3kgJHtzdHJhdGVneS5uYW1lfSB0aHJvd3MgZXJyb3I6YCwgZXJyb3JUb1Rocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yVG9UaHJvdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlBZnRlckluTXMgfHwgcmV0cnlBZnRlckluTXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5TG9nZ2VyLmluZm8oYFJldHJ5ICR7cmV0cnlDb3VudH06IFJldHJ5IHN0cmF0ZWd5ICR7c3RyYXRlZ3kubmFtZX0gcmV0cmllcyBhZnRlciAke3JldHJ5QWZ0ZXJJbk1zfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkocmV0cnlBZnRlckluTXMsIHVuZGVmaW5lZCwgeyBhYm9ydFNpZ25hbDogcmVxdWVzdC5hYm9ydFNpZ25hbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHJldHJ5UmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3lMb2dnZXIuaW5mbyhgUmV0cnkgJHtyZXRyeUNvdW50fTogUmV0cnkgc3RyYXRlZ3kgJHtzdHJhdGVneS5uYW1lfSByZWRpcmVjdHMgdG8gJHtyZWRpcmVjdFRvfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC51cmwgPSByZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcmV0cnlSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBOb25lIG9mIHRoZSByZXRyeSBzdHJhdGVnaWVzIGNvdWxkIHdvcmsgd2l0aCB0aGUgcmVjZWl2ZWQgZXJyb3IuIFRocm93aW5nIGl0LmApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZUVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYE5vbmUgb2YgdGhlIHJldHJ5IHN0cmF0ZWdpZXMgY291bGQgd29yayB3aXRoIHRoZSByZWNlaXZlZCByZXNwb25zZS4gUmV0dXJuaW5nIGl0LmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGFsbCB0aGUgcmV0cmllcyBza2lwIGFuZCB0aGVyZSdzIG5vIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHN0aWxsIGluIHRoZSByZXRyeSBsb29wLCBzbyBhIG5ldyByZXF1ZXN0IHdpbGwgYmUgc2VudFxuICAgICAgICAgICAgICAgIC8vIHVudGlsIGBtYXhSZXRyaWVzYCBpcyByZWFjaGVkLlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8qKlxuICogVGhlIHByb2dyYW1tYXRpYyBpZGVudGlmaWVyIG9mIHRoZSBzZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3kuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3lOYW1lID0gXCJzZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3lcIjtcbi8qKlxuICogRWFjaCBQaXBlbGluZVJlcXVlc3QgZ2V0cyBhIHVuaXF1ZSBpZCB1cG9uIGNyZWF0aW9uLlxuICogVGhpcyBwb2xpY3kgcGFzc2VzIHRoYXQgdW5pcXVlIGlkIGFsb25nIHZpYSBhbiBIVFRQIGhlYWRlciB0byBlbmFibGUgYmV0dGVyXG4gKiB0ZWxlbWV0cnkgYW5kIHRyYWNpbmcuXG4gKiBAcGFyYW0gcmVxdWVzdElkSGVhZGVyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBoZWFkZXIgdG8gcGFzcyB0aGUgcmVxdWVzdCBJRCB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENsaWVudFJlcXVlc3RJZFBvbGljeShyZXF1ZXN0SWRIZWFkZXJOYW1lID0gXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3lOYW1lLFxuICAgICAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5oYXMocmVxdWVzdElkSGVhZGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KHJlcXVlc3RJZEhlYWRlck5hbWUsIHJlcXVlc3QucmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0KHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRDbGllbnRSZXF1ZXN0SWRQb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIE5hbWUgb2YgdGhlIFRMUyBQb2xpY3lcbiAqL1xuZXhwb3J0IGNvbnN0IHRsc1BvbGljeU5hbWUgPSBcInRsc1BvbGljeVwiO1xuLyoqXG4gKiBHZXRzIGEgcGlwZWxpbmUgcG9saWN5IHRoYXQgYWRkcyB0aGUgY2xpZW50IGNlcnRpZmljYXRlIHRvIHRoZSBIdHRwQ2xpZW50IGFnZW50IGZvciBhdXRoZW50aWNhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRsc1BvbGljeSh0bHNTZXR0aW5ncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRsc1BvbGljeU5hbWUsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiBhc3luYyAocmVxLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICAvLyBVc2VycyBtYXkgZGVmaW5lIGEgcmVxdWVzdCB0bHNTZXR0aW5ncywgaG9ub3IgdGhvc2Ugb3ZlciB0aGUgY2xpZW50IGxldmVsIG9uZVxuICAgICAgICAgICAgaWYgKCFyZXEudGxzU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICByZXEudGxzU2V0dGluZ3MgPSB0bHNTZXR0aW5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0KHJlcSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRsc1BvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZVRyYWNpbmdDbGllbnQsIH0gZnJvbSBcIkBhenVyZS9jb3JlLXRyYWNpbmdcIjtcbmltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50VmFsdWUgfSBmcm9tIFwiLi4vdXRpbC91c2VyQWdlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNFcnJvciB9IGZyb20gXCJAYXp1cmUvY29yZS11dGlsXCI7XG5pbXBvcnQgeyBpc1Jlc3RFcnJvciB9IGZyb20gXCIuLi9yZXN0RXJyb3JcIjtcbi8qKlxuICogVGhlIHByb2dyYW1tYXRpYyBpZGVudGlmaWVyIG9mIHRoZSB0cmFjaW5nUG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgdHJhY2luZ1BvbGljeU5hbWUgPSBcInRyYWNpbmdQb2xpY3lcIjtcbi8qKlxuICogQSBzaW1wbGUgcG9saWN5IHRvIGNyZWF0ZSBPcGVuVGVsZW1ldHJ5IFNwYW5zIGZvciBlYWNoIHJlcXVlc3QgbWFkZSBieSB0aGUgcGlwZWxpbmVcbiAqIHRoYXQgaGFzIFNwYW5PcHRpb25zIHdpdGggYSBwYXJlbnQuXG4gKiBSZXF1ZXN0cyBtYWRlIHdpdGhvdXQgYSBwYXJlbnQgU3BhbiB3aWxsIG5vdCBiZSByZWNvcmRlZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHRlbGVtZXRyeSBsb2dnZWQgYnkgdGhlIHRyYWNpbmcgcG9saWN5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhY2luZ1BvbGljeShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnRWYWx1ZShvcHRpb25zLnVzZXJBZ2VudFByZWZpeCk7XG4gICAgY29uc3QgdHJhY2luZ0NsaWVudCA9IHRyeUNyZWF0ZVRyYWNpbmdDbGllbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0cmFjaW5nUG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghdHJhY2luZ0NsaWVudCB8fCAhKChfYSA9IHJlcXVlc3QudHJhY2luZ09wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFjaW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc3BhbiwgdHJhY2luZ0NvbnRleHQgfSA9IChfYiA9IHRyeUNyZWF0ZVNwYW4odHJhY2luZ0NsaWVudCwgcmVxdWVzdCwgdXNlckFnZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgICAgICBpZiAoIXNwYW4gfHwgIXRyYWNpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhY2luZ0NsaWVudC53aXRoQ29udGV4dCh0cmFjaW5nQ29udGV4dCwgbmV4dCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdHJ5UHJvY2Vzc1Jlc3BvbnNlKHNwYW4sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdHJ5UHJvY2Vzc0Vycm9yKHNwYW4sIGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB0cnlDcmVhdGVUcmFjaW5nQ2xpZW50KCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFjaW5nQ2xpZW50KHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogXCJcIixcbiAgICAgICAgICAgIHBhY2thZ2VOYW1lOiBcIkBhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmVcIixcbiAgICAgICAgICAgIHBhY2thZ2VWZXJzaW9uOiBTREtfVkVSU0lPTixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuaW5nKGBFcnJvciB3aGVuIGNyZWF0aW5nIHRoZSBUcmFjaW5nQ2xpZW50OiAke2dldEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDcmVhdGVTcGFuKHRyYWNpbmdDbGllbnQsIHJlcXVlc3QsIHVzZXJBZ2VudCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEFzIHBlciBzcGVjLCB3ZSBkbyBub3QgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gSFRUUCBhbmQgSFRUUFMgaW4gc3BhbiBuYW1lLlxuICAgICAgICBjb25zdCB7IHNwYW4sIHVwZGF0ZWRPcHRpb25zIH0gPSB0cmFjaW5nQ2xpZW50LnN0YXJ0U3BhbihgSFRUUCAke3JlcXVlc3QubWV0aG9kfWAsIHsgdHJhY2luZ09wdGlvbnM6IHJlcXVlc3QudHJhY2luZ09wdGlvbnMgfSwge1xuICAgICAgICAgICAgc3BhbktpbmQ6IFwiY2xpZW50XCIsXG4gICAgICAgICAgICBzcGFuQXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFwiaHR0cC5tZXRob2RcIjogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgXCJodHRwLnVybFwiOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucmVxdWVzdElkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZSBzcGFuIGlzIG5vdCByZWNvcmRpbmcsIGRvbid0IGRvIGFueSBtb3JlIHdvcmsuXG4gICAgICAgIGlmICghc3Bhbi5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckFnZW50KSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImh0dHAudXNlcl9hZ2VudFwiLCB1c2VyQWdlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBoZWFkZXJzXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0cmFjaW5nQ2xpZW50LmNyZWF0ZVJlcXVlc3RIZWFkZXJzKHVwZGF0ZWRPcHRpb25zLnRyYWNpbmdPcHRpb25zLnRyYWNpbmdDb250ZXh0KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3BhbiwgdHJhY2luZ0NvbnRleHQ6IHVwZGF0ZWRPcHRpb25zLnRyYWNpbmdPcHRpb25zLnRyYWNpbmdDb250ZXh0IH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuaW5nKGBTa2lwcGluZyBjcmVhdGluZyBhIHRyYWNpbmcgc3BhbiBkdWUgdG8gYW4gZXJyb3I6ICR7Z2V0RXJyb3JNZXNzYWdlKGUpfWApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeVByb2Nlc3NFcnJvcihzcGFuLCBlcnJvcikge1xuICAgIHRyeSB7XG4gICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgZXJyb3I6IGlzRXJyb3IoZXJyb3IpID8gZXJyb3IgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNSZXN0RXJyb3IoZXJyb3IpICYmIGVycm9yLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiaHR0cC5zdGF0dXNfY29kZVwiLCBlcnJvci5zdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmVuZCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybmluZyhgU2tpcHBpbmcgdHJhY2luZyBzcGFuIHByb2Nlc3NpbmcgZHVlIHRvIGFuIGVycm9yOiAke2dldEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlQcm9jZXNzUmVzcG9uc2Uoc3BhbiwgcmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImh0dHAuc3RhdHVzX2NvZGVcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgY29uc3Qgc2VydmljZVJlcXVlc3RJZCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tcy1yZXF1ZXN0LWlkXCIpO1xuICAgICAgICBpZiAoc2VydmljZVJlcXVlc3RJZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJzZXJ2aWNlUmVxdWVzdElkXCIsIHNlcnZpY2VSZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybmluZyhgU2tpcHBpbmcgdHJhY2luZyBzcGFuIHByb2Nlc3NpbmcgZHVlIHRvIGFuIGVycm9yOiAke2dldEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjaW5nUG9saWN5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZ2V0VXNlckFnZW50SGVhZGVyTmFtZSwgZ2V0VXNlckFnZW50VmFsdWUgfSBmcm9tIFwiLi4vdXRpbC91c2VyQWdlbnRcIjtcbmNvbnN0IFVzZXJBZ2VudEhlYWRlck5hbWUgPSBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCk7XG4vKipcbiAqIFRoZSBwcm9ncmFtbWF0aWMgaWRlbnRpZmllciBvZiB0aGUgdXNlckFnZW50UG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgdXNlckFnZW50UG9saWN5TmFtZSA9IFwidXNlckFnZW50UG9saWN5XCI7XG4vKipcbiAqIEEgcG9saWN5IHRoYXQgc2V0cyB0aGUgVXNlci1BZ2VudCBoZWFkZXIgKG9yIGVxdWl2YWxlbnQpIHRvIHJlZmxlY3RcbiAqIHRoZSBsaWJyYXJ5IHZlcnNpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY3VzdG9taXplIHRoZSB1c2VyIGFnZW50IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlckFnZW50UG9saWN5KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVzZXJBZ2VudFZhbHVlID0gZ2V0VXNlckFnZW50VmFsdWUob3B0aW9ucy51c2VyQWdlbnRQcmVmaXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHVzZXJBZ2VudFBvbGljeU5hbWUsXG4gICAgICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG5leHQpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdC5oZWFkZXJzLmhhcyhVc2VyQWdlbnRIZWFkZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoVXNlckFnZW50SGVhZGVyTmFtZSwgdXNlckFnZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQocmVxdWVzdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZXJBZ2VudFBvbGljeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiQGF6dXJlL2NvcmUtdXRpbFwiO1xuaW1wb3J0IHsgY3VzdG9tIH0gZnJvbSBcIi4vdXRpbC9pbnNwZWN0XCI7XG5pbXBvcnQgeyBTYW5pdGl6ZXIgfSBmcm9tIFwiLi91dGlsL3Nhbml0aXplclwiO1xuY29uc3QgZXJyb3JTYW5pdGl6ZXIgPSBuZXcgU2FuaXRpemVyKCk7XG4vKipcbiAqIEEgY3VzdG9tIGVycm9yIHR5cGUgZm9yIGZhaWxlZCBwaXBlbGluZSByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVzdEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGlvbnMuY29kZTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmVzdEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ2dpbmcgbWV0aG9kIGZvciB1dGlsLmluc3BlY3QgaW4gTm9kZVxuICAgICAqL1xuICAgIFtjdXN0b21dKCkge1xuICAgICAgICByZXR1cm4gYFJlc3RFcnJvcjogJHt0aGlzLm1lc3NhZ2V9IFxcbiAke2Vycm9yU2FuaXRpemVyLnNhbml0aXplKHRoaXMpfWA7XG4gICAgfVxufVxuLyoqXG4gKiBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC5cbiAqIFRoaXMgbWVhbnMgdGhlIGFjdHVhbCByZXF1ZXN0IGZhaWxlZCBmb3Igc29tZSByZWFzb24sXG4gKiBzdWNoIGFzIGEgRE5TIGlzc3VlIG9yIHRoZSBjb25uZWN0aW9uIGJlaW5nIGxvc3QuXG4gKi9cblJlc3RFcnJvci5SRVFVRVNUX1NFTkRfRVJST1IgPSBcIlJFUVVFU1RfU0VORF9FUlJPUlwiO1xuLyoqXG4gKiBUaGlzIG1lYW5zIHRoYXQgcGFyc2luZyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGZhaWxlZC5cbiAqIEl0IG1heSBoYXZlIGJlZW4gbWFsZm9ybWVkLlxuICovXG5SZXN0RXJyb3IuUEFSU0VfRVJST1IgPSBcIlBBUlNFX0VSUk9SXCI7XG4vKipcbiAqIFR5cGVndWFyZCBmb3IgUmVzdEVycm9yXG4gKiBAcGFyYW0gZSAtIFNvbWV0aGluZyBjYXVnaHQgYnkgYSBjYXRjaCBjbGF1c2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc3RFcnJvcihlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBSZXN0RXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0Vycm9yKGUpICYmIGUubmFtZSA9PT0gXCJSZXN0RXJyb3JcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3RFcnJvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGdldFJhbmRvbUludGVnZXJJbmNsdXNpdmUgfSBmcm9tIFwiQGF6dXJlL2NvcmUtdXRpbFwiO1xuaW1wb3J0IHsgaXNUaHJvdHRsaW5nUmV0cnlSZXNwb25zZSB9IGZyb20gXCIuL3Rocm90dGxpbmdSZXRyeVN0cmF0ZWd5XCI7XG4vLyBpbnRlcnZhbHMgYXJlIGluIG1pbGxpc2Vjb25kc1xuY29uc3QgREVGQVVMVF9DTElFTlRfUkVUUllfSU5URVJWQUwgPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DTElFTlRfTUFYX1JFVFJZX0lOVEVSVkFMID0gMTAwMCAqIDY0O1xuLyoqXG4gKiBBIHJldHJ5IHN0cmF0ZWd5IHRoYXQgcmV0cmllcyB3aXRoIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyBkZWxheSBpbiB0aGVzZSB0d28gY2FzZXM6XG4gKiAtIFdoZW4gdGhlcmUgYXJlIGVycm9ycyBpbiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgbGF5ZXIgKGUuZy4gRE5TIGxvb2t1cCBmYWlsdXJlcykuXG4gKiAtIE9yIG90aGVyd2lzZSBpZiB0aGUgb3V0Z29pbmcgcmVxdWVzdCBmYWlscyAoNDA4LCBncmVhdGVyIG9yIGVxdWFsIHRoYW4gNTAwLCBleGNlcHQgZm9yIDUwMSBhbmQgNTA1KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9uZW50aWFsUmV0cnlTdHJhdGVneShvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAoX2EgPSBvcHRpb25zLnJldHJ5RGVsYXlJbk1zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX0NMSUVOVF9SRVRSWV9JTlRFUlZBTDtcbiAgICBjb25zdCBtYXhSZXRyeUludGVydmFsID0gKF9iID0gb3B0aW9ucy5tYXhSZXRyeURlbGF5SW5NcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9DTElFTlRfTUFYX1JFVFJZX0lOVEVSVkFMO1xuICAgIGxldCByZXRyeUFmdGVySW5NcyA9IHJldHJ5SW50ZXJ2YWw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJleHBvbmVudGlhbFJldHJ5U3RyYXRlZ3lcIixcbiAgICAgICAgcmV0cnkoeyByZXRyeUNvdW50LCByZXNwb25zZSwgcmVzcG9uc2VFcnJvciB9KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkU3lzdGVtRXJyb3IgPSBpc1N5c3RlbUVycm9yKHJlc3BvbnNlRXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgaWdub3JlU3lzdGVtRXJyb3JzID0gbWF0Y2hlZFN5c3RlbUVycm9yICYmIG9wdGlvbnMuaWdub3JlU3lzdGVtRXJyb3JzO1xuICAgICAgICAgICAgY29uc3QgaXNFeHBvbmVudGlhbCA9IGlzRXhwb25lbnRpYWxSZXRyeVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUV4cG9uZW50aWFsUmVzcG9uc2UgPSBpc0V4cG9uZW50aWFsICYmIG9wdGlvbnMuaWdub3JlSHR0cFN0YXR1c0NvZGVzO1xuICAgICAgICAgICAgY29uc3QgdW5rbm93blJlc3BvbnNlID0gcmVzcG9uc2UgJiYgKGlzVGhyb3R0bGluZ1JldHJ5UmVzcG9uc2UocmVzcG9uc2UpIHx8ICFpc0V4cG9uZW50aWFsKTtcbiAgICAgICAgICAgIGlmICh1bmtub3duUmVzcG9uc2UgfHwgaWdub3JlRXhwb25lbnRpYWxSZXNwb25zZSB8fCBpZ25vcmVTeXN0ZW1FcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBza2lwU3RyYXRlZ3k6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZUVycm9yICYmICFtYXRjaGVkU3lzdGVtRXJyb3IgJiYgIWlzRXhwb25lbnRpYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvclRvVGhyb3c6IHJlc3BvbnNlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGhlIGRlbGF5IGVhY2ggdGltZVxuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWxheSA9IHJldHJ5QWZ0ZXJJbk1zICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gICAgICAgICAgICAvLyBEb24ndCBsZXQgdGhlIGRlbGF5IGV4Y2VlZCB0aGUgbWF4aW11bVxuICAgICAgICAgICAgY29uc3QgY2xhbXBlZEV4cG9uZW50aWFsRGVsYXkgPSBNYXRoLm1pbihtYXhSZXRyeUludGVydmFsLCBleHBvbmVudGlhbERlbGF5KTtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBmaW5hbCB2YWx1ZSB0byBoYXZlIHNvbWUgXCJqaXR0ZXJcIiAod2l0aGluIDUwJSBvZiB0aGUgZGVsYXkgc2l6ZSkgc29cbiAgICAgICAgICAgIC8vIHRoYXQgcmV0cmllcyBhY3Jvc3MgbXVsdGlwbGUgY2xpZW50cyBkb24ndCBvY2N1ciBzaW11bHRhbmVvdXNseS5cbiAgICAgICAgICAgIHJldHJ5QWZ0ZXJJbk1zID1cbiAgICAgICAgICAgICAgICBjbGFtcGVkRXhwb25lbnRpYWxEZWxheSAvIDIgKyBnZXRSYW5kb21JbnRlZ2VySW5jbHVzaXZlKDAsIGNsYW1wZWRFeHBvbmVudGlhbERlbGF5IC8gMik7XG4gICAgICAgICAgICByZXR1cm4geyByZXRyeUFmdGVySW5NcyB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEEgcmVzcG9uc2UgaXMgYSByZXRyeSByZXNwb25zZSBpZiBpdCBoYXMgc3RhdHVzIGNvZGVzOlxuICogLSA0MDgsIG9yXG4gKiAtIEdyZWF0ZXIgb3IgZXF1YWwgdGhhbiA1MDAsIGV4Y2VwdCBmb3IgNTAxIGFuZCA1MDUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0V4cG9uZW50aWFsUmV0cnlSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBCb29sZWFuKHJlc3BvbnNlICYmXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA4KSAmJlxuICAgICAgICByZXNwb25zZS5zdGF0dXMgIT09IDUwMSAmJlxuICAgICAgICByZXNwb25zZS5zdGF0dXMgIT09IDUwNSk7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBlcnJvciBmcm9tIGEgcGlwZWxpbmUgcmVzcG9uc2Ugd2FzIHRyaWdnZXJlZCBpbiB0aGUgbmV0d29yayBsYXllci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3lzdGVtRXJyb3IoZXJyKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGVyci5jb2RlID09PSBcIkVUSU1FRE9VVFwiIHx8XG4gICAgICAgIGVyci5jb2RlID09PSBcIkVTT0NLRVRUSU1FRE9VVFwiIHx8XG4gICAgICAgIGVyci5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiIHx8XG4gICAgICAgIGVyci5jb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fFxuICAgICAgICBlcnIuY29kZSA9PT0gXCJFTk9FTlRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBwYXJzZUhlYWRlclZhbHVlQXNOdW1iZXIgfSBmcm9tIFwiLi4vdXRpbC9oZWxwZXJzXCI7XG4vKipcbiAqIFRoZSBoZWFkZXIgdGhhdCBjb21lcyBiYWNrIGZyb20gQXp1cmUgc2VydmljZXMgcmVwcmVzZW50aW5nXG4gKiB0aGUgYW1vdW50IG9mIHRpbWUgKG1pbmltdW0pIHRvIHdhaXQgdG8gcmV0cnkgKGluIHNlY29uZHMgb3IgdGltZXN0YW1wIGFmdGVyIHdoaWNoIHdlIGNhbiByZXRyeSkuXG4gKi9cbmNvbnN0IFJldHJ5QWZ0ZXJIZWFkZXIgPSBcIlJldHJ5LUFmdGVyXCI7XG4vKipcbiAqIFRoZSBoZWFkZXJzIHRoYXQgY29tZSBiYWNrIGZyb20gQXp1cmUgc2VydmljZXMgcmVwcmVzZW50aW5nXG4gKiB0aGUgYW1vdW50IG9mIHRpbWUgKG1pbmltdW0pIHRvIHdhaXQgdG8gcmV0cnkuXG4gKlxuICogXCJyZXRyeS1hZnRlci1tc1wiLCBcIngtbXMtcmV0cnktYWZ0ZXItbXNcIiA6IG1pbGxpc2Vjb25kc1xuICogXCJSZXRyeS1BZnRlclwiIDogc2Vjb25kcyBvciB0aW1lc3RhbXBcbiAqL1xuY29uc3QgQWxsUmV0cnlBZnRlckhlYWRlcnMgPSBbXCJyZXRyeS1hZnRlci1tc1wiLCBcIngtbXMtcmV0cnktYWZ0ZXItbXNcIiwgUmV0cnlBZnRlckhlYWRlcl07XG4vKipcbiAqIEEgcmVzcG9uc2UgaXMgYSB0aHJvdHRsaW5nIHJldHJ5IHJlc3BvbnNlIGlmIGl0IGhhcyBhIHRocm90dGxpbmcgc3RhdHVzIGNvZGUgKDQyOSBvciA1MDMpLFxuICogYXMgbG9uZyBhcyBvbmUgb2YgdGhlIFsgXCJSZXRyeS1BZnRlclwiIG9yIFwicmV0cnktYWZ0ZXItbXNcIiBvciBcIngtbXMtcmV0cnktYWZ0ZXItbXNcIiBdIGhlYWRlcnMgaGFzIGEgdmFsaWQgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0aGUgYHJldHJ5QWZ0ZXJJbk1zYCB2YWx1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgYSB0aHJvdHRsaW5nIHJldHJ5IHJlc3BvbnNlLlxuICogSWYgbm90IHRocm90dGxpbmcgcmV0cnkgcmVzcG9uc2UsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJldHJ5QWZ0ZXJJbk1zKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgJiYgWzQyOSwgNTAzXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgICAvLyBIZWFkZXJzOiBcInJldHJ5LWFmdGVyLW1zXCIsIFwieC1tcy1yZXRyeS1hZnRlci1tc1wiLCBcIlJldHJ5LUFmdGVyXCJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgQWxsUmV0cnlBZnRlckhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJWYWx1ZSA9IHBhcnNlSGVhZGVyVmFsdWVBc051bWJlcihyZXNwb25zZSwgaGVhZGVyKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyVmFsdWUgPT09IDAgfHwgcmV0cnlBZnRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gXCJSZXRyeS1BZnRlclwiIGhlYWRlciA9PT4gc2Vjb25kc1xuICAgICAgICAgICAgICAgIC8vIFwicmV0cnktYWZ0ZXItbXNcIiwgXCJ4LW1zLXJldHJ5LWFmdGVyLW1zXCIgaGVhZGVycyA9PT4gbWlsbGktc2Vjb25kc1xuICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpcGx5aW5nRmFjdG9yID0gaGVhZGVyID09PSBSZXRyeUFmdGVySGVhZGVyID8gMTAwMCA6IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5QWZ0ZXJWYWx1ZSAqIG11bHRpcGx5aW5nRmFjdG9yOyAvLyBpbiBtaWxsaS1zZWNvbmRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0cnlBZnRlckhlYWRlciAoXCJSZXRyeS1BZnRlclwiKSBoYXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgaXQgbWlnaHQgYmUgZm9ybWF0dGVkIGFzIGEgZGF0ZSBpbnN0ZWFkIG9mIGEgbnVtYmVyIG9mIHNlY29uZHNcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgICBpZiAoIXJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGRhdGUgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgICBjb25zdCBkaWZmID0gZGF0ZSAtIERhdGUubm93KCk7XG4gICAgICAgIC8vIG5lZ2F0aXZlIGRpZmYgd291bGQgbWVhbiBhIGRhdGUgaW4gdGhlIHBhc3QsIHNvIHJldHJ5IGFzYXAgd2l0aCAwIG1pbGxpc2Vjb25kc1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGRpZmYpID8gTWF0aC5tYXgoMCwgZGlmZikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJlc3BvbnNlIGlzIGEgcmV0cnkgcmVzcG9uc2UgaWYgaXQgaGFzIGEgdGhyb3R0bGluZyBzdGF0dXMgY29kZSAoNDI5IG9yIDUwMyksXG4gKiBhcyBsb25nIGFzIG9uZSBvZiB0aGUgWyBcIlJldHJ5LUFmdGVyXCIgb3IgXCJyZXRyeS1hZnRlci1tc1wiIG9yIFwieC1tcy1yZXRyeS1hZnRlci1tc1wiIF0gaGVhZGVycyBoYXMgYSB2YWxpZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGhyb3R0bGluZ1JldHJ5UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGdldFJldHJ5QWZ0ZXJJbk1zKHJlc3BvbnNlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGluZ1JldHJ5U3RyYXRlZ3koKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogXCJ0aHJvdHRsaW5nUmV0cnlTdHJhdGVneVwiLFxuICAgICAgICByZXRyeSh7IHJlc3BvbnNlIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJJbk1zID0gZ2V0UmV0cnlBZnRlckluTXMocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmV0cnlBZnRlckluTXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2tpcFN0cmF0ZWd5OiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJldHJ5QWZ0ZXJJbk1zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGluZ1JldHJ5U3RyYXRlZ3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSBcIkBhenVyZS9hYm9ydC1jb250cm9sbGVyXCI7XG5jb25zdCBTdGFuZGFyZEFib3J0TWVzc2FnZSA9IFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIjtcbi8qKlxuICogQSB3cmFwcGVyIGZvciBzZXRUaW1lb3V0IHRoYXQgcmVzb2x2ZXMgYSBwcm9taXNlIGFmdGVyIGRlbGF5SW5NcyBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0gZGVsYXlJbk1zIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYmUgZGVsYXllZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSByZXNvbHZlZCB3aXRoIGFmdGVyIGEgdGltZW91dCBvZiB0IG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGRlbGF5IC0gY3VycmVudGx5IGFib3J0IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgLSBhYm9ydFNpZ25hbCAtIFRoZSBhYm9ydFNpZ25hbCBhc3NvY2lhdGVkIHdpdGggY29udGFpbmluZyBvcGVyYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgIC0gYWJvcnRFcnJvck1zZyAtIFRoZSBhYm9ydCBlcnJvciBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCBjb250YWluaW5nIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIFJlc29sdmVkIHByb21pc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5NcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgdGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBvbkFib3J0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlamVjdE9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBBYm9ydEVycm9yKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRFcnJvck1zZykgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRFcnJvck1zZyA6IFN0YW5kYXJkQWJvcnRNZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsKSAmJiBvbkFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvbkFib3J0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0T25BYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbCkgJiYgb3B0aW9ucy5hYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0T25BYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCBkZWxheUluTXMpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0ZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBpbnZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIZWFkZXJWYWx1ZUFzTnVtYmVyKHJlc3BvbnNlLCBoZWFkZXJOYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzLmdldChoZWFkZXJOYW1lKTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsdWVBc051bSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZUFzTnVtKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB2YWx1ZUFzTnVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tIFwidXRpbFwiO1xuZXhwb3J0IGNvbnN0IGN1c3RvbSA9IGluc3BlY3QuY3VzdG9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zcGVjdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIkBhenVyZS9jb3JlLXV0aWxcIjtcbmNvbnN0IFJlZGFjdGVkU3RyaW5nID0gXCJSRURBQ1RFRFwiO1xuLy8gTWFrZSBzdXJlIHRoaXMgbGlzdCBpcyB1cC10by1kYXRlIHdpdGggdGhlIG9uZSB1bmRlciBjb3JlL2xvZ2dlci9SZWFkbWUjS2V5Y29uY2VwdHNcbmNvbnN0IGRlZmF1bHRBbGxvd2VkSGVhZGVyTmFtZXMgPSBbXG4gICAgXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgXCJ4LW1zLXJldHVybi1jbGllbnQtcmVxdWVzdC1pZFwiLFxuICAgIFwieC1tcy11c2VyYWdlbnRcIixcbiAgICBcIngtbXMtY29ycmVsYXRpb24tcmVxdWVzdC1pZFwiLFxuICAgIFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgXCJjbGllbnQtcmVxdWVzdC1pZFwiLFxuICAgIFwibXMtY3ZcIixcbiAgICBcInJldHVybi1jbGllbnQtcmVxdWVzdC1pZFwiLFxuICAgIFwidHJhY2VwYXJlbnRcIixcbiAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIixcbiAgICBcIkFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcIixcbiAgICBcIkFjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kXCIsXG4gICAgXCJPcmlnaW5cIixcbiAgICBcIkFjY2VwdFwiLFxuICAgIFwiQWNjZXB0LUVuY29kaW5nXCIsXG4gICAgXCJDYWNoZS1Db250cm9sXCIsXG4gICAgXCJDb25uZWN0aW9uXCIsXG4gICAgXCJDb250ZW50LUxlbmd0aFwiLFxuICAgIFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJEYXRlXCIsXG4gICAgXCJFVGFnXCIsXG4gICAgXCJFeHBpcmVzXCIsXG4gICAgXCJJZi1NYXRjaFwiLFxuICAgIFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICBcIklmLU5vbmUtTWF0Y2hcIixcbiAgICBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICBcIlByYWdtYVwiLFxuICAgIFwiUmVxdWVzdC1JZFwiLFxuICAgIFwiUmV0cnktQWZ0ZXJcIixcbiAgICBcIlNlcnZlclwiLFxuICAgIFwiVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICBcIlVzZXItQWdlbnRcIixcbiAgICBcIldXVy1BdXRoZW50aWNhdGVcIixcbl07XG5jb25zdCBkZWZhdWx0QWxsb3dlZFF1ZXJ5UGFyYW1ldGVycyA9IFtcImFwaS12ZXJzaW9uXCJdO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFNhbml0aXplciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRpdGlvbmFsQWxsb3dlZEhlYWRlck5hbWVzOiBhbGxvd2VkSGVhZGVyTmFtZXMgPSBbXSwgYWRkaXRpb25hbEFsbG93ZWRRdWVyeVBhcmFtZXRlcnM6IGFsbG93ZWRRdWVyeVBhcmFtZXRlcnMgPSBbXSwgfSA9IHt9KSB7XG4gICAgICAgIGFsbG93ZWRIZWFkZXJOYW1lcyA9IGRlZmF1bHRBbGxvd2VkSGVhZGVyTmFtZXMuY29uY2F0KGFsbG93ZWRIZWFkZXJOYW1lcyk7XG4gICAgICAgIGFsbG93ZWRRdWVyeVBhcmFtZXRlcnMgPSBkZWZhdWx0QWxsb3dlZFF1ZXJ5UGFyYW1ldGVycy5jb25jYXQoYWxsb3dlZFF1ZXJ5UGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuYWxsb3dlZEhlYWRlck5hbWVzID0gbmV3IFNldChhbGxvd2VkSGVhZGVyTmFtZXMubWFwKChuKSA9PiBuLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgdGhpcy5hbGxvd2VkUXVlcnlQYXJhbWV0ZXJzID0gbmV3IFNldChhbGxvd2VkUXVlcnlQYXJhbWV0ZXJzLm1hcCgocCkgPT4gcC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfVxuICAgIHNhbml0aXplKG9iaikge1xuICAgICAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gRW5zdXJlIEVycm9ycyBpbmNsdWRlIHRoZWlyIGludGVyZXN0aW5nIG5vbi1lbnVtZXJhYmxlIG1lbWJlcnNcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7IG5hbWU6IHZhbHVlLm5hbWUsIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImhlYWRlcnNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplSGVhZGVycyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZVVybCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplUXVlcnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImJvZHlcIikge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGxvZyB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJyZXNwb25zZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgbG9nIHJlc3BvbnNlIGFnYWluXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJvcGVyYXRpb25TcGVjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIHNlbmRPcGVyYXRpb25SZXF1ZXN0LCB0aGUgcmVxdWVzdCBjYXJyaWVzIGEgbWFzc2l2ZVxuICAgICAgICAgICAgICAgIC8vIGZpZWxkIHdpdGggdGhlIGF1dG9yZXN0IHNwZWMuIE5vIG5lZWQgdG8gbG9nIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCAyKTtcbiAgICB9XG4gICAgc2FuaXRpemVIZWFkZXJzKG9iaikge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dlZEhlYWRlck5hbWVzLmhhcyhrZXkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FuaXRpemVkW2tleV0gPSBSZWRhY3RlZFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FuaXRpemVkO1xuICAgIH1cbiAgICBzYW5pdGl6ZVF1ZXJ5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW5pdGl6ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dlZFF1ZXJ5UGFyYW1ldGVycy5oYXMoay50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHNhbml0aXplZFtrXSA9IHZhbHVlW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FuaXRpemVkW2tdID0gUmVkYWN0ZWRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbml0aXplZDtcbiAgICB9XG4gICAgc2FuaXRpemVVcmwodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodmFsdWUpO1xuICAgICAgICBpZiAoIXVybC5zZWFyY2gpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHVybC5zZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd2VkUXVlcnlQYXJhbWV0ZXJzLmhhcyhrZXkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIFJlZGFjdGVkU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FuaXRpemVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZGVsYXkgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjeWNsZXIgaWYgbm9uZSBhcmUgcHJvdmlkZWRcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NZQ0xFUl9PUFRJT05TID0ge1xuICAgIGZvcmNlZFJlZnJlc2hXaW5kb3dJbk1zOiAxMDAwLFxuICAgIHJldHJ5SW50ZXJ2YWxJbk1zOiAzMDAwLFxuICAgIHJlZnJlc2hXaW5kb3dJbk1zOiAxMDAwICogNjAgKiAyLCAvLyBTdGFydCByZWZyZXNoaW5nIDJtIGJlZm9yZSBleHBpcnlcbn07XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuIHVucmVsaWFibGUgYWNjZXNzIHRva2VuIGdldHRlciAod2hpY2ggbWF5IHJlc29sdmUgd2l0aCBudWxsKVxuICogaW50byBhbiBBY2Nlc3NUb2tlbkdldHRlciBieSByZXRyeWluZyB0aGUgdW5yZWxpYWJsZSBnZXR0ZXIgaW4gYSByZWd1bGFyXG4gKiBpbnRlcnZhbC5cbiAqXG4gKiBAcGFyYW0gZ2V0QWNjZXNzVG9rZW4gLSBBIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYSBwcm9taXNlIG9mIGFuIGFjY2VzcyB0b2tlbiB0aGF0IG1heSBmYWlsIGJ5IHJldHVybmluZyBudWxsLlxuICogQHBhcmFtIHJldHJ5SW50ZXJ2YWxJbk1zIC0gVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBiZXR3ZWVuIHJldHJ5IGF0dGVtcHRzLlxuICogQHBhcmFtIHJlZnJlc2hUaW1lb3V0IC0gVGhlIHRpbWVzdGFtcCBhZnRlciB3aGljaCB0aGUgcmVmcmVzaCBhdHRlbXB0IHdpbGwgZmFpbCwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCwgaWYgaXQgcmVzb2x2ZXMsIHdpbGwgcmVzb2x2ZSB3aXRoIGFuIGFjY2VzcyB0b2tlbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYmVnaW5SZWZyZXNoKGdldEFjY2Vzc1Rva2VuLCByZXRyeUludGVydmFsSW5NcywgcmVmcmVzaFRpbWVvdXQpIHtcbiAgICAvLyBUaGlzIHdyYXBwZXIgaGFuZGxlcyBleGNlcHRpb25zIGdyYWNlZnVsbHkgYXMgbG9uZyBhcyB3ZSBoYXZlbid0IGV4Y2VlZGVkXG4gICAgLy8gdGhlIHRpbWVvdXQuXG4gICAgYXN5bmMgZnVuY3Rpb24gdHJ5R2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIDwgcmVmcmVzaFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgLy8gVGltZW91dCBpcyB1cCwgc28gdGhyb3cgaWYgaXQncyBzdGlsbCBudWxsXG4gICAgICAgICAgICBpZiAoZmluYWxUb2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWZyZXNoIGFjY2VzcyB0b2tlbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluYWxUb2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdG9rZW4gPSBhd2FpdCB0cnlHZXRBY2Nlc3NUb2tlbigpO1xuICAgIHdoaWxlICh0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBkZWxheShyZXRyeUludGVydmFsSW5Ncyk7XG4gICAgICAgIHRva2VuID0gYXdhaXQgdHJ5R2V0QWNjZXNzVG9rZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdG9rZW4gY3ljbGVyIGZyb20gYSBjcmVkZW50aWFsLCBzY29wZXMsIGFuZCBvcHRpb25hbCBzZXR0aW5ncy5cbiAqXG4gKiBBIHRva2VuIGN5Y2xlciByZXByZXNlbnRzIGEgd2F5IHRvIHJlbGlhYmx5IHJldHJpZXZlIGEgdmFsaWQgYWNjZXNzIHRva2VuXG4gKiBmcm9tIGEgVG9rZW5DcmVkZW50aWFsLiBJdCB3aWxsIGhhbmRsZSBpbml0aWFsaXppbmcgdGhlIHRva2VuLCByZWZyZXNoaW5nIGl0XG4gKiB3aGVuIGl0IG5lYXJzIGV4cGlyYXRpb24sIGFuZCBzeW5jaHJvbml6ZXMgcmVmcmVzaCBhdHRlbXB0cyB0byBhdm9pZFxuICogY29uY3VycmVuY3kgaGF6YXJkcy5cbiAqXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIHRoZSB1bmRlcmx5aW5nIFRva2VuQ3JlZGVudGlhbCB0aGF0IHByb3ZpZGVzIHRoZSBhY2Nlc3NcbiAqIHRva2VuXG4gKiBAcGFyYW0gdG9rZW5DeWNsZXJPcHRpb25zIC0gb3B0aW9uYWxseSBvdmVycmlkZSBkZWZhdWx0IHNldHRpbmdzIGZvciB0aGUgY3ljbGVyXG4gKlxuICogQHJldHVybnMgLSBhIGZ1bmN0aW9uIHRoYXQgcmVsaWFibHkgcHJvZHVjZXMgYSB2YWxpZCBhY2Nlc3MgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuQ3ljbGVyKGNyZWRlbnRpYWwsIHRva2VuQ3ljbGVyT3B0aW9ucykge1xuICAgIGxldCByZWZyZXNoV29ya2VyID0gbnVsbDtcbiAgICBsZXQgdG9rZW4gPSBudWxsO1xuICAgIGxldCB0ZW5hbnRJZDtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NZQ0xFUl9PUFRJT05TKSwgdG9rZW5DeWNsZXJPcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGxpdHRsZSBob2xkZXIgZGVmaW5lcyBzZXZlcmFsIHByZWRpY2F0ZXMgdGhhdCB3ZSB1c2UgdG8gY29uc3RydWN0XG4gICAgICogdGhlIHJ1bGVzIG9mIHJlZnJlc2hpbmcgdGhlIHRva2VuLlxuICAgICAqL1xuICAgIGNvbnN0IGN5Y2xlciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIHRydWUgaWYgYSByZWZyZXNoIGpvYiBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaXNSZWZyZXNoaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hXb3JrZXIgIT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyB0cnVlIGlmIHRoZSBjeWNsZXIgU0hPVUxEIHJlZnJlc2ggKHdlIGFyZSB3aXRoaW4gdGhlIHJlZnJlc2hcbiAgICAgICAgICogd2luZG93IGFuZCBub3QgYWxyZWFkeSByZWZyZXNoaW5nKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHNob3VsZFJlZnJlc2goKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKCFjeWNsZXIuaXNSZWZyZXNoaW5nICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b2tlbi5leHBpcmVzT25UaW1lc3RhbXApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC0gb3B0aW9ucy5yZWZyZXNoV2luZG93SW5NcyA8IERhdGUubm93KCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgdHJ1ZSBpZiB0aGUgY3ljbGVyIE1VU1QgcmVmcmVzaCAobnVsbCBvciBuZWFybHktZXhwaXJlZFxuICAgICAgICAgKiB0b2tlbikuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgbXVzdFJlZnJlc2goKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRva2VuID09PSBudWxsIHx8IHRva2VuLmV4cGlyZXNPblRpbWVzdGFtcCAtIG9wdGlvbnMuZm9yY2VkUmVmcmVzaFdpbmRvd0luTXMgPCBEYXRlLm5vdygpKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIHJlZnJlc2ggam9iIG9yIHJldHVybnMgdGhlIGV4aXN0aW5nIGpvYiBpZiBvbmUgaXMgYWxyZWFkeVxuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVmcmVzaChzY29wZXMsIGdldFRva2VuT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghY3ljbGVyLmlzUmVmcmVzaGluZykge1xuICAgICAgICAgICAgLy8gV2UgYmluZCBgc2NvcGVzYCBoZXJlIHRvIGF2b2lkIHBhc3NpbmcgaXQgYXJvdW5kIGEgbG90XG4gICAgICAgICAgICBjb25zdCB0cnlHZXRBY2Nlc3NUb2tlbiA9ICgpID0+IGNyZWRlbnRpYWwuZ2V0VG9rZW4oc2NvcGVzLCBnZXRUb2tlbk9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcHJvbWlzZSBjaGFpbmluZyB0byBpbnNlcnQgYW4gYXNzaWdubWVudCB0byBgdG9rZW5gXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIHJlZnJlc2ggY2FuIGJlIGNvbnNpZGVyZWQgZG9uZS5cbiAgICAgICAgICAgIHJlZnJlc2hXb3JrZXIgPSBiZWdpblJlZnJlc2godHJ5R2V0QWNjZXNzVG9rZW4sIG9wdGlvbnMucmV0cnlJbnRlcnZhbEluTXMsIFxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHRva2VuLCB0aGVuIHdlIHNob3VsZCB0aW1lb3V0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAoX2EgPSB0b2tlbiA9PT0gbnVsbCB8fCB0b2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9rZW4uZXhwaXJlc09uVGltZXN0YW1wKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlLm5vdygpKVxuICAgICAgICAgICAgICAgIC50aGVuKChfdG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICByZWZyZXNoV29ya2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IF90b2tlbjtcbiAgICAgICAgICAgICAgICB0ZW5hbnRJZCA9IGdldFRva2VuT3B0aW9ucy50ZW5hbnRJZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxzbyBzaG91bGQgcmVzZXQgdGhlIHJlZnJlc2hlciBpZiB3ZSBlbnRlciBhIGZhaWxlZCBzdGF0ZS4gIEFsbFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGF3YWl0ZXJzIHdpbGwgdGhyb3csIGJ1dCBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgc3RhcnQgYVxuICAgICAgICAgICAgICAgIC8vIG5ldyByZXRyeSBjaGFpbi5cbiAgICAgICAgICAgICAgICByZWZyZXNoV29ya2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGVuYW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZnJlc2hXb3JrZXI7XG4gICAgfVxuICAgIHJldHVybiBhc3luYyAoc2NvcGVzLCB0b2tlbk9wdGlvbnMpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2ltcGxlIHJ1bGVzOlxuICAgICAgICAvLyAtIElmIHdlIE1VU1QgcmVmcmVzaCwgdGhlbiByZXR1cm4gdGhlIHJlZnJlc2ggdGFzaywgYmxvY2tpbmdcbiAgICAgICAgLy8gICB0aGUgcGlwZWxpbmUgdW50aWwgYSB0b2tlbiBpcyBhdmFpbGFibGUuXG4gICAgICAgIC8vIC0gSWYgd2UgU0hPVUxEIHJlZnJlc2gsIHRoZW4gcnVuIHJlZnJlc2ggYnV0IGRvbid0IHJldHVybiBpdFxuICAgICAgICAvLyAgICh3ZSBjYW4gc3RpbGwgdXNlIHRoZSBjYWNoZWQgdG9rZW4pLlxuICAgICAgICAvLyAtIFJldHVybiB0aGUgdG9rZW4sIHNpbmNlIGl0J3MgZmluZSBpZiB3ZSBkaWRuJ3QgcmV0dXJuIGluXG4gICAgICAgIC8vICAgc3RlcCAxLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgdGVuYW50SWQgcGFzc2VkIGluIHRva2VuIG9wdGlvbnMgaXMgZGlmZmVyZW50IHRvIHRoZSBvbmUgd2UgaGF2ZVxuICAgICAgICAvLyBPciBpZiB3ZSBhcmUgaW4gY2xhaW0gY2hhbGxlbmdlIGFuZCB0aGUgdG9rZW4gd2FzIHJlamVjdGVkIGFuZCBhIG5ldyBhY2Nlc3MgdG9rZW4gbmVlZCB0byBiZSBpc3N1ZWQsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCB0aGUgbmV3IHRlbmFudElkIG9yIHRva2VuLlxuICAgICAgICBjb25zdCBtdXN0UmVmcmVzaCA9IHRlbmFudElkICE9PSB0b2tlbk9wdGlvbnMudGVuYW50SWQgfHwgQm9vbGVhbih0b2tlbk9wdGlvbnMuY2xhaW1zKSB8fCBjeWNsZXIubXVzdFJlZnJlc2g7XG4gICAgICAgIGlmIChtdXN0UmVmcmVzaClcbiAgICAgICAgICAgIHJldHVybiByZWZyZXNoKHNjb3BlcywgdG9rZW5PcHRpb25zKTtcbiAgICAgICAgaWYgKGN5Y2xlci5zaG91bGRSZWZyZXNoKSB7XG4gICAgICAgICAgICByZWZyZXNoKHNjb3BlcywgdG9rZW5PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuQ3ljbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZ2V0SGVhZGVyTmFtZSwgc2V0UGxhdGZvcm1TcGVjaWZpY0RhdGEgfSBmcm9tIFwiLi91c2VyQWdlbnRQbGF0Zm9ybVwiO1xuaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnRTdHJpbmcodGVsZW1ldHJ5SW5mbykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGVsZW1ldHJ5SW5mbykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHZhbHVlID8gYCR7a2V5fS8ke3ZhbHVlfWAgOiBrZXk7XG4gICAgICAgIHBhcnRzLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbihcIiBcIik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpIHtcbiAgICByZXR1cm4gZ2V0SGVhZGVyTmFtZSgpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudFZhbHVlKHByZWZpeCkge1xuICAgIGNvbnN0IHJ1bnRpbWVJbmZvID0gbmV3IE1hcCgpO1xuICAgIHJ1bnRpbWVJbmZvLnNldChcImNvcmUtcmVzdC1waXBlbGluZVwiLCBTREtfVkVSU0lPTik7XG4gICAgc2V0UGxhdGZvcm1TcGVjaWZpY0RhdGEocnVudGltZUluZm8pO1xuICAgIGNvbnN0IGRlZmF1bHRBZ2VudCA9IGdldFVzZXJBZ2VudFN0cmluZyhydW50aW1lSW5mbyk7XG4gICAgY29uc3QgdXNlckFnZW50VmFsdWUgPSBwcmVmaXggPyBgJHtwcmVmaXh9ICR7ZGVmYXVsdEFnZW50fWAgOiBkZWZhdWx0QWdlbnQ7XG4gICAgcmV0dXJuIHVzZXJBZ2VudFZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlckFnZW50LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVhZGVyTmFtZSgpIHtcbiAgICByZXR1cm4gXCJVc2VyLUFnZW50XCI7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UGxhdGZvcm1TcGVjaWZpY0RhdGEobWFwKSB7XG4gICAgbWFwLnNldChcIk5vZGVcIiwgcHJvY2Vzcy52ZXJzaW9uKTtcbiAgICBtYXAuc2V0KFwiT1NcIiwgYCgke29zLmFyY2goKX0tJHtvcy50eXBlKCl9LSR7b3MucmVsZWFzZSgpfSlgKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZXJBZ2VudFBsYXRmb3JtLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbi8qKlxuICogR2VuZXJhdGVkIFVuaXZlcnNhbGx5IFVuaXF1ZSBJZGVudGlmaWVyXG4gKlxuICogQHJldHVybnMgUkZDNDEyMiB2NCBVVUlELlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVV1aWQoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZVRyYWNpbmdDb250ZXh0IH0gZnJvbSBcIi4vdHJhY2luZ0NvbnRleHRcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0VHJhY2luZ1NwYW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGlzUmVjb3JkaW5nOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgcmVjb3JkRXhjZXB0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHJpYnV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9LFxuICAgICAgICBzZXRTdGF0dXM6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRJbnN0cnVtZW50ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlUmVxdWVzdEhlYWRlcnM6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VUcmFjZXBhcmVudEhlYWRlcjogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRTcGFuOiAoX25hbWUsIHNwYW5PcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYW46IGNyZWF0ZURlZmF1bHRUcmFjaW5nU3BhbigpLFxuICAgICAgICAgICAgICAgIHRyYWNpbmdDb250ZXh0OiBjcmVhdGVUcmFjaW5nQ29udGV4dCh7IHBhcmVudENvbnRleHQ6IHNwYW5PcHRpb25zLnRyYWNpbmdDb250ZXh0IH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd2l0aENvbnRleHQoX2NvbnRleHQsIGNhbGxiYWNrLCAuLi5jYWxsYmFja0FyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayguLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5sZXQgaW5zdHJ1bWVudGVySW1wbGVtZW50YXRpb247XG4vKipcbiAqIEV4dGVuZHMgdGhlIEF6dXJlIFNESyB3aXRoIHN1cHBvcnQgZm9yIGEgZ2l2ZW4gaW5zdHJ1bWVudGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSBpbnN0cnVtZW50ZXIgLSBUaGUgaW5zdHJ1bWVudGVyIGltcGxlbWVudGF0aW9uIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluc3RydW1lbnRlcihpbnN0cnVtZW50ZXIpIHtcbiAgICBpbnN0cnVtZW50ZXJJbXBsZW1lbnRhdGlvbiA9IGluc3RydW1lbnRlcjtcbn1cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudGx5IHNldCBpbnN0cnVtZW50ZXIsIGEgTm8tT3AgaW5zdHJ1bWVudGVyIGJ5IGRlZmF1bHQuXG4gKlxuICogQHJldHVybnMgVGhlIGN1cnJlbnRseSBzZXQgaW5zdHJ1bWVudGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnN0cnVtZW50ZXIoKSB7XG4gICAgaWYgKCFpbnN0cnVtZW50ZXJJbXBsZW1lbnRhdGlvbikge1xuICAgICAgICBpbnN0cnVtZW50ZXJJbXBsZW1lbnRhdGlvbiA9IGNyZWF0ZURlZmF1bHRJbnN0cnVtZW50ZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RydW1lbnRlckltcGxlbWVudGF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdHJ1bWVudGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZ2V0SW5zdHJ1bWVudGVyIH0gZnJvbSBcIi4vaW5zdHJ1bWVudGVyXCI7XG5pbXBvcnQgeyBrbm93bkNvbnRleHRLZXlzIH0gZnJvbSBcIi4vdHJhY2luZ0NvbnRleHRcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0cmFjaW5nIGNsaWVudC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhlIHRyYWNpbmcgY2xpZW50LlxuICogQHJldHVybnMgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgVHJhY2luZ0NsaWVudH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFjaW5nQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG5hbWVzcGFjZSwgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIHN0YXJ0U3BhbihuYW1lLCBvcGVyYXRpb25PcHRpb25zLCBzcGFuT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhblJlc3VsdCA9IGdldEluc3RydW1lbnRlcigpLnN0YXJ0U3BhbihuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNwYW5PcHRpb25zKSwgeyBwYWNrYWdlTmFtZTogcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uOiBwYWNrYWdlVmVyc2lvbiwgdHJhY2luZ0NvbnRleHQ6IChfYSA9IG9wZXJhdGlvbk9wdGlvbnMgPT09IG51bGwgfHwgb3BlcmF0aW9uT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlcmF0aW9uT3B0aW9ucy50cmFjaW5nT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYWNpbmdDb250ZXh0IH0pKTtcbiAgICAgICAgbGV0IHRyYWNpbmdDb250ZXh0ID0gc3RhcnRTcGFuUmVzdWx0LnRyYWNpbmdDb250ZXh0O1xuICAgICAgICBjb25zdCBzcGFuID0gc3RhcnRTcGFuUmVzdWx0LnNwYW47XG4gICAgICAgIGlmICghdHJhY2luZ0NvbnRleHQuZ2V0VmFsdWUoa25vd25Db250ZXh0S2V5cy5uYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICB0cmFjaW5nQ29udGV4dCA9IHRyYWNpbmdDb250ZXh0LnNldFZhbHVlKGtub3duQ29udGV4dEtleXMubmFtZXNwYWNlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiYXoubmFtZXNwYWNlXCIsIHRyYWNpbmdDb250ZXh0LmdldFZhbHVlKGtub3duQ29udGV4dEtleXMubmFtZXNwYWNlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3BlcmF0aW9uT3B0aW9ucywge1xuICAgICAgICAgICAgdHJhY2luZ09wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BlcmF0aW9uT3B0aW9ucyA9PT0gbnVsbCB8fCBvcGVyYXRpb25PcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVyYXRpb25PcHRpb25zLnRyYWNpbmdPcHRpb25zKSwgeyB0cmFjaW5nQ29udGV4dCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgdXBkYXRlZE9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHdpdGhTcGFuKG5hbWUsIG9wZXJhdGlvbk9wdGlvbnMsIGNhbGxiYWNrLCBzcGFuT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNwYW4sIHVwZGF0ZWRPcHRpb25zIH0gPSBzdGFydFNwYW4obmFtZSwgb3BlcmF0aW9uT3B0aW9ucywgc3Bhbk9wdGlvbnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2l0aENvbnRleHQodXBkYXRlZE9wdGlvbnMudHJhY2luZ09wdGlvbnMudHJhY2luZ0NvbnRleHQsICgpID0+IFByb21pc2UucmVzb2x2ZShjYWxsYmFjayh1cGRhdGVkT3B0aW9ucywgc3BhbikpKTtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBzdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aENvbnRleHQoY29udGV4dCwgY2FsbGJhY2ssIC4uLmNhbGxiYWNrQXJncykge1xuICAgICAgICByZXR1cm4gZ2V0SW5zdHJ1bWVudGVyKCkud2l0aENvbnRleHQoY29udGV4dCwgY2FsbGJhY2ssIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHRyYWNlcGFyZW50IGhlYWRlciB2YWx1ZSBpbnRvIGEgc3BhbiBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYWNlcGFyZW50SGVhZGVyIC0gVGhlIHRyYWNlcGFyZW50IGhlYWRlciB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyBBbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBpZGVudGlmaWVyIGZvciB0aGUgc3Bhbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVRyYWNlcGFyZW50SGVhZGVyKHRyYWNlcGFyZW50SGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnN0cnVtZW50ZXIoKS5wYXJzZVRyYWNlcGFyZW50SGVhZGVyKHRyYWNlcGFyZW50SGVhZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvZiByZXF1ZXN0IGhlYWRlcnMgdG8gcHJvcGFnYXRlIHRyYWNpbmcgaW5mb3JtYXRpb24gdG8gYSBiYWNrZW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYWNpbmdDb250ZXh0IC0gVGhlIGNvbnRleHQgY29udGFpbmluZyB0aGUgc3BhbiB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybnMgVGhlIHNldCBvZiBoZWFkZXJzIHRvIGFkZCB0byBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhlYWRlcnModHJhY2luZ0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGdldEluc3RydW1lbnRlcigpLmNyZWF0ZVJlcXVlc3RIZWFkZXJzKHRyYWNpbmdDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRTcGFuLFxuICAgICAgICB3aXRoU3BhbixcbiAgICAgICAgd2l0aENvbnRleHQsXG4gICAgICAgIHBhcnNlVHJhY2VwYXJlbnRIZWFkZXIsXG4gICAgICAgIGNyZWF0ZVJlcXVlc3RIZWFkZXJzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjaW5nQ2xpZW50LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGtub3duQ29udGV4dEtleXMgPSB7XG4gICAgc3BhbjogU3ltYm9sLmZvcihcIkBhenVyZS9jb3JlLXRyYWNpbmcgc3BhblwiKSxcbiAgICBuYW1lc3BhY2U6IFN5bWJvbC5mb3IoXCJAYXp1cmUvY29yZS10cmFjaW5nIG5hbWVzcGFjZVwiKSxcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFRyYWNpbmdDb250ZXh0fSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBIHNldCBvZiBrbm93biBrZXlzIHRoYXQgbWF5IGJlIHNldCBvbiB0aGUgY29udGV4dC5cbiAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBUcmFjaW5nQ29udGV4dH0gd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYWNpbmdDb250ZXh0KG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjb250ZXh0ID0gbmV3IFRyYWNpbmdDb250ZXh0SW1wbChvcHRpb25zLnBhcmVudENvbnRleHQpO1xuICAgIGlmIChvcHRpb25zLnNwYW4pIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQuc2V0VmFsdWUoa25vd25Db250ZXh0S2V5cy5zcGFuLCBvcHRpb25zLnNwYW4pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYW1lc3BhY2UpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQuc2V0VmFsdWUoa25vd25Db250ZXh0S2V5cy5uYW1lc3BhY2UsIG9wdGlvbnMubmFtZXNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgVHJhY2luZ0NvbnRleHRJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0TWFwID1cbiAgICAgICAgICAgIGluaXRpYWxDb250ZXh0IGluc3RhbmNlb2YgVHJhY2luZ0NvbnRleHRJbXBsXG4gICAgICAgICAgICAgICAgPyBuZXcgTWFwKGluaXRpYWxDb250ZXh0Ll9jb250ZXh0TWFwKVxuICAgICAgICAgICAgICAgIDogbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBuZXcgVHJhY2luZ0NvbnRleHRJbXBsKHRoaXMpO1xuICAgICAgICBuZXdDb250ZXh0Ll9jb250ZXh0TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRleHQ7XG4gICAgfVxuICAgIGdldFZhbHVlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dE1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgZGVsZXRlVmFsdWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBuZXcgVHJhY2luZ0NvbnRleHRJbXBsKHRoaXMpO1xuICAgICAgICBuZXdDb250ZXh0Ll9jb250ZXh0TWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjaW5nQ29udGV4dC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4vb2JqZWN0XCI7XG4vKipcbiAqIFR5cGVndWFyZCBmb3IgYW4gZXJyb3Igb2JqZWN0IHNoYXBlIChoYXMgbmFtZSBhbmQgbWVzc2FnZSlcbiAqIEBwYXJhbSBlIC0gU29tZXRoaW5nIGNhdWdodCBieSBhIGNhdGNoIGNsYXVzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAgIGlmIChpc09iamVjdChlKSkge1xuICAgICAgICBjb25zdCBoYXNOYW1lID0gdHlwZW9mIGUubmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgY29uc3QgaGFzTWVzc2FnZSA9IHR5cGVvZiBlLm1lc3NhZ2UgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIHJldHVybiBoYXNOYW1lICYmIGhhc01lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogR2l2ZW4gd2hhdCBpcyB0aG91Z2h0IHRvIGJlIGFuIGVycm9yIG9iamVjdCwgcmV0dXJuIHRoZSBtZXNzYWdlIGlmIHBvc3NpYmxlLlxuICogSWYgdGhlIG1lc3NhZ2UgaXMgbWlzc2luZywgcmV0dXJucyBhIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGUgLSBTb21ldGhpbmcgdGhyb3duIGZyb20gYSB0cnkgYmxvY2tcbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlIG9yIGEgc3RyaW5nIG9mIHRoZSBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGUpIHtcbiAgICBpZiAoaXNFcnJvcihlKSkge1xuICAgICAgICByZXR1cm4gZS5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0cmluZ2lmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSBcIm9iamVjdFwiICYmIGUpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBTdHJpbmcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBcIlt1bmFibGUgdG8gc3RyaW5naWZ5IGlucHV0XVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVW5rbm93biBlcnJvciAke3N0cmluZ2lmaWVkfWA7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG52YXIgX2E7XG4vKipcbiAqIEEgY29uc3RhbnQgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgdGhlIGNvZGUgaXMgcnVubmluZyBpcyBOb2RlLkpTLlxuICovXG5leHBvcnQgY29uc3QgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgQm9vbGVhbihwcm9jZXNzLnZlcnNpb24pICYmIEJvb2xlYW4oKF9hID0gcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOb2RlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHdoZW4gYW4gaW5wdXQgaXMgYSBnZW5lcmljIEpTIG9iamVjdC5cbiAqIEByZXR1cm5zIHRydWUgd2hlbiBpbnB1dCBpcyBhbiBvYmplY3QgdHlwZSB0aGF0IGlzIG5vdCBudWxsLCBBcnJheSwgUmVnRXhwLCBvciBEYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBpbnB1dCAhPT0gbnVsbCAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShpbnB1dCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIERhdGUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHZhbHVlIGJldHdlZW4gYSBsb3dlciBhbmQgdXBwZXIgYm91bmQsXG4gKiBpbmNsdXNpdmUgb2YgYm90aCBib3VuZHMuXG4gKiBOb3RlIHRoYXQgdGhpcyB1c2VzIE1hdGgucmFuZG9tIGFuZCBpc24ndCBzZWN1cmUuIElmIHlvdSBuZWVkIHRvIHVzZVxuICogdGhpcyBmb3IgYW55IGtpbmQgb2Ygc2VjdXJpdHkgcHVycG9zZSwgZmluZCBhIGJldHRlciBzb3VyY2Ugb2YgcmFuZG9tLlxuICogQHBhcmFtIG1pbiAtIFRoZSBzbWFsbGVzdCBpbnRlZ2VyIHZhbHVlIGFsbG93ZWQuXG4gKiBAcGFyYW0gbWF4IC0gVGhlIGxhcmdlc3QgaW50ZWdlciB2YWx1ZSBhbGxvd2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tSW50ZWdlckluY2x1c2l2ZShtaW4sIG1heCkge1xuICAgIC8vIE1ha2Ugc3VyZSBpbnB1dHMgYXJlIGludGVnZXJzLlxuICAgIG1pbiA9IE1hdGguY2VpbChtaW4pO1xuICAgIG1heCA9IE1hdGguZmxvb3IobWF4KTtcbiAgICAvLyBQaWNrIGEgcmFuZG9tIG9mZnNldCBmcm9tIHplcm8gdG8gdGhlIHNpemUgb2YgdGhlIHJhbmdlLlxuICAgIC8vIFNpbmNlIE1hdGgucmFuZG9tKCkgY2FuIG5ldmVyIHJldHVybiAxLCB3ZSBoYXZlIHRvIG1ha2UgdGhlIHJhbmdlIG9uZSBsYXJnZXJcbiAgICAvLyBpbiBvcmRlciB0byBiZSBpbmNsdXNpdmUgb2YgdGhlIG1heGltdW0gdmFsdWUgYWZ0ZXIgd2UgdGFrZSB0aGUgZmxvb3IuXG4gICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgbWluO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBEZWZhdWx0IGtleSB1c2VkIHRvIGFjY2VzcyB0aGUgWE1MIGF0dHJpYnV0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBYTUxfQVRUUktFWSA9IFwiJFwiO1xuLyoqXG4gKiBEZWZhdWx0IGtleSB1c2VkIHRvIGFjY2VzcyB0aGUgWE1MIHZhbHVlIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBYTUxfQ0hBUktFWSA9IFwiX1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eG1sLmNvbW1vbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IFhNTEJ1aWxkZXIsIFhNTFBhcnNlciwgWE1MVmFsaWRhdG9yIH0gZnJvbSBcImZhc3QteG1sLXBhcnNlclwiO1xuaW1wb3J0IHsgWE1MX0FUVFJLRVksIFhNTF9DSEFSS0VZIH0gZnJvbSBcIi4veG1sLmNvbW1vblwiO1xuZnVuY3Rpb24gZ2V0Q29tbW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJpYnV0ZXNHcm91cE5hbWU6IFhNTF9BVFRSS0VZLFxuICAgICAgICB0ZXh0Tm9kZU5hbWU6IChfYSA9IG9wdGlvbnMueG1sQ2hhcktleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogWE1MX0NIQVJLRVksXG4gICAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VyaWFsaXplck9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRDb21tb25PcHRpb25zKG9wdGlvbnMpKSwgeyBhdHRyaWJ1dGVOYW1lUHJlZml4OiBcIkBfXCIsIGZvcm1hdDogdHJ1ZSwgc3VwcHJlc3NFbXB0eU5vZGU6IHRydWUsIGluZGVudEJ5OiBcIlwiLCByb290Tm9kZU5hbWU6IChfYSA9IG9wdGlvbnMucm9vdE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwicm9vdFwiLCBjZGF0YVByb3BOYW1lOiAoX2IgPSBvcHRpb25zLmNkYXRhUHJvcE5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiX19jZGF0YVwiIH0pO1xufVxuZnVuY3Rpb24gZ2V0UGFyc2VyT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRDb21tb25PcHRpb25zKG9wdGlvbnMpKSwgeyBwYXJzZUF0dHJpYnV0ZVZhbHVlOiBmYWxzZSwgcGFyc2VUYWdWYWx1ZTogZmFsc2UsIGF0dHJpYnV0ZU5hbWVQcmVmaXg6IFwiXCIsIHN0b3BOb2Rlczogb3B0aW9ucy5zdG9wTm9kZXMsIHByb2Nlc3NFbnRpdGllczogZmFsc2UgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIEpTT04gb2JqZWN0IHRvIFhNTCBzdHJpbmdcbiAqIEBwYXJhbSBvYmogLSBKU09OIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgaW50byBYTUwgc3RyaW5nXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgdGhhdCBnb3Zlcm4gdGhlIFhNTCBidWlsZGluZyBvZiBnaXZlbiBKU09OIG9iamVjdFxuICogYHJvb3ROYW1lYCBpbmRpY2F0ZXMgdGhlIG5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudCBpbiB0aGUgcmVzdWx0aW5nIFhNTFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5WE1MKG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcGFyc2VyT3B0aW9ucyA9IGdldFNlcmlhbGl6ZXJPcHRpb25zKG9wdHMpO1xuICAgIGNvbnN0IGoyeCA9IG5ldyBYTUxCdWlsZGVyKHBhcnNlck9wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSB7IFtwYXJzZXJPcHRpb25zLnJvb3ROb2RlTmFtZV06IG9iaiB9O1xuICAgIGNvbnN0IHhtbERhdGEgPSBqMnguYnVpbGQobm9kZSk7XG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JHt4bWxEYXRhfWAucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBYTUwgc3RyaW5nIGludG8gSlNPTlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyBjb250YWluaW5nIHRoZSBYTUwgY29udGVudCB0byBiZSBwYXJzZWQgaW50byBKU09OXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgdGhhdCBnb3Zlcm4gdGhlIHBhcnNpbmcgb2YgZ2l2ZW4geG1sIHN0cmluZ1xuICogYGluY2x1ZGVSb290YCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcm9vdCBlbGVtZW50IGlzIHRvIGJlIGluY2x1ZGVkIG9yIG5vdCBpbiB0aGUgb3V0cHV0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVhNTChzdHIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghc3RyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvY3VtZW50IGlzIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uID0gWE1MVmFsaWRhdG9yLnZhbGlkYXRlKHN0cik7XG4gICAgaWYgKHZhbGlkYXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFhNTFBhcnNlcihnZXRQYXJzZXJPcHRpb25zKG9wdHMpKTtcbiAgICBjb25zdCBwYXJzZWRYbWwgPSBwYXJzZXIucGFyc2UodW5lc2NhcGVIVE1MKHN0cikpO1xuICAgIC8vIFJlbW92ZSB0aGUgPD94bWwgdmVyc2lvbj1cIi4uLlwiID8+IG5vZGUuXG4gICAgLy8gVGhpcyBpcyBhIGNoYW5nZSBpbiBiZWhhdmlvciBvbiBmeHAgdjQuIElzc3VlICM0MjRcbiAgICBpZiAocGFyc2VkWG1sW1wiP3htbFwiXSkge1xuICAgICAgICBkZWxldGUgcGFyc2VkWG1sW1wiP3htbFwiXTtcbiAgICB9XG4gICAgaWYgKCFvcHRzLmluY2x1ZGVSb290KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZFhtbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkWG1sW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFhtbDtcbn1cbmZ1bmN0aW9uIHVuZXNjYXBlSFRNTChzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIilcbiAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpXG4gICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKVxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eG1sLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgX19hc3luY0RlbGVnYXRvciwgX19hc3luY0dlbmVyYXRvciwgX19hc3luY1ZhbHVlcywgX19hd2FpdCwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgXCJAYXp1cmUvY29yZS1wYWdpbmdcIjtcbmltcG9ydCB7IEdlbmVyYXRlZENsaWVudCB9IGZyb20gXCIuL2dlbmVyYXRlZFwiO1xuaW1wb3J0IHsgaXNOYW1lZEtleUNyZWRlbnRpYWwsIGlzU0FTQ3JlZGVudGlhbCwgaXNUb2tlbkNyZWRlbnRpYWwsIH0gZnJvbSBcIkBhenVyZS9jb3JlLWF1dGhcIjtcbmltcG9ydCB7IFNUT1JBR0VfU0NPUEUsIFRhYmxlc0xvZ2dpbmdBbGxvd2VkSGVhZGVyTmFtZXMgfSBmcm9tIFwiLi91dGlscy9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRlY29kZUNvbnRpbnVhdGlvblRva2VuLCBlbmNvZGVDb250aW51YXRpb25Ub2tlbiB9IGZyb20gXCIuL3V0aWxzL2NvbnRpbnVhdGlvblRva2VuXCI7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVPYmplY3RzQXJyYXksIGRlc2VyaWFsaXplU2lnbmVkSWRlbnRpZmllciwgc2VyaWFsaXplLCBzZXJpYWxpemVRdWVyeU9wdGlvbnMsIHNlcmlhbGl6ZVNpZ25lZElkZW50aWZpZXJzLCB9IGZyb20gXCIuL3NlcmlhbGl6YXRpb25cIjtcbmltcG9ydCB7IHBhcnNlWE1MLCBzdHJpbmdpZnlYTUwgfSBmcm9tIFwiQGF6dXJlL2NvcmUteG1sXCI7XG5pbXBvcnQgeyBJbnRlcm5hbFRhYmxlVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi9UYWJsZVRyYW5zYWN0aW9uXCI7XG5pbXBvcnQgeyBVdWlkIH0gZnJvbSBcIi4vdXRpbHMvdXVpZFwiO1xuaW1wb3J0IHsgYXBpVmVyc2lvblBvbGljeSB9IGZyb20gXCIuL3V0aWxzL2FwaVZlcnNpb25Qb2xpY3lcIjtcbmltcG9ydCB7IGNvc21vc1BhdGNoUG9saWN5IH0gZnJvbSBcIi4vY29zbW9zUGF0aFBvbGljeVwiO1xuaW1wb3J0IHsgZXNjYXBlUXVvdGVzIH0gZnJvbSBcIi4vb2RhdGFcIjtcbmltcG9ydCB7IGdldENsaWVudFBhcmFtc0Zyb21Db25uZWN0aW9uU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMvY29ubmVjdGlvblN0cmluZ1wiO1xuaW1wb3J0IHsgaGFuZGxlVGFibGVBbHJlYWR5RXhpc3RzIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3JIZWxwZXJzXCI7XG5pbXBvcnQgeyBpc0Nvc21vc0VuZHBvaW50IH0gZnJvbSBcIi4vdXRpbHMvaXNDb3Ntb3NFbmRwb2ludFwiO1xuaW1wb3J0IHsgaXNDcmVkZW50aWFsIH0gZnJvbSBcIi4vdXRpbHMvaXNDcmVkZW50aWFsXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCB7IHNldFRva2VuQ2hhbGxlbmdlQXV0aGVudGljYXRpb25Qb2xpY3kgfSBmcm9tIFwiLi91dGlscy9jaGFsbGVuZ2VBdXRoZW50aWNhdGlvblV0aWxzXCI7XG5pbXBvcnQgeyB0YWJsZXNOYW1lZEtleUNyZWRlbnRpYWxQb2xpY3kgfSBmcm9tIFwiLi90YWJsZXNOYW1lZENyZWRlbnRpYWxQb2xpY3lcIjtcbmltcG9ydCB7IHRhYmxlc1NBU1Rva2VuUG9saWN5IH0gZnJvbSBcIi4vdGFibGVzU0FTVG9rZW5Qb2xpY3lcIjtcbmltcG9ydCB7IHRyYWNpbmdDbGllbnQgfSBmcm9tIFwiLi91dGlscy90cmFjaW5nXCI7XG4vKipcbiAqIEEgVGFibGVDbGllbnQgcmVwcmVzZW50cyBhIENsaWVudCB0byB0aGUgQXp1cmUgVGFibGVzIHNlcnZpY2UgYWxsb3dpbmcgeW91XG4gKiB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gYSBzaW5nbGUgdGFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWJsZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IodXJsLCB0YWJsZU5hbWUsIGNyZWRlbnRpYWxPck9wdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IGlzQ3JlZGVudGlhbChjcmVkZW50aWFsT3JPcHRpb25zKSA/IGNyZWRlbnRpYWxPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbCA9IGNyZWRlbnRpYWw7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucyA9ICghaXNDcmVkZW50aWFsKGNyZWRlbnRpYWxPck9wdGlvbnMpID8gY3JlZGVudGlhbE9yT3B0aW9ucyA6IG9wdGlvbnMpIHx8IHt9O1xuICAgICAgICB0aGlzLmFsbG93SW5zZWN1cmVDb25uZWN0aW9uID0gKF9hID0gdGhpcy5jbGllbnRPcHRpb25zLmFsbG93SW5zZWN1cmVDb25uZWN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmVuZHBvaW50ID0gdGhpcy5jbGllbnRPcHRpb25zLmVuZHBvaW50IHx8IHRoaXMudXJsO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFBpcGVsaW5lT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGllbnRPcHRpb25zKSwgeyBsb2dnaW5nT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGxvZ2dlcjogbG9nZ2VyLmluZm8sXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbEFsbG93ZWRIZWFkZXJOYW1lczogWy4uLlRhYmxlc0xvZ2dpbmdBbGxvd2VkSGVhZGVyTmFtZXNdLFxuICAgICAgICAgICAgfSwgZGVzZXJpYWxpemF0aW9uT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHBhcnNlWE1MLFxuICAgICAgICAgICAgfSwgc2VyaWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnlYTUwsXG4gICAgICAgICAgICB9IH0pO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGllbnQgPSBuZXcgR2VuZXJhdGVkQ2xpZW50KHRoaXMudXJsLCBpbnRlcm5hbFBpcGVsaW5lT3B0aW9ucyk7XG4gICAgICAgIGlmIChpc05hbWVkS2V5Q3JlZGVudGlhbChjcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkQ2xpZW50LnBpcGVsaW5lLmFkZFBvbGljeSh0YWJsZXNOYW1lZEtleUNyZWRlbnRpYWxQb2xpY3koY3JlZGVudGlhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU0FTQ3JlZGVudGlhbChjcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkQ2xpZW50LnBpcGVsaW5lLmFkZFBvbGljeSh0YWJsZXNTQVNUb2tlblBvbGljeShjcmVkZW50aWFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVG9rZW5DcmVkZW50aWFsKGNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICBzZXRUb2tlbkNoYWxsZW5nZUF1dGhlbnRpY2F0aW9uUG9saWN5KGdlbmVyYXRlZENsaWVudC5waXBlbGluZSwgY3JlZGVudGlhbCwgU1RPUkFHRV9TQ09QRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29zbW9zRW5kcG9pbnQodGhpcy51cmwpKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDbGllbnQucGlwZWxpbmUuYWRkUG9saWN5KGNvc21vc1BhdGNoUG9saWN5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZENsaWVudC5waXBlbGluZS5hZGRQb2xpY3koYXBpVmVyc2lvblBvbGljeShvcHRpb25zLnZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbmVyYXRlZENsaWVudCA9IGdlbmVyYXRlZENsaWVudDtcbiAgICAgICAgdGhpcy50YWJsZSA9IGdlbmVyYXRlZENsaWVudC50YWJsZTtcbiAgICAgICAgdGhpcy5waXBlbGluZSA9IGdlbmVyYXRlZENsaWVudC5waXBlbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVybWFuZW50bHkgZGVsZXRlcyB0aGUgY3VycmVudCB0YWJsZSB3aXRoIGFsbCBvZiBpdHMgZW50aXRpZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgZGVsZXRpbmcgYSB0YWJsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgeyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbCwgVGFibGVDbGllbnQgfSA9IHJlcXVpcmUoXCJAYXp1cmUvZGF0YS10YWJsZXNcIilcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gXCI8c3RvcmFnZSBhY2NvdW50IG5hbWU+XCI7XG4gICAgICogY29uc3QgYWNjb3VudEtleSA9IFwiPGFjY291bnQga2V5PlwiXG4gICAgICogY29uc3QgdGFibGVOYW1lID0gXCI8dGFibGUgbmFtZT5cIjtcbiAgICAgKiBjb25zdCBzaGFyZWRLZXlDcmVkZW50aWFsID0gbmV3IEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsKGFjY291bnQsIGFjY291bnRLZXkpO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFRhYmxlQ2xpZW50KFxuICAgICAqICAgYGh0dHBzOi8vJHthY2NvdW50fS50YWJsZS5jb3JlLndpbmRvd3MubmV0YCxcbiAgICAgKiAgIGAke3RhYmxlTmFtZX1gLFxuICAgICAqICAgc2hhcmVkS2V5Q3JlZGVudGlhbFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBjYWxsaW5nIGRlbGV0ZVRhYmxlIHdpbGwgZGVsZXRlIHRoZSB0YWJsZSB1c2VkXG4gICAgICogLy8gdG8gaW5zdGFudGlhdGUgdGhlIFRhYmxlQ2xpZW50LlxuICAgICAqIC8vIE5vdGU6IElmIHRoZSB0YWJsZSBkb2Vzbid0IGV4aXN0IHRoaXMgZnVuY3Rpb24gZG9lc24ndCBmYWlsLlxuICAgICAqIGF3YWl0IGNsaWVudC5kZWxldGVUYWJsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYXp1cmUvYXp1cmUtc2RrL3RzLW5hbWluZy1vcHRpb25zXG4gICAgZGVsZXRlVGFibGUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQuZGVsZXRlVGFibGVcIiwgb3B0aW9ucywgYXN5bmMgKHVwZGF0ZWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudGFibGUuZGVsZXRlKHRoaXMudGFibGVOYW1lLCB1cGRhdGVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcIlRhYmxlQ2xpZW50LmRlbGV0ZVRhYmxlOiBUYWJsZSBkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIHRhYmxlIHdpdGggdGhlIHRhYmxlTmFtZSBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIGNyZWF0aW5nIGEgdGFibGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHsgQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwsIFRhYmxlQ2xpZW50IH0gPSByZXF1aXJlKFwiQGF6dXJlL2RhdGEtdGFibGVzXCIpXG4gICAgICogY29uc3QgYWNjb3VudCA9IFwiPHN0b3JhZ2UgYWNjb3VudCBuYW1lPlwiO1xuICAgICAqIGNvbnN0IGFjY291bnRLZXkgPSBcIjxhY2NvdW50IGtleT5cIlxuICAgICAqIGNvbnN0IHRhYmxlTmFtZSA9IFwiPHRhYmxlIG5hbWU+XCI7XG4gICAgICogY29uc3Qgc2hhcmVkS2V5Q3JlZGVudGlhbCA9IG5ldyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbChhY2NvdW50LCBhY2NvdW50S2V5KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBUYWJsZUNsaWVudChcbiAgICAgKiAgIGBodHRwczovLyR7YWNjb3VudH0udGFibGUuY29yZS53aW5kb3dzLm5ldGAsXG4gICAgICogICBgJHt0YWJsZU5hbWV9YCxcbiAgICAgKiAgIHNoYXJlZEtleUNyZWRlbnRpYWxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gY2FsbGluZyBjcmVhdGUgdGFibGUgd2lsbCBjcmVhdGUgdGhlIHRhYmxlIHVzZWRcbiAgICAgKiAvLyB0byBpbnN0YW50aWF0ZSB0aGUgVGFibGVDbGllbnQuXG4gICAgICogLy8gTm90ZTogSWYgdGhlIHRhYmxlIGFscmVhZHlcbiAgICAgKiAvLyBleGlzdHMgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LlxuICAgICAqIGF3YWl0IGNsaWVudC5jcmVhdGVUYWJsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYXp1cmUvYXp1cmUtc2RrL3RzLW5hbWluZy1vcHRpb25zXG4gICAgY3JlYXRlVGFibGUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQuY3JlYXRlVGFibGVcIiwgb3B0aW9ucywgYXN5bmMgKHVwZGF0ZWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudGFibGUuY3JlYXRlKHsgbmFtZTogdGhpcy50YWJsZU5hbWUgfSwgdXBkYXRlZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUYWJsZUFscmVhZHlFeGlzdHMoZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkT3B0aW9ucyksIHsgbG9nZ2VyLCB0YWJsZU5hbWU6IHRoaXMudGFibGVOYW1lIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGUgZW50aXR5IGluIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gcGFydGl0aW9uS2V5IC0gVGhlIHBhcnRpdGlvbiBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gcm93S2V5IC0gVGhlIHJvdyBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSBnZXR0aW5nIGFuIGVudGl0eVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgeyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbCwgVGFibGVDbGllbnQgfSA9IHJlcXVpcmUoXCJAYXp1cmUvZGF0YS10YWJsZXNcIilcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gXCI8c3RvcmFnZSBhY2NvdW50IG5hbWU+XCI7XG4gICAgICogY29uc3QgYWNjb3VudEtleSA9IFwiPGFjY291bnQga2V5PlwiXG4gICAgICogY29uc3QgdGFibGVOYW1lID0gXCI8dGFibGUgbmFtZT5cIjtcbiAgICAgKiBjb25zdCBzaGFyZWRLZXlDcmVkZW50aWFsID0gbmV3IEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsKGFjY291bnQsIGFjY291bnRLZXkpO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFRhYmxlQ2xpZW50KFxuICAgICAqICAgYGh0dHBzOi8vJHthY2NvdW50fS50YWJsZS5jb3JlLndpbmRvd3MubmV0YCxcbiAgICAgKiAgIGAke3RhYmxlTmFtZX1gLFxuICAgICAqICAgc2hhcmVkS2V5Q3JlZGVudGlhbFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBnZXRFbnRpdHkgd2lsbCBnZXQgYSBzaW5nbGUgZW50aXR5IHN0b3JlZCBpbiB0aGUgc2VydmljZSB0aGF0XG4gICAgICogLy8gbWF0Y2hlcyBleGFjdGx5IHRoZSBwYXJ0aXRpb25LZXkgYW5kIHJvd0tleSB1c2VkIGFzIHBhcmFtZXRlcnNcbiAgICAgKiAvLyB0byB0aGUgbWV0aG9kLlxuICAgICAqIGNvbnN0IGVudGl0eSA9IGF3YWl0IGNsaWVudC5nZXRFbnRpdHkoXCI8cGFydGl0aW9uS2V5PlwiLCBcIjxyb3dLZXk+XCIpO1xuICAgICAqIGNvbnNvbGUubG9nKGVudGl0eSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0RW50aXR5KHBhcnRpdGlvbktleSwgcm93S2V5LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGF6dXJlL2F6dXJlLXNkay90cy1uYW1pbmctb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0NsaWVudC53aXRoU3BhbihcIlRhYmxlQ2xpZW50LmdldEVudGl0eVwiLCBvcHRpb25zLCBhc3luYyAodXBkYXRlZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRCb2R5O1xuICAgICAgICAgICAgZnVuY3Rpb24gb25SZXNwb25zZShyYXdSZXNwb25zZSwgZmxhdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkQm9keSA9IHJhd1Jlc3BvbnNlLnBhcnNlZEJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWRPcHRpb25zLm9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE9wdGlvbnMub25SZXNwb25zZShyYXdSZXNwb25zZSwgZmxhdFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRpc2FibGVUeXBlQ29udmVyc2lvbiwgcXVlcnlPcHRpb25zIH0gPSB1cGRhdGVkT3B0aW9ucywgZ2V0RW50aXR5T3B0aW9ucyA9IF9fcmVzdCh1cGRhdGVkT3B0aW9ucywgW1wiZGlzYWJsZVR5cGVDb252ZXJzaW9uXCIsIFwicXVlcnlPcHRpb25zXCJdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudGFibGUucXVlcnlFbnRpdGllc1dpdGhQYXJ0aXRpb25BbmRSb3dLZXkodGhpcy50YWJsZU5hbWUsIGVzY2FwZVF1b3RlcyhwYXJ0aXRpb25LZXkpLCBlc2NhcGVRdW90ZXMocm93S2V5KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRFbnRpdHlPcHRpb25zKSwgeyBxdWVyeU9wdGlvbnM6IHNlcmlhbGl6ZVF1ZXJ5T3B0aW9ucyhxdWVyeU9wdGlvbnMgfHwge30pLCBvblJlc3BvbnNlIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlRW50aXR5ID0gZGVzZXJpYWxpemUocGFyc2VkQm9keSwgZGlzYWJsZVR5cGVDb252ZXJzaW9uICE9PSBudWxsICYmIGRpc2FibGVUeXBlQ29udmVyc2lvbiAhPT0gdm9pZCAwID8gZGlzYWJsZVR5cGVDb252ZXJzaW9uIDogZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlRW50aXR5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcmllcyBlbnRpdGllcyBpbiBhIHRhYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgbGlzdGluZyBlbnRpdGllc1xuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgeyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbCwgVGFibGVDbGllbnQgfSA9IHJlcXVpcmUoXCJAYXp1cmUvZGF0YS10YWJsZXNcIilcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gXCI8c3RvcmFnZSBhY2NvdW50IG5hbWU+XCI7XG4gICAgICogY29uc3QgYWNjb3VudEtleSA9IFwiPGFjY291bnQga2V5PlwiXG4gICAgICogY29uc3QgdGFibGVOYW1lID0gXCI8dGFibGUgbmFtZT5cIjtcbiAgICAgKiBjb25zdCBzaGFyZWRLZXlDcmVkZW50aWFsID0gbmV3IEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsKGFjY291bnQsIGFjY291bnRLZXkpO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFRhYmxlQ2xpZW50KFxuICAgICAqICAgYGh0dHBzOi8vJHthY2NvdW50fS50YWJsZS5jb3JlLndpbmRvd3MubmV0YCxcbiAgICAgKiAgIGAke3RhYmxlTmFtZX1gLFxuICAgICAqICAgc2hhcmVkS2V5Q3JlZGVudGlhbFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBsaXN0IGVudGl0aWVzIHJldHVybnMgYSBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgKiAvLyB0aGlzIGhlbHBzIGNvbnN1bWluZyBwYWdpbmF0ZWQgcmVzcG9uc2VzIGJ5XG4gICAgICogLy8gYXV0b21hdGljYWxseSBoYW5kbGluZyBnZXR0aW5nIHRoZSBuZXh0IHBhZ2VzXG4gICAgICogY29uc3QgZW50aXRpZXMgPSBjbGllbnQubGlzdEVudGl0aWVzKCk7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGxvb3Agd2lsbCBnZXQgYWxsIHRoZSBlbnRpdGllcyBmcm9tIGFsbCB0aGUgcGFnZXNcbiAgICAgKiAvLyByZXR1cm5lZCBieSB0aGUgc2VydmljZVxuICAgICAqIGZvciBhd2FpdCAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICogICAgY29uc29sZS5sb2coZW50aXR5KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbGlzdEVudGl0aWVzKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYXp1cmUvYXp1cmUtc2RrL3RzLW5hbWluZy1vcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMudGFibGVOYW1lO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5saXN0RW50aXRpZXNBbGwodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnlQYWdlOiAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcXVlcnlPcHRpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucXVlcnlPcHRpb25zKSwgeyB0b3A6IHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5tYXhQYWdlU2l6ZSB9KSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmNvbnRpbnVhdGlvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VPcHRpb25zLmNvbnRpbnVhdGlvblRva2VuID0gc2V0dGluZ3MuY29udGludWF0aW9uVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RFbnRpdGllc1BhZ2UodGFibGVOYW1lLCBwYWdlT3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsaXN0RW50aXRpZXNBbGwodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGxpc3RFbnRpdGllc0FsbF8xKCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSB5aWVsZCBfX2F3YWl0KHRoaXMuX2xpc3RFbnRpdGllcyh0YWJsZU5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQoeWllbGQqIF9fYXN5bmNEZWxlZ2F0b3IoX19hc3luY1ZhbHVlcyhmaXJzdFBhZ2UpKSk7XG4gICAgICAgICAgICBpZiAoZmlyc3RQYWdlLmNvbnRpbnVhdGlvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhDb250aW51YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGNvbnRpbnVhdGlvblRva2VuOiBmaXJzdFBhZ2UuY29udGludWF0aW9uVG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX2FzeW5jVmFsdWVzKHRoaXMubGlzdEVudGl0aWVzUGFnZSh0YWJsZU5hbWUsIG9wdGlvbnNXaXRoQ29udGludWF0aW9uKSksIF9jOyBfYyA9IHlpZWxkIF9fYXdhaXQoX2IubmV4dCgpKSwgIV9jLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMocGFnZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2EuY2FsbChfYikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaXN0RW50aXRpZXNQYWdlKHRhYmxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGxpc3RFbnRpdGllc1BhZ2VfMSgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB5aWVsZCBfX2F3YWl0KHRyYWNpbmdDbGllbnQud2l0aFNwYW4oXCJUYWJsZUNsaWVudC5saXN0RW50aXRpZXNQYWdlXCIsIG9wdGlvbnMsICh1cGRhdGVkT3B0aW9ucykgPT4gdGhpcy5fbGlzdEVudGl0aWVzKHRhYmxlTmFtZSwgdXBkYXRlZE9wdGlvbnMpKSk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHJlc3VsdCk7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0LmNvbnRpbnVhdGlvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhDb250aW51YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGNvbnRpbnVhdGlvblRva2VuOiByZXN1bHQuY29udGludWF0aW9uVG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgX19hd2FpdCh0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQubGlzdEVudGl0aWVzUGFnZVwiLCBvcHRpb25zV2l0aENvbnRpbnVhdGlvbiwgKHVwZGF0ZWRPcHRpb25zLCBzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiY29udGludWF0aW9uVG9rZW5cIiwgcmVzdWx0LmNvbnRpbnVhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RFbnRpdGllcyh0YWJsZU5hbWUsIHVwZGF0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2xpc3RFbnRpdGllcyh0YWJsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRpc2FibGVUeXBlQ29udmVyc2lvbiA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBzZXJpYWxpemVRdWVyeU9wdGlvbnMob3B0aW9ucy5xdWVyeU9wdGlvbnMgfHwge30pO1xuICAgICAgICBjb25zdCBsaXN0RW50aXRpZXNPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBxdWVyeU9wdGlvbnMgfSk7XG4gICAgICAgIC8vIElmIGEgY29udGludWF0aW9uIHRva2VuIGlzIHVzZWQsIGRlY29kZSBpdCBhbmQgc2V0IHRoZSBuZXh0IHJvdyBhbmQgcGFydGl0aW9uIGtleVxuICAgICAgICBpZiAob3B0aW9ucy5jb250aW51YXRpb25Ub2tlbikge1xuICAgICAgICAgICAgY29uc3QgY29udGludWF0aW9uVG9rZW4gPSBkZWNvZGVDb250aW51YXRpb25Ub2tlbihvcHRpb25zLmNvbnRpbnVhdGlvblRva2VuKTtcbiAgICAgICAgICAgIGxpc3RFbnRpdGllc09wdGlvbnMubmV4dFJvd0tleSA9IGNvbnRpbnVhdGlvblRva2VuLm5leHRSb3dLZXk7XG4gICAgICAgICAgICBsaXN0RW50aXRpZXNPcHRpb25zLm5leHRQYXJ0aXRpb25LZXkgPSBjb250aW51YXRpb25Ub2tlbi5uZXh0UGFydGl0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeE1zQ29udGludWF0aW9uTmV4dFBhcnRpdGlvbktleTogbmV4dFBhcnRpdGlvbktleSwgeE1zQ29udGludWF0aW9uTmV4dFJvd0tleTogbmV4dFJvd0tleSwgdmFsdWUsIH0gPSBhd2FpdCB0aGlzLnRhYmxlLnF1ZXJ5RW50aXRpZXModGFibGVOYW1lLCBsaXN0RW50aXRpZXNPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdGFibGVFbnRpdGllcyA9IGRlc2VyaWFsaXplT2JqZWN0c0FycmF5KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IFtdLCBkaXNhYmxlVHlwZUNvbnZlcnNpb24pO1xuICAgICAgICAvLyBFbmNvZGUgbmV4dFBhcnRpdGlvbktleSBhbmQgbmV4dFJvd0tleSBhcyBhIHNpbmdsZSBjb250aW51YXRpb24gdG9rZW4gYW5kIGFkZCBpdCBhcyBhXG4gICAgICAgIC8vIHByb3BlcnR5IHRvIHRoZSBwYWdlLlxuICAgICAgICBjb25zdCBjb250aW51YXRpb25Ub2tlbiA9IGVuY29kZUNvbnRpbnVhdGlvblRva2VuKG5leHRQYXJ0aXRpb25LZXksIG5leHRSb3dLZXkpO1xuICAgICAgICBjb25zdCBwYWdlID0gT2JqZWN0LmFzc2lnbihbLi4udGFibGVFbnRpdGllc10sIHtcbiAgICAgICAgICAgIGNvbnRpbnVhdGlvblRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBlbnRpdHkgaW4gdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSBlbnRpdHkgLSBUaGUgcHJvcGVydGllcyBmb3IgdGhlIHRhYmxlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSBjcmVhdGluZyBhbiBlbnRpdHlcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHsgQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwsIFRhYmxlQ2xpZW50IH0gPSByZXF1aXJlKFwiQGF6dXJlL2RhdGEtdGFibGVzXCIpXG4gICAgICogY29uc3QgYWNjb3VudCA9IFwiPHN0b3JhZ2UgYWNjb3VudCBuYW1lPlwiO1xuICAgICAqIGNvbnN0IGFjY291bnRLZXkgPSBcIjxhY2NvdW50IGtleT5cIlxuICAgICAqIGNvbnN0IHRhYmxlTmFtZSA9IFwiPHRhYmxlIG5hbWU+XCI7XG4gICAgICogY29uc3Qgc2hhcmVkS2V5Q3JlZGVudGlhbCA9IG5ldyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbChhY2NvdW50LCBhY2NvdW50S2V5KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBUYWJsZUNsaWVudChcbiAgICAgKiAgIGBodHRwczovLyR7YWNjb3VudH0udGFibGUuY29yZS53aW5kb3dzLm5ldGAsXG4gICAgICogICBgJHt0YWJsZU5hbWV9YCxcbiAgICAgKiAgIHNoYXJlZEtleUNyZWRlbnRpYWxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gcGFydGl0aW9uS2V5IGFuZCByb3dLZXkgYXJlIHJlcXVpcmVkIHByb3BlcnRpZXMgb2YgdGhlIGVudGl0eSB0byBjcmVhdGVcbiAgICAgKiAvLyBhbmQgYWNjZXB0cyBhbnkgb3RoZXIgcHJvcGVydGllc1xuICAgICAqIGF3YWl0IGNsaWVudC5jcmVhdGVFbnRpdHkoe3BhcnRpdGlvbktleTogXCJwMVwiLCByb3dLZXk6IFwicjFcIiwgZm9vOiBcIkhlbGxvIVwifSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlRW50aXR5KGVudGl0eSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhenVyZS9henVyZS1zZGsvdHMtbmFtaW5nLW9wdGlvbnNcbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdDbGllbnQud2l0aFNwYW4oXCJUYWJsZUNsaWVudC5jcmVhdGVFbnRpdHlcIiwgb3B0aW9ucywgKHVwZGF0ZWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVUYWJsZUVudGl0eSA9IF9fcmVzdCh1cGRhdGVkT3B0aW9ucyB8fCB7fSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGUuaW5zZXJ0RW50aXR5KHRoaXMudGFibGVOYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWF0ZVRhYmxlRW50aXR5KSwgeyB0YWJsZUVudGl0eVByb3BlcnRpZXM6IHNlcmlhbGl6ZShlbnRpdHkpLCByZXNwb25zZVByZWZlcmVuY2U6IFwicmV0dXJuLW5vLWNvbnRlbnRcIiB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBzcGVjaWZpZWQgZW50aXR5IGluIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gcGFydGl0aW9uS2V5IC0gVGhlIHBhcnRpdGlvbiBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gcm93S2V5IC0gVGhlIHJvdyBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSBkZWxldGluZyBhbiBlbnRpdHlcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHsgQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwsIFRhYmxlQ2xpZW50IH0gPSByZXF1aXJlKFwiQGF6dXJlL2RhdGEtdGFibGVzXCIpXG4gICAgICogY29uc3QgYWNjb3VudCA9IFwiPHN0b3JhZ2UgYWNjb3VudCBuYW1lPlwiO1xuICAgICAqIGNvbnN0IGFjY291bnRLZXkgPSBcIjxhY2NvdW50IGtleT5cIlxuICAgICAqIGNvbnN0IHRhYmxlTmFtZSA9IFwiPHRhYmxlIG5hbWU+XCI7XG4gICAgICogY29uc3Qgc2hhcmVkS2V5Q3JlZGVudGlhbCA9IG5ldyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbChhY2NvdW50LCBhY2NvdW50S2V5KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBUYWJsZUNsaWVudChcbiAgICAgKiAgIGBodHRwczovLyR7YWNjb3VudH0udGFibGUuY29yZS53aW5kb3dzLm5ldGAsXG4gICAgICogICBgJHt0YWJsZU5hbWV9YCxcbiAgICAgKiAgIHNoYXJlZEtleUNyZWRlbnRpYWxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gZGVsZXRlRW50aXR5IGRlbGV0ZXMgdGhlIGVudGl0eSB0aGF0IG1hdGNoZXNcbiAgICAgKiAvLyBleGFjdGx5IHRoZSBwYXJ0aXRpb25LZXkgYW5kIHJvd0tleSBwYXNzZWQgYXMgcGFyYW1ldGVyc1xuICAgICAqIGF3YWl0IGNsaWVudC5kZWxldGVFbnRpdHkoXCI8cGFydGl0aW9uS2V5PlwiLCBcIjxyb3dLZXk+XCIpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGVsZXRlRW50aXR5KHBhcnRpdGlvbktleSwgcm93S2V5LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGF6dXJlL2F6dXJlLXNkay90cy1uYW1pbmctb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0NsaWVudC53aXRoU3BhbihcIlRhYmxlQ2xpZW50LmRlbGV0ZUVudGl0eVwiLCBvcHRpb25zLCAodXBkYXRlZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXRhZyA9IFwiKlwiIH0gPSB1cGRhdGVkT3B0aW9ucywgcmVzdCA9IF9fcmVzdCh1cGRhdGVkT3B0aW9ucywgW1wiZXRhZ1wiXSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZS5kZWxldGVFbnRpdHkodGhpcy50YWJsZU5hbWUsIGVzY2FwZVF1b3RlcyhwYXJ0aXRpb25LZXkpLCBlc2NhcGVRdW90ZXMocm93S2V5KSwgZXRhZywgZGVsZXRlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZW50aXR5IGluIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gZW50aXR5IC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGVudGl0eSB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIGRpZmZlcmVudCBtb2RlcyBmb3IgdXBkYXRpbmcgdGhlIGVudGl0eTpcbiAgICAgKiAgICAgICAgICAgICAgIC0gTWVyZ2U6IFVwZGF0ZXMgYW4gZW50aXR5IGJ5IHVwZGF0aW5nIHRoZSBlbnRpdHkncyBwcm9wZXJ0aWVzIHdpdGhvdXQgcmVwbGFjaW5nIHRoZSBleGlzdGluZyBlbnRpdHkuXG4gICAgICogICAgICAgICAgICAgICAtIFJlcGxhY2U6IFVwZGF0ZXMgYW4gZXhpc3RpbmcgZW50aXR5IGJ5IHJlcGxhY2luZyB0aGUgZW50aXJlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSB1cGRhdGluZyBhbiBlbnRpdHlcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHsgQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwsIFRhYmxlQ2xpZW50IH0gPSByZXF1aXJlKFwiQGF6dXJlL2RhdGEtdGFibGVzXCIpXG4gICAgICogY29uc3QgYWNjb3VudCA9IFwiPHN0b3JhZ2UgYWNjb3VudCBuYW1lPlwiO1xuICAgICAqIGNvbnN0IGFjY291bnRLZXkgPSBcIjxhY2NvdW50IGtleT5cIlxuICAgICAqIGNvbnN0IHRhYmxlTmFtZSA9IFwiPHRhYmxlIG5hbWU+XCI7XG4gICAgICogY29uc3Qgc2hhcmVkS2V5Q3JlZGVudGlhbCA9IG5ldyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbChhY2NvdW50LCBhY2NvdW50S2V5KTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBUYWJsZUNsaWVudChcbiAgICAgKiAgIGBodHRwczovLyR7YWNjb3VudH0udGFibGUuY29yZS53aW5kb3dzLm5ldGAsXG4gICAgICogICBgJHt0YWJsZU5hbWV9YCxcbiAgICAgKiAgIHNoYXJlZEtleUNyZWRlbnRpYWxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogY29uc3QgZW50aXR5ID0ge3BhcnRpdGlvbktleTogXCJwMVwiLCByb3dLZXk6IFwicjFcIiwgYmFyOiBcInVwZGF0ZWRCYXJcIn07XG4gICAgICpcbiAgICAgKiAvLyBVcGRhdGUgdXNlcyB1cGRhdGUgbW9kZSBcIk1lcmdlXCIgYXMgZGVmYXVsdFxuICAgICAqIC8vIG1lcmdlIG1lYW5zIHRoYXQgdXBkYXRlIHdpbGwgbWF0Y2ggYSBzdG9yZWQgZW50aXR5XG4gICAgICogLy8gdGhhdCBoYXMgdGhlIHNhbWUgcGFydGl0aW9uS2V5IGFuZCByb3dLZXkgYXMgdGhlIGVudGl0eVxuICAgICAqIC8vIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFuZCB0aGVuIHdpbGwgb25seSB1cGRhdGUgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBpbiBpdC5cbiAgICAgKiAvLyBBbnkgb3RoZXIgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgZW50aXR5IHBhc3NlZCB0byB1cGRhdGVFbnRpdHlcbiAgICAgKiAvLyB3aWxsIHJlbWFpbiBhcyB0aGV5IGFyZSBpbiB0aGUgc2VydmljZVxuICAgICAqIGF3YWl0IGNsaWVudC51cGRhdGVFbnRpdHkoZW50aXR5KVxuICAgICAqXG4gICAgICogLy8gV2UgY2FuIGFsc28gc2V0IHRoZSB1cGRhdGUgbW9kZSB0byBSZXBsYWNlLCB3aGljaCB3aWxsIG1hdGNoIHRoZSBlbnRpdHkgcGFzc2VkXG4gICAgICogLy8gdG8gdXBkYXRlRW50aXR5IHdpdGggb25lIHN0b3JlZCBpbiB0aGUgc2VydmljZSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAqIC8vIElmIHRoZXJlIGFyZSBhbnkgbWlzc2luZyBwcm9wZXJ0aWVzIGluIHRoZSBlbnRpdHkgcGFzc2VkIHRvIHVwZGF0ZUVudGl0eSwgdGhleVxuICAgICAqIC8vIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbnRpdHkgc3RvcmVkIGluIHRoZSBzZXJ2aWNlXG4gICAgICogYXdhaXQgY2xpZW50LnVwZGF0ZUVudGl0eShlbnRpdHksIFwiUmVwbGFjZVwiKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHVwZGF0ZUVudGl0eShlbnRpdHksIG1vZGUgPSBcIk1lcmdlXCIsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYXp1cmUvYXp1cmUtc2RrL3RzLW5hbWluZy1vcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQudXBkYXRlRW50aXR5XCIsIG9wdGlvbnMsIGFzeW5jICh1cGRhdGVkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydGl0aW9uS2V5ID0gZXNjYXBlUXVvdGVzKGVudGl0eS5wYXJ0aXRpb25LZXkpO1xuICAgICAgICAgICAgY29uc3Qgcm93S2V5ID0gZXNjYXBlUXVvdGVzKGVudGl0eS5yb3dLZXkpO1xuICAgICAgICAgICAgY29uc3QgX2EgPSB1cGRhdGVkT3B0aW9ucyB8fCB7fSwgeyBldGFnID0gXCIqXCIgfSA9IF9hLCB1cGRhdGVFbnRpdHlPcHRpb25zID0gX19yZXN0KF9hLCBbXCJldGFnXCJdKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcIk1lcmdlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZS5tZXJnZUVudGl0eSh0aGlzLnRhYmxlTmFtZSwgcGFydGl0aW9uS2V5LCByb3dLZXksIE9iamVjdC5hc3NpZ24oeyB0YWJsZUVudGl0eVByb3BlcnRpZXM6IHNlcmlhbGl6ZShlbnRpdHkpLCBpZk1hdGNoOiBldGFnIH0sIHVwZGF0ZUVudGl0eU9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcIlJlcGxhY2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlLnVwZGF0ZUVudGl0eSh0aGlzLnRhYmxlTmFtZSwgcGFydGl0aW9uS2V5LCByb3dLZXksIE9iamVjdC5hc3NpZ24oeyB0YWJsZUVudGl0eVByb3BlcnRpZXM6IHNlcmlhbGl6ZShlbnRpdHkpLCBpZk1hdGNoOiBldGFnIH0sIHVwZGF0ZUVudGl0eU9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgdXBkYXRlIG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbnRpdHlNb2RlOiBtb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwc2VydCBhbiBlbnRpdHkgaW4gdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSBlbnRpdHkgLSBUaGUgcHJvcGVydGllcyBmb3IgdGhlIHRhYmxlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBkaWZmZXJlbnQgbW9kZXMgZm9yIHVwZGF0aW5nIHRoZSBlbnRpdHk6XG4gICAgICogICAgICAgICAgICAgICAtIE1lcmdlOiBVcGRhdGVzIGFuIGVudGl0eSBieSB1cGRhdGluZyB0aGUgZW50aXR5J3MgcHJvcGVydGllcyB3aXRob3V0IHJlcGxhY2luZyB0aGUgZXhpc3RpbmcgZW50aXR5LlxuICAgICAqICAgICAgICAgICAgICAgLSBSZXBsYWNlOiBVcGRhdGVzIGFuIGV4aXN0aW5nIGVudGl0eSBieSByZXBsYWNpbmcgdGhlIGVudGlyZSBlbnRpdHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgdXBzZXJ0aW5nIGFuIGVudGl0eVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgeyBBenVyZU5hbWVkS2V5Q3JlZGVudGlhbCwgVGFibGVDbGllbnQgfSA9IHJlcXVpcmUoXCJAYXp1cmUvZGF0YS10YWJsZXNcIilcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gXCI8c3RvcmFnZSBhY2NvdW50IG5hbWU+XCI7XG4gICAgICogY29uc3QgYWNjb3VudEtleSA9IFwiPGFjY291bnQga2V5PlwiXG4gICAgICogY29uc3QgdGFibGVOYW1lID0gXCI8dGFibGUgbmFtZT5cIjtcbiAgICAgKiBjb25zdCBzaGFyZWRLZXlDcmVkZW50aWFsID0gbmV3IEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsKGFjY291bnQsIGFjY291bnRLZXkpO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFRhYmxlQ2xpZW50KFxuICAgICAqICAgYGh0dHBzOi8vJHthY2NvdW50fS50YWJsZS5jb3JlLndpbmRvd3MubmV0YCxcbiAgICAgKiAgIGAke3RhYmxlTmFtZX1gLFxuICAgICAqICAgc2hhcmVkS2V5Q3JlZGVudGlhbFxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBjb25zdCBlbnRpdHkgPSB7cGFydGl0aW9uS2V5OiBcInAxXCIsIHJvd0tleTogXCJyMVwiLCBiYXI6IFwidXBkYXRlZEJhclwifTtcbiAgICAgKlxuICAgICAqIC8vIFVwc2VydCB1c2VzIHVwZGF0ZSBtb2RlIFwiTWVyZ2VcIiBhcyBkZWZhdWx0LlxuICAgICAqIC8vIFRoaXMgYmVoYXZlcyBzaW1pbGFybHkgdG8gdXBkYXRlIGJ1dCBjcmVhdGVzIHRoZSBlbnRpdHlcbiAgICAgKiAvLyBpZiBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZXJ2aWNlXG4gICAgICogYXdhaXQgY2xpZW50LnVwc2VydEVudGl0eShlbnRpdHkpXG4gICAgICpcbiAgICAgKiAvLyBXZSBjYW4gYWxzbyBzZXQgdGhlIHVwZGF0ZSBtb2RlIHRvIFJlcGxhY2UuXG4gICAgICogLy8gVGhpcyBiZWhhdmVzIHNpbWlsYXJseSB0byB1cGRhdGUgYnV0IGNyZWF0ZXMgdGhlIGVudGl0eVxuICAgICAqIC8vIGlmIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlcnZpY2VcbiAgICAgKiBhd2FpdCBjbGllbnQudXBzZXJ0RW50aXR5KGVudGl0eSwgXCJSZXBsYWNlXCIpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdXBzZXJ0RW50aXR5KGVudGl0eSwgbW9kZSA9IFwiTWVyZ2VcIiwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhenVyZS9henVyZS1zZGsvdHMtbmFtaW5nLW9wdGlvbnNcbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdDbGllbnQud2l0aFNwYW4oXCJUYWJsZUNsaWVudC51cHNlcnRFbnRpdHlcIiwgb3B0aW9ucywgYXN5bmMgKHVwZGF0ZWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aXRpb25LZXkgPSBlc2NhcGVRdW90ZXMoZW50aXR5LnBhcnRpdGlvbktleSk7XG4gICAgICAgICAgICBjb25zdCByb3dLZXkgPSBlc2NhcGVRdW90ZXMoZW50aXR5LnJvd0tleSk7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJNZXJnZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGUubWVyZ2VFbnRpdHkodGhpcy50YWJsZU5hbWUsIHBhcnRpdGlvbktleSwgcm93S2V5LCBPYmplY3QuYXNzaWduKHsgdGFibGVFbnRpdHlQcm9wZXJ0aWVzOiBzZXJpYWxpemUoZW50aXR5KSB9LCB1cGRhdGVkT3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiUmVwbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGUudXBkYXRlRW50aXR5KHRoaXMudGFibGVOYW1lLCBwYXJ0aXRpb25LZXksIHJvd0tleSwgT2JqZWN0LmFzc2lnbih7IHRhYmxlRW50aXR5UHJvcGVydGllczogc2VyaWFsaXplKGVudGl0eSkgfSwgdXBkYXRlZE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgdXBkYXRlIG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICB1cHNlcnRFbnRpdHlNb2RlOiBtb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IGFueSBzdG9yZWQgYWNjZXNzIHBvbGljaWVzIHNwZWNpZmllZCBvbiB0aGUgdGFibGUgdGhhdCBtYXkgYmUgdXNlZCB3aXRoXG4gICAgICogU2hhcmVkIEFjY2VzcyBTaWduYXR1cmVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXRBY2Nlc3NQb2xpY3kob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQuZ2V0QWNjZXNzUG9saWN5XCIsIG9wdGlvbnMsIGFzeW5jICh1cGRhdGVkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkSWRlbnRpZmllcnMgPSBhd2FpdCB0aGlzLnRhYmxlLmdldEFjY2Vzc1BvbGljeSh0aGlzLnRhYmxlTmFtZSwgdXBkYXRlZE9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplU2lnbmVkSWRlbnRpZmllcihzaWduZWRJZGVudGlmaWVycyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHN0b3JlZCBhY2Nlc3MgcG9saWNpZXMgZm9yIHRoZSB0YWJsZSB0aGF0IG1heSBiZSB1c2VkIHdpdGggU2hhcmVkIEFjY2VzcyBTaWduYXR1cmVzLlxuICAgICAqIEBwYXJhbSB0YWJsZUFjbCAtIFRoZSBBY2Nlc3MgQ29udHJvbCBMaXN0IGZvciB0aGUgdGFibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHNldEFjY2Vzc1BvbGljeSh0YWJsZUFjbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nQ2xpZW50LndpdGhTcGFuKFwiVGFibGVDbGllbnQuc2V0QWNjZXNzUG9saWN5XCIsIG9wdGlvbnMsICh1cGRhdGVkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VybGlhbGl6ZWRBY2wgPSBzZXJpYWxpemVTaWduZWRJZGVudGlmaWVycyh0YWJsZUFjbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZS5zZXRBY2Nlc3NQb2xpY3kodGhpcy50YWJsZU5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZE9wdGlvbnMpLCB7IHRhYmxlQWNsOiBzZXJsaWFsaXplZEFjbCB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXRzIGEgVHJhbnNhY3Rpb24gd2hpY2ggaXMgY29tcG9zZWQgb2YgYSBzZXQgb2YgYWN0aW9ucy4gWW91IGNhbiBwcm92aWRlIHRoZSBhY3Rpb25zIGFzIGEgbGlzdFxuICAgICAqIG9yIHlvdSBjYW4gdXNlIHtAbGluayBUYWJsZVRyYW5zYWN0aW9ufSB0byBoZWxwIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHsgVGFibGVDbGllbnQgfSA9IHJlcXVpcmUoXCJAYXp1cmUvZGF0YS10YWJsZXNcIik7XG4gICAgICogY29uc3QgY29ubmVjdGlvblN0cmluZyA9IFwiPGNvbm5lY3Rpb24tc3RyaW5nPlwiXG4gICAgICogY29uc3QgdGFibGVOYW1lID0gXCI8dGFibGVOYW1lPlwiXG4gICAgICogY29uc3QgY2xpZW50ID0gVGFibGVDbGllbnQuZnJvbUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZywgdGFibGVOYW1lKTtcbiAgICAgKiBjb25zdCBhY3Rpb25zID0gW1xuICAgICAqICAgIFtcImNyZWF0ZVwiLCB7cGFydGl0aW9uS2V5OiBcInAxXCIsIHJvd0tleTogXCIxXCIsIGRhdGE6IFwidGVzdDFcIn1dLFxuICAgICAqICAgIFtcImRlbGV0ZVwiLCB7cGFydGl0aW9uS2V5OiBcInAxXCIsIHJvd0tleTogXCIyXCJ9XSxcbiAgICAgKiAgICBbXCJ1cGRhdGVcIiwge3BhcnRpdGlvbktleTogXCJwMVwiLCByb3dLZXk6IFwiM1wiLCBkYXRhOiBcIm5ld1Rlc3RcIn0sIFwiTWVyZ2VcIl1cbiAgICAgKiBdXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKGFjdGlvbnMpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRXhhbXBsZSB1c2FnZSB3aXRoIFRhYmxlVHJhbnNhY3Rpb246XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB7IFRhYmxlQ2xpZW50IH0gPSByZXF1aXJlKFwiQGF6dXJlL2RhdGEtdGFibGVzXCIpO1xuICAgICAqIGNvbnN0IGNvbm5lY3Rpb25TdHJpbmcgPSBcIjxjb25uZWN0aW9uLXN0cmluZz5cIlxuICAgICAqIGNvbnN0IHRhYmxlTmFtZSA9IFwiPHRhYmxlTmFtZT5cIlxuICAgICAqIGNvbnN0IGNsaWVudCA9IFRhYmxlQ2xpZW50LmZyb21Db25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcsIHRhYmxlTmFtZSk7XG4gICAgICogY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVGFibGVUcmFuc2FjdGlvbigpO1xuICAgICAqIC8vIENhbGwgdGhlIGF2YWlsYWJsZSBhY3Rpb24gaW4gdGhlIFRhYmxlVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICogdHJhbnNhY3Rpb24uY3JlYXRlKHtwYXJ0aXRpb25LZXk6IFwicDFcIiwgcm93S2V5OiBcIjFcIiwgZGF0YTogXCJ0ZXN0MVwifSk7XG4gICAgICogdHJhbnNhY3Rpb24uZGVsZXRlKFwicDFcIiwgXCIyXCIpO1xuICAgICAqIHRyYW5zYWN0aW9uLnVwZGF0ZSh7cGFydGl0aW9uS2V5OiBcInAxXCIsIHJvd0tleTogXCIzXCIsIGRhdGE6IFwibmV3VGVzdFwifSwgXCJNZXJnZVwiKVxuICAgICAqIC8vIHN1Ym1pdFRyYW5zYWN0aW9uIHdpdGggdGhlIGFjdGlvbnMgbGlzdCBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLmFjdGlvbnMpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvbnMgLSB0dXBsZSB0aGF0IGNvbnRhaW5zIHRoZSBhY3Rpb24gdG8gcGVyZm9ybSwgYW5kIHRoZSBlbnRpdHkgdG8gcGVyZm9ybSB0aGUgYWN0aW9uIHdpdGhcbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUcmFuc2FjdGlvbihhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbktleSA9IGFjdGlvbnNbMF1bMV0ucGFydGl0aW9uS2V5O1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gVXVpZC5nZW5lcmF0ZVV1aWQoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlc2V0SWQgPSBVdWlkLmdlbmVyYXRlVXVpZCgpO1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb25DbGllbnQpIHtcbiAgICAgICAgICAgIC8vIEFkZCBwaXBlbGluZVxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNsaWVudCA9IG5ldyBJbnRlcm5hbFRhYmxlVHJhbnNhY3Rpb24odGhpcy51cmwsIHBhcnRpdGlvbktleSwgdHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQsIHRoaXMuZ2VuZXJhdGVkQ2xpZW50LCBuZXcgVGFibGVDbGllbnQodGhpcy51cmwsIHRoaXMudGFibGVOYW1lKSwgdGhpcy5jcmVkZW50aWFsLCB0aGlzLmFsbG93SW5zZWN1cmVDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25DbGllbnQucmVzZXQodHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQsIHBhcnRpdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IFthY3Rpb24sIGVudGl0eSwgdXBkYXRlTW9kZSA9IFwiTWVyZ2VcIiwgdXBkYXRlT3B0aW9uc10gPSBpdGVtO1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY3JlYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25DbGllbnQuY3JlYXRlRW50aXR5KGVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNsaWVudC5kZWxldGVFbnRpdHkoZW50aXR5LnBhcnRpdGlvbktleSwgZW50aXR5LnJvd0tleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNsaWVudC51cGRhdGVFbnRpdHkoZW50aXR5LCB1cGRhdGVNb2RlLCB1cGRhdGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVwc2VydFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uQ2xpZW50LnVwc2VydEVudGl0eShlbnRpdHksIHVwZGF0ZU1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUYWJsZUNsaWVudCBmcm9tIGNvbm5lY3Rpb24gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25TdHJpbmcgLSBBY2NvdW50IGNvbm5lY3Rpb24gc3RyaW5nIG9yIGEgU0FTIGNvbm5lY3Rpb24gc3RyaW5nIG9mIGFuIEF6dXJlIHN0b3JhZ2UgYWNjb3VudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm90ZSAtIEFjY291bnQgY29ubmVjdGlvbiBzdHJpbmcgY2FuIG9ubHkgYmUgdXNlZCBpbiBOT0RFLkpTIHJ1bnRpbWUuIF1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY291bnQgY29ubmVjdGlvbiBzdHJpbmcgZXhhbXBsZSAtXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBgRGVmYXVsdEVuZHBvaW50c1Byb3RvY29sPWh0dHBzO0FjY291bnROYW1lPW15YWNjb3VudDtBY2NvdW50S2V5PWFjY291bnRLZXk7RW5kcG9pbnRTdWZmaXg9Y29yZS53aW5kb3dzLm5ldGBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNBUyBjb25uZWN0aW9uIHN0cmluZyBleGFtcGxlIC1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBCbG9iRW5kcG9pbnQ9aHR0cHM6Ly9teWFjY291bnQudGFibGUuY29yZS53aW5kb3dzLm5ldC87UXVldWVFbmRwb2ludD1odHRwczovL215YWNjb3VudC5xdWV1ZS5jb3JlLndpbmRvd3MubmV0LztGaWxlRW5kcG9pbnQ9aHR0cHM6Ly9teWFjY291bnQuZmlsZS5jb3JlLndpbmRvd3MubmV0LztUYWJsZUVuZHBvaW50PWh0dHBzOi8vbXlhY2NvdW50LnRhYmxlLmNvcmUud2luZG93cy5uZXQvO1NoYXJlZEFjY2Vzc1NpZ25hdHVyZT1zYXNTdHJpbmdgXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgSFRUUCBwaXBlbGluZS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBUYWJsZUNsaWVudCBmcm9tIHRoZSBnaXZlbiBjb25uZWN0aW9uIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZywgdGFibGVOYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGF6dXJlL2F6dXJlLXNkay90cy1uYW1pbmctb3B0aW9uc1xuICAgIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1cmwsIG9wdGlvbnM6IGNsaWVudE9wdGlvbnMsIGNyZWRlbnRpYWwsIH0gPSBnZXRDbGllbnRQYXJhbXNGcm9tQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGNyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVDbGllbnQodXJsLCB0YWJsZU5hbWUsIGNyZWRlbnRpYWwsIGNsaWVudE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZUNsaWVudCh1cmwsIHRhYmxlTmFtZSwgY2xpZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZUNsaWVudC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IEhlYWRlckNvbnN0YW50cywgVFJBTlNBQ1RJT05fSFRUUF9MSU5FX0VORElORywgVFJBTlNBQ1RJT05fSFRUUF9WRVJTSU9OXzFfMSwgfSBmcm9tIFwiLi91dGlscy9jb25zdGFudHNcIjtcbmltcG9ydCB7IGNyZWF0ZUh0dHBIZWFkZXJzLCBjcmVhdGVQaXBlbGluZVJlcXVlc3QsIH0gZnJvbSBcIkBhenVyZS9jb3JlLXJlc3QtcGlwZWxpbmVcIjtcbmltcG9ydCB7IGdldENoYW5nZVNldEJvdW5kYXJ5IH0gZnJvbSBcIi4vdXRpbHMvdHJhbnNhY3Rpb25IZWxwZXJzXCI7XG5leHBvcnQgY29uc3QgdHJhbnNhY3Rpb25SZXF1ZXN0QXNzZW1ibGVQb2xpY3lOYW1lID0gXCJ0cmFuc2FjdGlvblJlcXVlc3RBc3NlbWJsZVBvbGljeVwiO1xuY29uc3QgZHVtbXlSZXNwb25zZSA9IHtcbiAgICByZXF1ZXN0OiBjcmVhdGVQaXBlbGluZVJlcXVlc3QoeyB1cmw6IFwiRkFLRVwiIH0pLFxuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IGNyZWF0ZUh0dHBIZWFkZXJzKCksXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zYWN0aW9uUmVxdWVzdEFzc2VtYmxlUG9saWN5KGJvZHlQYXJ0cywgY2hhbmdlc2V0SWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0cmFuc2FjdGlvblJlcXVlc3RBc3NlbWJsZVBvbGljeU5hbWUsXG4gICAgICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlJlcXVlc3QgPSBnZXROZXh0U3VicmVxdWVzdEJvZHlQYXJ0KHJlcXVlc3QsIGNoYW5nZXNldElkKTtcbiAgICAgICAgICAgIGJvZHlQYXJ0cy5wdXNoKHN1YlJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gSW50ZXJjZXB0IHJlcXVlc3QgZnJvbSBnb2luZyB0byB3aXJlXG4gICAgICAgICAgICByZXR1cm4gZHVtbXlSZXNwb25zZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IHRyYW5zYWN0aW9uSGVhZGVyRmlsdGVyUG9saWN5TmFtZSA9IFwidHJhbnNhY3Rpb25IZWFkZXJGaWx0ZXJQb2xpY3lcIjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdGlvbkhlYWRlckZpbHRlclBvbGljeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0cmFuc2FjdGlvbkhlYWRlckZpbHRlclBvbGljeU5hbWUsXG4gICAgICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG5leHQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzdWJyZXF1ZXN0cyBzaG91bGQgbm90IGhhdmUgdGhlIHgtbXMtdmVyc2lvbiBoZWFkZXIuXG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKEhlYWRlckNvbnN0YW50cy5YX01TX1ZFUlNJT04pO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQocmVxdWVzdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1YlJlcXVlc3RVcmwodXJsKSB7XG4gICAgY29uc3Qgc2FzVG9rZW5QYXJ0cyA9IFtcInN2XCIsIFwic3NcIiwgXCJzcnRcIiwgXCJzcFwiLCBcInNlXCIsIFwic3RcIiwgXCJzcHJcIiwgXCJzaWdcIl07XG4gICAgY29uc3QgdXJsUGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICAgIHNhc1Rva2VuUGFydHMuZm9yRWFjaCgocGFydCkgPT4gdXJsUGFyc2VkLnNlYXJjaFBhcmFtcy5kZWxldGUocGFydCkpO1xuICAgIHJldHVybiB1cmxQYXJzZWQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldE5leHRTdWJyZXF1ZXN0Qm9keVBhcnQocmVxdWVzdCwgY2hhbmdlc2V0SWQpIHtcbiAgICBjb25zdCBjaGFuZ2VzZXRCb3VuZGFyeSA9IGdldENoYW5nZVNldEJvdW5kYXJ5KGNoYW5nZXNldElkKTtcbiAgICBjb25zdCBzdWJSZXF1ZXN0UHJlZml4ID0gYC0tJHtjaGFuZ2VzZXRCb3VuZGFyeX0ke1RSQU5TQUNUSU9OX0hUVFBfTElORV9FTkRJTkd9JHtIZWFkZXJDb25zdGFudHMuQ09OVEVOVF9UWVBFfTogYXBwbGljYXRpb24vaHR0cCR7VFJBTlNBQ1RJT05fSFRUUF9MSU5FX0VORElOR30ke0hlYWRlckNvbnN0YW50cy5DT05URU5UX1RSQU5TRkVSX0VOQ09ESU5HfTogYmluYXJ5YDtcbiAgICBjb25zdCBzdWJSZXF1ZXN0VXJsID0gZ2V0U3ViUmVxdWVzdFVybChyZXF1ZXN0LnVybCk7XG4gICAgLy8gU3RhcnQgdG8gYXNzZW1ibGUgc3ViIHJlcXVlc3RcbiAgICBjb25zdCBzdWJSZXF1ZXN0ID0gW1xuICAgICAgICBzdWJSZXF1ZXN0UHJlZml4LFxuICAgICAgICBcIlwiLFxuICAgICAgICBgJHtyZXF1ZXN0Lm1ldGhvZC50b1N0cmluZygpfSAke3N1YlJlcXVlc3RVcmx9ICR7VFJBTlNBQ1RJT05fSFRUUF9WRVJTSU9OXzFfMX1gLCAvLyBzdWIgcmVxdWVzdCBzdGFydCBsaW5lIHdpdGggbWV0aG9kLFxuICAgIF07XG4gICAgLy8gQWRkIHJlcXVpcmVkIGhlYWRlcnNcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcmVxdWVzdC5oZWFkZXJzKSB7XG4gICAgICAgIHN1YlJlcXVlc3QucHVzaChgJHtuYW1lfTogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHN1Yi1yZXF1ZXN0IGJvZHlcbiAgICBzdWJSZXF1ZXN0LnB1c2goYCR7VFJBTlNBQ1RJT05fSFRUUF9MSU5FX0VORElOR31gKTsgLy8gc3ViIHJlcXVlc3QncyBoZWFkZXJzIG5lZWQgZW5kIHdpdGggYW4gZW1wdHkgbGluZVxuICAgIGlmIChyZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgc3ViUmVxdWVzdC5wdXNoKFN0cmluZyhyZXF1ZXN0LmJvZHkpKTtcbiAgICB9XG4gICAgLy8gQWRkIHN1YnJlcXVlc3QgdG8gdHJhbnNhY3Rpb24gYm9keVxuICAgIHJldHVybiBzdWJSZXF1ZXN0LmpvaW4oVFJBTlNBQ1RJT05fSFRUUF9MSU5FX0VORElORyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZVBvbGljaWVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgc2VyaWFsaXphdGlvblBvbGljeSwgc2VyaWFsaXphdGlvblBvbGljeU5hbWUsIH0gZnJvbSBcIkBhenVyZS9jb3JlLWNsaWVudFwiO1xuaW1wb3J0IHsgUmVzdEVycm9yLCBjcmVhdGVIdHRwSGVhZGVycywgY3JlYXRlUGlwZWxpbmVSZXF1ZXN0LCB9IGZyb20gXCJAYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lXCI7XG5pbXBvcnQgeyBnZXRJbml0aWFsVHJhbnNhY3Rpb25Cb2R5LCBnZXRUcmFuc2FjdGlvbkh0dHBSZXF1ZXN0Qm9keSwgfSBmcm9tIFwiLi91dGlscy90cmFuc2FjdGlvbkhlbHBlcnNcIjtcbmltcG9ydCB7IHRyYW5zYWN0aW9uSGVhZGVyRmlsdGVyUG9saWN5LCB0cmFuc2FjdGlvbkhlYWRlckZpbHRlclBvbGljeU5hbWUsIHRyYW5zYWN0aW9uUmVxdWVzdEFzc2VtYmxlUG9saWN5LCB0cmFuc2FjdGlvblJlcXVlc3RBc3NlbWJsZVBvbGljeU5hbWUsIH0gZnJvbSBcIi4vVGFibGVQb2xpY2llc1wiO1xuaW1wb3J0IHsgY29zbW9zUGF0Y2hQb2xpY3kgfSBmcm9tIFwiLi9jb3Ntb3NQYXRoUG9saWN5XCI7XG5pbXBvcnQgeyBnZXRUcmFuc2FjdGlvbkhlYWRlcnMgfSBmcm9tIFwiLi91dGlscy90cmFuc2FjdGlvbkhlYWRlcnNcIjtcbmltcG9ydCB7IGlzQ29zbW9zRW5kcG9pbnQgfSBmcm9tIFwiLi91dGlscy9pc0Nvc21vc0VuZHBvaW50XCI7XG5pbXBvcnQgeyB0cmFjaW5nQ2xpZW50IH0gZnJvbSBcIi4vdXRpbHMvdHJhY2luZ1wiO1xuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYSBsaXN0IG9mIHRyYW5zYWN0aW9uIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFRhYmxlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucyAhPT0gbnVsbCAmJiBhY3Rpb25zICE9PSB2b2lkIDAgPyBhY3Rpb25zIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjcmVhdGUgYWN0aW9uIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBlbnRpdHkgLSBlbnRpdHkgdG8gY3JlYXRlXG4gICAgICovXG4gICAgY3JlYXRlRW50aXR5KGVudGl0eSkge1xuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaChbXCJjcmVhdGVcIiwgZW50aXR5XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBkZWxldGUgYWN0aW9uIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBwYXJ0aXRpb25LZXkgLSBwYXJ0aXRpb24ga2V5IG9mIHRoZSBlbnRpdHkgdG8gZGVsZXRlXG4gICAgICogQHBhcmFtIHJvd0tleSAtIHJvd0tleSBvZiB0aGUgZW50aXR5IHRvIGRlbGV0ZVxuICAgICAqL1xuICAgIGRlbGV0ZUVudGl0eShwYXJ0aXRpb25LZXksIHJvd0tleSkge1xuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaChbXCJkZWxldGVcIiwgeyBwYXJ0aXRpb25LZXksIHJvd0tleSB9XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gdXBkYXRlIGFjdGlvbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gZW50aXR5IC0gZW50aXR5IHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB1cGRhdGVNb2RlT3JPcHRpb25zIC0gdXBkYXRlIG1vZGUgb3IgdXBkYXRlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdXBkYXRlT3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSB1cGRhdGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdXBkYXRlRW50aXR5KGVudGl0eSwgdXBkYXRlTW9kZU9yT3B0aW9ucywgdXBkYXRlT3B0aW9ucykge1xuICAgICAgICAvLyBVcGRhdGVNb2RlIGlzIGEgc3RyaW5nIHVuaW9uXG4gICAgICAgIGNvbnN0IHJlYWxVcGRhdGVNb2RlID0gdHlwZW9mIHVwZGF0ZU1vZGVPck9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyB1cGRhdGVNb2RlT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZWFsVXBkYXRlT3B0aW9ucyA9IHR5cGVvZiB1cGRhdGVNb2RlT3JPcHRpb25zID09PSBcIm9iamVjdFwiID8gdXBkYXRlTW9kZU9yT3B0aW9ucyA6IHVwZGF0ZU9wdGlvbnM7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKFtcInVwZGF0ZVwiLCBlbnRpdHksIHJlYWxVcGRhdGVNb2RlICE9PSBudWxsICYmIHJlYWxVcGRhdGVNb2RlICE9PSB2b2lkIDAgPyByZWFsVXBkYXRlTW9kZSA6IFwiTWVyZ2VcIiwgcmVhbFVwZGF0ZU9wdGlvbnMgIT09IG51bGwgJiYgcmVhbFVwZGF0ZU9wdGlvbnMgIT09IHZvaWQgMCA/IHJlYWxVcGRhdGVPcHRpb25zIDoge31dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB1cHNlcnQgYWN0aW9uIHRvIHRoZSB0cmFuc2FjdGlvbiwgd2hpY2ggaW5zZXJ0cyBpZiB0aGUgZW50aXR5IGRvZXNuJ3QgZXhpc3Qgb3IgdXBkYXRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICogQHBhcmFtIGVudGl0eSAtIGVudGl0eSB0byB1cHNlcnRcbiAgICAgKiBAcGFyYW0gdXBkYXRlTW9kZSAtIHVwZGF0ZSBtb2RlXG4gICAgICovXG4gICAgdXBzZXJ0RW50aXR5KGVudGl0eSwgdXBkYXRlTW9kZSA9IFwiTWVyZ2VcIikge1xuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaChbXCJ1cHNlcnRcIiwgZW50aXR5LCB1cGRhdGVNb2RlXSk7XG4gICAgfVxufVxuLyoqXG4gKiBUYWJsZVRyYW5zYWN0aW9uIGNvbGxlY3RzIHN1Yi1vcGVyYXRpb25zIHRoYXQgY2FuIGJlIHN1Ym1pdHRlZCB0b2dldGhlciB2aWEgc3VibWl0VHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVybmFsVGFibGVUcmFuc2FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHVybCAtIFRhYmxlcyBhY2NvdW50IHVybFxuICAgICAqIEBwYXJhbSBwYXJ0aXRpb25LZXkgLSBwYXJ0aXRpb24ga2V5XG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWwgLSBjcmVkZW50aWFsIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcGFydGl0aW9uS2V5LCB0cmFuc2FjdGlvbklkLCBjaGFuZ2VzZXRJZCwgY2xpZW50LCBpbnRlcmNlcHRDbGllbnQsIGNyZWRlbnRpYWwsIGFsbG93SW5zZWN1cmVDb25uZWN0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmludGVyY2VwdENsaWVudCA9IGludGVyY2VwdENsaWVudDtcbiAgICAgICAgdGhpcy5hbGxvd0luc2VjdXJlQ29ubmVjdGlvbiA9IGFsbG93SW5zZWN1cmVDb25uZWN0aW9uO1xuICAgICAgICAvLyBJbml0aWFsaXplIFJlc2V0LWFibGUgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnJlc2V0YWJsZVN0YXRlID0gdGhpcy5pbml0aWFsaXplU2hhcmVkU3RhdGUodHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQsIHBhcnRpdGlvbktleSk7XG4gICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgYXV0aCBtZXRob2QgdXNlZCB3ZSBuZWVkIHRvIGJ1aWxkIHRoZSB1cmxcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBTQVMgdG9rZW4gaXMgcHJvdmlkZWQgYXMgcGFydCBvZiB0aGUgVVJMIHdlIG5lZWQgdG8gbW92ZSBpdCBhZnRlciAkYmF0Y2hcbiAgICAgICAgICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsUGFydHNbMF07XG4gICAgICAgICAgICBjb25zdCBzYXMgPSB1cmxQYXJ0cy5sZW5ndGggPiAxID8gYD8ke3VybFBhcnRzWzFdfWAgOiBcIlwiO1xuICAgICAgICAgICAgdGhpcy51cmwgPSBgJHt0aGlzLmdldFVybFdpdGhTbGFzaCgpfSRiYXRjaCR7c2FzfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGEgU2hhcmVkS2V5IGNyZWRlbnRpYWwgbm8gU0FTIHRva2VuIGlzIG5lZWRlZFxuICAgICAgICAgICAgdGhpcy51cmwgPSBgJHt0aGlzLmdldFVybFdpdGhTbGFzaCgpfSRiYXRjaGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVzZXQodHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQsIHBhcnRpdGlvbktleSkge1xuICAgICAgICB0aGlzLnJlc2V0YWJsZVN0YXRlID0gdGhpcy5pbml0aWFsaXplU2hhcmVkU3RhdGUodHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQsIHBhcnRpdGlvbktleSk7XG4gICAgfVxuICAgIGluaXRpYWxpemVTaGFyZWRTdGF0ZSh0cmFuc2FjdGlvbklkLCBjaGFuZ2VzZXRJZCwgcGFydGl0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdPcGVyYXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IGJvZHlQYXJ0cyA9IGdldEluaXRpYWxUcmFuc2FjdGlvbkJvZHkodHJhbnNhY3Rpb25JZCwgY2hhbmdlc2V0SWQpO1xuICAgICAgICBjb25zdCBpc0Nvc21vcyA9IGlzQ29zbW9zRW5kcG9pbnQodGhpcy51cmwpO1xuICAgICAgICBwcmVwYXRlVHJhbnNhY3Rpb25QaXBlbGluZSh0aGlzLmludGVyY2VwdENsaWVudC5waXBlbGluZSwgYm9keVBhcnRzLCBjaGFuZ2VzZXRJZCwgaXNDb3Ntb3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICAgIGNoYW5nZXNldElkLFxuICAgICAgICAgICAgcGFydGl0aW9uS2V5LFxuICAgICAgICAgICAgcGVuZGluZ09wZXJhdGlvbnMsXG4gICAgICAgICAgICBib2R5UGFydHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjcmVhdGVFbnRpdHkgb3BlcmF0aW9uIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBlbnRpdHkgLSBFbnRpdHkgdG8gY3JlYXRlXG4gICAgICovXG4gICAgY3JlYXRlRW50aXR5KGVudGl0eSkge1xuICAgICAgICB0aGlzLmNoZWNrUGFydGl0aW9uS2V5KGVudGl0eS5wYXJ0aXRpb25LZXkpO1xuICAgICAgICB0aGlzLnJlc2V0YWJsZVN0YXRlLnBlbmRpbmdPcGVyYXRpb25zLnB1c2godGhpcy5pbnRlcmNlcHRDbGllbnQuY3JlYXRlRW50aXR5KGVudGl0eSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY3JlYXRlRW50aXR5IG9wZXJhdGlvbiB0byB0aGUgdHJhbnNhY3Rpb24gcGVyIGVhY2ggZW50aXR5IGluIHRoZSBlbnRpdGllcyBhcnJheVxuICAgICAqIEBwYXJhbSBlbnRpdGllcyAtIEFycmF5IG9mIGVudGl0aWVzIHRvIGNyZWF0ZVxuICAgICAqL1xuICAgIGNyZWF0ZUVudGl0aWVzKGVudGl0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFydGl0aW9uS2V5KGVudGl0eS5wYXJ0aXRpb25LZXkpO1xuICAgICAgICAgICAgdGhpcy5yZXNldGFibGVTdGF0ZS5wZW5kaW5nT3BlcmF0aW9ucy5wdXNoKHRoaXMuaW50ZXJjZXB0Q2xpZW50LmNyZWF0ZUVudGl0eShlbnRpdHkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZGVsZXRlRW50aXR5IG9wZXJhdGlvbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gcGFydGl0aW9uS2V5IC0gUGFydGl0aW9uIGtleSBvZiB0aGUgZW50aXR5IHRvIGRlbGV0ZVxuICAgICAqIEBwYXJhbSByb3dLZXkgLSBSb3cga2V5IG9mIHRoZSBlbnRpdHkgdG8gZGVsZXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGVsZXRlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZUVudGl0eShwYXJ0aXRpb25LZXksIHJvd0tleSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoZWNrUGFydGl0aW9uS2V5KHBhcnRpdGlvbktleSk7XG4gICAgICAgIHRoaXMucmVzZXRhYmxlU3RhdGUucGVuZGluZ09wZXJhdGlvbnMucHVzaCh0aGlzLmludGVyY2VwdENsaWVudC5kZWxldGVFbnRpdHkocGFydGl0aW9uS2V5LCByb3dLZXksIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB1cGRhdGVFbnRpdHkgb3BlcmF0aW9uIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBlbnRpdHkgLSBFbnRpdHkgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIG1vZGUgLSBVcGRhdGUgbW9kZSAoTWVyZ2Ugb3IgUmVwbGFjZSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB1cGRhdGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdXBkYXRlRW50aXR5KGVudGl0eSwgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoZWNrUGFydGl0aW9uS2V5KGVudGl0eS5wYXJ0aXRpb25LZXkpO1xuICAgICAgICB0aGlzLnJlc2V0YWJsZVN0YXRlLnBlbmRpbmdPcGVyYXRpb25zLnB1c2godGhpcy5pbnRlcmNlcHRDbGllbnQudXBkYXRlRW50aXR5KGVudGl0eSwgbW9kZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIHVwc2VydEVudGl0eSBvcGVyYXRpb24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGVudGl0eSAtIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgdGFibGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSBtb2RlICAgLSBUaGUgZGlmZmVyZW50IG1vZGVzIGZvciB1cGRhdGluZyB0aGUgZW50aXR5OlxuICAgICAqICAgICAgICAgICAgICAgLSBNZXJnZTogVXBkYXRlcyBhbiBlbnRpdHkgYnkgdXBkYXRpbmcgdGhlIGVudGl0eSdzIHByb3BlcnRpZXMgd2l0aG91dCByZXBsYWNpbmcgdGhlIGV4aXN0aW5nIGVudGl0eS5cbiAgICAgKiAgICAgICAgICAgICAgIC0gUmVwbGFjZTogVXBkYXRlcyBhbiBleGlzdGluZyBlbnRpdHkgYnkgcmVwbGFjaW5nIHRoZSBlbnRpcmUgZW50aXR5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB1cHNlcnRFbnRpdHkoZW50aXR5LCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJ0aXRpb25LZXkoZW50aXR5LnBhcnRpdGlvbktleSk7XG4gICAgICAgIHRoaXMucmVzZXRhYmxlU3RhdGUucGVuZGluZ09wZXJhdGlvbnMucHVzaCh0aGlzLmludGVyY2VwdENsaWVudC51cHNlcnRFbnRpdHkoZW50aXR5LCBtb2RlLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdHMgdGhlIG9wZXJhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMucmVzZXRhYmxlU3RhdGUucGVuZGluZ09wZXJhdGlvbnMpO1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHJhbnNhY3Rpb25IdHRwUmVxdWVzdEJvZHkodGhpcy5yZXNldGFibGVTdGF0ZS5ib2R5UGFydHMsIHRoaXMucmVzZXRhYmxlU3RhdGUudHJhbnNhY3Rpb25JZCwgdGhpcy5yZXNldGFibGVTdGF0ZS5jaGFuZ2VzZXRJZCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRUcmFuc2FjdGlvbkhlYWRlcnModGhpcy5yZXNldGFibGVTdGF0ZS50cmFuc2FjdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdDbGllbnQud2l0aFNwYW4oXCJUYWJsZVRyYW5zYWN0aW9uLnN1Ym1pdFRyYW5zYWN0aW9uXCIsIHt9LCBhc3luYyAodXBkYXRlZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVQaXBlbGluZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNyZWF0ZUh0dHBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIHRyYWNpbmdPcHRpb25zOiB1cGRhdGVkT3B0aW9ucy50cmFjaW5nT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhbGxvd0luc2VjdXJlQ29ubmVjdGlvbjogdGhpcy5hbGxvd0luc2VjdXJlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb25SZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJhbnNhY3Rpb25SZXNwb25zZShyYXdUcmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrUGFydGl0aW9uS2V5KHBhcnRpdGlvbktleSkge1xuICAgICAgICBpZiAodGhpcy5yZXNldGFibGVTdGF0ZS5wYXJ0aXRpb25LZXkgIT09IHBhcnRpdGlvbktleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIG9wZXJhdGlvbnMgaW4gYSB0cmFuc2FjdGlvbiBtdXN0IHRhcmdldCB0aGUgc2FtZSBwYXJ0aXRpb25LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXJsV2l0aFNsYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuZW5kc1dpdGgoXCIvXCIpID8gdGhpcy51cmwgOiBgJHt0aGlzLnVybH0vYDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmFuc2FjdGlvblJlc3BvbnNlKHRyYW5zYWN0aW9uUmVzcG9uc2UpIHtcbiAgICBjb25zdCBzdWJSZXNwb25zZVByZWZpeCA9IGAtLWNoYW5nZXNldHJlc3BvbnNlX2A7XG4gICAgY29uc3Qgc3RhdHVzID0gdHJhbnNhY3Rpb25SZXNwb25zZS5zdGF0dXM7XG4gICAgY29uc3QgcmF3Qm9keSA9IHRyYW5zYWN0aW9uUmVzcG9uc2UuYm9keUFzVGV4dCB8fCBcIlwiO1xuICAgIGNvbnN0IHNwbGl0Qm9keSA9IHJhd0JvZHkuc3BsaXQoc3ViUmVzcG9uc2VQcmVmaXgpO1xuICAgIGNvbnN0IGlzU3VjY2Vzc0J5U3RhdHVzID0gMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPCAzMDA7XG4gICAgaWYgKCFpc1N1Y2Nlc3NCeVN0YXR1cykge1xuICAgICAgICBoYW5kbGVCb2R5RXJyb3IocmF3Qm9keSwgc3RhdHVzLCB0cmFuc2FjdGlvblJlc3BvbnNlLnJlcXVlc3QsIHRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICAvLyBEcm9wcGluZyB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudHMgYXMgdGhleSBhcmUgdGhlIGJvdW5kYXJpZXNcbiAgICAvLyB3ZSBqdXN0IGNhcmUgYWJvdXQgc3ViIHJlcXVlc3QgY29udGVudFxuICAgIGNvbnN0IHN1YlJlc3BvbnNlcyA9IHNwbGl0Qm9keS5zbGljZSgxLCBzcGxpdEJvZHkubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgcmVzcG9uc2VzID0gc3ViUmVzcG9uc2VzLm1hcCgoc3ViUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzTWF0Y2ggPSBzdWJSZXNwb25zZS5tYXRjaCgvSFRUUFxcLzEuMSAoWzAtOV0qKS8pO1xuICAgICAgICBpZiAoKHN0YXR1c01hdGNoID09PSBudWxsIHx8IHN0YXR1c01hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0dXNNYXRjaC5sZW5ndGgpICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGV4dHJhY3Qgc3RhdHVzIGZyb20gc3ViLXJlc3BvbnNlOlxcbiAke3N1YlJlc3BvbnNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YlJlc3BvbnNlU3RhdHVzID0gTnVtYmVyLnBhcnNlSW50KHN0YXR1c01hdGNoWzFdKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHN1YlJlc3BvbnNlU3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBzdWItcmVzcG9uc2Ugc3RhdHVzIHRvIGJlIGFuIGludGVnZXIgJHtzdWJSZXNwb25zZVN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5TWF0Y2ggPSBzdWJSZXNwb25zZS5tYXRjaCgvXFx7KC4qKVxcfS8pO1xuICAgICAgICBpZiAoKGJvZHlNYXRjaCA9PT0gbnVsbCB8fCBib2R5TWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlNYXRjaC5sZW5ndGgpID09PSAyKSB7XG4gICAgICAgICAgICBoYW5kbGVCb2R5RXJyb3IoYm9keU1hdGNoWzBdLCBzdWJSZXNwb25zZVN0YXR1cywgdHJhbnNhY3Rpb25SZXNwb25zZS5yZXF1ZXN0LCB0cmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldGFnTWF0Y2ggPSBzdWJSZXNwb25zZS5tYXRjaCgvRVRhZzogKC4qKS8pO1xuICAgICAgICBjb25zdCByb3dLZXlNYXRjaCA9IHN1YlJlc3BvbnNlLm1hdGNoKC9Sb3dLZXk9JyguKiknLyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBzdGF0dXM6IHN1YlJlc3BvbnNlU3RhdHVzIH0sICgocm93S2V5TWF0Y2ggPT09IG51bGwgfHwgcm93S2V5TWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd0tleU1hdGNoLmxlbmd0aCkgPT09IDIgJiYgeyByb3dLZXk6IHJvd0tleU1hdGNoWzFdIH0pKSwgKChldGFnTWF0Y2ggPT09IG51bGwgfHwgZXRhZ01hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldGFnTWF0Y2gubGVuZ3RoKSA9PT0gMiAmJiB7IGV0YWc6IGV0YWdNYXRjaFsxXSB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdWJSZXNwb25zZXM6IHJlc3BvbnNlcyxcbiAgICAgICAgZ2V0UmVzcG9uc2VGb3JFbnRpdHk6IChyb3dLZXkpID0+IHJlc3BvbnNlcy5maW5kKChyKSA9PiByLnJvd0tleSA9PT0gcm93S2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQm9keUVycm9yKGJvZHlBc1RleHQsIHN0YXR1c0NvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgcGFyc2VkRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRXJyb3IgPSBKU09OLnBhcnNlKGJvZHlBc1RleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoX2MpIHtcbiAgICAgICAgcGFyc2VkRXJyb3IgPSB7fTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBcIlRyYW5zYWN0aW9uIEZhaWxlZFwiO1xuICAgIGxldCBjb2RlO1xuICAgIC8vIE9ubHkgdHJhbnNhY3Rpb24gc3ViLXJlc3BvbnNlcyByZXR1cm4gYm9keVxuICAgIGlmIChwYXJzZWRFcnJvciAmJiBwYXJzZWRFcnJvcltcIm9kYXRhLmVycm9yXCJdKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gcGFyc2VkRXJyb3JbXCJvZGF0YS5lcnJvclwiXTtcbiAgICAgICAgbWVzc2FnZSA9IChfYiA9IChfYSA9IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbWVzc2FnZTtcbiAgICAgICAgY29kZSA9IGVycm9yLmNvZGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXN0RXJyb3IobWVzc2FnZSwge1xuICAgICAgICBjb2RlLFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXNwb25zZSxcbiAgICB9KTtcbn1cbi8qKlxuICogUHJlcGFyZXMgdGhlIHRyYW5zYWN0aW9uIHBpcGVsaW5lIHRvIGludGVyY2VwdCBvcGVyYXRpb25zXG4gKiBAcGFyYW0gcGlwZWxpbmUgLSBDbGllbnQgcGlwZWxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhdGVUcmFuc2FjdGlvblBpcGVsaW5lKHBpcGVsaW5lLCBib2R5UGFydHMsIGNoYW5nZXNldElkLCBpc0Nvc21vcykge1xuICAgIC8vIEZpc3QsIHdlIG5lZWQgdG8gY2xlYXIgYWxsIHRoZSBleGlzdGluZyBwb2xpY2llcyB0byBtYWtlIHN1cmUgd2Ugc3RhcnRcbiAgICAvLyB3aXRoIGEgZnJlc2ggc3RhdGUuXG4gICAgY29uc3QgcG9saWNpZXMgPSBwaXBlbGluZS5nZXRPcmRlcmVkUG9saWNpZXMoKTtcbiAgICBmb3IgKGNvbnN0IHBvbGljeSBvZiBwb2xpY2llcykge1xuICAgICAgICBwaXBlbGluZS5yZW1vdmVQb2xpY3koe1xuICAgICAgICAgICAgbmFtZTogcG9saWN5Lm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBXaXRoIHRoZSBjbGVhciBzdGF0ZSB3ZSBub3cgaW5pdGlhbGl6ZSB0aGUgcGlwZWxpbmVzIHJlcXVpcmVkIGZvciBpbnRlcmNlcHRpbmcgdGhlIHJlcXVlc3RzLlxuICAgIC8vIFVzZSB0cmFuc2FjdGlvbiBhc3NlbWJsZSBwb2xpY3kgdG8gYXNzZW1ibGUgcmVxdWVzdCBhbmQgaW50ZXJjZXB0IHJlcXVlc3QgZnJvbSBnb2luZyB0byB3aXJlXG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KHNlcmlhbGl6YXRpb25Qb2xpY3koKSwgeyBwaGFzZTogXCJTZXJpYWxpemVcIiB9KTtcbiAgICBwaXBlbGluZS5hZGRQb2xpY3kodHJhbnNhY3Rpb25IZWFkZXJGaWx0ZXJQb2xpY3koKSk7XG4gICAgcGlwZWxpbmUuYWRkUG9saWN5KHRyYW5zYWN0aW9uUmVxdWVzdEFzc2VtYmxlUG9saWN5KGJvZHlQYXJ0cywgY2hhbmdlc2V0SWQpKTtcbiAgICBpZiAoaXNDb3Ntb3MpIHtcbiAgICAgICAgcGlwZWxpbmUuYWRkUG9saWN5KGNvc21vc1BhdGNoUG9saWN5KCksIHtcbiAgICAgICAgICAgIGFmdGVyUG9saWNpZXM6IFt0cmFuc2FjdGlvbkhlYWRlckZpbHRlclBvbGljeU5hbWVdLFxuICAgICAgICAgICAgYmVmb3JlUG9saWNpZXM6IFtzZXJpYWxpemF0aW9uUG9saWN5TmFtZSwgdHJhbnNhY3Rpb25SZXF1ZXN0QXNzZW1ibGVQb2xpY3lOYW1lXSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFibGVUcmFuc2FjdGlvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmNvbnN0IGNvc21vc1BhdGNoUG9saWN5TmFtZSA9IFwiY29zbW9zUGF0Y2hQb2xpY3lcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb3Ntb3NQYXRjaFBvbGljeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBjb3Ntb3NQYXRjaFBvbGljeU5hbWUsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiAocmVxdWVzdCwgbmV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBcIlBBVENIXCIpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoXCJYLUhUVFAtTWV0aG9kXCIsIFwiTUVSR0VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zbW9zUGF0aFBvbGljeS5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgTWljcm9zb2Z0IChSKSBBdXRvUmVzdCBDb2RlIEdlbmVyYXRvci5cbiAqIENoYW5nZXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvciBhbmQgd2lsbCBiZSBsb3N0IGlmIHRoZSBjb2RlIGlzIHJlZ2VuZXJhdGVkLlxuICovXG5pbXBvcnQgKiBhcyBjb3JlQ2xpZW50IGZyb20gXCJAYXp1cmUvY29yZS1jbGllbnRcIjtcbmltcG9ydCB7IFRhYmxlSW1wbCwgU2VydmljZUltcGwgfSBmcm9tIFwiLi9vcGVyYXRpb25zXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgR2VuZXJhdGVkQ2xpZW50IGV4dGVuZHMgY29yZUNsaWVudC5TZXJ2aWNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgR2VuZXJhdGVkQ2xpZW50IGNsYXNzLlxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCBvZiB0aGUgc2VydmljZSBhY2NvdW50IG9yIHRhYmxlIHRoYXQgaXMgdGhlIHRhcmdldCBvZiB0aGUgZGVzaXJlZCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIHBhcmFtZXRlciBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3VybCcgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6aW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYWNrYWdlRGV0YWlscyA9IGBhenNkay1qcy1kYXRhLXRhYmxlcy8xMy4xLjJgO1xuICAgICAgICBjb25zdCB1c2VyQWdlbnRQcmVmaXggPSBvcHRpb25zLnVzZXJBZ2VudE9wdGlvbnMgJiYgb3B0aW9ucy51c2VyQWdlbnRPcHRpb25zLnVzZXJBZ2VudFByZWZpeFxuICAgICAgICAgICAgPyBgJHtvcHRpb25zLnVzZXJBZ2VudE9wdGlvbnMudXNlckFnZW50UHJlZml4fSAke3BhY2thZ2VEZXRhaWxzfWBcbiAgICAgICAgICAgIDogYCR7cGFja2FnZURldGFpbHN9YDtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpLCB7IHVzZXJBZ2VudE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnRQcmVmaXhcbiAgICAgICAgICAgIH0sIGJhc2VVcmk6IChfYiA9IChfYSA9IG9wdGlvbnMuZW5kcG9pbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMuYmFzZVVyaSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJ7dXJsfVwiIH0pO1xuICAgICAgICBzdXBlcihvcHRpb25zV2l0aERlZmF1bHRzKTtcbiAgICAgICAgLy8gUGFyYW1ldGVyIGFzc2lnbm1lbnRzXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAvLyBBc3NpZ25pbmcgdmFsdWVzIHRvIENvbnN0YW50IHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uIHx8IFwiMjAxOS0wMi0wMlwiO1xuICAgICAgICB0aGlzLnRhYmxlID0gbmV3IFRhYmxlSW1wbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNlcnZpY2VJbXBsKHRoaXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlZENsaWVudC5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgTWljcm9zb2Z0IChSKSBBdXRvUmVzdCBDb2RlIEdlbmVyYXRvci5cbiAqIENoYW5nZXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvciBhbmQgd2lsbCBiZSBsb3N0IGlmIHRoZSBjb2RlIGlzIHJlZ2VuZXJhdGVkLlxuICovXG5leHBvcnQgY29uc3QgVGFibGVRdWVyeVJlc3BvbnNlID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlUXVlcnlSZXNwb25zZVwiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlUXVlcnlSZXNwb25zZVwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG9kYXRhTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJvZGF0YVxcXFwubWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIm9kYXRhXFxcXC5tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIHhtbEVsZW1lbnROYW1lOiBcIlRhYmxlUmVzcG9uc2VQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNlcXVlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVJlc3BvbnNlUHJvcGVydGllc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IFRhYmxlUmVzcG9uc2VQcm9wZXJ0aWVzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlUmVzcG9uc2VQcm9wZXJ0aWVzXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVSZXNwb25zZVByb3BlcnRpZXNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVOYW1lXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJUYWJsZU5hbWVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb2RhdGFUeXBlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwib2RhdGFcXFxcLnR5cGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIm9kYXRhXFxcXC50eXBlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9kYXRhSWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJvZGF0YVxcXFwuaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIm9kYXRhXFxcXC5pZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZGF0YUVkaXRMaW5rOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwib2RhdGFcXFxcLmVkaXRMaW5rXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJvZGF0YVxcXFwuZWRpdExpbmtcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IFRhYmxlU2VydmljZUVycm9yID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlU2VydmljZUVycm9yXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVTZXJ2aWNlRXJyb3JcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBvZGF0YUVycm9yOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwib2RhdGFcXFxcLmVycm9yXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJvZGF0YVxcXFwuZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVNlcnZpY2VFcnJvck9kYXRhRXJyb3JcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVTZXJ2aWNlRXJyb3JPZGF0YUVycm9yID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlU2VydmljZUVycm9yT2RhdGFFcnJvclwiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlU2VydmljZUVycm9yT2RhdGFFcnJvclwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJjb2RlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJjb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVTZXJ2aWNlRXJyb3JPZGF0YUVycm9yTWVzc2FnZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVNlcnZpY2VFcnJvck9kYXRhRXJyb3JNZXNzYWdlID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlU2VydmljZUVycm9yT2RhdGFFcnJvck1lc3NhZ2VcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVNlcnZpY2VFcnJvck9kYXRhRXJyb3JNZXNzYWdlXCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczoge1xuICAgICAgICAgICAgbGFuZzoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcImxhbmdcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcImxhbmdcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IFRhYmxlUHJvcGVydGllcyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZVByb3BlcnRpZXNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVByb3BlcnRpZXNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVOYW1lXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJUYWJsZU5hbWVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IFRhYmxlRW50aXR5UXVlcnlSZXNwb25zZSA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZUVudGl0eVF1ZXJ5UmVzcG9uc2VcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZUVudGl0eVF1ZXJ5UmVzcG9uc2VcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBvZGF0YU1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwib2RhdGFcXFxcLm1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJvZGF0YVxcXFwubWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICB4bWxFbGVtZW50TmFtZTogXCJUYWJsZUVudGl0eVByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHR5cGU6IHsgbmFtZTogXCJhbnlcIiB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2lnbmVkSWRlbnRpZmllciA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJTaWduZWRJZGVudGlmaWVyXCIsXG4gICAgeG1sTmFtZTogXCJTaWduZWRJZGVudGlmaWVyXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiU2lnbmVkSWRlbnRpZmllclwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiSWRcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjY2Vzc1BvbGljeToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkFjY2Vzc1BvbGljeVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiQWNjZXNzUG9saWN5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQWNjZXNzUG9saWN5XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IEFjY2Vzc1BvbGljeSA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJBY2Nlc3NQb2xpY3lcIixcbiAgICB4bWxOYW1lOiBcIkFjY2Vzc1BvbGljeVwiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIkFjY2Vzc1BvbGljeVwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiU3RhcnRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIlN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cGlyeToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkV4cGlyeVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiRXhwaXJ5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBlcm1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJQZXJtaXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJQZXJtaXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVNlcnZpY2VQcm9wZXJ0aWVzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlU2VydmljZVByb3BlcnRpZXNcIixcbiAgICB4bWxOYW1lOiBcIlN0b3JhZ2VTZXJ2aWNlUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlU2VydmljZVByb3BlcnRpZXNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBsb2dnaW5nOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiTG9nZ2luZ1wiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiTG9nZ2luZ1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkxvZ2dpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob3VyTWV0cmljczoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkhvdXJNZXRyaWNzXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJIb3VyTWV0cmljc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk1ldHJpY3NcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaW51dGVNZXRyaWNzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiTWludXRlTWV0cmljc1wiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiTWludXRlTWV0cmljc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk1ldHJpY3NcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQ29yc1wiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiQ29yc1wiLFxuICAgICAgICAgICAgICAgIHhtbElzV3JhcHBlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxFbGVtZW50TmFtZTogXCJDb3JzUnVsZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTZXF1ZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ29yc1J1bGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBMb2dnaW5nID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIkxvZ2dpbmdcIixcbiAgICB4bWxOYW1lOiBcIkxvZ2dpbmdcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJMb2dnaW5nXCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczoge1xuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJEZWxldGVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJSZWFkXCIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJSZWFkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIldyaXRlXCIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJXcml0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJCb29sZWFuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0ZW50aW9uUG9saWN5OiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiUmV0ZW50aW9uUG9saWN5XCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJSZXRlbnRpb25Qb2xpY3lcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSZXRlbnRpb25Qb2xpY3lcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgUmV0ZW50aW9uUG9saWN5ID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlJldGVudGlvblBvbGljeVwiLFxuICAgIHhtbE5hbWU6IFwiUmV0ZW50aW9uUG9saWN5XCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiUmV0ZW50aW9uUG9saWN5XCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczoge1xuICAgICAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkVuYWJsZWRcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkVuYWJsZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRheXM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgICAgICBJbmNsdXNpdmVNaW5pbXVtOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJEYXlzXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJEYXlzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk51bWJlclwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBNZXRyaWNzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIk1ldHJpY3NcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJNZXRyaWNzXCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczoge1xuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkVuYWJsZWRcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkVuYWJsZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluY2x1ZGVBUElzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiSW5jbHVkZUFQSXNcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkluY2x1ZGVBUElzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXRlbnRpb25Qb2xpY3k6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJSZXRlbnRpb25Qb2xpY3lcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIlJldGVudGlvblBvbGljeVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJldGVudGlvblBvbGljeVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBDb3JzUnVsZSA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJDb3JzUnVsZVwiLFxuICAgIHhtbE5hbWU6IFwiQ29yc1J1bGVcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJDb3JzUnVsZVwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGFsbG93ZWRPcmlnaW5zOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWxsb3dlZE9yaWdpbnNcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkFsbG93ZWRPcmlnaW5zXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbG93ZWRNZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWxsb3dlZE1ldGhvZHNcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkFsbG93ZWRNZXRob2RzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbG93ZWRIZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWxsb3dlZEhlYWRlcnNcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkFsbG93ZWRIZWFkZXJzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9zZWRIZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiRXhwb3NlZEhlYWRlcnNcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIkV4cG9zZWRIZWFkZXJzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heEFnZUluU2Vjb25kczoge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIEluY2x1c2l2ZU1pbmltdW06IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIk1heEFnZUluU2Vjb25kc1wiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiTWF4QWdlSW5TZWNvbmRzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk51bWJlclwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVNlcnZpY2VTdGF0cyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZVNlcnZpY2VTdGF0c1wiLFxuICAgIHhtbE5hbWU6IFwiU3RvcmFnZVNlcnZpY2VTdGF0c1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlU2VydmljZVN0YXRzXCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczoge1xuICAgICAgICAgICAgZ2VvUmVwbGljYXRpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJHZW9SZXBsaWNhdGlvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiR2VvUmVwbGljYXRpb25cIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJHZW9SZXBsaWNhdGlvblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBHZW9SZXBsaWNhdGlvbiA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJHZW9SZXBsaWNhdGlvblwiLFxuICAgIHhtbE5hbWU6IFwiR2VvUmVwbGljYXRpb25cIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJHZW9SZXBsaWNhdGlvblwiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIlN0YXR1c1wiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiU3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RTeW5jVGltZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkxhc3RTeW5jVGltZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiTGFzdFN5bmNUaW1lXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVJlc3BvbnNlID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlUmVzcG9uc2VcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVJlc3BvbnNlXCIsXG4gICAgICAgIG1vZGVsUHJvcGVydGllczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBUYWJsZVJlc3BvbnNlUHJvcGVydGllcy50eXBlLm1vZGVsUHJvcGVydGllcyksIHsgb2RhdGFNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIm9kYXRhXFxcXC5tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwib2RhdGFcXFxcLm1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB9KVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVRdWVyeUhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfcXVlcnlIZWFkZXJzXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVRdWVyeUhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXRlVGltZVJmYzExMjNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4TXNDb250aW51YXRpb25OZXh0VGFibGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1jb250aW51YXRpb24tbmV4dHRhYmxlbmFtZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1jb250aW51YXRpb24tbmV4dHRhYmxlbmFtZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVRdWVyeUV4Y2VwdGlvbkhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfcXVlcnlFeGNlcHRpb25IZWFkZXJzXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVRdWVyeUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVDcmVhdGVIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX2NyZWF0ZUhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZUNyZWF0ZUhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXRlVGltZVJmYzExMjNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVmZXJlbmNlQXBwbGllZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcInByZWZlcmVuY2UtYXBwbGllZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwicHJlZmVyZW5jZS1hcHBsaWVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZUNyZWF0ZUV4Y2VwdGlvbkhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfY3JlYXRlRXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlQ3JlYXRlRXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZURlbGV0ZUhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfZGVsZXRlSGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlRGVsZXRlSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZURlbGV0ZUV4Y2VwdGlvbkhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfZGVsZXRlRXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlRGVsZXRlRXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVF1ZXJ5RW50aXRpZXNIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX3F1ZXJ5RW50aXRpZXNIZWFkZXJzXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVRdWVyeUVudGl0aWVzSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhNc0NvbnRpbnVhdGlvbk5leHRQYXJ0aXRpb25LZXk6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cGFydGl0aW9ua2V5XCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cGFydGl0aW9ua2V5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhNc0NvbnRpbnVhdGlvbk5leHRSb3dLZXk6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cm93a2V5XCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cm93a2V5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVF1ZXJ5RW50aXRpZXNFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX3F1ZXJ5RW50aXRpZXNFeGNlcHRpb25IZWFkZXJzXCIsXG4gICAgdHlwZToge1xuICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiVGFibGVRdWVyeUVudGl0aWVzRXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVF1ZXJ5RW50aXRpZXNXaXRoUGFydGl0aW9uQW5kUm93S2V5SGVhZGVycyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZV9xdWVyeUVudGl0aWVzV2l0aFBhcnRpdGlvbkFuZFJvd0tleUhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVF1ZXJ5RW50aXRpZXNXaXRoUGFydGl0aW9uQW5kUm93S2V5SGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV0YWc6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhNc0NvbnRpbnVhdGlvbk5leHRQYXJ0aXRpb25LZXk6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cGFydGl0aW9ua2V5XCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cGFydGl0aW9ua2V5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhNc0NvbnRpbnVhdGlvbk5leHRSb3dLZXk6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cm93a2V5XCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNvbnRpbnVhdGlvbi1uZXh0cm93a2V5XCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVF1ZXJ5RW50aXRpZXNXaXRoUGFydGl0aW9uQW5kUm93S2V5RXhjZXB0aW9uSGVhZGVycyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZV9xdWVyeUVudGl0aWVzV2l0aFBhcnRpdGlvbkFuZFJvd0tleUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVF1ZXJ5RW50aXRpZXNXaXRoUGFydGl0aW9uQW5kUm93S2V5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVVwZGF0ZUVudGl0eUhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfdXBkYXRlRW50aXR5SGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlVXBkYXRlRW50aXR5SGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV0YWc6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZVVwZGF0ZUVudGl0eUV4Y2VwdGlvbkhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfdXBkYXRlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlVXBkYXRlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZU1lcmdlRW50aXR5SGVhZGVycyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZV9tZXJnZUVudGl0eUhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZU1lcmdlRW50aXR5SGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV0YWc6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZU1lcmdlRW50aXR5RXhjZXB0aW9uSGVhZGVycyA9IHtcbiAgICBzZXJpYWxpemVkTmFtZTogXCJUYWJsZV9tZXJnZUVudGl0eUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZU1lcmdlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZURlbGV0ZUVudGl0eUhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfZGVsZXRlRW50aXR5SGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlRGVsZXRlRW50aXR5SGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZURlbGV0ZUVudGl0eUV4Y2VwdGlvbkhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfZGVsZXRlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlRGVsZXRlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVycm9yQ29kZToge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBUYWJsZUluc2VydEVudGl0eUhlYWRlcnMgPSB7XG4gICAgc2VyaWFsaXplZE5hbWU6IFwiVGFibGVfaW5zZXJ0RW50aXR5SGVhZGVyc1wiLFxuICAgIHR5cGU6IHtcbiAgICAgICAgbmFtZTogXCJDb21wb3NpdGVcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIlRhYmxlSW5zZXJ0RW50aXR5SGVhZGVyc1wiLFxuICAgICAgICBtb2RlbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdElkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRhdGVUaW1lUmZjMTEyM1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV0YWc6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJldGFnXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWZlcmVuY2VBcHBsaWVkOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwicHJlZmVyZW5jZS1hcHBsaWVkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJwcmVmZXJlbmNlLWFwcGxpZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJjb250ZW50LXR5cGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcImNvbnRlbnQtdHlwZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVJbnNlcnRFbnRpdHlFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX2luc2VydEVudGl0eUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZUluc2VydEVudGl0eUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVHZXRBY2Nlc3NQb2xpY3lIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX2dldEFjY2Vzc1BvbGljeUhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZUdldEFjY2Vzc1BvbGljeUhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXRlVGltZVJmYzExMjNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVHZXRBY2Nlc3NQb2xpY3lFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX2dldEFjY2Vzc1BvbGljeUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZUdldEFjY2Vzc1BvbGljeUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVTZXRBY2Nlc3NQb2xpY3lIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX3NldEFjY2Vzc1BvbGljeUhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVNldEFjY2Vzc1BvbGljeUhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXRlVGltZVJmYzExMjNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgVGFibGVTZXRBY2Nlc3NQb2xpY3lFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlRhYmxlX3NldEFjY2Vzc1BvbGljeUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJUYWJsZVNldEFjY2Vzc1BvbGljeUV4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZVNldFByb3BlcnRpZXNIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2Vfc2V0UHJvcGVydGllc0hlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlU2V0UHJvcGVydGllc0hlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZVNldFByb3BlcnRpZXNFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2Vfc2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlU2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZUdldFByb3BlcnRpZXNIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2VfZ2V0UHJvcGVydGllc0hlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlR2V0UHJvcGVydGllc0hlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZUdldFByb3BlcnRpZXNFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2VfZ2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlR2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZUdldFN0YXRpc3RpY3NIZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2VfZ2V0U3RhdGlzdGljc0hlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlR2V0U3RhdGlzdGljc0hlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQ6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtcmVxdWVzdC1pZFwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLXZlcnNpb25cIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHhtbE5hbWU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXRlVGltZVJmYzExMjNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgU2VydmljZUdldFN0YXRpc3RpY3NFeGNlcHRpb25IZWFkZXJzID0ge1xuICAgIHNlcmlhbGl6ZWROYW1lOiBcIlNlcnZpY2VfZ2V0U3RhdGlzdGljc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICB0eXBlOiB7XG4gICAgICAgIG5hbWU6IFwiQ29tcG9zaXRlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJTZXJ2aWNlR2V0U3RhdGlzdGljc0V4Y2VwdGlvbkhlYWRlcnNcIixcbiAgICAgICAgbW9kZWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ4LW1zLWVycm9yLWNvZGVcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIngtbXMtZXJyb3ItY29kZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBwZXJzLmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBNaWNyb3NvZnQgKFIpIEF1dG9SZXN0IENvZGUgR2VuZXJhdG9yLlxuICogQ2hhbmdlcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yIGFuZCB3aWxsIGJlIGxvc3QgaWYgdGhlIGNvZGUgaXMgcmVnZW5lcmF0ZWQuXG4gKi9cbmltcG9ydCB7IFRhYmxlUHJvcGVydGllcyBhcyBUYWJsZVByb3BlcnRpZXNNYXBwZXIsIFRhYmxlU2VydmljZVByb3BlcnRpZXMgYXMgVGFibGVTZXJ2aWNlUHJvcGVydGllc01hcHBlciB9IGZyb20gXCIuLi9tb2RlbHMvbWFwcGVyc1wiO1xuZXhwb3J0IGNvbnN0IGFjY2VwdCA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcImFjY2VwdFwiLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiYXBwbGljYXRpb24vanNvbjtvZGF0YT1taW5pbWFsbWV0YWRhdGFcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWNjZXB0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdXJsID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwidXJsXCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcInVybFwiLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgeG1sTmFtZTogXCJ1cmxcIixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBza2lwRW5jb2Rpbmc6IHRydWVcbn07XG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcInZlcnNpb25cIixcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIjIwMTktMDItMDJcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwieC1tcy12ZXJzaW9uXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcmVxdWVzdElkID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJyZXF1ZXN0SWRcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIngtbXMtY2xpZW50LXJlcXVlc3QtaWRcIixcbiAgICAgICAgeG1sTmFtZTogXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZGF0YVNlcnZpY2VWZXJzaW9uID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwiZGF0YVNlcnZpY2VWZXJzaW9uXCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIzLjBcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiRGF0YVNlcnZpY2VWZXJzaW9uXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZm9ybWF0ID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJxdWVyeU9wdGlvbnNcIiwgXCJmb3JtYXRcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIiRmb3JtYXRcIixcbiAgICAgICAgeG1sTmFtZTogXCIkZm9ybWF0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdG9wID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJxdWVyeU9wdGlvbnNcIiwgXCJ0b3BcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICBJbmNsdXNpdmVNaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIiR0b3BcIixcbiAgICAgICAgeG1sTmFtZTogXCIkdG9wXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiTnVtYmVyXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc2VsZWN0ID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJxdWVyeU9wdGlvbnNcIiwgXCJzZWxlY3RcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIiRzZWxlY3RcIixcbiAgICAgICAgeG1sTmFtZTogXCIkc2VsZWN0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZmlsdGVyID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJxdWVyeU9wdGlvbnNcIiwgXCJmaWx0ZXJcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIiRmaWx0ZXJcIixcbiAgICAgICAgeG1sTmFtZTogXCIkZmlsdGVyXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbmV4dFRhYmxlTmFtZSA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBbXCJvcHRpb25zXCIsIFwibmV4dFRhYmxlTmFtZVwiXSxcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiTmV4dFRhYmxlTmFtZVwiLFxuICAgICAgICB4bWxOYW1lOiBcIk5leHRUYWJsZU5hbWVcIixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZSA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBbXCJvcHRpb25zXCIsIFwiY29udGVudFR5cGVcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPW5vbWV0YWRhdGFcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdGFibGVQcm9wZXJ0aWVzID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwidGFibGVQcm9wZXJ0aWVzXCIsXG4gICAgbWFwcGVyOiBUYWJsZVByb3BlcnRpZXNNYXBwZXJcbn07XG5leHBvcnQgY29uc3QgcmVzcG9uc2VQcmVmZXJlbmNlID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJyZXNwb25zZVByZWZlcmVuY2VcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIlByZWZlclwiLFxuICAgICAgICB4bWxOYW1lOiBcIlByZWZlclwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGFjY2VwdDEgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogXCJhY2NlcHRcIixcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWNjZXB0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdGFibGUgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogXCJ0YWJsZVwiLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ0YWJsZVwiLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgeG1sTmFtZTogXCJ0YWJsZVwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRpbWVvdXQgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogW1wib3B0aW9uc1wiLCBcInRpbWVvdXRcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICBJbmNsdXNpdmVNaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcInRpbWVvdXRcIixcbiAgICAgICAgeG1sTmFtZTogXCJ0aW1lb3V0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiTnVtYmVyXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbmV4dFBhcnRpdGlvbktleSA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBbXCJvcHRpb25zXCIsIFwibmV4dFBhcnRpdGlvbktleVwiXSxcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiTmV4dFBhcnRpdGlvbktleVwiLFxuICAgICAgICB4bWxOYW1lOiBcIk5leHRQYXJ0aXRpb25LZXlcIixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBuZXh0Um93S2V5ID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJuZXh0Um93S2V5XCJdLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJOZXh0Um93S2V5XCIsXG4gICAgICAgIHhtbE5hbWU6IFwiTmV4dFJvd0tleVwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHBhcnRpdGlvbktleSA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcInBhcnRpdGlvbktleVwiLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJwYXJ0aXRpb25LZXlcIixcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHhtbE5hbWU6IFwicGFydGl0aW9uS2V5XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgcm93S2V5ID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwicm93S2V5XCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcInJvd0tleVwiLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgeG1sTmFtZTogXCJyb3dLZXlcIixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZTEgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogW1wib3B0aW9uc1wiLCBcImNvbnRlbnRUeXBlXCJdLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBpc0NvbnN0YW50OiB0cnVlLFxuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJDb250ZW50LVR5cGVcIixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpbmdcIlxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0YWJsZUVudGl0eVByb3BlcnRpZXMgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogW1wib3B0aW9uc1wiLCBcInRhYmxlRW50aXR5UHJvcGVydGllc1wiXSxcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwidGFibGVFbnRpdHlQcm9wZXJ0aWVzXCIsXG4gICAgICAgIHhtbE5hbWU6IFwidGFibGVFbnRpdHlQcm9wZXJ0aWVzXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgdmFsdWU6IHsgdHlwZTogeyBuYW1lOiBcImFueVwiIH0gfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBpZk1hdGNoID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFtcIm9wdGlvbnNcIiwgXCJpZk1hdGNoXCJdLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJJZi1NYXRjaFwiLFxuICAgICAgICB4bWxOYW1lOiBcIklmLU1hdGNoXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgaWZNYXRjaDEgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogXCJpZk1hdGNoXCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIklmLU1hdGNoXCIsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB4bWxOYW1lOiBcIklmLU1hdGNoXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgYWNjZXB0MiA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcImFjY2VwdFwiLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgICAgIGlzQ29uc3RhbnQ6IHRydWUsXG4gICAgICAgIHNlcmlhbGl6ZWROYW1lOiBcIkFjY2VwdFwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbXAgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogXCJjb21wXCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJhY2xcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiY29tcFwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlMiA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBbXCJvcHRpb25zXCIsIFwiY29udGVudFR5cGVcIl0sXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdGFibGVBY2wgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogW1wib3B0aW9uc1wiLCBcInRhYmxlQWNsXCJdLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJ0YWJsZUFjbFwiLFxuICAgICAgICB4bWxOYW1lOiBcIlNpZ25lZElkZW50aWZpZXJzXCIsXG4gICAgICAgIHhtbElzV3JhcHBlZDogdHJ1ZSxcbiAgICAgICAgeG1sRWxlbWVudE5hbWU6IFwiU2lnbmVkSWRlbnRpZmllclwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlNlcXVlbmNlXCIsXG4gICAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbXBvc2l0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU2lnbmVkSWRlbnRpZmllclwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBhY2NlcHQzID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwiYWNjZXB0XCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiQWNjZXB0XCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdGFibGVTZXJ2aWNlUHJvcGVydGllcyA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcInRhYmxlU2VydmljZVByb3BlcnRpZXNcIixcbiAgICBtYXBwZXI6IFRhYmxlU2VydmljZVByb3BlcnRpZXNNYXBwZXJcbn07XG5leHBvcnQgY29uc3QgcmVzdHlwZSA9IHtcbiAgICBwYXJhbWV0ZXJQYXRoOiBcInJlc3R5cGVcIixcbiAgICBtYXBwZXI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcInNlcnZpY2VcIixcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwicmVzdHlwZVwiLFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmluZ1wiXG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbXAxID0ge1xuICAgIHBhcmFtZXRlclBhdGg6IFwiY29tcFwiLFxuICAgIG1hcHBlcjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwicHJvcGVydGllc1wiLFxuICAgICAgICBpc0NvbnN0YW50OiB0cnVlLFxuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJjb21wXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY29tcDIgPSB7XG4gICAgcGFyYW1ldGVyUGF0aDogXCJjb21wXCIsXG4gICAgbWFwcGVyOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJzdGF0c1wiLFxuICAgICAgICBpc0NvbnN0YW50OiB0cnVlLFxuICAgICAgICBzZXJpYWxpemVkTmFtZTogXCJjb21wXCIsXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaW5nXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbWV0ZXJzLmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBNaWNyb3NvZnQgKFIpIEF1dG9SZXN0IENvZGUgR2VuZXJhdG9yLlxuICogQ2hhbmdlcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yIGFuZCB3aWxsIGJlIGxvc3QgaWYgdGhlIGNvZGUgaXMgcmVnZW5lcmF0ZWQuXG4gKi9cbmltcG9ydCAqIGFzIGNvcmVDbGllbnQgZnJvbSBcIkBhenVyZS9jb3JlLWNsaWVudFwiO1xuaW1wb3J0ICogYXMgTWFwcGVycyBmcm9tIFwiLi4vbW9kZWxzL21hcHBlcnNcIjtcbmltcG9ydCAqIGFzIFBhcmFtZXRlcnMgZnJvbSBcIi4uL21vZGVscy9wYXJhbWV0ZXJzXCI7XG4vKiogQ2xhc3MgY29udGFpbmluZyBTZXJ2aWNlIG9wZXJhdGlvbnMuICovXG5leHBvcnQgY2xhc3MgU2VydmljZUltcGwge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIFNlcnZpY2UgY2xhc3MuXG4gICAgICogQHBhcmFtIGNsaWVudCBSZWZlcmVuY2UgdG8gdGhlIHNlcnZpY2UgY2xpZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnRpZXMgZm9yIGFuIGFjY291bnQncyBUYWJsZSBzZXJ2aWNlIGVuZHBvaW50LCBpbmNsdWRpbmcgcHJvcGVydGllcyBmb3IgQW5hbHl0aWNzIGFuZCBDT1JTXG4gICAgICogKENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKSBydWxlcy5cbiAgICAgKiBAcGFyYW0gdGFibGVTZXJ2aWNlUHJvcGVydGllcyBUaGUgVGFibGUgU2VydmljZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgc2V0UHJvcGVydGllcyh0YWJsZVNlcnZpY2VQcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlU2VydmljZVByb3BlcnRpZXMsIG9wdGlvbnMgfSwgc2V0UHJvcGVydGllc09wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIGFjY291bnQncyBUYWJsZSBzZXJ2aWNlLCBpbmNsdWRpbmcgcHJvcGVydGllcyBmb3IgQW5hbHl0aWNzIGFuZCBDT1JTXG4gICAgICogKENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKSBydWxlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldFByb3BlcnRpZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VuZE9wZXJhdGlvblJlcXVlc3QoeyBvcHRpb25zIH0sIGdldFByb3BlcnRpZXNPcGVyYXRpb25TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHN0YXRpc3RpY3MgcmVsYXRlZCB0byByZXBsaWNhdGlvbiBmb3IgdGhlIFRhYmxlIHNlcnZpY2UuIEl0IGlzIG9ubHkgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHNlY29uZGFyeSBsb2NhdGlvbiBlbmRwb2ludCB3aGVuIHJlYWQtYWNjZXNzIGdlby1yZWR1bmRhbnQgcmVwbGljYXRpb24gaXMgZW5hYmxlZCBmb3IgdGhlIGFjY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBnZXRTdGF0aXN0aWNzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlbmRPcGVyYXRpb25SZXF1ZXN0KHsgb3B0aW9ucyB9LCBnZXRTdGF0aXN0aWNzT3BlcmF0aW9uU3BlYyk7XG4gICAgfVxufVxuLy8gT3BlcmF0aW9uIFNwZWNpZmljYXRpb25zXG5jb25zdCB4bWxTZXJpYWxpemVyID0gY29yZUNsaWVudC5jcmVhdGVTZXJpYWxpemVyKE1hcHBlcnMsIC8qIGlzWG1sICovIHRydWUpO1xuY29uc3Qgc2V0UHJvcGVydGllc09wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgaHR0cE1ldGhvZDogXCJQVVRcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjAyOiB7XG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlNlcnZpY2VTZXRQcm9wZXJ0aWVzSGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZUVycm9yLFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5TZXJ2aWNlU2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVxdWVzdEJvZHk6IFBhcmFtZXRlcnMudGFibGVTZXJ2aWNlUHJvcGVydGllcyxcbiAgICBxdWVyeVBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnRpbWVvdXQsIFBhcmFtZXRlcnMucmVzdHlwZSwgUGFyYW1ldGVycy5jb21wMV0sXG4gICAgdXJsUGFyYW1ldGVyczogW1BhcmFtZXRlcnMudXJsXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMudmVyc2lvbixcbiAgICAgICAgUGFyYW1ldGVycy5yZXF1ZXN0SWQsXG4gICAgICAgIFBhcmFtZXRlcnMuY29udGVudFR5cGUyLFxuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdDNcbiAgICBdLFxuICAgIGlzWE1MOiB0cnVlLFxuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3htbDsgY2hhcnNldD11dGYtOFwiLFxuICAgIG1lZGlhVHlwZTogXCJ4bWxcIixcbiAgICBzZXJpYWxpemVyOiB4bWxTZXJpYWxpemVyXG59O1xuY29uc3QgZ2V0UHJvcGVydGllc09wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgaHR0cE1ldGhvZDogXCJHRVRcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjAwOiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZVByb3BlcnRpZXMsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlNlcnZpY2VHZXRQcm9wZXJ0aWVzSGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZUVycm9yLFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5TZXJ2aWNlR2V0UHJvcGVydGllc0V4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcXVlcnlQYXJhbWV0ZXJzOiBbUGFyYW1ldGVycy50aW1lb3V0LCBQYXJhbWV0ZXJzLnJlc3R5cGUsIFBhcmFtZXRlcnMuY29tcDFdLFxuICAgIHVybFBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnVybF0sXG4gICAgaGVhZGVyUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLnZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMucmVxdWVzdElkLFxuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdDJcbiAgICBdLFxuICAgIGlzWE1MOiB0cnVlLFxuICAgIHNlcmlhbGl6ZXI6IHhtbFNlcmlhbGl6ZXJcbn07XG5jb25zdCBnZXRTdGF0aXN0aWNzT3BlcmF0aW9uU3BlYyA9IHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBodHRwTWV0aG9kOiBcIkdFVFwiLFxuICAgIHJlc3BvbnNlczoge1xuICAgICAgICAyMDA6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXJ2aWNlU3RhdHMsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlNlcnZpY2VHZXRTdGF0aXN0aWNzSGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZUVycm9yLFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5TZXJ2aWNlR2V0U3RhdGlzdGljc0V4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcXVlcnlQYXJhbWV0ZXJzOiBbUGFyYW1ldGVycy50aW1lb3V0LCBQYXJhbWV0ZXJzLnJlc3R5cGUsIFBhcmFtZXRlcnMuY29tcDJdLFxuICAgIHVybFBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnVybF0sXG4gICAgaGVhZGVyUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLnZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMucmVxdWVzdElkLFxuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdDJcbiAgICBdLFxuICAgIGlzWE1MOiB0cnVlLFxuICAgIHNlcmlhbGl6ZXI6IHhtbFNlcmlhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBNaWNyb3NvZnQgKFIpIEF1dG9SZXN0IENvZGUgR2VuZXJhdG9yLlxuICogQ2hhbmdlcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yIGFuZCB3aWxsIGJlIGxvc3QgaWYgdGhlIGNvZGUgaXMgcmVnZW5lcmF0ZWQuXG4gKi9cbmltcG9ydCAqIGFzIGNvcmVDbGllbnQgZnJvbSBcIkBhenVyZS9jb3JlLWNsaWVudFwiO1xuaW1wb3J0ICogYXMgTWFwcGVycyBmcm9tIFwiLi4vbW9kZWxzL21hcHBlcnNcIjtcbmltcG9ydCAqIGFzIFBhcmFtZXRlcnMgZnJvbSBcIi4uL21vZGVscy9wYXJhbWV0ZXJzXCI7XG4vKiogQ2xhc3MgY29udGFpbmluZyBUYWJsZSBvcGVyYXRpb25zLiAqL1xuZXhwb3J0IGNsYXNzIFRhYmxlSW1wbCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgVGFibGUgY2xhc3MuXG4gICAgICogQHBhcmFtIGNsaWVudCBSZWZlcmVuY2UgdG8gdGhlIHNlcnZpY2UgY2xpZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIHRhYmxlcyB1bmRlciB0aGUgZ2l2ZW4gYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHF1ZXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlbmRPcGVyYXRpb25SZXF1ZXN0KHsgb3B0aW9ucyB9LCBxdWVyeU9wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhYmxlIHVuZGVyIHRoZSBnaXZlbiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB0YWJsZVByb3BlcnRpZXMgVGhlIFRhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBjcmVhdGUodGFibGVQcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlUHJvcGVydGllcywgb3B0aW9ucyB9LCBjcmVhdGVPcGVyYXRpb25TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIHBlcm1hbmVudGx5IGRlbGV0ZXMgdGhlIHNwZWNpZmllZCB0YWJsZS5cbiAgICAgKiBAcGFyYW0gdGFibGUgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZGVsZXRlKHRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlLCBvcHRpb25zIH0sIGRlbGV0ZU9wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGVudGl0aWVzIGluIGEgdGFibGUuXG4gICAgICogQHBhcmFtIHRhYmxlIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHF1ZXJ5RW50aXRpZXModGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlbmRPcGVyYXRpb25SZXF1ZXN0KHsgdGFibGUsIG9wdGlvbnMgfSwgcXVlcnlFbnRpdGllc09wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGVudGl0aWVzIGluIGEgdGFibGUuXG4gICAgICogQHBhcmFtIHRhYmxlIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gcGFydGl0aW9uS2V5IFRoZSBwYXJ0aXRpb24ga2V5IG9mIHRoZSBlbnRpdHkuXG4gICAgICogQHBhcmFtIHJvd0tleSBUaGUgcm93IGtleSBvZiB0aGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgcXVlcnlFbnRpdGllc1dpdGhQYXJ0aXRpb25BbmRSb3dLZXkodGFibGUsIHBhcnRpdGlvbktleSwgcm93S2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlLCBwYXJ0aXRpb25LZXksIHJvd0tleSwgb3B0aW9ucyB9LCBxdWVyeUVudGl0aWVzV2l0aFBhcnRpdGlvbkFuZFJvd0tleU9wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW50aXR5IGluIGEgdGFibGUuXG4gICAgICogQHBhcmFtIHRhYmxlIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gcGFydGl0aW9uS2V5IFRoZSBwYXJ0aXRpb24ga2V5IG9mIHRoZSBlbnRpdHkuXG4gICAgICogQHBhcmFtIHJvd0tleSBUaGUgcm93IGtleSBvZiB0aGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgdXBkYXRlRW50aXR5KHRhYmxlLCBwYXJ0aXRpb25LZXksIHJvd0tleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VuZE9wZXJhdGlvblJlcXVlc3QoeyB0YWJsZSwgcGFydGl0aW9uS2V5LCByb3dLZXksIG9wdGlvbnMgfSwgdXBkYXRlRW50aXR5T3BlcmF0aW9uU3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlIGVudGl0eSBpbiBhIHRhYmxlLlxuICAgICAqIEBwYXJhbSB0YWJsZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAgICogQHBhcmFtIHBhcnRpdGlvbktleSBUaGUgcGFydGl0aW9uIGtleSBvZiB0aGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSByb3dLZXkgVGhlIHJvdyBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIG1lcmdlRW50aXR5KHRhYmxlLCBwYXJ0aXRpb25LZXksIHJvd0tleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VuZE9wZXJhdGlvblJlcXVlc3QoeyB0YWJsZSwgcGFydGl0aW9uS2V5LCByb3dLZXksIG9wdGlvbnMgfSwgbWVyZ2VFbnRpdHlPcGVyYXRpb25TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgc3BlY2lmaWVkIGVudGl0eSBpbiBhIHRhYmxlLlxuICAgICAqIEBwYXJhbSB0YWJsZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAgICogQHBhcmFtIHBhcnRpdGlvbktleSBUaGUgcGFydGl0aW9uIGtleSBvZiB0aGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSByb3dLZXkgVGhlIHJvdyBrZXkgb2YgdGhlIGVudGl0eS5cbiAgICAgKiBAcGFyYW0gaWZNYXRjaCBNYXRjaCBjb25kaXRpb24gZm9yIGFuIGVudGl0eSB0byBiZSBkZWxldGVkLiBJZiBzcGVjaWZpZWQgYW5kIGEgbWF0Y2hpbmcgZW50aXR5IGlzXG4gICAgICogICAgICAgICAgICAgICAgbm90IGZvdW5kLCBhbiBlcnJvciB3aWxsIGJlIHJhaXNlZC4gVG8gZm9yY2UgYW4gdW5jb25kaXRpb25hbCBkZWxldGUsIHNldCB0byB0aGUgd2lsZGNhcmQgY2hhcmFjdGVyXG4gICAgICogICAgICAgICAgICAgICAgKCopLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZGVsZXRlRW50aXR5KHRhYmxlLCBwYXJ0aXRpb25LZXksIHJvd0tleSwgaWZNYXRjaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VuZE9wZXJhdGlvblJlcXVlc3QoeyB0YWJsZSwgcGFydGl0aW9uS2V5LCByb3dLZXksIGlmTWF0Y2gsIG9wdGlvbnMgfSwgZGVsZXRlRW50aXR5T3BlcmF0aW9uU3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBlbnRpdHkgaW4gYSB0YWJsZS5cbiAgICAgKiBAcGFyYW0gdGFibGUgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgaW5zZXJ0RW50aXR5KHRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlLCBvcHRpb25zIH0sIGluc2VydEVudGl0eU9wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbnkgc3RvcmVkIGFjY2VzcyBwb2xpY2llcyBzcGVjaWZpZWQgb24gdGhlIHRhYmxlIHRoYXQgbWF5IGJlIHVzZWQgd2l0aFxuICAgICAqIFNoYXJlZCBBY2Nlc3MgU2lnbmF0dXJlcy5cbiAgICAgKiBAcGFyYW0gdGFibGUgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0QWNjZXNzUG9saWN5KHRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZW5kT3BlcmF0aW9uUmVxdWVzdCh7IHRhYmxlLCBvcHRpb25zIH0sIGdldEFjY2Vzc1BvbGljeU9wZXJhdGlvblNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHN0b3JlZCBhY2Nlc3MgcG9saWNpZXMgZm9yIHRoZSB0YWJsZSB0aGF0IG1heSBiZSB1c2VkIHdpdGggU2hhcmVkIEFjY2VzcyBTaWduYXR1cmVzLlxuICAgICAqIEBwYXJhbSB0YWJsZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBzZXRBY2Nlc3NQb2xpY3kodGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlbmRPcGVyYXRpb25SZXF1ZXN0KHsgdGFibGUsIG9wdGlvbnMgfSwgc2V0QWNjZXNzUG9saWN5T3BlcmF0aW9uU3BlYyk7XG4gICAgfVxufVxuLy8gT3BlcmF0aW9uIFNwZWNpZmljYXRpb25zXG5jb25zdCB4bWxTZXJpYWxpemVyID0gY29yZUNsaWVudC5jcmVhdGVTZXJpYWxpemVyKE1hcHBlcnMsIC8qIGlzWG1sICovIHRydWUpO1xuY29uc3Qgc2VyaWFsaXplciA9IGNvcmVDbGllbnQuY3JlYXRlU2VyaWFsaXplcihNYXBwZXJzLCAvKiBpc1htbCAqLyBmYWxzZSk7XG5jb25zdCBxdWVyeU9wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIvVGFibGVzXCIsXG4gICAgaHR0cE1ldGhvZDogXCJHRVRcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjAwOiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlUXVlcnlSZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVRdWVyeUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjogTWFwcGVycy5UYWJsZVNlcnZpY2VFcnJvcixcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVRdWVyeUV4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcXVlcnlQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMuZm9ybWF0LFxuICAgICAgICBQYXJhbWV0ZXJzLnRvcCxcbiAgICAgICAgUGFyYW1ldGVycy5zZWxlY3QsXG4gICAgICAgIFBhcmFtZXRlcnMuZmlsdGVyLFxuICAgICAgICBQYXJhbWV0ZXJzLm5leHRUYWJsZU5hbWVcbiAgICBdLFxuICAgIHVybFBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnVybF0sXG4gICAgaGVhZGVyUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdCxcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5kYXRhU2VydmljZVZlcnNpb25cbiAgICBdLFxuICAgIHNlcmlhbGl6ZXJcbn07XG5jb25zdCBjcmVhdGVPcGVyYXRpb25TcGVjID0ge1xuICAgIHBhdGg6IFwiL1RhYmxlc1wiLFxuICAgIGh0dHBNZXRob2Q6IFwiUE9TVFwiLFxuICAgIHJlc3BvbnNlczoge1xuICAgICAgICAyMDE6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVSZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVDcmVhdGVIZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIDIwNDoge1xuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZUNyZWF0ZUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjogTWFwcGVycy5UYWJsZVNlcnZpY2VFcnJvcixcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVDcmVhdGVFeGNlcHRpb25IZWFkZXJzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVlc3RCb2R5OiBQYXJhbWV0ZXJzLnRhYmxlUHJvcGVydGllcyxcbiAgICBxdWVyeVBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLmZvcm1hdF0sXG4gICAgdXJsUGFyYW1ldGVyczogW1BhcmFtZXRlcnMudXJsXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0LFxuICAgICAgICBQYXJhbWV0ZXJzLnZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMucmVxdWVzdElkLFxuICAgICAgICBQYXJhbWV0ZXJzLmRhdGFTZXJ2aWNlVmVyc2lvbixcbiAgICAgICAgUGFyYW1ldGVycy5jb250ZW50VHlwZSxcbiAgICAgICAgUGFyYW1ldGVycy5yZXNwb25zZVByZWZlcmVuY2VcbiAgICBdLFxuICAgIG1lZGlhVHlwZTogXCJqc29uXCIsXG4gICAgc2VyaWFsaXplclxufTtcbmNvbnN0IGRlbGV0ZU9wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIvVGFibGVzKCd7dGFibGV9JylcIixcbiAgICBodHRwTWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIHJlc3BvbnNlczoge1xuICAgICAgICAyMDQ6IHtcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVEZWxldGVIZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXJ2aWNlRXJyb3IsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlRGVsZXRlRXhjZXB0aW9uSGVhZGVyc1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cmxQYXJhbWV0ZXJzOiBbUGFyYW1ldGVycy51cmwsIFBhcmFtZXRlcnMudGFibGVdLFxuICAgIGhlYWRlclBhcmFtZXRlcnM6IFtcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5hY2NlcHQxXG4gICAgXSxcbiAgICBzZXJpYWxpemVyXG59O1xuY29uc3QgcXVlcnlFbnRpdGllc09wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIve3RhYmxlfSgpXCIsXG4gICAgaHR0cE1ldGhvZDogXCJHRVRcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjAwOiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlRW50aXR5UXVlcnlSZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVRdWVyeUVudGl0aWVzSGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZUVycm9yLFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZVF1ZXJ5RW50aXRpZXNFeGNlcHRpb25IZWFkZXJzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHF1ZXJ5UGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLmZvcm1hdCxcbiAgICAgICAgUGFyYW1ldGVycy50b3AsXG4gICAgICAgIFBhcmFtZXRlcnMuc2VsZWN0LFxuICAgICAgICBQYXJhbWV0ZXJzLmZpbHRlcixcbiAgICAgICAgUGFyYW1ldGVycy50aW1lb3V0LFxuICAgICAgICBQYXJhbWV0ZXJzLm5leHRQYXJ0aXRpb25LZXksXG4gICAgICAgIFBhcmFtZXRlcnMubmV4dFJvd0tleVxuICAgIF0sXG4gICAgdXJsUGFyYW1ldGVyczogW1BhcmFtZXRlcnMudXJsLCBQYXJhbWV0ZXJzLnRhYmxlXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0LFxuICAgICAgICBQYXJhbWV0ZXJzLnZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMucmVxdWVzdElkLFxuICAgICAgICBQYXJhbWV0ZXJzLmRhdGFTZXJ2aWNlVmVyc2lvblxuICAgIF0sXG4gICAgc2VyaWFsaXplclxufTtcbmNvbnN0IHF1ZXJ5RW50aXRpZXNXaXRoUGFydGl0aW9uQW5kUm93S2V5T3BlcmF0aW9uU3BlYyA9IHtcbiAgICBwYXRoOiBcIi97dGFibGV9KFBhcnRpdGlvbktleT0ne3BhcnRpdGlvbktleX0nLFJvd0tleT0ne3Jvd0tleX0nKVwiLFxuICAgIGh0dHBNZXRob2Q6IFwiR0VUXCIsXG4gICAgcmVzcG9uc2VzOiB7XG4gICAgICAgIDIwMDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IHsgbmFtZTogXCJEaWN0aW9uYXJ5XCIsIHZhbHVlOiB7IHR5cGU6IHsgbmFtZTogXCJhbnlcIiB9IH0gfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVRdWVyeUVudGl0aWVzV2l0aFBhcnRpdGlvbkFuZFJvd0tleUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjogTWFwcGVycy5UYWJsZVNlcnZpY2VFcnJvcixcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVRdWVyeUVudGl0aWVzV2l0aFBhcnRpdGlvbkFuZFJvd0tleUV4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcXVlcnlQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMuZm9ybWF0LFxuICAgICAgICBQYXJhbWV0ZXJzLnNlbGVjdCxcbiAgICAgICAgUGFyYW1ldGVycy5maWx0ZXIsXG4gICAgICAgIFBhcmFtZXRlcnMudGltZW91dFxuICAgIF0sXG4gICAgdXJsUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLnVybCxcbiAgICAgICAgUGFyYW1ldGVycy50YWJsZSxcbiAgICAgICAgUGFyYW1ldGVycy5wYXJ0aXRpb25LZXksXG4gICAgICAgIFBhcmFtZXRlcnMucm93S2V5XG4gICAgXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0LFxuICAgICAgICBQYXJhbWV0ZXJzLnZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMucmVxdWVzdElkLFxuICAgICAgICBQYXJhbWV0ZXJzLmRhdGFTZXJ2aWNlVmVyc2lvblxuICAgIF0sXG4gICAgc2VyaWFsaXplclxufTtcbmNvbnN0IHVwZGF0ZUVudGl0eU9wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIve3RhYmxlfShQYXJ0aXRpb25LZXk9J3twYXJ0aXRpb25LZXl9JyxSb3dLZXk9J3tyb3dLZXl9JylcIixcbiAgICBodHRwTWV0aG9kOiBcIlBVVFwiLFxuICAgIHJlc3BvbnNlczoge1xuICAgICAgICAyMDQ6IHtcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVVcGRhdGVFbnRpdHlIZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXJ2aWNlRXJyb3IsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlVXBkYXRlRW50aXR5RXhjZXB0aW9uSGVhZGVyc1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXF1ZXN0Qm9keTogUGFyYW1ldGVycy50YWJsZUVudGl0eVByb3BlcnRpZXMsXG4gICAgcXVlcnlQYXJhbWV0ZXJzOiBbUGFyYW1ldGVycy5mb3JtYXQsIFBhcmFtZXRlcnMudGltZW91dF0sXG4gICAgdXJsUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLnVybCxcbiAgICAgICAgUGFyYW1ldGVycy50YWJsZSxcbiAgICAgICAgUGFyYW1ldGVycy5wYXJ0aXRpb25LZXksXG4gICAgICAgIFBhcmFtZXRlcnMucm93S2V5XG4gICAgXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMudmVyc2lvbixcbiAgICAgICAgUGFyYW1ldGVycy5yZXF1ZXN0SWQsXG4gICAgICAgIFBhcmFtZXRlcnMuZGF0YVNlcnZpY2VWZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdDEsXG4gICAgICAgIFBhcmFtZXRlcnMuY29udGVudFR5cGUxLFxuICAgICAgICBQYXJhbWV0ZXJzLmlmTWF0Y2hcbiAgICBdLFxuICAgIG1lZGlhVHlwZTogXCJqc29uXCIsXG4gICAgc2VyaWFsaXplclxufTtcbmNvbnN0IG1lcmdlRW50aXR5T3BlcmF0aW9uU3BlYyA9IHtcbiAgICBwYXRoOiBcIi97dGFibGV9KFBhcnRpdGlvbktleT0ne3BhcnRpdGlvbktleX0nLFJvd0tleT0ne3Jvd0tleX0nKVwiLFxuICAgIGh0dHBNZXRob2Q6IFwiUEFUQ0hcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjA0OiB7XG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlTWVyZ2VFbnRpdHlIZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXJ2aWNlRXJyb3IsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlTWVyZ2VFbnRpdHlFeGNlcHRpb25IZWFkZXJzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVlc3RCb2R5OiBQYXJhbWV0ZXJzLnRhYmxlRW50aXR5UHJvcGVydGllcyxcbiAgICBxdWVyeVBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLmZvcm1hdCwgUGFyYW1ldGVycy50aW1lb3V0XSxcbiAgICB1cmxQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMudXJsLFxuICAgICAgICBQYXJhbWV0ZXJzLnRhYmxlLFxuICAgICAgICBQYXJhbWV0ZXJzLnBhcnRpdGlvbktleSxcbiAgICAgICAgUGFyYW1ldGVycy5yb3dLZXlcbiAgICBdLFxuICAgIGhlYWRlclBhcmFtZXRlcnM6IFtcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5kYXRhU2VydmljZVZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0MSxcbiAgICAgICAgUGFyYW1ldGVycy5jb250ZW50VHlwZTEsXG4gICAgICAgIFBhcmFtZXRlcnMuaWZNYXRjaFxuICAgIF0sXG4gICAgbWVkaWFUeXBlOiBcImpzb25cIixcbiAgICBzZXJpYWxpemVyXG59O1xuY29uc3QgZGVsZXRlRW50aXR5T3BlcmF0aW9uU3BlYyA9IHtcbiAgICBwYXRoOiBcIi97dGFibGV9KFBhcnRpdGlvbktleT0ne3BhcnRpdGlvbktleX0nLFJvd0tleT0ne3Jvd0tleX0nKVwiLFxuICAgIGh0dHBNZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgcmVzcG9uc2VzOiB7XG4gICAgICAgIDIwNDoge1xuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZURlbGV0ZUVudGl0eUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjogTWFwcGVycy5UYWJsZVNlcnZpY2VFcnJvcixcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVEZWxldGVFbnRpdHlFeGNlcHRpb25IZWFkZXJzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHF1ZXJ5UGFyYW1ldGVyczogW1BhcmFtZXRlcnMuZm9ybWF0LCBQYXJhbWV0ZXJzLnRpbWVvdXRdLFxuICAgIHVybFBhcmFtZXRlcnM6IFtcbiAgICAgICAgUGFyYW1ldGVycy51cmwsXG4gICAgICAgIFBhcmFtZXRlcnMudGFibGUsXG4gICAgICAgIFBhcmFtZXRlcnMucGFydGl0aW9uS2V5LFxuICAgICAgICBQYXJhbWV0ZXJzLnJvd0tleVxuICAgIF0sXG4gICAgaGVhZGVyUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdCxcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5kYXRhU2VydmljZVZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMuaWZNYXRjaDFcbiAgICBdLFxuICAgIHNlcmlhbGl6ZXJcbn07XG5jb25zdCBpbnNlcnRFbnRpdHlPcGVyYXRpb25TcGVjID0ge1xuICAgIHBhdGg6IFwiL3t0YWJsZX1cIixcbiAgICBodHRwTWV0aG9kOiBcIlBPU1RcIixcbiAgICByZXNwb25zZXM6IHtcbiAgICAgICAgMjAxOiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogeyBuYW1lOiBcIkRpY3Rpb25hcnlcIiwgdmFsdWU6IHsgdHlwZTogeyBuYW1lOiBcImFueVwiIH0gfSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZUluc2VydEVudGl0eUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgMjA0OiB7XG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlSW5zZXJ0RW50aXR5SGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBib2R5TWFwcGVyOiBNYXBwZXJzLlRhYmxlU2VydmljZUVycm9yLFxuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZUluc2VydEVudGl0eUV4Y2VwdGlvbkhlYWRlcnNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVxdWVzdEJvZHk6IFBhcmFtZXRlcnMudGFibGVFbnRpdHlQcm9wZXJ0aWVzLFxuICAgIHF1ZXJ5UGFyYW1ldGVyczogW1BhcmFtZXRlcnMuZm9ybWF0LCBQYXJhbWV0ZXJzLnRpbWVvdXRdLFxuICAgIHVybFBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnVybCwgUGFyYW1ldGVycy50YWJsZV0sXG4gICAgaGVhZGVyUGFyYW1ldGVyczogW1xuICAgICAgICBQYXJhbWV0ZXJzLmFjY2VwdCxcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5kYXRhU2VydmljZVZlcnNpb24sXG4gICAgICAgIFBhcmFtZXRlcnMuY29udGVudFR5cGUsXG4gICAgICAgIFBhcmFtZXRlcnMucmVzcG9uc2VQcmVmZXJlbmNlXG4gICAgXSxcbiAgICBtZWRpYVR5cGU6IFwianNvblwiLFxuICAgIHNlcmlhbGl6ZXJcbn07XG5jb25zdCBnZXRBY2Nlc3NQb2xpY3lPcGVyYXRpb25TcGVjID0ge1xuICAgIHBhdGg6IFwiL3t0YWJsZX1cIixcbiAgICBodHRwTWV0aG9kOiBcIkdFVFwiLFxuICAgIHJlc3BvbnNlczoge1xuICAgICAgICAyMDA6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogeyBuYW1lOiBcIkNvbXBvc2l0ZVwiLCBjbGFzc05hbWU6IFwiU2lnbmVkSWRlbnRpZmllclwiIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5hbWU6IFwiU2lnbmVkSWRlbnRpZmllcnNcIixcbiAgICAgICAgICAgICAgICB4bWxOYW1lOiBcIlNpZ25lZElkZW50aWZpZXJzXCIsXG4gICAgICAgICAgICAgICAgeG1sSXNXcmFwcGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHhtbEVsZW1lbnROYW1lOiBcIlNpZ25lZElkZW50aWZpZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVHZXRBY2Nlc3NQb2xpY3lIZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGJvZHlNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXJ2aWNlRXJyb3IsXG4gICAgICAgICAgICBoZWFkZXJzTWFwcGVyOiBNYXBwZXJzLlRhYmxlR2V0QWNjZXNzUG9saWN5RXhjZXB0aW9uSGVhZGVyc1xuICAgICAgICB9XG4gICAgfSxcbiAgICBxdWVyeVBhcmFtZXRlcnM6IFtQYXJhbWV0ZXJzLnRpbWVvdXQsIFBhcmFtZXRlcnMuY29tcF0sXG4gICAgdXJsUGFyYW1ldGVyczogW1BhcmFtZXRlcnMudXJsLCBQYXJhbWV0ZXJzLnRhYmxlXSxcbiAgICBoZWFkZXJQYXJhbWV0ZXJzOiBbXG4gICAgICAgIFBhcmFtZXRlcnMudmVyc2lvbixcbiAgICAgICAgUGFyYW1ldGVycy5yZXF1ZXN0SWQsXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0MlxuICAgIF0sXG4gICAgaXNYTUw6IHRydWUsXG4gICAgc2VyaWFsaXplcjogeG1sU2VyaWFsaXplclxufTtcbmNvbnN0IHNldEFjY2Vzc1BvbGljeU9wZXJhdGlvblNwZWMgPSB7XG4gICAgcGF0aDogXCIve3RhYmxlfVwiLFxuICAgIGh0dHBNZXRob2Q6IFwiUFVUXCIsXG4gICAgcmVzcG9uc2VzOiB7XG4gICAgICAgIDIwNDoge1xuICAgICAgICAgICAgaGVhZGVyc01hcHBlcjogTWFwcGVycy5UYWJsZVNldEFjY2Vzc1BvbGljeUhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYm9keU1hcHBlcjogTWFwcGVycy5UYWJsZVNlcnZpY2VFcnJvcixcbiAgICAgICAgICAgIGhlYWRlcnNNYXBwZXI6IE1hcHBlcnMuVGFibGVTZXRBY2Nlc3NQb2xpY3lFeGNlcHRpb25IZWFkZXJzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVlc3RCb2R5OiBQYXJhbWV0ZXJzLnRhYmxlQWNsLFxuICAgIHF1ZXJ5UGFyYW1ldGVyczogW1BhcmFtZXRlcnMudGltZW91dCwgUGFyYW1ldGVycy5jb21wXSxcbiAgICB1cmxQYXJhbWV0ZXJzOiBbUGFyYW1ldGVycy51cmwsIFBhcmFtZXRlcnMudGFibGVdLFxuICAgIGhlYWRlclBhcmFtZXRlcnM6IFtcbiAgICAgICAgUGFyYW1ldGVycy52ZXJzaW9uLFxuICAgICAgICBQYXJhbWV0ZXJzLnJlcXVlc3RJZCxcbiAgICAgICAgUGFyYW1ldGVycy5jb250ZW50VHlwZTIsXG4gICAgICAgIFBhcmFtZXRlcnMuYWNjZXB0M1xuICAgIF0sXG4gICAgaXNYTUw6IHRydWUsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veG1sOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgbWVkaWFUeXBlOiBcInhtbFwiLFxuICAgIHNlcmlhbGl6ZXI6IHhtbFNlcmlhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudExvZ2dlciB9IGZyb20gXCJAYXp1cmUvbG9nZ2VyXCI7XG4vKipcbiAqIFRoZSBcXEBhenVyZS9sb2dnZXIgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBwYWNrYWdlLlxuICovXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gY3JlYXRlQ2xpZW50TG9nZ2VyKFwiZGF0YS10YWJsZXNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXNJZlN0cmluZyhpbnB1dCwgcHJldmlvdXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQgPSBlc2NhcGVRdW90ZXMoaW5wdXQpO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGVzY2FwZSB0aGlzIGxpdGVyYWxcbiAgICAgICAgaWYgKHByZXZpb3VzICE9PSBcIlwiICYmICFwcmV2aW91cy50cmltKCkuZW5kc1dpdGgoXCInXCIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBgJyR7cmVzdWx0fSdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUXVvdGVzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLycvZywgXCInJ1wiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZURhdGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlID8gYGRhdGV0aW1lJyR7aW5wdXQudG9JU09TdHJpbmcoKX0nYCA6IGlucHV0O1xufVxuLyoqXG4gKiBFc2NhcGVzIGFuIG9kYXRhIGZpbHRlciBleHByZXNzaW9uIHRvIGF2b2lkIGVycm9ycyB3aXRoIHF1b3Rpbmcgc3RyaW5nIGxpdGVyYWxzLlxuICogRW5jb2RlcyBEYXRlIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZGF0YShzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgICBjb25zdCBmaXhFbmNvZGluZyA9ICh2YWx1ZSwgc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVEYXRlKGVzY2FwZVF1b3Rlc0lmU3RyaW5nKHZhbHVlLCBzdHJpbmcpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHN0cmluZ3NbaV0pO1xuICAgICAgICBpZiAoaSA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaXhFbmNvZGluZyh2YWx1ZXNbaV0sIHN0cmluZ3NbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5qb2luKFwiXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2RhdGEuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGJhc2U2NERlY29kZSwgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIi4vdXRpbHMvYnVmZmVyU2VyaWFsaXplclwiO1xuaW1wb3J0IHsgdHJ1bmNhdGVkSVNPODA2MURhdGUgfSBmcm9tIFwiLi91dGlscy90cnVuY2F0ZUlTTzgwNjFEYXRlXCI7XG5jb25zdCBwcm9wZXJ0eUNhc2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJQYXJ0aXRpb25LZXlcIiwgXCJwYXJ0aXRpb25LZXlcIl0sXG4gICAgW1wiUm93S2V5XCIsIFwicm93S2V5XCJdLFxuICAgIFtcIm9kYXRhLmV0YWdcIiwgXCJldGFnXCJdLFxuICAgIFtcIlRpbWVzdGFtcFwiLCBcInRpbWVzdGFtcFwiXSxcbl0pO1xuY29uc3QgRWRtID0ge1xuICAgIEJpbmFyeTogXCJFZG0uQmluYXJ5XCIsXG4gICAgQm9vbGVhbjogXCJFZG0uQm9vbGVhblwiLFxuICAgIERhdGVUaW1lOiBcIkVkbS5EYXRlVGltZVwiLFxuICAgIERvdWJsZTogXCJFZG0uRG91YmxlXCIsXG4gICAgR3VpZDogXCJFZG0uR3VpZFwiLFxuICAgIEludDMyOiBcIkVkbS5JbnQzMlwiLFxuICAgIEludDY0OiBcIkVkbS5JbnQ2NFwiLFxuICAgIFN0cmluZzogXCJFZG0uU3RyaW5nXCIsXG59O1xuZnVuY3Rpb24gc2VyaWFsaXplUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0geyB2YWx1ZSB9O1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzZXJpYWxpemVkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS50eXBlID0gRWRtLkludDY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgc2VyaWFsaXplZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS50eXBlID0gRWRtLkRhdGVUaW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgc2VyaWFsaXplZFZhbHVlLnZhbHVlID0gYmFzZTY0RW5jb2RlKHZhbHVlKTtcbiAgICAgICAgc2VyaWFsaXplZFZhbHVlLnR5cGUgPSBFZG0uQmluYXJ5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEVETSB0eXBlICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZFZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IHsgdmFsdWU6IG9iai52YWx1ZSB9O1xuICAgIGlmIChvYmoudHlwZSA9PT0gXCJCb29sZWFuXCIgfHxcbiAgICAgICAgb2JqLnR5cGUgPT09IFwiRGF0ZVRpbWVcIiB8fFxuICAgICAgICBvYmoudHlwZSA9PT0gXCJEb3VibGVcIiB8fFxuICAgICAgICBvYmoudHlwZSA9PT0gXCJHdWlkXCIgfHxcbiAgICAgICAgb2JqLnR5cGUgPT09IFwiSW50MzJcIiB8fFxuICAgICAgICBvYmoudHlwZSA9PT0gXCJJbnQ2NFwiIHx8XG4gICAgICAgIG9iai50eXBlID09PSBcIlN0cmluZ1wiIHx8XG4gICAgICAgIG9iai50eXBlID09PSBcIkJpbmFyeVwiKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS52YWx1ZSA9IG9iai52YWx1ZTtcbiAgICAgICAgc2VyaWFsaXplZFZhbHVlLnR5cGUgPSBFZG1bb2JqLnR5cGVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEVETSB0eXBlICR7dHlwZW9mIG9iai52YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnR5cGUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplUHJpbWl0aXZlKHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVQcm9wZXJ0eU5hbWVGb3JTZXJpYWxpemF0aW9uKHByb3BlcnR5TmFtZSkge1xuICAgIGZvciAoY29uc3QgW29yaWdpbmFsLCBpbnRlcm5hbF0gb2YgcHJvcGVydHlDYXNlTWFwKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbCA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgIGZvciAoY29uc3QgW3Byb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEtleSA9IHRyYW5zbGF0ZVByb3BlcnR5TmFtZUZvclNlcmlhbGl6YXRpb24ocHJvcGVydHlOYW1lKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFZhbCA9IGdldFNlcmlhbGl6ZWRWYWx1ZShwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgc2VyaWFsaXplZFt0cmFuc2Zvcm1lZEtleV0gPSBzZXJpYWxpemVkVmFsLnZhbHVlO1xuICAgICAgICBpZiAoc2VyaWFsaXplZFZhbC50eXBlKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2Ake3RyYW5zZm9ybWVkS2V5fUBvZGF0YS50eXBlYF0gPSBzZXJpYWxpemVkVmFsLnR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5mdW5jdGlvbiBnZXRUeXBlZE9iamVjdCh2YWx1ZSwgdHlwZSwgZGlzYWJsZVR5cGVDb252ZXJzaW9uKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgRWRtLkJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gZGlzYWJsZVR5cGVDb252ZXJzaW9uID8geyB2YWx1ZSwgdHlwZTogXCJCb29sZWFuXCIgfSA6IHZhbHVlO1xuICAgICAgICBjYXNlIEVkbS5Eb3VibGU6XG4gICAgICAgICAgICByZXR1cm4gZGlzYWJsZVR5cGVDb252ZXJzaW9uID8geyB2YWx1ZSwgdHlwZTogXCJEb3VibGVcIiB9IDogdmFsdWU7XG4gICAgICAgIGNhc2UgRWRtLkludDMyOlxuICAgICAgICAgICAgcmV0dXJuIGRpc2FibGVUeXBlQ29udmVyc2lvbiA/IHsgdmFsdWUsIHR5cGU6IFwiSW50MzJcIiB9IDogdmFsdWU7XG4gICAgICAgIGNhc2UgRWRtLlN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBkaXNhYmxlVHlwZUNvbnZlcnNpb24gPyB7IHZhbHVlLCB0eXBlOiBcIlN0cmluZ1wiIH0gOiB2YWx1ZTtcbiAgICAgICAgY2FzZSBFZG0uRGF0ZVRpbWU6XG4gICAgICAgICAgICByZXR1cm4gZGlzYWJsZVR5cGVDb252ZXJzaW9uID8geyB2YWx1ZSwgdHlwZTogXCJEYXRlVGltZVwiIH0gOiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgRWRtLkludDY0OlxuICAgICAgICAgICAgcmV0dXJuIGRpc2FibGVUeXBlQ29udmVyc2lvbiA/IHsgdmFsdWUsIHR5cGU6IFwiSW50NjRcIiB9IDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBFZG0uR3VpZDpcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCB0eXBlOiBcIkd1aWRcIiB9O1xuICAgICAgICBjYXNlIEVkbS5CaW5hcnk6XG4gICAgICAgICAgICByZXR1cm4gZGlzYWJsZVR5cGVDb252ZXJzaW9uID8geyB2YWx1ZSwgdHlwZTogXCJCaW5hcnlcIiB9IDogYmFzZTY0RGVjb2RlKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBFRE0gdHlwZSAke3R5cGV9YCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKG9iaiwgZGlzYWJsZVR5cGVDb252ZXJzaW9uID0gZmFsc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGVzZXJpYWxpemVkID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJAb2RhdGEudHlwZVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkS2V5ID0gKF9hID0gcHJvcGVydHlDYXNlTWFwLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrZXk7XG4gICAgICAgICAgICBsZXQgdHlwZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGAke2tleX1Ab2RhdGEudHlwZWAgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9ialtgJHtrZXl9QG9kYXRhLnR5cGVgXTtcbiAgICAgICAgICAgICAgICB0eXBlZFZhbHVlID0gZ2V0VHlwZWRPYmplY3QodmFsdWUsIHR5cGUsIGRpc2FibGVUeXBlQ29udmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNhYmxlVHlwZUNvbnZlcnNpb24gJiYgW1wibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlcnZpY2UsIGRvZXNuJ3QgcmV0dXJuIHR5cGUgbWV0YWRhdGEgZm9yIG51bWJlciwgc3RyaW5ncyBvciBib29sZWFuc1xuICAgICAgICAgICAgICAgIC8vIGlmIGF1dG9tYXRpYyB0eXBlIGNvbnZlcnNpb24gaXMgZGlzYWJsZWQgd2UnbGwgaW5mZXIgdGhlIEVETSBvYmplY3RcbiAgICAgICAgICAgICAgICB0eXBlZFZhbHVlID0gaW5mZXJUeXBlZE9iamVjdChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc2VyaWFsaXplZFt0cmFuc2Zvcm1lZEtleV0gPSB0eXBlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZWQ7XG59XG5mdW5jdGlvbiBpbmZlclR5cGVkT2JqZWN0KHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHNraXAgc2VydmljZSBtZXRhZGF0YSBmaWVsZHMgc3VjaCBhcyBwYXJ0aXRpb25LZXkgYW5kIHJvd0tleSBhbmQgdXNlIHRoZSBzYW1lIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBzZXJ2aWNlXG4gICAgaWYgKHByb3BlcnR5Q2FzZU1hcC5oYXMocHJvcGVydHlOYW1lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogU3RyaW5nKHZhbHVlKSwgdHlwZTogXCJCb29sZWFuXCIgfTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGdldFR5cGVkTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGU6IFwiU3RyaW5nXCIgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciB3aGVuIHR5cGVDb252ZXJzaW9uIGlzIGVuYWJsZWQgb3IgdGhlIEVETSBvYmplY3Qgd2l0aCB0aGUgY29ycmVjdCBudW1iZXIgZm9ybWF0IERvdWJsZSBvciBJbnQzMiBpZiBkaXNhYmxlZFxuICovXG5mdW5jdGlvbiBnZXRUeXBlZE51bWJlcih2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlU3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZVN0ciwgdHlwZTogXCJJbnQzMlwiIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVTdHIsIHR5cGU6IFwiRG91YmxlXCIgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVPYmplY3RzQXJyYXkob2JqQXJyYXksIGRpc2FibGVUeXBlQ29udmVyc2lvbikge1xuICAgIHJldHVybiBvYmpBcnJheS5tYXAoKG9iaikgPT4gZGVzZXJpYWxpemUob2JqLCBkaXNhYmxlVHlwZUNvbnZlcnNpb24pKTtcbn1cbi8qKlxuICogRm9yIEFDTCBlbmRwb2ludHMgdGhlIFRhYmxlcyBTZXJ2aWNlIHRha2VzIGFuIElTTyBEYXRlIHdpdGhvdXQgZGVjaW1hbHMgaG93ZXZlclxuICogc2VyaWFsaXppbmcgYSBKYXZhU2NyaXB0IGRhdGUgZ2l2ZXMgdXMgYSBkYXRlIHdpdGggZGVjaW1hbHMgMjAyMS0wNy0wOFQwOToxMDowOS4wMDBaXG4gKiB3aGljaCBtYWtlcyB0aGUgWE1MIHJlcXVlc3QgYm9keSBpbnZhbGlkLCB0aGVzZSAyIGZ1bmN0aW9ucyBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHRoZVxuICogZGF0ZXMgc28gdGhhdCB0aGV5IGFyZSBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVTaWduZWRJZGVudGlmaWVycyhzaWduZWRJZGVudGlmaWVycykge1xuICAgIHJldHVybiBzaWduZWRJZGVudGlmaWVycy5tYXAoKGFjbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGlkLCBhY2Nlc3NQb2xpY3kgfSA9IGFjbDtcbiAgICAgICAgY29uc3QgX2EgPSBhY2Nlc3NQb2xpY3kgIT09IG51bGwgJiYgYWNjZXNzUG9saWN5ICE9PSB2b2lkIDAgPyBhY2Nlc3NQb2xpY3kgOiB7fSwgeyBzdGFydCwgZXhwaXJ5IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wic3RhcnRcIiwgXCJleHBpcnlcIl0pO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkU3RhcnQgPSBzdGFydFxuICAgICAgICAgICAgPyB0cnVuY2F0ZWRJU084MDYxRGF0ZShzdGFydCwgZmFsc2UgLyoqIHdpdGhNaWxsaXNlY29uZHMgKi8pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEV4cGlyeSA9IGV4cGlyeVxuICAgICAgICAgICAgPyB0cnVuY2F0ZWRJU084MDYxRGF0ZShleHBpcnksIGZhbHNlIC8qKiB3aXRoTWlsbGlzZWNvbmRzICovKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFjY2Vzc1BvbGljeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzZXJpYWxpemVkRXhwaXJ5ICYmIHsgZXhwaXJ5OiBzZXJpYWxpemVkRXhwaXJ5IH0pKSwgKHNlcmlhbGl6ZWRTdGFydCAmJiB7IHN0YXJ0OiBzZXJpYWxpemVkU3RhcnQgfSkpLCByZXN0KSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVNpZ25lZElkZW50aWZpZXIoc2lnbmVkSWRlbnRpZmllcnMpIHtcbiAgICByZXR1cm4gc2lnbmVkSWRlbnRpZmllcnMubWFwKChzaSkgPT4ge1xuICAgICAgICBjb25zdCB7IGlkLCBhY2Nlc3NQb2xpY3kgfSA9IHNpO1xuICAgICAgICBjb25zdCBfYSA9IGFjY2Vzc1BvbGljeSAhPT0gbnVsbCAmJiBhY2Nlc3NQb2xpY3kgIT09IHZvaWQgMCA/IGFjY2Vzc1BvbGljeSA6IHt9LCB7IHN0YXJ0LCBleHBpcnkgfSA9IF9hLCByZXN0QWNsID0gX19yZXN0KF9hLCBbXCJzdGFydFwiLCBcImV4cGlyeVwiXSk7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZFN0YXJ0ID0gc3RhcnQgPyBuZXcgRGF0ZShzdGFydCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEV4cGlyeSA9IGV4cGlyeSA/IG5ldyBEYXRlKGV4cGlyeSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFjY2Vzc1BvbGljeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChkZXNlcmlhbGl6ZWRFeHBpcnkgJiYgeyBleHBpcnk6IGRlc2VyaWFsaXplZEV4cGlyeSB9KSksIChkZXNlcmlhbGl6ZWRTdGFydCAmJiB7IHN0YXJ0OiBkZXNlcmlhbGl6ZWRTdGFydCB9KSksIHJlc3RBY2wpLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5T3B0aW9ucyhxdWVyeSkge1xuICAgIGNvbnN0IHsgc2VsZWN0IH0gPSBxdWVyeSwgcXVlcnlPcHRpb25zID0gX19yZXN0KHF1ZXJ5LCBbXCJzZWxlY3RcIl0pO1xuICAgIGNvbnN0IG1hcHBlZFF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnlPcHRpb25zKTtcbiAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFsd2F5cyByZXR1cm5lZCBieSB0aGUgc2VydmljZSBidXQgYXJlIG5vdCBhbGxvd2VkIGluIHNlbGVjdFxuICAgIGNvbnN0IGV4Y2x1ZGVGcm9tU2VsZWN0ID0gW1wiZXRhZ1wiLCBcIm9kYXRhLmV0YWdcIl07XG4gICAgaWYgKHNlbGVjdCkge1xuICAgICAgICBtYXBwZWRRdWVyeS5zZWxlY3QgPSBzZWxlY3RcbiAgICAgICAgICAgIC5maWx0ZXIoKHApID0+ICFleGNsdWRlRnJvbVNlbGVjdC5pbmNsdWRlcyhwKSlcbiAgICAgICAgICAgIC5tYXAodHJhbnNsYXRlUHJvcGVydHlOYW1lRm9yU2VyaWFsaXphdGlvbilcbiAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFF1ZXJ5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IEhlYWRlckNvbnN0YW50cyB9IGZyb20gXCIuL3V0aWxzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29tcHV0ZUhNQUNTSEEyNTYgfSBmcm9tIFwiLi91dGlscy9jb21wdXRlSE1BQ1NIQTI1NlwiO1xuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIHRhYmxlc05hbWVkS2V5Q3JlZGVudGlhbFBvbGljeS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRhYmxlc05hbWVkS2V5Q3JlZGVudGlhbFBvbGljeU5hbWUgPSBcInRhYmxlc05hbWVkS2V5Q3JlZGVudGlhbFBvbGljeVwiO1xuLyoqXG4gKiB0YWJsZXNOYW1lZEtleUNyZWRlbnRpYWxQb2xpY3kgaXMgYSBwb2xpY3kgdXNlZCB0byBzaWduIEhUVFAgcmVxdWVzdCB3aXRoIGEgc2hhcmVkIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhYmxlc05hbWVkS2V5Q3JlZGVudGlhbFBvbGljeShjcmVkZW50aWFsKSB7XG4gICAgZnVuY3Rpb24gc2lnblJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVxdWVzdCwgY3JlZGVudGlhbCk7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoSGVhZGVyQ29uc3RhbnRzLkFVVEhPUklaQVRJT04sIGhlYWRlclZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdGFibGVzTmFtZWRLZXlDcmVkZW50aWFsUG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgc2lnblJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVxdWVzdCwgY3JlZGVudGlhbCkge1xuICAgIGlmICghcmVxdWVzdC5oZWFkZXJzLmhhcyhIZWFkZXJDb25zdGFudHMuWF9NU19EQVRFKSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KEhlYWRlckNvbnN0YW50cy5YX01TX0RBVEUsIG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LmJvZHkgJiYgdHlwZW9mIHJlcXVlc3QuYm9keSA9PT0gXCJzdHJpbmdcIiAmJiByZXF1ZXN0LmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KEhlYWRlckNvbnN0YW50cy5DT05URU5UX0xFTkdUSCwgQnVmZmVyLmJ5dGVMZW5ndGgocmVxdWVzdC5ib2R5KSk7XG4gICAgfVxuICAgIC8vIElmIHgtbXMtZGF0ZSBpcyBwcmVzZW50LCB1c2UgaXQgb3RoZXJ3aXNlIGRhdGVcbiAgICBjb25zdCBkYXRlSGVhZGVyID0gZ2V0SGVhZGVyVmFsdWVUb1NpZ24ocmVxdWVzdCwgSGVhZGVyQ29uc3RhbnRzLlhfTVNfREFURSk7XG4gICAgaWYgKCFkYXRlSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzaWduIHJlcXVlc3Q6IHgtbXMtZGF0ZSBvciBkYXRlIGhlYWRlciBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1RvU2lnbiA9IFtcbiAgICAgICAgZGF0ZUhlYWRlcixcbiAgICAgICAgZ2V0Q2Fub25pY2FsaXplZFJlc291cmNlU3RyaW5nKHJlcXVlc3QsIGNyZWRlbnRpYWwpLFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBjb21wdXRlSE1BQ1NIQTI1NihzdHJpbmdUb1NpZ24sIGNyZWRlbnRpYWwua2V5KTtcbiAgICByZXR1cm4gYFNoYXJlZEtleUxpdGUgJHtjcmVkZW50aWFsLm5hbWV9OiR7c2lnbmF0dXJlfWA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJWYWx1ZVRvU2lnbihyZXF1ZXN0LCBoZWFkZXJOYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KGhlYWRlck5hbWUpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENhbm9uaWNhbGl6ZWRSZXNvdXJjZVN0cmluZyhyZXF1ZXN0LCBjcmVkZW50aWFsKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vcmVzdC9hcGkvc3RvcmFnZXNlcnZpY2VzL2F1dGhvcml6ZS13aXRoLXNoYXJlZC1rZXkjc2hhcmVkLWtleS1saXRlLWFuZC10YWJsZS1zZXJ2aWNlLWZvcm1hdC1mb3ItMjAwOS0wOS0xOS1hbmQtbGF0ZXJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBjb25zdCBwYXRoID0gdXJsLnBhdGhuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBjYW5vbmljYWxpemVkUmVzb3VyY2VTdHJpbmcgPSBcIi9cIiArIGNyZWRlbnRpYWwubmFtZSArIHBhdGg7XG4gICAgLy8gVGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgaW5jbHVkZSB0aGUgcXVlc3Rpb24gbWFyayBhbmQgdGhlIGNvbXAgcGFyYW1ldGVyIChmb3IgZXhhbXBsZSwgP2NvbXA9bWV0YWRhdGEpLiBObyBvdGhlciBwYXJhbWV0ZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBvbiB0aGUgcXVlcnkgc3RyaW5nLlxuICAgIGNvbnN0IGNvbXAgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImNvbXBcIik7XG4gICAgaWYgKGNvbXApIHtcbiAgICAgICAgY2Fub25pY2FsaXplZFJlc291cmNlU3RyaW5nID0gYCR7Y2Fub25pY2FsaXplZFJlc291cmNlU3RyaW5nfT9jb21wPSR7Y29tcH1gO1xuICAgIH1cbiAgICByZXR1cm4gY2Fub25pY2FsaXplZFJlc291cmNlU3RyaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGVzTmFtZWRDcmVkZW50aWFsUG9saWN5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBUaGUgcHJvZ3JhbW1hdGljIGlkZW50aWZpZXIgb2YgdGhlIHRhYmxlc1NBU1Rva2VuUG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgdGFibGVzU0FTVG9rZW5Qb2xpY3lOYW1lID0gXCJ0YWJsZXNTQVNUb2tlblBvbGljeVwiO1xuLyoqXG4gKiB0YWJsZXNTQVNUb2tlblBvbGljeSBpcyBhIHBvbGljeSB1c2VkIHRvIHNpZ24gSFRUUCByZXF1ZXN0IHdpdGggYSBzaGFyZWQga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFibGVzU0FTVG9rZW5Qb2xpY3koY3JlZGVudGlhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRhYmxlc1NBU1Rva2VuUG9saWN5TmFtZSxcbiAgICAgICAgYXN5bmMgc2VuZFJlcXVlc3QocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICAgICAgc2lnblVSTFdpdGhTQVMocmVxdWVzdCwgY3JlZGVudGlhbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25VUkxXaXRoU0FTKHJlcXVlc3QsIGNyZWRlbnRpYWwpIHtcbiAgICBjb25zdCBzYXNQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGNyZWRlbnRpYWwuc2lnbmF0dXJlKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2Ygc2FzUGFyYW1zKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmVxdWVzdC51cmwgPSB1cmwudG9TdHJpbmcoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlc1NBU1Rva2VuUG9saWN5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgQXp1cmVOYW1lZEtleUNyZWRlbnRpYWwgfSBmcm9tIFwiQGF6dXJlL2NvcmUtYXV0aFwiO1xuLyoqXG4gKiBHZXRzIGNsaWVudCBwYXJhbWV0ZXJzIGZyb20gYW4gQWNjb3VudCBDb25uZWN0aW9uIFN0cmluZ1xuICogT25seSBzdXBwb3J0ZWQgaW4gTm9kZS5qcyBub3Qgc3VwcG9ydGVkIGZvciBCcm93c2Vyc1xuICogQHBhcmFtIGV4dHJhY3RlZENyZWRzIC0gcGFyc2VkIGNvbm5lY3Rpb24gc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRhYmxlc1NlcnZpY2VDbGllbnQgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFjY291bnRDb25uZWN0aW9uU3RyaW5nKGV4dHJhY3RlZENyZWRzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzaGFyZWRLZXlDcmVkZW50aWFsID0gbmV3IEF6dXJlTmFtZWRLZXlDcmVkZW50aWFsKGV4dHJhY3RlZENyZWRzLmFjY291bnROYW1lLCBleHRyYWN0ZWRDcmVkcy5hY2NvdW50S2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IGV4dHJhY3RlZENyZWRzLnVybCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY3JlZGVudGlhbDogc2hhcmVkS2V5Q3JlZGVudGlhbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRDb25uZWN0aW9uU3RyaW5nKGFjY291bnROYW1lLCBhY2NvdW50S2V5LCBkZWZhdWx0RW5kcG9pbnRzUHJvdG9jb2wsIGVuZHBvaW50U3VmZml4LCB0YWJsZUVuZHBvaW50KSB7XG4gICAgaWYgKCF0YWJsZUVuZHBvaW50KSB7XG4gICAgICAgIC8vIFRhYmxlRW5kcG9pbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIEFjY291bnQgY29ubmVjdGlvbiBzdHJpbmdcbiAgICAgICAgLy8gQ2FuIGJlIG9idGFpbmVkIGZyb20gYCR7ZGVmYXVsdEVuZHBvaW50c1Byb3RvY29sfTovLyR7YWNjb3VudE5hbWV9LnRhYmxlLiR7ZW5kcG9pbnRTdWZmaXh9YFxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGRlZmF1bHRFbmRwb2ludHNQcm90b2NvbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocHJvdG9jb2wgIT09IFwiaHR0cHNcIiAmJiBwcm90b2NvbCAhPT0gXCJodHRwXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRGVmYXVsdEVuZHBvaW50c1Byb3RvY29sIGluIHRoZSBwcm92aWRlZCBDb25uZWN0aW9uIFN0cmluZy4gRXhwZWN0aW5nICdodHRwcycgb3IgJ2h0dHAnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kcG9pbnRTdWZmaXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRW5kcG9pbnRTdWZmaXggaW4gdGhlIHByb3ZpZGVkIENvbm5lY3Rpb24gU3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlRW5kcG9pbnQgPSBgJHtkZWZhdWx0RW5kcG9pbnRzUHJvdG9jb2x9Oi8vJHthY2NvdW50TmFtZX0udGFibGUuJHtlbmRwb2ludFN1ZmZpeH1gO1xuICAgIH1cbiAgICBpZiAoIWFjY291bnROYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQWNjb3VudE5hbWUgaW4gdGhlIHByb3ZpZGVkIENvbm5lY3Rpb24gU3RyaW5nXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhY2NvdW50S2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFjY291bnRLZXkgaW4gdGhlIHByb3ZpZGVkIENvbm5lY3Rpb24gU3RyaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBcIkFjY291bnRDb25uU3RyaW5nXCIsXG4gICAgICAgIHVybDogdGFibGVFbmRwb2ludCxcbiAgICAgICAgYWNjb3VudE5hbWUsXG4gICAgICAgIGFjY291bnRLZXksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnRDb25uZWN0aW9uU3RyaW5nLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBOYW1lIG9mIHRoZSBhcGlWZXJzaW9uIFBvbGljeVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBhcGlWZXJzaW9uUG9saWN5TmFtZSA9IFwiYXBpVmVyc2lvblBvbGljeVwiO1xuLyoqXG4gKiBQaXBlbGluZSBwb2xpY3kgdGhhdCBlbmFibGVzIHVzZXJzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGFwaSB2ZXJzaW9uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGFwaVZlcnNpb25Qb2xpY3kgPSAoYXBpVmVyc2lvbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGFwaVZlcnNpb25Qb2xpY3lOYW1lLFxuICAgICAgICBzZW5kUmVxdWVzdDogYXN5bmMgKHJlcSwgbmV4dCkgPT4ge1xuICAgICAgICAgICAgcmVxLmhlYWRlcnMuc2V0KFwieC1tcy12ZXJzaW9uXCIsIGFwaVZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQocmVxKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaVZlcnNpb25Qb2xpY3kuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQnVpbGRzIGFuIG9iamVjdCB3aXRoIHRoZSByZXF1aXJlZCBoZWFkZXJzIGZvciBhIFRyYW5zYWN0aW9uIHJlcXVlc3QuIEZvciBib3RoIE5vZGUgYW5kIEJyb3dzZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2VUcmFuc2FjdGlvbkhlYWRlcnModHJhbnNhY3Rpb25HdWlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJ4LW1zLXZlcnNpb25cIjogXCIyMDE5LTAyLTAyXCIsXG4gICAgICAgIERhdGFTZXJ2aWNlVmVyc2lvbjogXCIzLjA7XCIsXG4gICAgICAgIE1heERhdGFTZXJ2aWNlVmVyc2lvbjogXCIzLjA7TmV0RnhcIixcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogYG11bHRpcGFydC9taXhlZDsgYm91bmRhcnk9YmF0Y2hfJHt0cmFuc2FjdGlvbkd1aWR9YCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZVRyYW5zYWN0aW9uSGVhZGVycy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8qKlxuICogRW5jb2RlcyBhIGJ5dGUgYXJyYXkgaW4gYmFzZTY0IGZvcm1hdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBVaW50OEFyYXkgb3Igc3RyaW5nIHRvIGVuY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0RW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBidWZmZXJWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIpO1xuICAgICAgICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbn1cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmFzZTY0IHN0cmluZyB0byBkZWNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NERlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJTZXJpYWxpemVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgYmVhcmVyVG9rZW5BdXRoZW50aWNhdGlvblBvbGljeSB9IGZyb20gXCJAYXp1cmUvY29yZS1yZXN0LXBpcGVsaW5lXCI7XG5pbXBvcnQgeyBhdXRob3JpemVSZXF1ZXN0T25UZW5hbnRDaGFsbGVuZ2UgfSBmcm9tIFwiQGF6dXJlL2NvcmUtY2xpZW50XCI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogU2V0dXBzIHRoZSBjaGFsbGVuZ2UgYXV0aGVudGljYXRpb24gcG9saWN5IGZvciB0aGUgcHJvdmlkZWQgdG9rZW4gY3JlZGVudGlhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRva2VuQ2hhbGxlbmdlQXV0aGVudGljYXRpb25Qb2xpY3kocGlwZWxpbmUsIGNyZWRlbnRpYWwsIHNjb3Blcykge1xuICAgIC8vIE1ha2Ugc3VyZSBubyBiZWFyZXJUb2tlblBvbGljeSBpcyBzZXQuXG4gICAgcGlwZWxpbmUucmVtb3ZlUG9saWN5KHsgbmFtZTogXCJiZWFyZXJUb2tlblBvbGljeVwiIH0pO1xuICAgIHBpcGVsaW5lLmFkZFBvbGljeShiZWFyZXJUb2tlbkF1dGhlbnRpY2F0aW9uUG9saWN5KHtcbiAgICAgICAgY3JlZGVudGlhbCxcbiAgICAgICAgc2NvcGVzLFxuICAgICAgICBjaGFsbGVuZ2VDYWxsYmFja3M6IHsgYXV0aG9yaXplUmVxdWVzdE9uQ2hhbGxlbmdlOiBhdXRob3JpemVSZXF1ZXN0T25UZW5hbnRDaGFsbGVuZ2UgfSxcbiAgICB9KSwge1xuICAgICAgICBwaGFzZTogXCJTaWduXCIsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFsbGVuZ2VBdXRoZW50aWNhdGlvblV0aWxzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgY3JlYXRlSG1hYyB9IGZyb20gXCJjcnlwdG9cIjtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSE1BQ1NIQTI1NihzdHJpbmdUb1NpZ24sIGFjY291bnRLZXkpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShhY2NvdW50S2V5LCBcImJhc2U2NFwiKTtcbiAgICByZXR1cm4gY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBrZXkpLnVwZGF0ZShzdHJpbmdUb1NpZ24sIFwidXRmOFwiKS5kaWdlc3QoXCJiYXNlNjRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wdXRlSE1BQ1NIQTI1Ni5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGZyb21BY2NvdW50Q29ubmVjdGlvblN0cmluZywgZ2V0QWNjb3VudENvbm5lY3Rpb25TdHJpbmcgfSBmcm9tIFwiLi9hY2NvdW50Q29ubmVjdGlvblN0cmluZ1wiO1xuY29uc3QgRGV2ZWxvcG1lbnRDb25uZWN0aW9uU3RyaW5nID0gXCJEZWZhdWx0RW5kcG9pbnRzUHJvdG9jb2w9aHR0cDtBY2NvdW50TmFtZT1kZXZzdG9yZWFjY291bnQxO0FjY291bnRLZXk9RWJ5OHZkTTAyeE5PY3FGbHFVd0pQTGxtRXRsQ0RYSjFPVXpGVDUwdVNSWjZJRnN1RnEyVVZFckN6NEk2dHEvSzFTWkZQVE90ci9LQkhCZWtzb0dNR3c9PTtUYWJsZUVuZHBvaW50PWh0dHA6Ly8xMjcuMC4wLjE6MTAwMDIvZGV2c3RvcmVhY2NvdW50MVwiO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHBhcnNlcyBhIGNvbm5lY3Rpb24gc3RyaW5nIGludG8gYSBzZXQgb2ZcbiAqIHBhcmFtZXRlcnMgdG8gcGFzcyB0byBiZSBwYXNzZWQgdG8gVGFibGVDbGllbnRTZXJ2aWNlLFxuICogZGVwZW5kaW5nIG9uIHRoZSBjb25uZWN0aW9uIHN0cmluZyB0eXBlIHRoZXNlIHBhcmFtZXRlciB3b3VsZFxuICogY29udGFpbjpcbiAqIC0gQWNjb3VudCBDb25uZWN0aW9uIFN0cmluZzogIEEgcGlwZWxpbmUgdG8gc2lnbiB0aGUgcmVxdWVzdCB3aXRoIGEgU2hhcmVkS2V5XG4gKiAtIFNBUyBDb25uZWN0aW9uIFN0cmluZzogQXR0YWNoIGEgU0FTIHRva2VuIHRvIHRoZSBzdG9yYWdlIGFjY291bnQgdXJsIGZvciBhdXRoZW50aWNhdGlvblxuICogQHBhcmFtIGNvbm5lY3Rpb25TdHJpbmcgLSBDb25uZWN0aW9uIHN0cmluZyB0byBwYXJzZVxuICogQHBhcmFtIG9wdGlvbnMgLSBUYWJsZVNlcnZpY2UgY2xpZW50IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudFBhcmFtc0Zyb21Db25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChjb25uZWN0aW9uU3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInVzZWRldmVsb3BtZW50c3RvcmFnZT10cnVlXCIpICE9PSAtMSkge1xuICAgICAgICBjb25uZWN0aW9uU3RyaW5nID0gRGV2ZWxvcG1lbnRDb25uZWN0aW9uU3RyaW5nO1xuICAgICAgICBvcHRpb25zLmFsbG93SW5zZWN1cmVDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkQ3JlZHMgPSBleHRyYWN0Q29ubmVjdGlvblN0cmluZ1BhcnRzKGNvbm5lY3Rpb25TdHJpbmcpO1xuICAgIGlmIChleHRyYWN0ZWRDcmVkcy5raW5kID09PSBcIkFjY291bnRDb25uU3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BY2NvdW50Q29ubmVjdGlvblN0cmluZyhleHRyYWN0ZWRDcmVkcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dHJhY3RlZENyZWRzLmtpbmQgPT09IFwiU0FTQ29ublN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IGAke2V4dHJhY3RlZENyZWRzLnVybH0/JHtleHRyYWN0ZWRDcmVkcy5hY2NvdW50U2FzfWAsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdGlvbiBzdHJpbmcgbXVzdCBiZSBlaXRoZXIgYW4gQWNjb3VudCBjb25uZWN0aW9uIHN0cmluZyBvciBhIFNBUyBjb25uZWN0aW9uIHN0cmluZ1wiKTtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBwYXJ0cyBvZiBhbiBTdG9yYWdlIGFjY291bnQgY29ubmVjdGlvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb25TdHJpbmcgLSBDb25uZWN0aW9uIHN0cmluZy5cbiAqIEByZXR1cm5zIFN0cmluZyBrZXkgdmFsdWUgcGFpcnMgb2YgdGhlIHN0b3JhZ2UgYWNjb3VudCdzIHVybCBhbmQgY3JlZGVudGlhbHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q29ubmVjdGlvblN0cmluZ1BhcnRzKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgICAvLyBNYXRjaGluZyBUYWJsZUVuZHBvaW50IGluIHRoZSBBY2NvdW50IGNvbm5lY3Rpb24gc3RyaW5nXG4gICAgbGV0IHRhYmxlRW5kcG9pbnQgPSBnZXRWYWx1ZUluQ29ublN0cmluZyhjb25uZWN0aW9uU3RyaW5nLCBcIlRhYmxlRW5kcG9pbnRcIik7XG4gICAgLy8gU2xpY2luZyBvZmYgJy8nIGF0IHRoZSBlbmQgaWYgZXhpc3RzXG4gICAgLy8gKFRoZSBtZXRob2RzIHRoYXQgdXNlIGBleHRyYWN0Q29ubmVjdGlvblN0cmluZ1BhcnRzYCBleHBlY3QgdGhlIHVybCB0byBub3QgaGF2ZSBgL2AgYXQgdGhlIGVuZClcbiAgICB0YWJsZUVuZHBvaW50ID0gdGFibGVFbmRwb2ludC5lbmRzV2l0aChcIi9cIikgPyB0YWJsZUVuZHBvaW50LnNsaWNlKDAsIC0xKSA6IHRhYmxlRW5kcG9pbnQ7XG4gICAgaWYgKGlzQWNjb3VudENvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnRDb25uZWN0aW9uU3RyaW5nKGdldFZhbHVlSW5Db25uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcsIFwiQWNjb3VudE5hbWVcIiksIGdldFZhbHVlSW5Db25uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcsIFwiQWNjb3VudEtleVwiKSwgZ2V0VmFsdWVJbkNvbm5TdHJpbmcoY29ubmVjdGlvblN0cmluZywgXCJEZWZhdWx0RW5kcG9pbnRzUHJvdG9jb2xcIiksIGdldFZhbHVlSW5Db25uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcsIFwiRW5kcG9pbnRTdWZmaXhcIiksIHRhYmxlRW5kcG9pbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFNBU0Nvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZywgdGFibGVFbmRwb2ludCk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGNvbm5lY3Rpb24gc3RyaW5nIGlzIGFuIEFjY291bnQgQ29ubmVjdGlvbiBzdHJpbmcgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGlzQWNjb3VudENvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZykge1xuICAgIGNvbnN0IGxvd2VyY2FzZUNvbm5lY3Rpb25TdHJpbmcgPSBjb25uZWN0aW9uU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChsb3dlcmNhc2VDb25uZWN0aW9uU3RyaW5nLnNlYXJjaChcImRlZmF1bHRlbmRwb2ludHNwcm90b2NvbD1cIikgIT09IC0xICYmXG4gICAgICAgIGxvd2VyY2FzZUNvbm5lY3Rpb25TdHJpbmcuc2VhcmNoKFwiYWNjb3VudGtleT1cIikgIT09IC0xKTtcbn1cbmZ1bmN0aW9uIGdldFNBU0Nvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZywgdGFibGVFbmRwb2ludCkge1xuICAgIGNvbnN0IGFjY291bnROYW1lID0gZ2V0QWNjb3VudE5hbWVGcm9tVXJsKHRhYmxlRW5kcG9pbnQpO1xuICAgIGNvbnN0IGFjY291bnRTYXMgPSBnZXRWYWx1ZUluQ29ublN0cmluZyhjb25uZWN0aW9uU3RyaW5nLCBcIlNoYXJlZEFjY2Vzc1NpZ25hdHVyZVwiKTtcbiAgICBpZiAoIXRhYmxlRW5kcG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUYWJsZUVuZHBvaW50IGluIHRoZSBwcm92aWRlZCBTQVMgQ29ubmVjdGlvbiBTdHJpbmdcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhY2NvdW50U2FzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU2hhcmVkQWNjZXNzU2lnbmF0dXJlIGluIHRoZSBwcm92aWRlZCBTQVMgQ29ubmVjdGlvbiBTdHJpbmdcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhY2NvdW50TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFjY291bnROYW1lIGluIHRoZSBwcm92aWRlZCBTQVMgQ29ubmVjdGlvbiBTdHJpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7IGtpbmQ6IFwiU0FTQ29ublN0cmluZ1wiLCB1cmw6IHRhYmxlRW5kcG9pbnQsIGFjY291bnROYW1lLCBhY2NvdW50U2FzIH07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUluQ29ublN0cmluZyhjb25uZWN0aW9uU3RyaW5nLCBhcmd1bWVudCkge1xuICAgIGNvbnN0IHNlYXJjaEtleSA9IGFyZ3VtZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBjb25uZWN0aW9uU3RyaW5nLnNwbGl0KFwiO1wiKS5maWx0ZXIoKGUpID0+IEJvb2xlYW4oZSkpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB0cmltbWVkRWxlbWVudCA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICBjb25zdCBbZWxlbWVudEtleSwgdmFsdWVdID0gZ2V0VmFsdWVQYWlyKHRyaW1tZWRFbGVtZW50KTtcbiAgICAgICAgY29uc3Qga2V5ID0gZWxlbWVudEtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5ID09PSBzZWFyY2hLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlUGFpcihrdnApIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGlzIG5vdCBpbiBrdnAgZm9ybWF0IDxrZXk+PTx2YWx5ZT4gcmV0dXJuIGFuIGVtcHR5IGFycmF5XG4gICAgaWYgKCFrdnAgfHwga3ZwLmluZGV4T2YoXCI9XCIpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc3Vic3RyaW5nIGJlZm9yZSB0aGUgZmlyc3QgJz0nXG4gICAgY29uc3Qga2V5ID0ga3ZwLnN1YnN0cigwLCBrdnAuaW5kZXhPZihcIj1cIikpO1xuICAgIC8vIEdldCB0aGUgc3Vic3RyaW5nIGFmdGVyIHRoZSBmaXJzdCAnPSdcbiAgICBjb25zdCB2YWx1ZSA9IGt2cC5zdWJzdHIoa3ZwLmluZGV4T2YoXCI9XCIpICsgMSk7XG4gICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYWNjb3VudCBuYW1lIGZyb20gdGhlIHVybFxuICogQHBhcmFtIHVybCAtIFVSTCB0byBleHRyYWN0IHRoZSBhY2NvdW50IG5hbWUgZnJvbVxuICogQHJldHVybnMgVGhlIGFjY291bnQgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRBY2NvdW50TmFtZUZyb21VcmwodXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIGxldCBhY2NvdW50TmFtZTtcbiAgICBjb25zdCBob3N0ID0gcGFyc2VkVXJsLmhvc3QgfHwgXCJcIjtcbiAgICBjb25zdCBwYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgY29uc3QgaG9zdFBhcnRzID0gaG9zdC5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgcGF0aFBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgaWYgKGhvc3RQYXJ0cy5sZW5ndGggPj0gMSAmJiBob3N0UGFydHNbMV0gPT09IFwidGFibGVcIikge1xuICAgICAgICAvLyBgJHtkZWZhdWx0RW5kcG9pbnRzUHJvdG9jb2x9Oi8vJHthY2NvdW50TmFtZX0udGFibGUuJHtlbmRwb2ludFN1ZmZpeH1gO1xuICAgICAgICAvLyBTbGljaW5nIG9mZiAnLycgYXQgdGhlIGVuZCBpZiBleGlzdHNcbiAgICAgICAgdXJsID0gdXJsLmVuZHNXaXRoKFwiL1wiKSA/IHVybC5zbGljZSgwLCAtMSkgOiB1cmw7XG4gICAgICAgIGFjY291bnROYW1lID0gaG9zdC5zcGxpdChcIi5cIilbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICAvLyBJUHY0L0lQdjYgYWRkcmVzcyBob3N0cy4uLiBFeGFtcGxlIC0gaHR0cDovLzE5Mi4wLjAuMTA6MTAwMDEvZGV2c3RvcmVhY2NvdW50MS9cbiAgICAgICAgLy8gU2luZ2xlIHdvcmQgZG9tYWluIHdpdGhvdXQgYSBbZG90XSBpbiB0aGUgZW5kcG9pbnQuLi4gRXhhbXBsZSAtIGh0dHA6Ly9sb2NhbGhvc3Q6MTAwMDEvZGV2c3RvcmVhY2NvdW50MS9cbiAgICAgICAgLy8gLmdldFBhdGgoKSAtPiAvZGV2c3RvcmVhY2NvdW50MS9cbiAgICAgICAgYWNjb3VudE5hbWUgPSBwYXRoUGFydHNbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZXh0cmFjdCBhY2NvdW50TmFtZSB3aXRoIHByb3ZpZGVkIGluZm9ybWF0aW9uLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnROYW1lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvblN0cmluZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmV4cG9ydCBjb25zdCBTRVJWSUNFX1ZFUlNJT04gPSBcIjIwMTktMDItMDJcIjtcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9IVFRQX1ZFUlNJT05fMV8xID0gXCJIVFRQLzEuMVwiO1xuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0hUVFBfTElORV9FTkRJTkcgPSBcIlxcclxcblwiO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfU0NPUEUgPSBcImh0dHBzOi8vc3RvcmFnZS5henVyZS5jb20vLmRlZmF1bHRcIjtcbmV4cG9ydCBjb25zdCBIZWFkZXJDb25zdGFudHMgPSB7XG4gICAgQVVUSE9SSVpBVElPTjogXCJhdXRob3JpemF0aW9uXCIsXG4gICAgQ09OVEVOVF9MRU5HVEg6IFwiY29udGVudC1sZW5ndGhcIixcbiAgICBDT05URU5UX01ENTogXCJjb250ZW50LW1kNVwiLFxuICAgIENPTlRFTlRfVFlQRTogXCJjb250ZW50LXR5cGVcIixcbiAgICBDT05URU5UX1RSQU5TRkVSX0VOQ09ESU5HOiBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBEQVRFOiBcImRhdGVcIixcbiAgICBYX01TX0RBVEU6IFwieC1tcy1kYXRlXCIsXG4gICAgWF9NU19WRVJTSU9OOiBcIngtbXMtdmVyc2lvblwiLFxufTtcbmV4cG9ydCBjb25zdCBUYWJsZXNMb2dnaW5nQWxsb3dlZEhlYWRlck5hbWVzID0gW1xuICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIsXG4gICAgXCJDYWNoZS1Db250cm9sXCIsXG4gICAgXCJDb250ZW50LUxlbmd0aFwiLFxuICAgIFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJEYXRlXCIsXG4gICAgXCJQcmVmZXJcIixcbiAgICBcIlByZWZlcmVuY2UtQXBwbGllZFwiLFxuICAgIFwiUmVxdWVzdC1JZFwiLFxuICAgIFwidHJhY2VwYXJlbnRcIixcbiAgICBcIlRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJVc2VyLUFnZW50XCIsXG4gICAgXCJ4LW1zLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgXCJ4LW1zLXVzZXItYWdlbnRcIixcbiAgICBcIngtbXMtZGF0ZVwiLFxuICAgIFwieC1tcy1lcnJvci1jb2RlXCIsXG4gICAgXCJ4LW1zLXJlcXVlc3QtaWRcIixcbiAgICBcIngtbXMtcmV0dXJuLWNsaWVudC1yZXF1ZXN0LWlkXCIsXG4gICAgXCJ4LW1zLXZlcnNpb25cIixcbiAgICBcIkFjY2VwdC1SYW5nZXNcIixcbiAgICBcIkFjY2VwdFwiLFxuICAgIFwiQ29udGVudC1EaXNwb3NpdGlvblwiLFxuICAgIFwiQ29udGVudC1FbmNvZGluZ1wiLFxuICAgIFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIFwiQ29udGVudC1NRDVcIixcbiAgICBcIkNvbnRlbnQtUmFuZ2VcIixcbiAgICBcIkVUYWdcIixcbiAgICBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICBcIlNlcnZlclwiLFxuICAgIFwiVmFyeVwiLFxuICAgIFwieC1tcy1jb250ZW50LWNyYzY0XCIsXG4gICAgXCJ4LW1zLWNvcHktYWN0aW9uXCIsXG4gICAgXCJ4LW1zLWNvcHktY29tcGxldGlvbi10aW1lXCIsXG4gICAgXCJ4LW1zLWNvcHktaWRcIixcbiAgICBcIngtbXMtY29weS1wcm9ncmVzc1wiLFxuICAgIFwieC1tcy1jb3B5LXN0YXR1c1wiLFxuICAgIFwieC1tcy1jb250aW51YXRpb24tTmV4dFRhYmxlTmFtZVwiLFxuICAgIFwieC1tcy1jb250aW51YXRpb24tTmV4dFBhcnRpdGlvbktleVwiLFxuICAgIFwieC1tcy1jb250aW51YXRpb24tTmV4dFJvd0tleVwiLFxuICAgIFwieC1tcy1oYXMtaW1tdXRhYmlsaXR5LXBvbGljeVwiLFxuICAgIFwieC1tcy1oYXMtbGVnYWwtaG9sZFwiLFxuICAgIFwieC1tcy1sZWFzZS1zdGF0ZVwiLFxuICAgIFwieC1tcy1sZWFzZS1zdGF0dXNcIixcbiAgICBcIngtbXMtcmFuZ2VcIixcbiAgICBcIngtbXMtcmVxdWVzdC1zZXJ2ZXItZW5jcnlwdGVkXCIsXG4gICAgXCJ4LW1zLXNlcnZlci1lbmNyeXB0ZWRcIixcbiAgICBcIngtbXMtc25hcHNob3RcIixcbiAgICBcIngtbXMtc291cmNlLXJhbmdlXCIsXG4gICAgXCJJZi1NYXRjaFwiLFxuICAgIFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICBcIklmLU5vbmUtTWF0Y2hcIixcbiAgICBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICBcIngtbXMtYWNjZXNzLXRpZXJcIixcbiAgICBcIngtbXMtYWNjZXNzLXRpZXItY2hhbmdlLXRpbWVcIixcbiAgICBcIngtbXMtYWNjZXNzLXRpZXItaW5mZXJyZWRcIixcbiAgICBcIngtbXMtYWNjb3VudC1raW5kXCIsXG4gICAgXCJ4LW1zLWFyY2hpdmUtc3RhdHVzXCIsXG4gICAgXCJ4LW1zLWNvcHktZGVzdGluYXRpb24tc25hcHNob3RcIixcbiAgICBcIngtbXMtY3JlYXRpb24tdGltZVwiLFxuICAgIFwieC1tcy1kZWZhdWx0LWVuY3J5cHRpb24tc2NvcGVcIixcbiAgICBcIngtbXMtZGVsZXRlLXR5cGUtcGVybWFuZW50XCIsXG4gICAgXCJ4LW1zLWRlbnktZW5jcnlwdGlvbi1zY29wZS1vdmVycmlkZVwiLFxuICAgIFwieC1tcy1lbmNyeXB0aW9uLWFsZ29yaXRobVwiLFxuICAgIFwieC1tcy1pbmNyZW1lbnRhbC1jb3B5XCIsXG4gICAgXCJ4LW1zLWxlYXNlLWFjdGlvblwiLFxuICAgIFwieC1tcy1sZWFzZS1icmVhay1wZXJpb2RcIixcbiAgICBcIngtbXMtbGVhc2UtZHVyYXRpb25cIixcbiAgICBcIngtbXMtbGVhc2UtaWRcIixcbiAgICBcIngtbXMtbGVhc2UtdGltZVwiLFxuICAgIFwieC1tcy1wYWdlLXdyaXRlXCIsXG4gICAgXCJ4LW1zLXByb3Bvc2VkLWxlYXNlLWlkXCIsXG4gICAgXCJ4LW1zLXJhbmdlLWdldC1jb250ZW50LW1kNVwiLFxuICAgIFwieC1tcy1yZWh5ZHJhdGUtcHJpb3JpdHlcIixcbiAgICBcIngtbXMtc2VxdWVuY2UtbnVtYmVyLWFjdGlvblwiLFxuICAgIFwieC1tcy1za3UtbmFtZVwiLFxuICAgIFwieC1tcy1zb3VyY2UtY29udGVudC1tZDVcIixcbiAgICBcIngtbXMtc291cmNlLWlmLW1hdGNoXCIsXG4gICAgXCJ4LW1zLXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFxuICAgIFwieC1tcy1zb3VyY2UtaWYtbm9uZS1tYXRjaFwiLFxuICAgIFwieC1tcy1zb3VyY2UtaWYtdW5tb2RpZmllZC1zaW5jZVwiLFxuICAgIFwieC1tcy10YWctY291bnRcIixcbiAgICBcIngtbXMtZW5jcnlwdGlvbi1rZXktc2hhMjU2XCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiLi9idWZmZXJTZXJpYWxpemVyXCI7XG4vKipcbiAqIEVuY29kZXMgdGhlIG5leHRQYXJ0aXRpb25LZXkgYW5kIG5leHRSb3dLZXkgaW50byBhIHNpbmdsZSBjb250aW51YXRpb24gdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNvbnRpbnVhdGlvblRva2VuKG5leHRQYXJ0aXRpb25LZXksIG5leHRSb3dLZXkpIHtcbiAgICBpZiAoIW5leHRQYXJ0aXRpb25LZXkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY29udGludWF0aW9uVG9rZW4gPSBPYmplY3QuYXNzaWduKHsgbmV4dFBhcnRpdGlvbktleSB9LCAobmV4dFJvd0tleSAmJiB7IG5leHRSb3dLZXkgfSkpO1xuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoY29udGludWF0aW9uVG9rZW4pKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIGNvbnRpbnVhdGlvblRva2VuIGludG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBuZXh0UGFydGl0aW9uS2V5IGFuZCBuZXh0Um93S2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVDb250aW51YXRpb25Ub2tlbihlbmNvZGVkVG9rZW4pIHtcbiAgICBjb25zdCBkZWNvZGVkVG9rZW4gPSBiYXNlNjREZWNvZGUoZW5jb2RlZFRva2VuKTtcbiAgICBsZXQgdG9rZW5TdHIgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBkZWNvZGVkVG9rZW4pIHtcbiAgICAgICAgdG9rZW5TdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICB9XG4gICAgY29uc3QgY29udGludWF0aW9uVG9rZW4gPSBKU09OLnBhcnNlKHRva2VuU3RyKTtcbiAgICByZXR1cm4gY29udGludWF0aW9uVG9rZW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250aW51YXRpb25Ub2tlbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVUYWJsZUFscmVhZHlFeGlzdHMoZXJyb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcmVzcG9uc2VFcnJvciA9IGdldEVycm9yUmVzcG9uc2UoZXJyb3IpO1xuICAgIGlmIChyZXNwb25zZUVycm9yICYmXG4gICAgICAgIHJlc3BvbnNlRXJyb3Iuc3RhdHVzID09PSA0MDkgJiZcbiAgICAgICAgKChfYSA9IHJlc3BvbnNlRXJyb3IucGFyc2VkQm9keS5vZGF0YUVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IFwiVGFibGVBbHJlYWR5RXhpc3RzXCIpIHtcbiAgICAgICAgKF9iID0gb3B0aW9ucy5sb2dnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmZvKGBUYWJsZSAke29wdGlvbnMudGFibGVOYW1lfSBhbHJlYWR5IEV4aXN0c2ApO1xuICAgICAgICBpZiAob3B0aW9ucy5vblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uUmVzcG9uc2UocmVzcG9uc2VFcnJvciwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gICAgaWYgKCFpc1Jlc3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xuICAgIGlmICghZXJyb3JSZXNwb25zZSB8fCAhaXNUYWJsZVNlcnZpY2VFcnJvclJlc3BvbnNlKGVycm9yUmVzcG9uc2UucGFyc2VkQm9keSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yUmVzcG9uc2U7XG59XG5mdW5jdGlvbiBpc1Jlc3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5uYW1lID09PSBcIlJlc3RFcnJvclwiO1xufVxuZnVuY3Rpb24gaXNUYWJsZVNlcnZpY2VFcnJvclJlc3BvbnNlKGVycm9yUmVzcG9uc2VCb2R5KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZXJyb3JSZXNwb25zZUJvZHkgPT09IG51bGwgfHwgZXJyb3JSZXNwb25zZUJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUmVzcG9uc2VCb2R5Lm9kYXRhRXJyb3IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JIZWxwZXJzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29zbW9zRW5kcG9pbnQodXJsKSB7XG4gICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwYXJzZWRVUkwuaG9zdG5hbWUuaW5kZXhPZihcIi50YWJsZS5jb3Ntb3NkYi5cIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGFyc2VkVVJMLmhvc3RuYW1lLmluZGV4T2YoXCIudGFibGUuY29zbW9zLlwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXJzZWRVUkwuaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgJiYgcGFyc2VkVVJMLnBvcnQgIT09IFwiMTAwMDJcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNDb3Ntb3NFbmRwb2ludC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGlzTmFtZWRLZXlDcmVkZW50aWFsLCBpc1NBU0NyZWRlbnRpYWwsIGlzVG9rZW5DcmVkZW50aWFsLCB9IGZyb20gXCJAYXp1cmUvY29yZS1hdXRoXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNDcmVkZW50aWFsKGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gKGlzU0FTQ3JlZGVudGlhbChjcmVkZW50aWFsKSB8fCBpc05hbWVkS2V5Q3JlZGVudGlhbChjcmVkZW50aWFsKSB8fCBpc1Rva2VuQ3JlZGVudGlhbChjcmVkZW50aWFsKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0NyZWRlbnRpYWwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBjcmVhdGVUcmFjaW5nQ2xpZW50IH0gZnJvbSBcIkBhenVyZS9jb3JlLXRyYWNpbmdcIjtcbi8qKlxuICogQSB0cmFjaW5nIGNsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBzcGFucy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgdHJhY2luZ0NsaWVudCA9IGNyZWF0ZVRyYWNpbmdDbGllbnQoe1xuICAgIG5hbWVzcGFjZTogXCJNaWNyb3NvZnQuRGF0YS5UYWJsZXNcIixcbiAgICBwYWNrYWdlTmFtZTogXCJAYXp1cmUvZGF0YS10YWJsZXNcIixcbiAgICBwYWNrYWdlVmVyc2lvbjogXCIxMy4yLjBcIixcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2luZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGdldEJhc2VUcmFuc2FjdGlvbkhlYWRlcnMgfSBmcm9tIFwiLi9iYXNlVHJhbnNhY3Rpb25IZWFkZXJzXCI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQnVpbGRzIGFuIG9iamVjdCB3aXRoIHRoZSByZXF1aXJlZCBoZWFkZXJzIGZvciBhIFRyYW5zYWN0aW9uIHJlcXVlc3QuIEZvciBOb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkhlYWRlcnModHJhbnNhY3Rpb25HdWlkKSB7XG4gICAgY29uc3QgYmFzZUhlYWRlcnMgPSBnZXRCYXNlVHJhbnNhY3Rpb25IZWFkZXJzKHRyYW5zYWN0aW9uR3VpZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZUhlYWRlcnMpLCB7IFxuICAgICAgICAvLyBUaGUgYmVsb3cgaGVhZGVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciBhcyB0aGV5IGFyZSBmbGFnZ2VkIGFzIFwidW5zYWZlIGhlYWRlcnNcIlxuICAgICAgICBcIkFjY2VwdC1DaGFyc2V0XCI6IFwiVVRGLThcIiwgQ29ubmVjdGlvbjogXCJLZWVwLUFsaXZlXCIgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbkhlYWRlcnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyBIZWFkZXJDb25zdGFudHMsIFRSQU5TQUNUSU9OX0hUVFBfTElORV9FTkRJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbi8qKlxuICogQnVpbGRzIGEgdHJhbnNhY3Rpb24gY2hhbmdlIHNldCBib3VuZGFyeSB0byBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdCBib2R5XG4gKiBAcGFyYW0gY2hhbmdlc2V0SWQgLSBJZCBvZiB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFuZ2VTZXRCb3VuZGFyeShjaGFuZ2VzZXRJZCkge1xuICAgIHJldHVybiBgY2hhbmdlc2V0XyR7Y2hhbmdlc2V0SWR9YDtcbn1cbi8qKlxuICogQnVpbGRzIGEgdHJhbnNhY3Rpb24gYm91bmRhcnkgdG8gYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uIHJlcXVlc3QgYm9keVxuICogQHBhcmFtIHRyYW5zYWN0aW9uSWQgLSBJZCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQm91bmRhcnkodHJhbnNhY3Rpb25JZCkge1xuICAgIHJldHVybiBgYmF0Y2hfJHt0cmFuc2FjdGlvbklkfWA7XG59XG4vKipcbiAqIFJldHVybnMgYW4gaW5pdGlhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNhY3Rpb24gYm9keS5cbiAqIEBwYXJhbSB0cmFuc2FjdGlvbklkIC0gSWQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gY2hhbmdlc2V0SWQgLSBJZCBvZiB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsVHJhbnNhY3Rpb25Cb2R5KHRyYW5zYWN0aW9uSWQsIGNoYW5nZXNldElkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25Cb3VuZGFyeSA9IGBiYXRjaF8ke3RyYW5zYWN0aW9uSWR9YDtcbiAgICByZXR1cm4gW1xuICAgICAgICBgLS0ke3RyYW5zYWN0aW9uQm91bmRhcnl9JHtUUkFOU0FDVElPTl9IVFRQX0xJTkVfRU5ESU5HfSR7SGVhZGVyQ29uc3RhbnRzLkNPTlRFTlRfVFlQRX06IG11bHRpcGFydC9taXhlZDsgYm91bmRhcnk9Y2hhbmdlc2V0XyR7Y2hhbmdlc2V0SWR9JHtUUkFOU0FDVElPTl9IVFRQX0xJTkVfRU5ESU5HfSR7VFJBTlNBQ1RJT05fSFRUUF9MSU5FX0VORElOR31gLFxuICAgIF07XG59XG4vKipcbiAqIEJ1aWxkIHRoZSBUcmFuc2FjdGlvbiBodHRwIHJlcXVlc3QgYm9keSB0byBzZW5kIHRvIHRoZSBzZXJ2aWNlLlxuICogQHBhcmFtIGJvZHlQYXJ0cyAtIFBhcnRzIG9mIHRoZSB0cmFuc2FjdGlvbiBib2R5LCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3Rpb25zIHRvIGJlIGluY2x1ZGVkIGluIHRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25JZCAtIElkIG9mIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGNoYW5nZXNldElkIC0gSWQgb2YgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZXNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25IdHRwUmVxdWVzdEJvZHkoYm9keVBhcnRzLCB0cmFuc2FjdGlvbklkLCBjaGFuZ2VzZXRJZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQm91bmRhcnkgPSBnZXRUcmFuc2FjdGlvbkJvdW5kYXJ5KHRyYW5zYWN0aW9uSWQpO1xuICAgIGNvbnN0IGNoYW5nZXNldEJvdW5kYXJ5ID0gZ2V0Q2hhbmdlU2V0Qm91bmRhcnkoY2hhbmdlc2V0SWQpO1xuICAgIGNvbnN0IGNoYW5nZXNldEVuZGluZyA9IGAtLSR7Y2hhbmdlc2V0Qm91bmRhcnl9LS1gO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRW5kaW5nID0gYC0tJHt0cmFuc2FjdGlvbkJvdW5kYXJ5fS0tYDtcbiAgICBjb25zdCBib2R5Q29udGVudCA9IGJvZHlQYXJ0cy5qb2luKFRSQU5TQUNUSU9OX0hUVFBfTElORV9FTkRJTkcpO1xuICAgIHJldHVybiBgJHtib2R5Q29udGVudH0ke1RSQU5TQUNUSU9OX0hUVFBfTElORV9FTkRJTkd9JHtjaGFuZ2VzZXRFbmRpbmd9JHtUUkFOU0FDVElPTl9IVFRQX0xJTkVfRU5ESU5HfSR7dHJhbnNhY3Rpb25FbmRpbmd9JHtUUkFOU0FDVElPTl9IVFRQX0xJTkVfRU5ESU5HfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbkhlbHBlcnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vKipcbiAqIFJvdW5kcyBhIGRhdGUgb2ZmIHRvIHNlY29uZHMuXG4gKlxuICogQHBhcmFtIGRhdGUgLVxuICogQHBhcmFtIHdpdGhNaWxsaXNlY29uZHMgLSBJZiB0cnVlLCBZWVlZLU1NLUREVGhoOm1tOnNzLmZmZmZmZmZaIHdpbGwgYmUgcmV0dXJuZWQ7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGZhbHNlLCBZWVlZLU1NLUREVGhoOm1tOnNzWiB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybnMgRGF0ZSBzdHJpbmcgaW4gSVNPODA2MSBmb3JtYXQsIHdpdGggb3Igd2l0aG91dCA3IG1pbGxpc2Vjb25kcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydW5jYXRlZElTTzgwNjFEYXRlKGRhdGUsIHdpdGhNaWxsaXNlY29uZHMgPSB0cnVlKSB7XG4gICAgLy8gRGF0ZS50b0lTT1N0cmluZygpIHdpbGwgcmV0dXJuIGxpa2UgXCIyMDE4LTEwLTI5VDA2OjM0OjM2LjEzOVpcIlxuICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuIHdpdGhNaWxsaXNlY29uZHNcbiAgICAgICAgPyBkYXRlU3RyaW5nLnN1YnN0cmluZygwLCBkYXRlU3RyaW5nLmxlbmd0aCAtIDEpICsgXCIwMDAwXCIgKyBcIlpcIlxuICAgICAgICA6IGRhdGVTdHJpbmcuc3Vic3RyaW5nKDAsIGRhdGVTdHJpbmcubGVuZ3RoIC0gNSkgKyBcIlpcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRydW5jYXRlSVNPODA2MURhdGUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuLy8gVGhpcyBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCB0byBiZSBhYmxlIHRvIHN0dWIgZ2VuZXJhdGVVdWlkXG4vLyBkdXJpbmcgdGVzdGluZy5cbmV4cG9ydCBjbGFzcyBVdWlkIHtcbiAgICBzdGF0aWMgZ2VuZXJhdGVVdWlkKCkge1xuICAgICAgICByZXR1cm4gdXVpZHY0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL2xvZ1wiO1xuY29uc3QgZGVidWdFbnZWYXJpYWJsZSA9ICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5ERUJVRykgfHwgdW5kZWZpbmVkO1xubGV0IGVuYWJsZWRTdHJpbmc7XG5sZXQgZW5hYmxlZE5hbWVzcGFjZXMgPSBbXTtcbmxldCBza2lwcGVkTmFtZXNwYWNlcyA9IFtdO1xuY29uc3QgZGVidWdnZXJzID0gW107XG5pZiAoZGVidWdFbnZWYXJpYWJsZSkge1xuICAgIGVuYWJsZShkZWJ1Z0VudlZhcmlhYmxlKTtcbn1cbmNvbnN0IGRlYnVnT2JqID0gT2JqZWN0LmFzc2lnbigobmFtZXNwYWNlKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnZ2VyKG5hbWVzcGFjZSk7XG59LCB7XG4gICAgZW5hYmxlLFxuICAgIGVuYWJsZWQsXG4gICAgZGlzYWJsZSxcbiAgICBsb2dcbn0pO1xuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBlbmFibGVkU3RyaW5nID0gbmFtZXNwYWNlcztcbiAgICBlbmFibGVkTmFtZXNwYWNlcyA9IFtdO1xuICAgIHNraXBwZWROYW1lc3BhY2VzID0gW107XG4gICAgY29uc3Qgd2lsZGNhcmQgPSAvXFwqL2c7XG4gICAgY29uc3QgbmFtZXNwYWNlTGlzdCA9IG5hbWVzcGFjZXMuc3BsaXQoXCIsXCIpLm1hcCgobnMpID0+IG5zLnRyaW0oKS5yZXBsYWNlKHdpbGRjYXJkLCBcIi4qP1wiKSk7XG4gICAgZm9yIChjb25zdCBucyBvZiBuYW1lc3BhY2VMaXN0KSB7XG4gICAgICAgIGlmIChucy5zdGFydHNXaXRoKFwiLVwiKSkge1xuICAgICAgICAgICAgc2tpcHBlZE5hbWVzcGFjZXMucHVzaChuZXcgUmVnRXhwKGBeJHtucy5zdWJzdHIoMSl9JGApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuYWJsZWROYW1lc3BhY2VzLnB1c2gobmV3IFJlZ0V4cChgXiR7bnN9JGApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGRlYnVnZ2Vycykge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGVkID0gZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZXNwYWNlKSB7XG4gICAgaWYgKG5hbWVzcGFjZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2tpcHBlZCBvZiBza2lwcGVkTmFtZXNwYWNlcykge1xuICAgICAgICBpZiAoc2tpcHBlZC50ZXN0KG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVuYWJsZWROYW1lc3BhY2Ugb2YgZW5hYmxlZE5hbWVzcGFjZXMpIHtcbiAgICAgICAgaWYgKGVuYWJsZWROYW1lc3BhY2UudGVzdChuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGVuYWJsZWRTdHJpbmcgfHwgXCJcIjtcbiAgICBlbmFibGUoXCJcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnZ2VyKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IG5ld0RlYnVnZ2VyID0gT2JqZWN0LmFzc2lnbihkZWJ1Zywge1xuICAgICAgICBlbmFibGVkOiBlbmFibGVkKG5hbWVzcGFjZSksXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIGxvZzogZGVidWdPYmoubG9nLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIGV4dGVuZFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFuZXdEZWJ1Z2dlci5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXJnc1swXSA9IGAke25hbWVzcGFjZX0gJHthcmdzWzBdfWA7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGVidWdnZXIubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1Z2dlcnMucHVzaChuZXdEZWJ1Z2dlcik7XG4gICAgcmV0dXJuIG5ld0RlYnVnZ2VyO1xufVxuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBjb25zdCBpbmRleCA9IGRlYnVnZ2Vycy5pbmRleE9mKHRoaXMpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGRlYnVnZ2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IG5ld0RlYnVnZ2VyID0gY3JlYXRlRGVidWdnZXIoYCR7dGhpcy5uYW1lc3BhY2V9OiR7bmFtZXNwYWNlfWApO1xuICAgIG5ld0RlYnVnZ2VyLmxvZyA9IHRoaXMubG9nO1xuICAgIHJldHVybiBuZXdEZWJ1Z2dlcjtcbn1cbmV4cG9ydCBkZWZhdWx0IGRlYnVnT2JqO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWcuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5pbXBvcnQgZGVidWcgZnJvbSBcIi4vZGVidWdcIjtcbmNvbnN0IHJlZ2lzdGVyZWRMb2dnZXJzID0gbmV3IFNldCgpO1xuY29uc3QgbG9nTGV2ZWxGcm9tRW52ID0gKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LkFaVVJFX0xPR19MRVZFTCkgfHwgdW5kZWZpbmVkO1xubGV0IGF6dXJlTG9nTGV2ZWw7XG4vKipcbiAqIFRoZSBBenVyZUxvZ2dlciBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3Igb3ZlcnJpZGluZyB3aGVyZSBsb2dzIGFyZSBvdXRwdXQgdG8uXG4gKiBCeSBkZWZhdWx0LCBsb2dzIGFyZSBzZW50IHRvIHN0ZGVyci5cbiAqIE92ZXJyaWRlIHRoZSBgbG9nYCBtZXRob2QgdG8gcmVkaXJlY3QgbG9ncyB0byBhbm90aGVyIGxvY2F0aW9uLlxuICovXG5leHBvcnQgY29uc3QgQXp1cmVMb2dnZXIgPSBkZWJ1ZyhcImF6dXJlXCIpO1xuQXp1cmVMb2dnZXIubG9nID0gKC4uLmFyZ3MpID0+IHtcbiAgICBkZWJ1Zy5sb2coLi4uYXJncyk7XG59O1xuY29uc3QgQVpVUkVfTE9HX0xFVkVMUyA9IFtcInZlcmJvc2VcIiwgXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdO1xuaWYgKGxvZ0xldmVsRnJvbUVudikge1xuICAgIC8vIGF2b2lkIGNhbGxpbmcgc2V0TG9nTGV2ZWwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGEgbWlzLXNldCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBjcmFzaFxuICAgIGlmIChpc0F6dXJlTG9nTGV2ZWwobG9nTGV2ZWxGcm9tRW52KSkge1xuICAgICAgICBzZXRMb2dMZXZlbChsb2dMZXZlbEZyb21FbnYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQVpVUkVfTE9HX0xFVkVMIHNldCB0byB1bmtub3duIGxvZyBsZXZlbCAnJHtsb2dMZXZlbEZyb21FbnZ9JzsgbG9nZ2luZyBpcyBub3QgZW5hYmxlZC4gQWNjZXB0YWJsZSB2YWx1ZXM6ICR7QVpVUkVfTE9HX0xFVkVMUy5qb2luKFwiLCBcIil9LmApO1xuICAgIH1cbn1cbi8qKlxuICogSW1tZWRpYXRlbHkgZW5hYmxlcyBsb2dnaW5nIGF0IHRoZSBzcGVjaWZpZWQgbG9nIGxldmVsLlxuICogQHBhcmFtIGxldmVsIC0gVGhlIGxvZyBsZXZlbCB0byBlbmFibGUgZm9yIGxvZ2dpbmcuXG4gKiBPcHRpb25zIGZyb20gbW9zdCB2ZXJib3NlIHRvIGxlYXN0IHZlcmJvc2UgYXJlOlxuICogLSB2ZXJib3NlXG4gKiAtIGluZm9cbiAqIC0gd2FybmluZ1xuICogLSBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwgJiYgIWlzQXp1cmVMb2dMZXZlbChsZXZlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvZyBsZXZlbCAnJHtsZXZlbH0nLiBBY2NlcHRhYmxlIHZhbHVlczogJHtBWlVSRV9MT0dfTEVWRUxTLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBhenVyZUxvZ0xldmVsID0gbGV2ZWw7XG4gICAgY29uc3QgZW5hYmxlZE5hbWVzcGFjZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiByZWdpc3RlcmVkTG9nZ2Vycykge1xuICAgICAgICBpZiAoc2hvdWxkRW5hYmxlKGxvZ2dlcikpIHtcbiAgICAgICAgICAgIGVuYWJsZWROYW1lc3BhY2VzLnB1c2gobG9nZ2VyLm5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVidWcuZW5hYmxlKGVuYWJsZWROYW1lc3BhY2VzLmpvaW4oXCIsXCIpKTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjdXJyZW50bHkgc3BlY2lmaWVkIGxvZyBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ0xldmVsKCkge1xuICAgIHJldHVybiBhenVyZUxvZ0xldmVsO1xufVxuY29uc3QgbGV2ZWxNYXAgPSB7XG4gICAgdmVyYm9zZTogNDAwLFxuICAgIGluZm86IDMwMCxcbiAgICB3YXJuaW5nOiAyMDAsXG4gICAgZXJyb3I6IDEwMFxufTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciBmb3IgdXNlIGJ5IHRoZSBBenVyZSBTREtzIHRoYXQgaW5oZXJpdHMgZnJvbSBgQXp1cmVMb2dnZXJgLlxuICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBuYW1lIG9mIHRoZSBTREsgcGFja2FnZS5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudExvZ2dlcihuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBjbGllbnRSb290TG9nZ2VyID0gQXp1cmVMb2dnZXIuZXh0ZW5kKG5hbWVzcGFjZSk7XG4gICAgcGF0Y2hMb2dNZXRob2QoQXp1cmVMb2dnZXIsIGNsaWVudFJvb3RMb2dnZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBjcmVhdGVMb2dnZXIoY2xpZW50Um9vdExvZ2dlciwgXCJlcnJvclwiKSxcbiAgICAgICAgd2FybmluZzogY3JlYXRlTG9nZ2VyKGNsaWVudFJvb3RMb2dnZXIsIFwid2FybmluZ1wiKSxcbiAgICAgICAgaW5mbzogY3JlYXRlTG9nZ2VyKGNsaWVudFJvb3RMb2dnZXIsIFwiaW5mb1wiKSxcbiAgICAgICAgdmVyYm9zZTogY3JlYXRlTG9nZ2VyKGNsaWVudFJvb3RMb2dnZXIsIFwidmVyYm9zZVwiKVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRjaExvZ01ldGhvZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgY2hpbGQubG9nID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcGFyZW50LmxvZyguLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKHBhcmVudCwgbGV2ZWwpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBPYmplY3QuYXNzaWduKHBhcmVudC5leHRlbmQobGV2ZWwpLCB7XG4gICAgICAgIGxldmVsXG4gICAgfSk7XG4gICAgcGF0Y2hMb2dNZXRob2QocGFyZW50LCBsb2dnZXIpO1xuICAgIGlmIChzaG91bGRFbmFibGUobG9nZ2VyKSkge1xuICAgICAgICBjb25zdCBlbmFibGVkTmFtZXNwYWNlcyA9IGRlYnVnLmRpc2FibGUoKTtcbiAgICAgICAgZGVidWcuZW5hYmxlKGVuYWJsZWROYW1lc3BhY2VzICsgXCIsXCIgKyBsb2dnZXIubmFtZXNwYWNlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJlZExvZ2dlcnMuYWRkKGxvZ2dlcik7XG4gICAgcmV0dXJuIGxvZ2dlcjtcbn1cbmZ1bmN0aW9uIHNob3VsZEVuYWJsZShsb2dnZXIpIHtcbiAgICBpZiAoYXp1cmVMb2dMZXZlbCAmJiBsZXZlbE1hcFtsb2dnZXIubGV2ZWxdIDw9IGxldmVsTWFwW2F6dXJlTG9nTGV2ZWxdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQXp1cmVMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgIHJldHVybiBBWlVSRV9MT0dfTEVWRUxTLmluY2x1ZGVzKGxvZ0xldmVsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHV0aWwgZnJvbSBcInV0aWxcIjtcbmltcG9ydCB7IEVPTCB9IGZyb20gXCJvc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyhtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYCR7dXRpbC5mb3JtYXQobWVzc2FnZSwgLi4uYXJncyl9JHtFT0x9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZXhlY2EgPSByZXF1aXJlKCdleGVjYScpO1xuXG5jb25zdCBnZXRDb2x1bW5Cb3VuZGFyaWVzID0gYXN5bmMgaGVhZGVyID0+IHtcblx0Ly8gUmVnZXggY2FwdHVyZXMgZWFjaCBpbmRpdmlkdWFsIGNvbHVtblxuXHQvLyBeXFxTK1xccysgICAgICAgLT4gRmlyc3QgY29sdW1uXG5cdC8vIFxccypcXFMrXFxzKlxcUyskIC0+IExhc3QgY29sdW1uIChjb21iaW5lZClcblx0Ly8gXFxzKlxcUysgICAgICAgIC0+IFJlZ3VsYXIgY29sdW1uc1xuXHRjb25zdCByZWdleCA9IC9eXFxTK1xccyt8XFxzKlxcUytcXHMqXFxTKyR8XFxzKlxcUysvZztcblx0Y29uc3QgYm91bmRhcmllcyA9IFtdO1xuXHRsZXQgbWF0Y2g7XG5cblx0d2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoaGVhZGVyKSkpIHtcblx0XHRib3VuZGFyaWVzLnB1c2gobWF0Y2hbMF0ubGVuZ3RoKTtcblx0fVxuXG5cdC8vIEV4dGVuZCBsYXN0IGNvbHVtbiBib3VuZGFyeVxuXHRib3VuZGFyaWVzW2JvdW5kYXJpZXMubGVuZ3RoIC0gMV0gPSAtMTtcblxuXHRyZXR1cm4gYm91bmRhcmllcztcbn07XG5cbmNvbnN0IHBhcnNlT3V0cHV0ID0gYXN5bmMgb3V0cHV0ID0+IHtcblx0Y29uc3QgbGluZXMgPSBvdXRwdXQudHJpbSgpLnNwbGl0KCdcXG4nKTtcblx0Y29uc3QgYm91bmRhcmllcyA9IGF3YWl0IGdldENvbHVtbkJvdW5kYXJpZXMobGluZXNbMF0pO1xuXG5cdHJldHVybiBsaW5lcy5zbGljZSgxKS5tYXAobGluZSA9PiB7XG5cdFx0Y29uc3QgY2wgPSBib3VuZGFyaWVzLm1hcChib3VuZGFyeSA9PiB7XG5cdFx0XHQvLyBIYW5kbGUgZXh0cmEtbG9uZyBsYXN0IGNvbHVtblxuXHRcdFx0Y29uc3QgY29sdW1uID0gYm91bmRhcnkgPiAwID8gbGluZS5zbGljZSgwLCBib3VuZGFyeSkgOiBsaW5lO1xuXHRcdFx0bGluZSA9IGxpbmUuc2xpY2UoYm91bmRhcnkpO1xuXHRcdFx0cmV0dXJuIGNvbHVtbi50cmltKCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZmlsZXN5c3RlbTogY2xbMF0sXG5cdFx0XHRzaXplOiBwYXJzZUludChjbFsxXSwgMTApICogMTAyNCxcblx0XHRcdHVzZWQ6IHBhcnNlSW50KGNsWzJdLCAxMCkgKiAxMDI0LFxuXHRcdFx0YXZhaWxhYmxlOiBwYXJzZUludChjbFszXSwgMTApICogMTAyNCxcblx0XHRcdGNhcGFjaXR5OiBwYXJzZUludChjbFs0XSwgMTApIC8gMTAwLFxuXHRcdFx0bW91bnRwb2ludDogY2xbNV1cblx0XHR9O1xuXHR9KTtcbn07XG5cbmNvbnN0IHJ1biA9IGFzeW5jIGFyZ3MgPT4ge1xuXHRjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWNhKCdkZicsIGFyZ3MpO1xuXHRyZXR1cm4gcGFyc2VPdXRwdXQoc3Rkb3V0KTtcbn07XG5cbmNvbnN0IGRmID0gYXN5bmMgKCkgPT4gcnVuKFsnLWtQJ10pO1xuXG5kZi5mcyA9IGFzeW5jIG5hbWUgPT4ge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBuYW1lYCBwYXJhbWV0ZXIgcmVxdWlyZWQnKTtcblx0fVxuXG5cdGNvbnN0IGRhdGEgPSBhd2FpdCBydW4oWycta1AnXSk7XG5cblx0Zm9yIChjb25zdCBpdGVtIG9mIGRhdGEpIHtcblx0XHRpZiAoaXRlbS5maWxlc3lzdGVtID09PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgZmlsZXN5c3RlbSBcXGAke25hbWV9XFxgIGRvZXNuJ3QgZXhpc3RgKTtcbn07XG5cbmRmLmZpbGUgPSBhc3luYyBmaWxlID0+IHtcblx0aWYgKHR5cGVvZiBmaWxlICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgZmlsZWAgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG5cdH1cblxuXHRsZXQgZGF0YTtcblx0dHJ5IHtcblx0XHRkYXRhID0gYXdhaXQgcnVuKFsnLWtQJywgZmlsZV0pO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmICgvTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeS8udGVzdChlcnJvci5zdGRlcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgZmlsZSBcXGAke2ZpbGV9XFxgIGRvZXNuJ3QgZXhpc3RgKTtcblx0XHR9XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fVxuXG5cdHJldHVybiBkYXRhWzBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZjtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBkZjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcblx0bW9kdWxlLmV4cG9ydHMuX3BhcnNlT3V0cHV0ID0gcGFyc2VPdXRwdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY2hpbGRQcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuY29uc3QgY3Jvc3NTcGF3biA9IHJlcXVpcmUoJ2Nyb3NzLXNwYXduJyk7XG5jb25zdCBzdHJpcEZpbmFsTmV3bGluZSA9IHJlcXVpcmUoJ3N0cmlwLWZpbmFsLW5ld2xpbmUnKTtcbmNvbnN0IG5wbVJ1blBhdGggPSByZXF1aXJlKCducG0tcnVuLXBhdGgnKTtcbmNvbnN0IG9uZXRpbWUgPSByZXF1aXJlKCdvbmV0aW1lJyk7XG5jb25zdCBtYWtlRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpO1xuY29uc3Qgbm9ybWFsaXplU3RkaW8gPSByZXF1aXJlKCcuL2xpYi9zdGRpbycpO1xuY29uc3Qge3NwYXduZWRLaWxsLCBzcGF3bmVkQ2FuY2VsLCBzZXR1cFRpbWVvdXQsIHNldEV4aXRIYW5kbGVyfSA9IHJlcXVpcmUoJy4vbGliL2tpbGwnKTtcbmNvbnN0IHtoYW5kbGVJbnB1dCwgZ2V0U3Bhd25lZFJlc3VsdCwgbWFrZUFsbFN0cmVhbSwgdmFsaWRhdGVJbnB1dFN5bmN9ID0gcmVxdWlyZSgnLi9saWIvc3RyZWFtLmpzJyk7XG5jb25zdCB7bWVyZ2VQcm9taXNlLCBnZXRTcGF3bmVkUHJvbWlzZX0gPSByZXF1aXJlKCcuL2xpYi9wcm9taXNlLmpzJyk7XG5jb25zdCB7am9pbkNvbW1hbmQsIHBhcnNlQ29tbWFuZH0gPSByZXF1aXJlKCcuL2xpYi9jb21tYW5kLmpzJyk7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0JVRkZFUiA9IDEwMDAgKiAxMDAwICogMTAwO1xuXG5jb25zdCBnZXRFbnYgPSAoe2VudjogZW52T3B0aW9uLCBleHRlbmRFbnYsIHByZWZlckxvY2FsLCBsb2NhbERpcn0pID0+IHtcblx0Y29uc3QgZW52ID0gZXh0ZW5kRW52ID8gey4uLnByb2Nlc3MuZW52LCAuLi5lbnZPcHRpb259IDogZW52T3B0aW9uO1xuXG5cdGlmIChwcmVmZXJMb2NhbCkge1xuXHRcdHJldHVybiBucG1SdW5QYXRoLmVudih7ZW52LCBjd2Q6IGxvY2FsRGlyfSk7XG5cdH1cblxuXHRyZXR1cm4gZW52O1xufTtcblxuY29uc3QgaGFuZGxlQXJncyA9IChmaWxlLCBhcmdzLCBvcHRpb25zID0ge30pID0+IHtcblx0Y29uc3QgcGFyc2VkID0gY3Jvc3NTcGF3bi5fcGFyc2UoZmlsZSwgYXJncywgb3B0aW9ucyk7XG5cdGZpbGUgPSBwYXJzZWQuY29tbWFuZDtcblx0YXJncyA9IHBhcnNlZC5hcmdzO1xuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cblx0b3B0aW9ucyA9IHtcblx0XHRtYXhCdWZmZXI6IERFRkFVTFRfTUFYX0JVRkZFUixcblx0XHRidWZmZXI6IHRydWUsXG5cdFx0c3RyaXBGaW5hbE5ld2xpbmU6IHRydWUsXG5cdFx0ZXh0ZW5kRW52OiB0cnVlLFxuXHRcdHByZWZlckxvY2FsOiBmYWxzZSxcblx0XHRsb2NhbERpcjogb3B0aW9ucy5jd2QgfHwgcHJvY2Vzcy5jd2QoKSxcblx0XHRlbmNvZGluZzogJ3V0ZjgnLFxuXHRcdHJlamVjdDogdHJ1ZSxcblx0XHRjbGVhbnVwOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnMsXG5cdFx0d2luZG93c0hpZGU6IHRydWVcblx0fTtcblxuXHRvcHRpb25zLmVudiA9IGdldEVudihvcHRpb25zKTtcblxuXHRvcHRpb25zLnN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0aW9ucyk7XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgcGF0aC5iYXNlbmFtZShmaWxlLCAnLmV4ZScpID09PSAnY21kJykge1xuXHRcdC8vICMxMTZcblx0XHRhcmdzLnVuc2hpZnQoJy9xJyk7XG5cdH1cblxuXHRyZXR1cm4ge2ZpbGUsIGFyZ3MsIG9wdGlvbnMsIHBhcnNlZH07XG59O1xuXG5jb25zdCBoYW5kbGVPdXRwdXQgPSAob3B0aW9ucywgdmFsdWUsIGVycm9yKSA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG5cdFx0Ly8gV2hlbiBgZXhlY2Euc3luYygpYCBlcnJvcnMsIHdlIG5vcm1hbGl6ZSBpdCB0byAnJyB0byBtaW1pYyBgZXhlY2EoKWBcblx0XHRyZXR1cm4gZXJyb3IgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICcnO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuc3RyaXBGaW5hbE5ld2xpbmUpIHtcblx0XHRyZXR1cm4gc3RyaXBGaW5hbE5ld2xpbmUodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZXhlY2EgPSAoZmlsZSwgYXJncywgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBwYXJzZWQgPSBoYW5kbGVBcmdzKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuXHRjb25zdCBjb21tYW5kID0gam9pbkNvbW1hbmQoZmlsZSwgYXJncyk7XG5cblx0bGV0IHNwYXduZWQ7XG5cdHRyeSB7XG5cdFx0c3Bhd25lZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bihwYXJzZWQuZmlsZSwgcGFyc2VkLmFyZ3MsIHBhcnNlZC5vcHRpb25zKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBFbnN1cmUgdGhlIHJldHVybmVkIGVycm9yIGlzIGFsd2F5cyBib3RoIGEgcHJvbWlzZSBhbmQgYSBjaGlsZCBwcm9jZXNzXG5cdFx0Y29uc3QgZHVtbXlTcGF3bmVkID0gbmV3IGNoaWxkUHJvY2Vzcy5DaGlsZFByb2Nlc3MoKTtcblx0XHRjb25zdCBlcnJvclByb21pc2UgPSBQcm9taXNlLnJlamVjdChtYWtlRXJyb3Ioe1xuXHRcdFx0ZXJyb3IsXG5cdFx0XHRzdGRvdXQ6ICcnLFxuXHRcdFx0c3RkZXJyOiAnJyxcblx0XHRcdGFsbDogJycsXG5cdFx0XHRjb21tYW5kLFxuXHRcdFx0cGFyc2VkLFxuXHRcdFx0dGltZWRPdXQ6IGZhbHNlLFxuXHRcdFx0aXNDYW5jZWxlZDogZmFsc2UsXG5cdFx0XHRraWxsZWQ6IGZhbHNlXG5cdFx0fSkpO1xuXHRcdHJldHVybiBtZXJnZVByb21pc2UoZHVtbXlTcGF3bmVkLCBlcnJvclByb21pc2UpO1xuXHR9XG5cblx0Y29uc3Qgc3Bhd25lZFByb21pc2UgPSBnZXRTcGF3bmVkUHJvbWlzZShzcGF3bmVkKTtcblx0Y29uc3QgdGltZWRQcm9taXNlID0gc2V0dXBUaW1lb3V0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLCBzcGF3bmVkUHJvbWlzZSk7XG5cdGNvbnN0IHByb2Nlc3NEb25lID0gc2V0RXhpdEhhbmRsZXIoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHRpbWVkUHJvbWlzZSk7XG5cblx0Y29uc3QgY29udGV4dCA9IHtpc0NhbmNlbGVkOiBmYWxzZX07XG5cblx0c3Bhd25lZC5raWxsID0gc3Bhd25lZEtpbGwuYmluZChudWxsLCBzcGF3bmVkLmtpbGwuYmluZChzcGF3bmVkKSk7XG5cdHNwYXduZWQuY2FuY2VsID0gc3Bhd25lZENhbmNlbC5iaW5kKG51bGwsIHNwYXduZWQsIGNvbnRleHQpO1xuXG5cdGNvbnN0IGhhbmRsZVByb21pc2UgPSBhc3luYyAoKSA9PiB7XG5cdFx0Y29uc3QgW3tlcnJvciwgY29kZSwgc2lnbmFsLCB0aW1lZE91dH0sIHN0ZG91dFJlc3VsdCwgc3RkZXJyUmVzdWx0LCBhbGxSZXN1bHRdID0gYXdhaXQgZ2V0U3Bhd25lZFJlc3VsdChzcGF3bmVkLCBwYXJzZWQub3B0aW9ucywgcHJvY2Vzc0RvbmUpO1xuXHRcdGNvbnN0IHN0ZG91dCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgc3Rkb3V0UmVzdWx0KTtcblx0XHRjb25zdCBzdGRlcnIgPSBoYW5kbGVPdXRwdXQocGFyc2VkLm9wdGlvbnMsIHN0ZGVyclJlc3VsdCk7XG5cdFx0Y29uc3QgYWxsID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCBhbGxSZXN1bHQpO1xuXG5cdFx0aWYgKGVycm9yIHx8IGNvZGUgIT09IDAgfHwgc2lnbmFsICE9PSBudWxsKSB7XG5cdFx0XHRjb25zdCByZXR1cm5lZEVycm9yID0gbWFrZUVycm9yKHtcblx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdGNvZGUsXG5cdFx0XHRcdHNpZ25hbCxcblx0XHRcdFx0c3Rkb3V0LFxuXHRcdFx0XHRzdGRlcnIsXG5cdFx0XHRcdGFsbCxcblx0XHRcdFx0Y29tbWFuZCxcblx0XHRcdFx0cGFyc2VkLFxuXHRcdFx0XHR0aW1lZE91dCxcblx0XHRcdFx0aXNDYW5jZWxlZDogY29udGV4dC5pc0NhbmNlbGVkLFxuXHRcdFx0XHRraWxsZWQ6IHNwYXduZWQua2lsbGVkXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFwYXJzZWQub3B0aW9ucy5yZWplY3QpIHtcblx0XHRcdFx0cmV0dXJuIHJldHVybmVkRXJyb3I7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IHJldHVybmVkRXJyb3I7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbW1hbmQsXG5cdFx0XHRleGl0Q29kZTogMCxcblx0XHRcdGV4aXRDb2RlTmFtZTogJ1NVQ0NFU1MnLFxuXHRcdFx0c3Rkb3V0LFxuXHRcdFx0c3RkZXJyLFxuXHRcdFx0YWxsLFxuXHRcdFx0ZmFpbGVkOiBmYWxzZSxcblx0XHRcdHRpbWVkT3V0OiBmYWxzZSxcblx0XHRcdGlzQ2FuY2VsZWQ6IGZhbHNlLFxuXHRcdFx0a2lsbGVkOiBmYWxzZVxuXHRcdH07XG5cdH07XG5cblx0Y29uc3QgaGFuZGxlUHJvbWlzZU9uY2UgPSBvbmV0aW1lKGhhbmRsZVByb21pc2UpO1xuXG5cdGNyb3NzU3Bhd24uX2Vub2VudC5ob29rQ2hpbGRQcm9jZXNzKHNwYXduZWQsIHBhcnNlZC5wYXJzZWQpO1xuXG5cdGhhbmRsZUlucHV0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLmlucHV0KTtcblxuXHRzcGF3bmVkLmFsbCA9IG1ha2VBbGxTdHJlYW0oc3Bhd25lZCk7XG5cblx0cmV0dXJuIG1lcmdlUHJvbWlzZShzcGF3bmVkLCBoYW5kbGVQcm9taXNlT25jZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4ZWNhO1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGZpbGUsIGFyZ3MsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgcGFyc2VkID0gaGFuZGxlQXJncyhmaWxlLCBhcmdzLCBvcHRpb25zKTtcblx0Y29uc3QgY29tbWFuZCA9IGpvaW5Db21tYW5kKGZpbGUsIGFyZ3MpO1xuXG5cdHZhbGlkYXRlSW5wdXRTeW5jKHBhcnNlZC5vcHRpb25zKTtcblxuXHRsZXQgcmVzdWx0O1xuXHR0cnkge1xuXHRcdHJlc3VsdCA9IGNoaWxkUHJvY2Vzcy5zcGF3blN5bmMocGFyc2VkLmZpbGUsIHBhcnNlZC5hcmdzLCBwYXJzZWQub3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0dGhyb3cgbWFrZUVycm9yKHtcblx0XHRcdGVycm9yLFxuXHRcdFx0c3Rkb3V0OiAnJyxcblx0XHRcdHN0ZGVycjogJycsXG5cdFx0XHRhbGw6ICcnLFxuXHRcdFx0Y29tbWFuZCxcblx0XHRcdHBhcnNlZCxcblx0XHRcdHRpbWVkT3V0OiBmYWxzZSxcblx0XHRcdGlzQ2FuY2VsZWQ6IGZhbHNlLFxuXHRcdFx0a2lsbGVkOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0cmVzdWx0LnN0ZG91dCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgcmVzdWx0LnN0ZG91dCwgcmVzdWx0LmVycm9yKTtcblx0cmVzdWx0LnN0ZGVyciA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgcmVzdWx0LnN0ZGVyciwgcmVzdWx0LmVycm9yKTtcblxuXHRpZiAocmVzdWx0LmVycm9yIHx8IHJlc3VsdC5zdGF0dXMgIT09IDAgfHwgcmVzdWx0LnNpZ25hbCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGVycm9yID0gbWFrZUVycm9yKHtcblx0XHRcdC4uLnJlc3VsdCxcblx0XHRcdGNvZGU6IHJlc3VsdC5zdGF0dXMsXG5cdFx0XHRjb21tYW5kLFxuXHRcdFx0cGFyc2VkLFxuXHRcdFx0dGltZWRPdXQ6IHJlc3VsdC5lcnJvciAmJiByZXN1bHQuZXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcsXG5cdFx0XHRpc0NhbmNlbGVkOiBmYWxzZSxcblx0XHRcdGtpbGxlZDogcmVzdWx0LnNpZ25hbCAhPT0gbnVsbFxuXHRcdH0pO1xuXG5cdFx0aWYgKCFwYXJzZWQub3B0aW9ucy5yZWplY3QpIHtcblx0XHRcdHJldHVybiBlcnJvcjtcblx0XHR9XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tbWFuZCxcblx0XHRleGl0Q29kZTogMCxcblx0XHRleGl0Q29kZU5hbWU6ICdTVUNDRVNTJyxcblx0XHRzdGRvdXQ6IHJlc3VsdC5zdGRvdXQsXG5cdFx0c3RkZXJyOiByZXN1bHQuc3RkZXJyLFxuXHRcdGZhaWxlZDogZmFsc2UsXG5cdFx0dGltZWRPdXQ6IGZhbHNlLFxuXHRcdGlzQ2FuY2VsZWQ6IGZhbHNlLFxuXHRcdGtpbGxlZDogZmFsc2Vcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbW1hbmQgPSAoY29tbWFuZCwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBbZmlsZSwgLi4uYXJnc10gPSBwYXJzZUNvbW1hbmQoY29tbWFuZCk7XG5cdHJldHVybiBleGVjYShmaWxlLCBhcmdzLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbW1hbmRTeW5jID0gKGNvbW1hbmQsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgW2ZpbGUsIC4uLmFyZ3NdID0gcGFyc2VDb21tYW5kKGNvbW1hbmQpO1xuXHRyZXR1cm4gZXhlY2Euc3luYyhmaWxlLCBhcmdzLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vZGUgPSAoc2NyaXB0UGF0aCwgYXJncywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmIChhcmdzICYmICFBcnJheS5pc0FycmF5KGFyZ3MpICYmIHR5cGVvZiBhcmdzID09PSAnb2JqZWN0Jykge1xuXHRcdG9wdGlvbnMgPSBhcmdzO1xuXHRcdGFyZ3MgPSBbXTtcblx0fVxuXG5cdGNvbnN0IHN0ZGlvID0gbm9ybWFsaXplU3RkaW8ubm9kZShvcHRpb25zKTtcblxuXHRjb25zdCB7bm9kZVBhdGggPSBwcm9jZXNzLmV4ZWNQYXRoLCBub2RlT3B0aW9ucyA9IHByb2Nlc3MuZXhlY0FyZ3Z9ID0gb3B0aW9ucztcblxuXHRyZXR1cm4gZXhlY2EoXG5cdFx0bm9kZVBhdGgsXG5cdFx0W1xuXHRcdFx0Li4ubm9kZU9wdGlvbnMsXG5cdFx0XHRzY3JpcHRQYXRoLFxuXHRcdFx0Li4uKEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW10pXG5cdFx0XSxcblx0XHR7XG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0c3RkaW46IHVuZGVmaW5lZCxcblx0XHRcdHN0ZG91dDogdW5kZWZpbmVkLFxuXHRcdFx0c3RkZXJyOiB1bmRlZmluZWQsXG5cdFx0XHRzdGRpbyxcblx0XHRcdHNoZWxsOiBmYWxzZVxuXHRcdH1cblx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBTUEFDRVNfUkVHRVhQID0gLyArL2c7XG5cbmNvbnN0IGpvaW5Db21tYW5kID0gKGZpbGUsIGFyZ3MgPSBbXSkgPT4ge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHtcblx0XHRyZXR1cm4gZmlsZTtcblx0fVxuXG5cdHJldHVybiBbZmlsZSwgLi4uYXJnc10uam9pbignICcpO1xufTtcblxuLy8gQWxsb3cgc3BhY2VzIHRvIGJlIGVzY2FwZWQgYnkgYSBiYWNrc2xhc2ggaWYgbm90IG1lYW50IGFzIGEgZGVsaW1pdGVyXG5jb25zdCBoYW5kbGVFc2NhcGluZyA9ICh0b2tlbnMsIHRva2VuLCBpbmRleCkgPT4ge1xuXHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRyZXR1cm4gW3Rva2VuXTtcblx0fVxuXG5cdGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChwcmV2aW91c1Rva2VuLmVuZHNXaXRoKCdcXFxcJykpIHtcblx0XHRyZXR1cm4gWy4uLnRva2Vucy5zbGljZSgwLCAtMSksIGAke3ByZXZpb3VzVG9rZW4uc2xpY2UoMCwgLTEpfSAke3Rva2VufWBdO1xuXHR9XG5cblx0cmV0dXJuIFsuLi50b2tlbnMsIHRva2VuXTtcbn07XG5cbi8vIEhhbmRsZSBgZXhlY2EuY29tbWFuZCgpYFxuY29uc3QgcGFyc2VDb21tYW5kID0gY29tbWFuZCA9PiB7XG5cdHJldHVybiBjb21tYW5kXG5cdFx0LnRyaW0oKVxuXHRcdC5zcGxpdChTUEFDRVNfUkVHRVhQKVxuXHRcdC5yZWR1Y2UoaGFuZGxlRXNjYXBpbmcsIFtdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRqb2luQ29tbWFuZCxcblx0cGFyc2VDb21tYW5kXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgZ2V0Q29kZSA9IChlcnJvciwgY29kZSkgPT4ge1xuXHRpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSkge1xuXHRcdHJldHVybiBbZXJyb3IuY29kZSwgb3MuY29uc3RhbnRzLmVycm5vW2Vycm9yLmNvZGVdXTtcblx0fVxuXG5cdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG5cdFx0cmV0dXJuIFt1dGlsLmdldFN5c3RlbUVycm9yTmFtZSgtY29kZSksIGNvZGVdO1xuXHR9XG5cblx0cmV0dXJuIFtdO1xufTtcblxuY29uc3QgZ2V0RXJyb3JQcmVmaXggPSAoe3RpbWVkT3V0LCB0aW1lb3V0LCBzaWduYWwsIGV4aXRDb2RlTmFtZSwgZXhpdENvZGUsIGlzQ2FuY2VsZWR9KSA9PiB7XG5cdGlmICh0aW1lZE91dCkge1xuXHRcdHJldHVybiBgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH0gbWlsbGlzZWNvbmRzYDtcblx0fVxuXG5cdGlmIChpc0NhbmNlbGVkKSB7XG5cdFx0cmV0dXJuICd3YXMgY2FuY2VsZWQnO1xuXHR9XG5cblx0aWYgKHNpZ25hbCkge1xuXHRcdHJldHVybiBgd2FzIGtpbGxlZCB3aXRoICR7c2lnbmFsfWA7XG5cdH1cblxuXHRpZiAoZXhpdENvZGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBgZmFpbGVkIHdpdGggZXhpdCBjb2RlICR7ZXhpdENvZGV9ICgke2V4aXRDb2RlTmFtZX0pYDtcblx0fVxuXG5cdHJldHVybiAnZmFpbGVkJztcbn07XG5cbmNvbnN0IG1ha2VFcnJvciA9ICh7XG5cdHN0ZG91dCxcblx0c3RkZXJyLFxuXHRhbGwsXG5cdGVycm9yLFxuXHRzaWduYWwsXG5cdGNvZGUsXG5cdGNvbW1hbmQsXG5cdHRpbWVkT3V0LFxuXHRpc0NhbmNlbGVkLFxuXHRraWxsZWQsXG5cdHBhcnNlZDoge29wdGlvbnM6IHt0aW1lb3V0fX1cbn0pID0+IHtcblx0Y29uc3QgW2V4aXRDb2RlTmFtZSwgZXhpdENvZGVdID0gZ2V0Q29kZShlcnJvciwgY29kZSk7XG5cblx0Y29uc3QgcHJlZml4ID0gZ2V0RXJyb3JQcmVmaXgoe3RpbWVkT3V0LCB0aW1lb3V0LCBzaWduYWwsIGV4aXRDb2RlTmFtZSwgZXhpdENvZGUsIGlzQ2FuY2VsZWR9KTtcblx0Y29uc3QgbWVzc2FnZSA9IGBDb21tYW5kICR7cHJlZml4fTogJHtjb21tYW5kfWA7XG5cblx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRlcnJvci5vcmlnaW5hbE1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuXHRcdGVycm9yLm1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbiR7ZXJyb3IubWVzc2FnZX1gO1xuXHR9IGVsc2Uge1xuXHRcdGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG5cblx0ZXJyb3IuY29tbWFuZCA9IGNvbW1hbmQ7XG5cdGRlbGV0ZSBlcnJvci5jb2RlO1xuXHRlcnJvci5leGl0Q29kZSA9IGV4aXRDb2RlO1xuXHRlcnJvci5leGl0Q29kZU5hbWUgPSBleGl0Q29kZU5hbWU7XG5cdGVycm9yLnN0ZG91dCA9IHN0ZG91dDtcblx0ZXJyb3Iuc3RkZXJyID0gc3RkZXJyO1xuXG5cdGlmIChhbGwgIT09IHVuZGVmaW5lZCkge1xuXHRcdGVycm9yLmFsbCA9IGFsbDtcblx0fVxuXG5cdGlmICgnYnVmZmVyZWREYXRhJyBpbiBlcnJvcikge1xuXHRcdGRlbGV0ZSBlcnJvci5idWZmZXJlZERhdGE7XG5cdH1cblxuXHRlcnJvci5mYWlsZWQgPSB0cnVlO1xuXHRlcnJvci50aW1lZE91dCA9IEJvb2xlYW4odGltZWRPdXQpO1xuXHRlcnJvci5pc0NhbmNlbGVkID0gaXNDYW5jZWxlZDtcblx0ZXJyb3Iua2lsbGVkID0ga2lsbGVkICYmICF0aW1lZE91dDtcblx0Ly8gYHNpZ25hbGAgZW1pdHRlZCBvbiBgc3Bhd25lZC5vbignZXhpdCcpYCBldmVudCBjYW4gYmUgYG51bGxgLiBXZSBub3JtYWxpemVcblx0Ly8gaXQgdG8gYHVuZGVmaW5lZGBcblx0ZXJyb3Iuc2lnbmFsID0gc2lnbmFsIHx8IHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gZXJyb3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IG9uRXhpdCA9IHJlcXVpcmUoJ3NpZ25hbC1leGl0Jyk7XG5jb25zdCBwRmluYWxseSA9IHJlcXVpcmUoJ3AtZmluYWxseScpO1xuXG5jb25zdCBERUZBVUxUX0ZPUkNFX0tJTExfVElNRU9VVCA9IDEwMDAgKiA1O1xuXG4vLyBNb25rZXktcGF0Y2hlcyBgY2hpbGRQcm9jZXNzLmtpbGwoKWAgdG8gYWRkIGBmb3JjZUtpbGxBZnRlclRpbWVvdXRgIGJlaGF2aW9yXG5jb25zdCBzcGF3bmVkS2lsbCA9IChraWxsLCBzaWduYWwgPSAnU0lHVEVSTScsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCBraWxsUmVzdWx0ID0ga2lsbChzaWduYWwpO1xuXHRzZXRLaWxsVGltZW91dChraWxsLCBzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpO1xuXHRyZXR1cm4ga2lsbFJlc3VsdDtcbn07XG5cbmNvbnN0IHNldEtpbGxUaW1lb3V0ID0gKGtpbGwsIHNpZ25hbCwgb3B0aW9ucywga2lsbFJlc3VsdCkgPT4ge1xuXHRpZiAoIXNob3VsZEZvcmNlS2lsbChzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdGltZW91dCA9IGdldEZvcmNlS2lsbEFmdGVyVGltZW91dChvcHRpb25zKTtcblx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0a2lsbCgnU0lHS0lMTCcpO1xuXHR9LCB0aW1lb3V0KS51bnJlZigpO1xufTtcblxuY29uc3Qgc2hvdWxkRm9yY2VLaWxsID0gKHNpZ25hbCwge2ZvcmNlS2lsbEFmdGVyVGltZW91dH0sIGtpbGxSZXN1bHQpID0+IHtcblx0cmV0dXJuIGlzU2lndGVybShzaWduYWwpICYmIGZvcmNlS2lsbEFmdGVyVGltZW91dCAhPT0gZmFsc2UgJiYga2lsbFJlc3VsdDtcbn07XG5cbmNvbnN0IGlzU2lndGVybSA9IHNpZ25hbCA9PiB7XG5cdHJldHVybiBzaWduYWwgPT09IG9zLmNvbnN0YW50cy5zaWduYWxzLlNJR1RFUk0gfHxcblx0XHQodHlwZW9mIHNpZ25hbCA9PT0gJ3N0cmluZycgJiYgc2lnbmFsLnRvVXBwZXJDYXNlKCkgPT09ICdTSUdURVJNJyk7XG59O1xuXG5jb25zdCBnZXRGb3JjZUtpbGxBZnRlclRpbWVvdXQgPSAoe2ZvcmNlS2lsbEFmdGVyVGltZW91dCA9IHRydWV9KSA9PiB7XG5cdGlmIChmb3JjZUtpbGxBZnRlclRpbWVvdXQgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gREVGQVVMVF9GT1JDRV9LSUxMX1RJTUVPVVQ7XG5cdH1cblxuXHRpZiAoIU51bWJlci5pc0ludGVnZXIoZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0KSB8fCBmb3JjZUtpbGxBZnRlclRpbWVvdXQgPCAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIFxcYGZvcmNlS2lsbEFmdGVyVGltZW91dFxcYCBvcHRpb24gdG8gYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290IFxcYCR7Zm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fVxcYCAoJHt0eXBlb2YgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fSlgKTtcblx0fVxuXG5cdHJldHVybiBmb3JjZUtpbGxBZnRlclRpbWVvdXQ7XG59O1xuXG4vLyBgY2hpbGRQcm9jZXNzLmNhbmNlbCgpYFxuY29uc3Qgc3Bhd25lZENhbmNlbCA9IChzcGF3bmVkLCBjb250ZXh0KSA9PiB7XG5cdGNvbnN0IGtpbGxSZXN1bHQgPSBzcGF3bmVkLmtpbGwoKTtcblxuXHRpZiAoa2lsbFJlc3VsdCkge1xuXHRcdGNvbnRleHQuaXNDYW5jZWxlZCA9IHRydWU7XG5cdH1cbn07XG5cbmNvbnN0IHRpbWVvdXRLaWxsID0gKHNwYXduZWQsIHNpZ25hbCwgcmVqZWN0KSA9PiB7XG5cdHNwYXduZWQua2lsbChzaWduYWwpO1xuXHRyZWplY3QoT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1RpbWVkIG91dCcpLCB7dGltZWRPdXQ6IHRydWUsIHNpZ25hbH0pKTtcbn07XG5cbi8vIGB0aW1lb3V0YCBvcHRpb24gaGFuZGxpbmdcbmNvbnN0IHNldHVwVGltZW91dCA9IChzcGF3bmVkLCB7dGltZW91dCwga2lsbFNpZ25hbCA9ICdTSUdURVJNJ30sIHNwYXduZWRQcm9taXNlKSA9PiB7XG5cdGlmICh0aW1lb3V0ID09PSAwIHx8IHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBzcGF3bmVkUHJvbWlzZTtcblx0fVxuXG5cdGlmICghTnVtYmVyLmlzSW50ZWdlcih0aW1lb3V0KSB8fCB0aW1lb3V0IDwgMCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBcXGB0aW1lb3V0XFxgIG9wdGlvbiB0byBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3QgXFxgJHt0aW1lb3V0fVxcYCAoJHt0eXBlb2YgdGltZW91dH0pYCk7XG5cdH1cblxuXHRsZXQgdGltZW91dElkO1xuXHRjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRpbWVvdXRLaWxsKHNwYXduZWQsIGtpbGxTaWduYWwsIHJlamVjdCk7XG5cdFx0fSwgdGltZW91dCk7XG5cdH0pO1xuXG5cdGNvbnN0IHNhZmVTcGF3bmVkUHJvbWlzZSA9IHBGaW5hbGx5KHNwYXduZWRQcm9taXNlLCAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBzYWZlU3Bhd25lZFByb21pc2VdKTtcbn07XG5cbi8vIGBjbGVhbnVwYCBvcHRpb24gaGFuZGxpbmdcbmNvbnN0IHNldEV4aXRIYW5kbGVyID0gKHNwYXduZWQsIHtjbGVhbnVwLCBkZXRhY2hlZH0sIHRpbWVkUHJvbWlzZSkgPT4ge1xuXHRpZiAoIWNsZWFudXAgfHwgZGV0YWNoZWQpIHtcblx0XHRyZXR1cm4gdGltZWRQcm9taXNlO1xuXHR9XG5cblx0Y29uc3QgcmVtb3ZlRXhpdEhhbmRsZXIgPSBvbkV4aXQoKCkgPT4ge1xuXHRcdHNwYXduZWQua2lsbCgpO1xuXHR9KTtcblxuXHQvLyBUT0RPOiBVc2UgbmF0aXZlIFwiZmluYWxseVwiIHN5bnRheCB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDEwXG5cdHJldHVybiBwRmluYWxseSh0aW1lZFByb21pc2UsIHJlbW92ZUV4aXRIYW5kbGVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzcGF3bmVkS2lsbCxcblx0c3Bhd25lZENhbmNlbCxcblx0c2V0dXBUaW1lb3V0LFxuXHRzZXRFeGl0SGFuZGxlclxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1lcmdlUHJvbWlzZVByb3BlcnR5ID0gKHNwYXduZWQsIHByb21pc2UsIHByb3BlcnR5KSA9PiB7XG5cdC8vIFN0YXJ0aW5nIHRoZSBtYWluIGBwcm9taXNlYCBpcyBkZWZlcnJlZCB0byBhdm9pZCBjb25zdW1pbmcgc3RyZWFtc1xuXHRjb25zdCB2YWx1ZSA9IHR5cGVvZiBwcm9taXNlID09PSAnZnVuY3Rpb24nID9cblx0XHQoLi4uYXJncykgPT4gcHJvbWlzZSgpW3Byb3BlcnR5XSguLi5hcmdzKSA6XG5cdFx0cHJvbWlzZVtwcm9wZXJ0eV0uYmluZChwcm9taXNlKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3Bhd25lZCwgcHJvcGVydHksIHtcblx0XHR2YWx1ZSxcblx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRjb25maWd1cmFibGU6IHRydWVcblx0fSk7XG59O1xuXG4vLyBUaGUgcmV0dXJuIHZhbHVlIGlzIGEgbWl4aW4gb2YgYGNoaWxkUHJvY2Vzc2AgYW5kIGBQcm9taXNlYFxuY29uc3QgbWVyZ2VQcm9taXNlID0gKHNwYXduZWQsIHByb21pc2UpID0+IHtcblx0bWVyZ2VQcm9taXNlUHJvcGVydHkoc3Bhd25lZCwgcHJvbWlzZSwgJ3RoZW4nKTtcblx0bWVyZ2VQcm9taXNlUHJvcGVydHkoc3Bhd25lZCwgcHJvbWlzZSwgJ2NhdGNoJyk7XG5cblx0Ly8gVE9ETzogUmVtb3ZlIHRoZSBgaWZgLWd1YXJkIHdoZW4gdGFyZ2V0aW5nIE5vZGUuanMgMTBcblx0aWYgKFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkpIHtcblx0XHRtZXJnZVByb21pc2VQcm9wZXJ0eShzcGF3bmVkLCBwcm9taXNlLCAnZmluYWxseScpO1xuXHR9XG5cblx0cmV0dXJuIHNwYXduZWQ7XG59O1xuXG4vLyBVc2UgcHJvbWlzZXMgaW5zdGVhZCBvZiBgY2hpbGRfcHJvY2Vzc2AgZXZlbnRzXG5jb25zdCBnZXRTcGF3bmVkUHJvbWlzZSA9IHNwYXduZWQgPT4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHNwYXduZWQub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG5cdFx0XHRyZXNvbHZlKHtjb2RlLCBzaWduYWx9KTtcblx0XHR9KTtcblxuXHRcdHNwYXduZWQub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHR9KTtcblxuXHRcdGlmIChzcGF3bmVkLnN0ZGluKSB7XG5cdFx0XHRzcGF3bmVkLnN0ZGluLm9uKCdlcnJvcicsIGVycm9yID0+IHtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bWVyZ2VQcm9taXNlLFxuXHRnZXRTcGF3bmVkUHJvbWlzZVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYWxpYXNlcyA9IFsnc3RkaW4nLCAnc3Rkb3V0JywgJ3N0ZGVyciddO1xuXG5jb25zdCBoYXNBbGlhcyA9IG9wdHMgPT4gYWxpYXNlcy5zb21lKGFsaWFzID0+IG9wdHNbYWxpYXNdICE9PSB1bmRlZmluZWQpO1xuXG5jb25zdCBub3JtYWxpemVTdGRpbyA9IG9wdHMgPT4ge1xuXHRpZiAoIW9wdHMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB7c3RkaW99ID0gb3B0cztcblxuXHRpZiAoc3RkaW8gPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBhbGlhc2VzLm1hcChhbGlhcyA9PiBvcHRzW2FsaWFzXSk7XG5cdH1cblxuXHRpZiAoaGFzQWxpYXMob3B0cykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEl0J3Mgbm90IHBvc3NpYmxlIHRvIHByb3ZpZGUgXFxgc3RkaW9cXGAgaW4gY29tYmluYXRpb24gd2l0aCBvbmUgb2YgJHthbGlhc2VzLm1hcChhbGlhcyA9PiBgXFxgJHthbGlhc31cXGBgKS5qb2luKCcsICcpfWApO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBzdGRpbyA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gc3RkaW87XG5cdH1cblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoc3RkaW8pKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RkaW9cXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgQXJyYXlcXGAsIGdvdCBcXGAke3R5cGVvZiBzdGRpb31cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KHN0ZGlvLmxlbmd0aCwgYWxpYXNlcy5sZW5ndGgpO1xuXHRyZXR1cm4gQXJyYXkuZnJvbSh7bGVuZ3RofSwgKHZhbHVlLCBpbmRleCkgPT4gc3RkaW9baW5kZXhdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplU3RkaW87XG5cbi8vIGBpcGNgIGlzIHB1c2hlZCB1bmxlc3MgaXQgaXMgYWxyZWFkeSBwcmVzZW50XG5tb2R1bGUuZXhwb3J0cy5ub2RlID0gb3B0cyA9PiB7XG5cdGNvbnN0IHN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0cyk7XG5cblx0aWYgKHN0ZGlvID09PSAnaXBjJykge1xuXHRcdHJldHVybiAnaXBjJztcblx0fVxuXG5cdGlmIChzdGRpbyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzdGRpbyA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gW3N0ZGlvLCBzdGRpbywgc3RkaW8sICdpcGMnXTtcblx0fVxuXG5cdGlmIChzdGRpby5pbmNsdWRlcygnaXBjJykpIHtcblx0XHRyZXR1cm4gc3RkaW87XG5cdH1cblxuXHRyZXR1cm4gWy4uLnN0ZGlvLCAnaXBjJ107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbmNvbnN0IGdldFN0cmVhbSA9IHJlcXVpcmUoJ2dldC1zdHJlYW0nKTtcbmNvbnN0IG1lcmdlU3RyZWFtID0gcmVxdWlyZSgnbWVyZ2Utc3RyZWFtJyk7XG5cbi8vIGBpbnB1dGAgb3B0aW9uXG5jb25zdCBoYW5kbGVJbnB1dCA9IChzcGF3bmVkLCBpbnB1dCkgPT4ge1xuXHQvLyBDaGVja2luZyBmb3Igc3RkaW4gaXMgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yNjg1MlxuXHQvLyBUT0RPOiBSZW1vdmUgYHx8IHNwYXduZWQuc3RkaW4gPT09IHVuZGVmaW5lZGAgb25jZSB3ZSBkcm9wIHN1cHBvcnQgZm9yIE5vZGUuanMgPD0xMi4yLjBcblx0aWYgKGlucHV0ID09PSB1bmRlZmluZWQgfHwgc3Bhd25lZC5zdGRpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGlzU3RyZWFtKGlucHV0KSkge1xuXHRcdGlucHV0LnBpcGUoc3Bhd25lZC5zdGRpbik7XG5cdH0gZWxzZSB7XG5cdFx0c3Bhd25lZC5zdGRpbi5lbmQoaW5wdXQpO1xuXHR9XG59O1xuXG4vLyBgYWxsYCBpbnRlcmxlYXZlcyBgc3Rkb3V0YCBhbmQgYHN0ZGVycmBcbmNvbnN0IG1ha2VBbGxTdHJlYW0gPSBzcGF3bmVkID0+IHtcblx0aWYgKCFzcGF3bmVkLnN0ZG91dCAmJiAhc3Bhd25lZC5zdGRlcnIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBtaXhlZCA9IG1lcmdlU3RyZWFtKCk7XG5cblx0aWYgKHNwYXduZWQuc3Rkb3V0KSB7XG5cdFx0bWl4ZWQuYWRkKHNwYXduZWQuc3Rkb3V0KTtcblx0fVxuXG5cdGlmIChzcGF3bmVkLnN0ZGVycikge1xuXHRcdG1peGVkLmFkZChzcGF3bmVkLnN0ZGVycik7XG5cdH1cblxuXHRyZXR1cm4gbWl4ZWQ7XG59O1xuXG4vLyBPbiBmYWlsdXJlLCBgcmVzdWx0LnN0ZG91dHxzdGRlcnJ8YWxsYCBzaG91bGQgY29udGFpbiB0aGUgY3VycmVudGx5IGJ1ZmZlcmVkIHN0cmVhbVxuY29uc3QgZ2V0QnVmZmVyZWREYXRhID0gYXN5bmMgKHN0cmVhbSwgc3RyZWFtUHJvbWlzZSkgPT4ge1xuXHRpZiAoIXN0cmVhbSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHN0cmVhbS5kZXN0cm95KCk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gYXdhaXQgc3RyZWFtUHJvbWlzZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gZXJyb3IuYnVmZmVyZWREYXRhO1xuXHR9XG59O1xuXG5jb25zdCBnZXRTdHJlYW1Qcm9taXNlID0gKHN0cmVhbSwge2VuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcn0pID0+IHtcblx0aWYgKCFzdHJlYW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIWJ1ZmZlcikge1xuXHRcdC8vIFRPRE86IFVzZSBgcmV0ID0gdXRpbC5wcm9taXNpZnkoc3RyZWFtLmZpbmlzaGVkKShzdHJlYW0pO2Agd2hlbiB0YXJnZXRpbmcgTm9kZS5qcyAxMFxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRzdHJlYW1cblx0XHRcdFx0Lm9uY2UoJ2VuZCcsIHJlc29sdmUpXG5cdFx0XHRcdC5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoZW5jb2RpbmcpIHtcblx0XHRyZXR1cm4gZ2V0U3RyZWFtKHN0cmVhbSwge2VuY29kaW5nLCBtYXhCdWZmZXJ9KTtcblx0fVxuXG5cdHJldHVybiBnZXRTdHJlYW0uYnVmZmVyKHN0cmVhbSwge21heEJ1ZmZlcn0pO1xufTtcblxuLy8gUmV0cmlldmUgcmVzdWx0IG9mIGNoaWxkIHByb2Nlc3M6IGV4aXQgY29kZSwgc2lnbmFsLCBlcnJvciwgc3RyZWFtcyAoc3Rkb3V0L3N0ZGVyci9hbGwpXG5jb25zdCBnZXRTcGF3bmVkUmVzdWx0ID0gYXN5bmMgKHtzdGRvdXQsIHN0ZGVyciwgYWxsfSwge2VuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcn0sIHByb2Nlc3NEb25lKSA9PiB7XG5cdGNvbnN0IHN0ZG91dFByb21pc2UgPSBnZXRTdHJlYW1Qcm9taXNlKHN0ZG91dCwge2VuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcn0pO1xuXHRjb25zdCBzdGRlcnJQcm9taXNlID0gZ2V0U3RyZWFtUHJvbWlzZShzdGRlcnIsIHtlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXJ9KTtcblx0Y29uc3QgYWxsUHJvbWlzZSA9IGdldFN0cmVhbVByb21pc2UoYWxsLCB7ZW5jb2RpbmcsIGJ1ZmZlciwgbWF4QnVmZmVyOiBtYXhCdWZmZXIgKiAyfSk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoW3Byb2Nlc3NEb25lLCBzdGRvdXRQcm9taXNlLCBzdGRlcnJQcm9taXNlLCBhbGxQcm9taXNlXSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFtcblx0XHRcdHtlcnJvciwgY29kZTogZXJyb3IuY29kZSwgc2lnbmFsOiBlcnJvci5zaWduYWwsIHRpbWVkT3V0OiBlcnJvci50aW1lZE91dH0sXG5cdFx0XHRnZXRCdWZmZXJlZERhdGEoc3Rkb3V0LCBzdGRvdXRQcm9taXNlKSxcblx0XHRcdGdldEJ1ZmZlcmVkRGF0YShzdGRlcnIsIHN0ZGVyclByb21pc2UpLFxuXHRcdFx0Z2V0QnVmZmVyZWREYXRhKGFsbCwgYWxsUHJvbWlzZSlcblx0XHRdKTtcblx0fVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dFN5bmMgPSAoe2lucHV0fSkgPT4ge1xuXHRpZiAoaXNTdHJlYW0oaW5wdXQpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBpbnB1dGAgb3B0aW9uIGNhbm5vdCBiZSBhIHN0cmVhbSBpbiBzeW5jIG1vZGUnKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGhhbmRsZUlucHV0LFxuXHRtYWtlQWxsU3RyZWFtLFxuXHRnZXRTcGF3bmVkUmVzdWx0LFxuXHR2YWxpZGF0ZUlucHV0U3luY1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHBhdGhLZXkgPSByZXF1aXJlKCdwYXRoLWtleScpO1xuXG5jb25zdCBucG1SdW5QYXRoID0gb3B0aW9ucyA9PiB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpLFxuXHRcdHBhdGg6IHByb2Nlc3MuZW52W3BhdGhLZXkoKV0sXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGxldCBwcmV2aW91cztcblx0bGV0IGN3ZFBhdGggPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QpO1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblxuXHR3aGlsZSAocHJldmlvdXMgIT09IGN3ZFBhdGgpIHtcblx0XHRyZXN1bHQucHVzaChwYXRoLmpvaW4oY3dkUGF0aCwgJ25vZGVfbW9kdWxlcy8uYmluJykpO1xuXHRcdHByZXZpb3VzID0gY3dkUGF0aDtcblx0XHRjd2RQYXRoID0gcGF0aC5yZXNvbHZlKGN3ZFBhdGgsICcuLicpO1xuXHR9XG5cblx0Ly8gRW5zdXJlIHRoZSBydW5uaW5nIGBub2RlYCBiaW5hcnkgaXMgdXNlZFxuXHRyZXN1bHQucHVzaChwYXRoLmRpcm5hbWUocHJvY2Vzcy5leGVjUGF0aCkpO1xuXG5cdHJldHVybiByZXN1bHQuY29uY2F0KG9wdGlvbnMucGF0aCkuam9pbihwYXRoLmRlbGltaXRlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5wbVJ1blBhdGg7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG5wbVJ1blBhdGg7XG5cbm1vZHVsZS5leHBvcnRzLmVudiA9IG9wdGlvbnMgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdGVudjogcHJvY2Vzcy5lbnYsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IGVudiA9IHsuLi5vcHRpb25zLmVudn07XG5cdGNvbnN0IHBhdGggPSBwYXRoS2V5KHtlbnZ9KTtcblxuXHRvcHRpb25zLnBhdGggPSBlbnZbcGF0aF07XG5cdGVudltwYXRoXSA9IG1vZHVsZS5leHBvcnRzKG9wdGlvbnMpO1xuXG5cdHJldHVybiBlbnY7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUsIHsgc2lnbmFsIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgICAgICBzaWduYWwgPT09IG51bGwgfHwgc2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBjbGVhbnVwKTtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgb25FdmVudCk7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uRXZlbnQoLi4uYXJncykge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2xlYW51cCk7XG4gICAgICAgIGVtaXR0ZXIub24obmFtZSwgb25FdmVudCk7XG4gICAgICAgIGVtaXR0ZXIub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBvbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBwcm9taXNpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wcm9taXNpZnlcIikpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoJ2FnZW50LWJhc2UnKTtcbmZ1bmN0aW9uIGlzQWdlbnQodikge1xuICAgIHJldHVybiBCb29sZWFuKHYpICYmIHR5cGVvZiB2LmFkZFJlcXVlc3QgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1NlY3VyZUVuZHBvaW50KCkge1xuICAgIGNvbnN0IHsgc3RhY2sgfSA9IG5ldyBFcnJvcigpO1xuICAgIGlmICh0eXBlb2Ygc3RhY2sgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0YWNrLnNwbGl0KCdcXG4nKS5zb21lKGwgPT4gbC5pbmRleE9mKCcoaHR0cHMuanM6JykgIT09IC0xIHx8IGwuaW5kZXhPZignbm9kZTpodHRwczonKSAhPT0gLTEpO1xufVxuZnVuY3Rpb24gY3JlYXRlQWdlbnQoY2FsbGJhY2ssIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGNyZWF0ZUFnZW50LkFnZW50KGNhbGxiYWNrLCBvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlQWdlbnQpIHtcbiAgICAvKipcbiAgICAgKiBCYXNlIGBodHRwLkFnZW50YCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBObyBwb29saW5nL2tlZXAtYWxpdmUgaXMgaW1wbGVtZW50ZWQgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBBZ2VudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBfb3B0cykge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGxldCBvcHRzID0gX29wdHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcHRzID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lb3V0IGZvciB0aGUgc29ja2V0IHRvIGJlIHJldHVybmVkIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmVuJ3QgYWN0dWFsbHkgdXNlZCBieSBgYWdlbnQtYmFzZWAsIGJ1dCBhcmUgcmVxdWlyZWRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGVzIGluIGBAdHlwZXMvbm9kZWAgOi9cbiAgICAgICAgICAgIHRoaXMubWF4RnJlZVNvY2tldHMgPSAxO1xuICAgICAgICAgICAgdGhpcy5tYXhTb2NrZXRzID0gMTtcbiAgICAgICAgICAgIHRoaXMubWF4VG90YWxTb2NrZXRzID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZnJlZVNvY2tldHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWZhdWx0UG9ydCgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5leHBsaWNpdERlZmF1bHRQb3J0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RGVmYXVsdFBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTZWN1cmVFbmRwb2ludCgpID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGRlZmF1bHRQb3J0KHYpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwbGljaXREZWZhdWx0UG9ydCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGxpY2l0UHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXRQcm90b2NvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NlY3VyZUVuZHBvaW50KCkgPyAnaHR0cHM6JyA6ICdodHRwOic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHByb3RvY29sKHYpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwbGljaXRQcm90b2NvbCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2socmVxLCBvcHRzLCBmbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFnZW50LWJhc2VcIiBoYXMgbm8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgeW91IG11c3Qgc3ViY2xhc3MgYW5kIG92ZXJyaWRlIGBjYWxsYmFjaygpYCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgbm9kZS1jb3JlJ3MgXCJfaHR0cF9jbGllbnQuanNcIiBtb2R1bGUgd2hlbiBjcmVhdGluZ1xuICAgICAgICAgKiBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGlzIEFnZW50IGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVxdWVzdChyZXEsIF9vcHRzKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgX29wdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnNlY3VyZUVuZHBvaW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnNlY3VyZUVuZHBvaW50ID0gaXNTZWN1cmVFbmRwb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaG9zdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5ob3N0ID0gJ2xvY2FsaG9zdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wb3J0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBvcHRzLnNlY3VyZUVuZHBvaW50ID8gNDQzIDogODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9IG9wdHMuc2VjdXJlRW5kcG9pbnQgPyAnaHR0cHM6JyA6ICdodHRwOic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5ob3N0ICYmIG9wdHMucGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggYSBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgc3BlY2lmaWVkIHRoZW4gaXQncyBtb3N0XG4gICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRoZSByZXN1bHQgb2YgYSBgdXJsLnBhcnNlKClgIGNhbGwuLi4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYHBhdGhgIHBvcnRpb24gc28gdGhhdCBgbmV0LmNvbm5lY3QoKWAgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gb3BlbiB0aGF0IGFzIGEgdW5peCBzb2NrZXQgZmlsZS5cbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0cy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuYWdlbnQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5ob3N0bmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLl9kZWZhdWx0QWdlbnQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5kZWZhdWx0UG9ydDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmNyZWF0ZUNvbm5lY3Rpb247XG4gICAgICAgICAgICAvLyBIaW50IHRvIHVzZSBcIkNvbm5lY3Rpb246IGNsb3NlXCJcbiAgICAgICAgICAgIC8vIFhYWDogbm9uLWRvY3VtZW50ZWQgYGh0dHBgIG1vZHVsZSBBUEkgOihcbiAgICAgICAgICAgIHJlcS5fbGFzdCA9IHRydWU7XG4gICAgICAgICAgICByZXEuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dE1zID0gb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dDtcbiAgICAgICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5faGFkRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXEuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIC8vIEZvciBTYWZldHkuIFNvbWUgYWRkaXRpb25hbCBlcnJvcnMgbWlnaHQgZmlyZSBsYXRlciBvblxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBkb3VibGUtZmlyZSB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICAgICAgICAgICAgcmVxLl9oYWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQSBcInNvY2tldFwiIHdhcyBub3QgY3JlYXRlZCBmb3IgSFRUUCByZXF1ZXN0IGJlZm9yZSAke3RpbWVvdXRNc31tc2ApO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0VUSU1FT1VUJztcbiAgICAgICAgICAgICAgICBvbmVycm9yKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tFcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltZWRPdXQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbmVycm9yKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25zb2NrZXQgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVkT3V0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNBZ2VudChzb2NrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzb2NrZXRgIGlzIGFjdHVhbGx5IGFuIGBodHRwLkFnZW50YCBpbnN0YW5jZSwgc29cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsaW5xdWlzaCByZXNwb25zaWJpbGl0eSBmb3IgdGhpcyBgcmVxYCB0byB0aGUgQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBoZXJlIG9uXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdDYWxsYmFjayByZXR1cm5lZCBhbm90aGVyIEFnZW50IGluc3RhbmNlICVvJywgc29ja2V0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuYWRkUmVxdWVzdChyZXEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ2ZyZWUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVTb2NrZXQoc29ja2V0LCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vblNvY2tldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgbm8gRHVwbGV4IHN0cmVhbSB3YXMgcmV0dXJuZWQgdG8gYWdlbnQtYmFzZSBmb3IgXFxgJHtyZXEubWV0aG9kfSAke3JlcS5wYXRofVxcYGApO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKG5ldyBFcnJvcignYGNhbGxiYWNrYCBpcyBub3QgZGVmaW5lZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvbWlzaWZpZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdDb252ZXJ0aW5nIGxlZ2FjeSBjYWxsYmFjayBmdW5jdGlvbiB0byBwcm9taXNlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzaWZpZWRDYWxsYmFjayA9IHByb21pc2lmeV8xLmRlZmF1bHQodGhpcy5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2lmaWVkQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZW91dE1zID09PSAnbnVtYmVyJyAmJiB0aW1lb3V0TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChvbnRpbWVvdXQsIHRpbWVvdXRNcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3BvcnQnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMucG9ydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBOdW1iZXIob3B0cy5wb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1Jlc29sdmluZyBzb2NrZXQgZm9yICVvIHJlcXVlc3Q6ICVvJywgb3B0cy5wcm90b2NvbCwgYCR7cmVxLm1ldGhvZH0gJHtyZXEucGF0aH1gKTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5wcm9taXNpZmllZENhbGxiYWNrKHJlcSwgb3B0cykpLnRoZW4ob25zb2NrZXQsIGNhbGxiYWNrRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycikuY2F0Y2goY2FsbGJhY2tFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJlZVNvY2tldChzb2NrZXQsIG9wdHMpIHtcbiAgICAgICAgICAgIGRlYnVnKCdGcmVlaW5nIHNvY2tldCAlbyAlbycsIHNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lLCBvcHRzKTtcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdEZXN0cm95aW5nIGFnZW50ICVvJywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVBZ2VudC5BZ2VudCA9IEFnZW50O1xuICAgIC8vIFNvIHRoYXQgYGluc3RhbmNlb2ZgIHdvcmtzIGNvcnJlY3RseVxuICAgIGNyZWF0ZUFnZW50LnByb3RvdHlwZSA9IGNyZWF0ZUFnZW50LkFnZW50LnByb3RvdHlwZTtcbn0pKGNyZWF0ZUFnZW50IHx8IChjcmVhdGVBZ2VudCA9IHt9KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwcm9taXNpZnkoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCByZXEsIG9wdHMsIChlcnIsIHJ0bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJ0bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9taXNpZnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNpZnkuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPVxue1xuICBwYXJhbGxlbCAgICAgIDogcmVxdWlyZSgnLi9wYXJhbGxlbC5qcycpLFxuICBzZXJpYWwgICAgICAgIDogcmVxdWlyZSgnLi9zZXJpYWwuanMnKSxcbiAgc2VyaWFsT3JkZXJlZCA6IHJlcXVpcmUoJy4vc2VyaWFsT3JkZXJlZC5qcycpXG59O1xuIiwiLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGFib3J0O1xuXG4vKipcbiAqIEFib3J0cyBsZWZ0b3ZlciBhY3RpdmUgam9ic1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIGN1cnJlbnQgc3RhdGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFib3J0KHN0YXRlKVxue1xuICBPYmplY3Qua2V5cyhzdGF0ZS5qb2JzKS5mb3JFYWNoKGNsZWFuLmJpbmQoc3RhdGUpKTtcblxuICAvLyByZXNldCBsZWZ0b3ZlciBqb2JzXG4gIHN0YXRlLmpvYnMgPSB7fTtcbn1cblxuLyoqXG4gKiBDbGVhbnMgdXAgbGVmdG92ZXIgam9iIGJ5IGludm9raW5nIGFib3J0IGZ1bmN0aW9uIGZvciB0aGUgcHJvdmlkZWQgam9iIGlkXG4gKlxuICogQHRoaXMgIHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGtleSAtIGpvYiBpZCB0byBhYm9ydFxuICovXG5mdW5jdGlvbiBjbGVhbihrZXkpXG57XG4gIGlmICh0eXBlb2YgdGhpcy5qb2JzW2tleV0gPT0gJ2Z1bmN0aW9uJylcbiAge1xuICAgIHRoaXMuam9ic1trZXldKCk7XG4gIH1cbn1cbiIsInZhciBkZWZlciA9IHJlcXVpcmUoJy4vZGVmZXIuanMnKTtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuXG4vKipcbiAqIFJ1bnMgcHJvdmlkZWQgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAqIGV2ZW4gaWYgY2FsbGJhY2sgaXRzZWxmIGlzIG5vdFxuICpcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayB0byBpbnZva2VcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBhdWdtZW50ZWQgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYXN5bmMoY2FsbGJhY2spXG57XG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG5cbiAgLy8gY2hlY2sgaWYgYXN5bmMgaGFwcGVuZWRcbiAgZGVmZXIoZnVuY3Rpb24oKSB7IGlzQXN5bmMgPSB0cnVlOyB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gYXN5bmNfY2FsbGJhY2soZXJyLCByZXN1bHQpXG4gIHtcbiAgICBpZiAoaXNBc3luYylcbiAgICB7XG4gICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBkZWZlcihmdW5jdGlvbiBuZXh0VGlja19jYWxsYmFjaygpXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZGVmZXI7XG5cbi8qKlxuICogUnVucyBwcm92aWRlZCBmdW5jdGlvbiBvbiBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgZXZlbnQgbG9vcFxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gcnVuXG4gKi9cbmZ1bmN0aW9uIGRlZmVyKGZuKVxue1xuICB2YXIgbmV4dFRpY2sgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09ICdmdW5jdGlvbidcbiAgICA/IHNldEltbWVkaWF0ZVxuICAgIDogKFxuICAgICAgdHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm9jZXNzLm5leHRUaWNrXG4gICAgICA6IG51bGxcbiAgICApO1xuXG4gIGlmIChuZXh0VGljaylcbiAge1xuICAgIG5leHRUaWNrKGZuKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgfVxufVxuIiwidmFyIGFzeW5jID0gcmVxdWlyZSgnLi9hc3luYy5qcycpXG4gICwgYWJvcnQgPSByZXF1aXJlKCcuL2Fib3J0LmpzJylcbiAgO1xuXG4vLyBBUElcbm1vZHVsZS5leHBvcnRzID0gaXRlcmF0ZTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVhY2ggam9iIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdG9yIC0gaXRlcmF0b3IgdG8gcnVuXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBjdXJyZW50IGpvYiBzdGF0dXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCB3aGVuIGFsbCBlbGVtZW50cyBwcm9jZXNzZWRcbiAqL1xuZnVuY3Rpb24gaXRlcmF0ZShsaXN0LCBpdGVyYXRvciwgc3RhdGUsIGNhbGxiYWNrKVxue1xuICAvLyBzdG9yZSBjdXJyZW50IGluZGV4XG4gIHZhciBrZXkgPSBzdGF0ZVsna2V5ZWRMaXN0J10gPyBzdGF0ZVsna2V5ZWRMaXN0J11bc3RhdGUuaW5kZXhdIDogc3RhdGUuaW5kZXg7XG5cbiAgc3RhdGUuam9ic1trZXldID0gcnVuSm9iKGl0ZXJhdG9yLCBrZXksIGxpc3Rba2V5XSwgZnVuY3Rpb24oZXJyb3IsIG91dHB1dClcbiAge1xuICAgIC8vIGRvbid0IHJlcGVhdCB5b3Vyc2VsZlxuICAgIC8vIHNraXAgc2Vjb25kYXJ5IGNhbGxiYWNrc1xuICAgIGlmICghKGtleSBpbiBzdGF0ZS5qb2JzKSlcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYW4gdXAgam9ic1xuICAgIGRlbGV0ZSBzdGF0ZS5qb2JzW2tleV07XG5cbiAgICBpZiAoZXJyb3IpXG4gICAge1xuICAgICAgLy8gZG9uJ3QgcHJvY2VzcyByZXN0IG9mIHRoZSByZXN1bHRzXG4gICAgICAvLyBzdG9wIHN0aWxsIGFjdGl2ZSBqb2JzXG4gICAgICAvLyBhbmQgcmVzZXQgdGhlIGxpc3RcbiAgICAgIGFib3J0KHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIHN0YXRlLnJlc3VsdHNba2V5XSA9IG91dHB1dDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gc2FsdmFnZWQgcmVzdWx0c1xuICAgIGNhbGxiYWNrKGVycm9yLCBzdGF0ZS5yZXN1bHRzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUnVucyBpdGVyYXRvciBvdmVyIHByb3ZpZGVkIGpvYiBlbGVtZW50XG4gKlxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBpdGVyYXRvciAtIGl0ZXJhdG9yIHRvIGludm9rZVxuICogQHBhcmFtICAge3N0cmluZ3xudW1iZXJ9IGtleSAtIGtleS9pbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgbGlzdCBvZiBqb2JzXG4gKiBAcGFyYW0gICB7bWl4ZWR9IGl0ZW0gLSBqb2IgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpbnZva2VkIGFmdGVyIGl0ZXJhdG9yIGlzIGRvbmUgd2l0aCB0aGUgam9iXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bWl4ZWR9IC0gam9iIGFib3J0IGZ1bmN0aW9uIG9yIHNvbWV0aGluZyBlbHNlXG4gKi9cbmZ1bmN0aW9uIHJ1bkpvYihpdGVyYXRvciwga2V5LCBpdGVtLCBjYWxsYmFjaylcbntcbiAgdmFyIGFib3J0ZXI7XG5cbiAgLy8gYWxsb3cgc2hvcnRjdXQgaWYgaXRlcmF0b3IgZXhwZWN0cyBvbmx5IHR3byBhcmd1bWVudHNcbiAgaWYgKGl0ZXJhdG9yLmxlbmd0aCA9PSAyKVxuICB7XG4gICAgYWJvcnRlciA9IGl0ZXJhdG9yKGl0ZW0sIGFzeW5jKGNhbGxiYWNrKSk7XG4gIH1cbiAgLy8gb3RoZXJ3aXNlIGdvIHdpdGggZnVsbCB0aHJlZSBhcmd1bWVudHNcbiAgZWxzZVxuICB7XG4gICAgYWJvcnRlciA9IGl0ZXJhdG9yKGl0ZW0sIGtleSwgYXN5bmMoY2FsbGJhY2spKTtcbiAgfVxuXG4gIHJldHVybiBhYm9ydGVyO1xufVxuIiwiLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgaW5pdGlhbCBzdGF0ZSBvYmplY3RcbiAqIGZvciBpdGVyYXRpb24gb3ZlciBsaXN0XG4gKlxuICogQHBhcmFtICAge2FycmF5fG9iamVjdH0gbGlzdCAtIGxpc3QgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb258bnVsbH0gc29ydE1ldGhvZCAtIGZ1bmN0aW9uIHRvIHVzZSBmb3Iga2V5cyBzb3J0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYG51bGxgIHRvIGtlZXAgdGhlbSBhcyBpc1xuICogQHJldHVybnMge29iamVjdH0gLSBpbml0aWFsIHN0YXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBzdGF0ZShsaXN0LCBzb3J0TWV0aG9kKVxue1xuICB2YXIgaXNOYW1lZExpc3QgPSAhQXJyYXkuaXNBcnJheShsaXN0KVxuICAgICwgaW5pdFN0YXRlID1cbiAgICB7XG4gICAgICBpbmRleCAgICA6IDAsXG4gICAgICBrZXllZExpc3Q6IGlzTmFtZWRMaXN0IHx8IHNvcnRNZXRob2QgPyBPYmplY3Qua2V5cyhsaXN0KSA6IG51bGwsXG4gICAgICBqb2JzICAgICA6IHt9LFxuICAgICAgcmVzdWx0cyAgOiBpc05hbWVkTGlzdCA/IHt9IDogW10sXG4gICAgICBzaXplICAgICA6IGlzTmFtZWRMaXN0ID8gT2JqZWN0LmtleXMobGlzdCkubGVuZ3RoIDogbGlzdC5sZW5ndGhcbiAgICB9XG4gICAgO1xuXG4gIGlmIChzb3J0TWV0aG9kKVxuICB7XG4gICAgLy8gc29ydCBhcnJheSBrZXlzIGJhc2VkIG9uIGl0J3MgdmFsdWVzXG4gICAgLy8gc29ydCBvYmplY3QncyBrZXlzIGp1c3Qgb24gb3duIG1lcml0XG4gICAgaW5pdFN0YXRlLmtleWVkTGlzdC5zb3J0KGlzTmFtZWRMaXN0ID8gc29ydE1ldGhvZCA6IGZ1bmN0aW9uKGEsIGIpXG4gICAge1xuICAgICAgcmV0dXJuIHNvcnRNZXRob2QobGlzdFthXSwgbGlzdFtiXSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW5pdFN0YXRlO1xufVxuIiwidmFyIGFib3J0ID0gcmVxdWlyZSgnLi9hYm9ydC5qcycpXG4gICwgYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jLmpzJylcbiAgO1xuXG4vLyBBUElcbm1vZHVsZS5leHBvcnRzID0gdGVybWluYXRvcjtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGpvYnMgaW4gdGhlIGF0dGFjaGVkIHN0YXRlIGNvbnRleHRcbiAqXG4gKiBAdGhpcyAgQXN5bmNLaXRTdGF0ZSNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZmluYWwgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRlcm1pbmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHRlcm1pbmF0b3IoY2FsbGJhY2spXG57XG4gIGlmICghT2JqZWN0LmtleXModGhpcy5qb2JzKS5sZW5ndGgpXG4gIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBmYXN0IGZvcndhcmQgaXRlcmF0aW9uIGluZGV4XG4gIHRoaXMuaW5kZXggPSB0aGlzLnNpemU7XG5cbiAgLy8gYWJvcnQgam9ic1xuICBhYm9ydCh0aGlzKTtcblxuICAvLyBzZW5kIGJhY2sgcmVzdWx0cyB3ZSBoYXZlIHNvIGZhclxuICBhc3luYyhjYWxsYmFjaykobnVsbCwgdGhpcy5yZXN1bHRzKTtcbn1cbiIsInZhciBpdGVyYXRlICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0ZS5qcycpXG4gICwgaW5pdFN0YXRlICA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLmpzJylcbiAgLCB0ZXJtaW5hdG9yID0gcmVxdWlyZSgnLi9saWIvdGVybWluYXRvci5qcycpXG4gIDtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBwYXJhbGxlbDtcblxuLyoqXG4gKiBSdW5zIGl0ZXJhdG9yIG92ZXIgcHJvdmlkZWQgYXJyYXkgZWxlbWVudHMgaW4gcGFyYWxsZWxcbiAqXG4gKiBAcGFyYW0gICB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBydW5cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpbnZva2VkIHdoZW4gYWxsIGVsZW1lbnRzIHByb2Nlc3NlZFxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIGpvYnMgdGVybWluYXRvclxuICovXG5mdW5jdGlvbiBwYXJhbGxlbChsaXN0LCBpdGVyYXRvciwgY2FsbGJhY2spXG57XG4gIHZhciBzdGF0ZSA9IGluaXRTdGF0ZShsaXN0KTtcblxuICB3aGlsZSAoc3RhdGUuaW5kZXggPCAoc3RhdGVbJ2tleWVkTGlzdCddIHx8IGxpc3QpLmxlbmd0aClcbiAge1xuICAgIGl0ZXJhdGUobGlzdCwgaXRlcmF0b3IsIHN0YXRlLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KVxuICAgIHtcbiAgICAgIGlmIChlcnJvcilcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9va3MgbGlrZSBpdCdzIHRoZSBsYXN0IG9uZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmpvYnMpLmxlbmd0aCA9PT0gMClcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdGUucmVzdWx0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXRlLmluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gdGVybWluYXRvci5iaW5kKHN0YXRlLCBjYWxsYmFjayk7XG59XG4iLCJ2YXIgc2VyaWFsT3JkZXJlZCA9IHJlcXVpcmUoJy4vc2VyaWFsT3JkZXJlZC5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHNlcmlhbDtcblxuLyoqXG4gKiBSdW5zIGl0ZXJhdG9yIG92ZXIgcHJvdmlkZWQgYXJyYXkgZWxlbWVudHMgaW4gc2VyaWVzXG4gKlxuICogQHBhcmFtICAge2FycmF5fG9iamVjdH0gbGlzdCAtIGFycmF5IG9yIG9iamVjdCAobmFtZWQgbGlzdCkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGl0ZXJhdG9yIC0gaXRlcmF0b3IgdG8gcnVuXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCB3aGVuIGFsbCBlbGVtZW50cyBwcm9jZXNzZWRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBqb2JzIHRlcm1pbmF0b3JcbiAqL1xuZnVuY3Rpb24gc2VyaWFsKGxpc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaylcbntcbiAgcmV0dXJuIHNlcmlhbE9yZGVyZWQobGlzdCwgaXRlcmF0b3IsIG51bGwsIGNhbGxiYWNrKTtcbn1cbiIsInZhciBpdGVyYXRlICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0ZS5qcycpXG4gICwgaW5pdFN0YXRlICA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLmpzJylcbiAgLCB0ZXJtaW5hdG9yID0gcmVxdWlyZSgnLi9saWIvdGVybWluYXRvci5qcycpXG4gIDtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBzZXJpYWxPcmRlcmVkO1xuLy8gc29ydGluZyBoZWxwZXJzXG5tb2R1bGUuZXhwb3J0cy5hc2NlbmRpbmcgID0gYXNjZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG5cbi8qKlxuICogUnVucyBpdGVyYXRvciBvdmVyIHByb3ZpZGVkIHNvcnRlZCBhcnJheSBlbGVtZW50cyBpbiBzZXJpZXNcbiAqXG4gKiBAcGFyYW0gICB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBydW5cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gc29ydE1ldGhvZCAtIGN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCB3aGVuIGFsbCBlbGVtZW50cyBwcm9jZXNzZWRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBqb2JzIHRlcm1pbmF0b3JcbiAqL1xuZnVuY3Rpb24gc2VyaWFsT3JkZXJlZChsaXN0LCBpdGVyYXRvciwgc29ydE1ldGhvZCwgY2FsbGJhY2spXG57XG4gIHZhciBzdGF0ZSA9IGluaXRTdGF0ZShsaXN0LCBzb3J0TWV0aG9kKTtcblxuICBpdGVyYXRlKGxpc3QsIGl0ZXJhdG9yLCBzdGF0ZSwgZnVuY3Rpb24gaXRlcmF0b3JIYW5kbGVyKGVycm9yLCByZXN1bHQpXG4gIHtcbiAgICBpZiAoZXJyb3IpXG4gICAge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXgrKztcblxuICAgIC8vIGFyZSB3ZSB0aGVyZSB5ZXQ/XG4gICAgaWYgKHN0YXRlLmluZGV4IDwgKHN0YXRlWydrZXllZExpc3QnXSB8fCBsaXN0KS5sZW5ndGgpXG4gICAge1xuICAgICAgaXRlcmF0ZShsaXN0LCBpdGVyYXRvciwgc3RhdGUsIGl0ZXJhdG9ySGFuZGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZG9uZSBoZXJlXG4gICAgY2FsbGJhY2sobnVsbCwgc3RhdGUucmVzdWx0cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0ZXJtaW5hdG9yLmJpbmQoc3RhdGUsIGNhbGxiYWNrKTtcbn1cblxuLypcbiAqIC0tIFNvcnQgbWV0aG9kc1xuICovXG5cbi8qKlxuICogc29ydCBoZWxwZXIgdG8gc29ydCBhcnJheSBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqXG4gKiBAcGFyYW0gICB7bWl4ZWR9IGEgLSBhbiBpdGVtIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSAgIHttaXhlZH0gYiAtIGFuIGl0ZW0gdG8gY29tcGFyZVxuICogQHJldHVybnMge251bWJlcn0gLSBjb21wYXJpc29uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYilcbntcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG4vKipcbiAqIHNvcnQgaGVscGVyIHRvIHNvcnQgYXJyYXkgZWxlbWVudHMgaW4gZGVzY2VuZGluZyBvcmRlclxuICpcbiAqIEBwYXJhbSAgIHttaXhlZH0gYSAtIGFuIGl0ZW0gdG8gY29tcGFyZVxuICogQHBhcmFtICAge21peGVkfSBiIC0gYW4gaXRlbSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGNvbXBhcmlzb24gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYilcbntcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIERlbGF5ZWRTdHJlYW0gPSByZXF1aXJlKCdkZWxheWVkLXN0cmVhbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJpbmVkU3RyZWFtO1xuZnVuY3Rpb24gQ29tYmluZWRTdHJlYW0oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMiAqIDEwMjQgKiAxMDI0O1xuICB0aGlzLnBhdXNlU3RyZWFtcyA9IHRydWU7XG5cbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbiAgdGhpcy5faW5zaWRlTG9vcCA9IGZhbHNlO1xuICB0aGlzLl9wZW5kaW5nTmV4dCA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhDb21iaW5lZFN0cmVhbSwgU3RyZWFtKTtcblxuQ29tYmluZWRTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgY29tYmluZWRTdHJlYW0gPSBuZXcgdGhpcygpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGNvbWJpbmVkU3RyZWFtW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cblxuICByZXR1cm4gY29tYmluZWRTdHJlYW07XG59O1xuXG5Db21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3RyZWFtICE9PSAnZnVuY3Rpb24nKVxuICAgICYmICh0eXBlb2Ygc3RyZWFtICE9PSAnc3RyaW5nJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Jvb2xlYW4nKVxuICAgICYmICh0eXBlb2Ygc3RyZWFtICE9PSAnbnVtYmVyJylcbiAgICAmJiAoIUJ1ZmZlci5pc0J1ZmZlcihzdHJlYW0pKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuXG4gIGlmIChpc1N0cmVhbUxpa2UpIHtcbiAgICBpZiAoIShzdHJlYW0gaW5zdGFuY2VvZiBEZWxheWVkU3RyZWFtKSkge1xuICAgICAgdmFyIG5ld1N0cmVhbSA9IERlbGF5ZWRTdHJlYW0uY3JlYXRlKHN0cmVhbSwge1xuICAgICAgICBtYXhEYXRhU2l6ZTogSW5maW5pdHksXG4gICAgICAgIHBhdXNlU3RyZWFtOiB0aGlzLnBhdXNlU3RyZWFtcyxcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtLm9uKCdkYXRhJywgdGhpcy5fY2hlY2tEYXRhU2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVFcnJvcnMoc3RyZWFtKTtcblxuICAgIGlmICh0aGlzLnBhdXNlU3RyZWFtcykge1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIFN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHRoaXMsIGRlc3QsIG9wdGlvbnMpO1xuICB0aGlzLnJlc3VtZSgpO1xuICByZXR1cm4gZGVzdDtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fZ2V0TmV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcblxuICBpZiAodGhpcy5faW5zaWRlTG9vcCkge1xuICAgIHRoaXMuX3BlbmRpbmdOZXh0ID0gdHJ1ZTtcbiAgICByZXR1cm47IC8vIGRlZmVyIGNhbGxcbiAgfVxuXG4gIHRoaXMuX2luc2lkZUxvb3AgPSB0cnVlO1xuICB0cnkge1xuICAgIGRvIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdOZXh0ID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWFsR2V0TmV4dCgpO1xuICAgIH0gd2hpbGUgKHRoaXMuX3BlbmRpbmdOZXh0KTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0aGlzLl9pbnNpZGVMb29wID0gZmFsc2U7XG4gIH1cbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fcmVhbEdldE5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXMuc2hpZnQoKTtcblxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtID09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5lbmQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3BpcGVOZXh0KHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldFN0cmVhbSA9IHN0cmVhbTtcbiAgZ2V0U3RyZWFtKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcbiAgICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgICBzdHJlYW0ub24oJ2RhdGEnLCB0aGlzLl9jaGVja0RhdGFTaXplLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5faGFuZGxlRXJyb3JzKHN0cmVhbSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGlwZU5leHQoc3RyZWFtKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fcGlwZU5leHQgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IHN0cmVhbTtcblxuICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG4gIGlmIChpc1N0cmVhbUxpa2UpIHtcbiAgICBzdHJlYW0ub24oJ2VuZCcsIHRoaXMuX2dldE5leHQuYmluZCh0aGlzKSk7XG4gICAgc3RyZWFtLnBpcGUodGhpcywge2VuZDogZmFsc2V9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBzdHJlYW07XG4gIHRoaXMud3JpdGUodmFsdWUpO1xuICB0aGlzLl9nZXROZXh0KCk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2hhbmRsZUVycm9ycyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLl9lbWl0RXJyb3IoZXJyKTtcbiAgfSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5wYXVzZVN0cmVhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZih0aGlzLnBhdXNlU3RyZWFtcyAmJiB0aGlzLl9jdXJyZW50U3RyZWFtICYmIHR5cGVvZih0aGlzLl9jdXJyZW50U3RyZWFtLnBhdXNlKSA9PSAnZnVuY3Rpb24nKSB0aGlzLl9jdXJyZW50U3RyZWFtLnBhdXNlKCk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMuX3JlbGVhc2VkID0gdHJ1ZTtcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9nZXROZXh0KCk7XG4gIH1cblxuICBpZih0aGlzLnBhdXNlU3RyZWFtcyAmJiB0aGlzLl9jdXJyZW50U3RyZWFtICYmIHR5cGVvZih0aGlzLl9jdXJyZW50U3RyZWFtLnJlc3VtZSkgPT0gJ2Z1bmN0aW9uJykgdGhpcy5fY3VycmVudFN0cmVhbS5yZXN1bWUoKTtcbiAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5lbWl0KCdlbmQnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB0aGlzLl9zdHJlYW1zID0gW107XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBudWxsO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9jaGVja0RhdGFTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZURhdGFTaXplKCk7XG4gIGlmICh0aGlzLmRhdGFTaXplIDw9IHRoaXMubWF4RGF0YVNpemUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9XG4gICAgJ0RlbGF5ZWRTdHJlYW0jbWF4RGF0YVNpemUgb2YgJyArIHRoaXMubWF4RGF0YVNpemUgKyAnIGJ5dGVzIGV4Y2VlZGVkLic7XG4gIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IobWVzc2FnZSkpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl91cGRhdGVEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGFTaXplID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3N0cmVhbXMuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbS5kYXRhU2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuZGF0YVNpemUgKz0gc3RyZWFtLmRhdGFTaXplO1xuICB9KTtcblxuICBpZiAodGhpcy5fY3VycmVudFN0cmVhbSAmJiB0aGlzLl9jdXJyZW50U3RyZWFtLmRhdGFTaXplKSB7XG4gICAgdGhpcy5kYXRhU2l6ZSArPSB0aGlzLl9jdXJyZW50U3RyZWFtLmRhdGFTaXplO1xuICB9XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2VtaXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNwID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuY29uc3QgZW5vZW50ID0gcmVxdWlyZSgnLi9saWIvZW5vZW50Jyk7XG5cbmZ1bmN0aW9uIHNwYXduKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAvLyBQYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UoY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG5cbiAgICAvLyBTcGF3biB0aGUgY2hpbGQgcHJvY2Vzc1xuICAgIGNvbnN0IHNwYXduZWQgPSBjcC5zcGF3bihwYXJzZWQuY29tbWFuZCwgcGFyc2VkLmFyZ3MsIHBhcnNlZC5vcHRpb25zKTtcblxuICAgIC8vIEhvb2sgaW50byBjaGlsZCBwcm9jZXNzIFwiZXhpdFwiIGV2ZW50IHRvIGVtaXQgYW4gZXJyb3IgaWYgdGhlIGNvbW1hbmRcbiAgICAvLyBkb2VzIG5vdCBleGlzdHMsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0luZGlnb1VuaXRlZC9ub2RlLWNyb3NzLXNwYXduL2lzc3Vlcy8xNlxuICAgIGVub2VudC5ob29rQ2hpbGRQcm9jZXNzKHNwYXduZWQsIHBhcnNlZCk7XG5cbiAgICByZXR1cm4gc3Bhd25lZDtcbn1cblxuZnVuY3Rpb24gc3Bhd25TeW5jKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAvLyBQYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UoY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG5cbiAgICAvLyBTcGF3biB0aGUgY2hpbGQgcHJvY2Vzc1xuICAgIGNvbnN0IHJlc3VsdCA9IGNwLnNwYXduU3luYyhwYXJzZWQuY29tbWFuZCwgcGFyc2VkLmFyZ3MsIHBhcnNlZC5vcHRpb25zKTtcblxuICAgIC8vIEFuYWx5emUgaWYgdGhlIGNvbW1hbmQgZG9lcyBub3QgZXhpc3QsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0luZGlnb1VuaXRlZC9ub2RlLWNyb3NzLXNwYXduL2lzc3Vlcy8xNlxuICAgIHJlc3VsdC5lcnJvciA9IHJlc3VsdC5lcnJvciB8fCBlbm9lbnQudmVyaWZ5RU5PRU5UU3luYyhyZXN1bHQuc3RhdHVzLCBwYXJzZWQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzcGF3bjtcbm1vZHVsZS5leHBvcnRzLnNwYXduID0gc3Bhd247XG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gc3Bhd25TeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5fcGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLl9lbm9lbnQgPSBlbm9lbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuZnVuY3Rpb24gbm90Rm91bmRFcnJvcihvcmlnaW5hbCwgc3lzY2FsbCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgJHtzeXNjYWxsfSAke29yaWdpbmFsLmNvbW1hbmR9IEVOT0VOVGApLCB7XG4gICAgICAgIGNvZGU6ICdFTk9FTlQnLFxuICAgICAgICBlcnJubzogJ0VOT0VOVCcsXG4gICAgICAgIHN5c2NhbGw6IGAke3N5c2NhbGx9ICR7b3JpZ2luYWwuY29tbWFuZH1gLFxuICAgICAgICBwYXRoOiBvcmlnaW5hbC5jb21tYW5kLFxuICAgICAgICBzcGF3bmFyZ3M6IG9yaWdpbmFsLmFyZ3MsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhvb2tDaGlsZFByb2Nlc3MoY3AsIHBhcnNlZCkge1xuICAgIGlmICghaXNXaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsRW1pdCA9IGNwLmVtaXQ7XG5cbiAgICBjcC5lbWl0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZzEpIHtcbiAgICAgICAgLy8gSWYgZW1pdHRpbmcgXCJleGl0XCIgZXZlbnQgYW5kIGV4aXQgY29kZSBpcyAxLCB3ZSBuZWVkIHRvIGNoZWNrIGlmXG4gICAgICAgIC8vIHRoZSBjb21tYW5kIGV4aXN0cyBhbmQgZW1pdCBhbiBcImVycm9yXCIgaW5zdGVhZFxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0luZGlnb1VuaXRlZC9ub2RlLWNyb3NzLXNwYXduL2lzc3Vlcy8xNlxuICAgICAgICBpZiAobmFtZSA9PT0gJ2V4aXQnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB2ZXJpZnlFTk9FTlQoYXJnMSwgcGFyc2VkLCAnc3Bhd24nKTtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEVtaXQuY2FsbChjcCwgJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbEVtaXQuYXBwbHkoY3AsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5RU5PRU5UKHN0YXR1cywgcGFyc2VkKSB7XG4gICAgaWYgKGlzV2luICYmIHN0YXR1cyA9PT0gMSAmJiAhcGFyc2VkLmZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvdW5kRXJyb3IocGFyc2VkLm9yaWdpbmFsLCAnc3Bhd24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5RU5PRU5UU3luYyhzdGF0dXMsIHBhcnNlZCkge1xuICAgIGlmIChpc1dpbiAmJiBzdGF0dXMgPT09IDEgJiYgIXBhcnNlZC5maWxlKSB7XG4gICAgICAgIHJldHVybiBub3RGb3VuZEVycm9yKHBhcnNlZC5vcmlnaW5hbCwgJ3NwYXduU3luYycpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBob29rQ2hpbGRQcm9jZXNzLFxuICAgIHZlcmlmeUVOT0VOVCxcbiAgICB2ZXJpZnlFTk9FTlRTeW5jLFxuICAgIG5vdEZvdW5kRXJyb3IsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgcmVzb2x2ZUNvbW1hbmQgPSByZXF1aXJlKCcuL3V0aWwvcmVzb2x2ZUNvbW1hbmQnKTtcbmNvbnN0IGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbC9lc2NhcGUnKTtcbmNvbnN0IHJlYWRTaGViYW5nID0gcmVxdWlyZSgnLi91dGlsL3JlYWRTaGViYW5nJyk7XG5cbmNvbnN0IGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbmNvbnN0IGlzRXhlY3V0YWJsZVJlZ0V4cCA9IC9cXC4oPzpjb218ZXhlKSQvaTtcbmNvbnN0IGlzQ21kU2hpbVJlZ0V4cCA9IC9ub2RlX21vZHVsZXNbXFxcXC9dLmJpbltcXFxcL11bXlxcXFwvXStcXC5jbWQkL2k7XG5cbmZ1bmN0aW9uIGRldGVjdFNoZWJhbmcocGFyc2VkKSB7XG4gICAgcGFyc2VkLmZpbGUgPSByZXNvbHZlQ29tbWFuZChwYXJzZWQpO1xuXG4gICAgY29uc3Qgc2hlYmFuZyA9IHBhcnNlZC5maWxlICYmIHJlYWRTaGViYW5nKHBhcnNlZC5maWxlKTtcblxuICAgIGlmIChzaGViYW5nKSB7XG4gICAgICAgIHBhcnNlZC5hcmdzLnVuc2hpZnQocGFyc2VkLmZpbGUpO1xuICAgICAgICBwYXJzZWQuY29tbWFuZCA9IHNoZWJhbmc7XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb21tYW5kKHBhcnNlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZC5maWxlO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vblNoZWxsKHBhcnNlZCkge1xuICAgIGlmICghaXNXaW4pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgJiBhZGQgc3VwcG9ydCBmb3Igc2hlYmFuZ3NcbiAgICBjb25zdCBjb21tYW5kRmlsZSA9IGRldGVjdFNoZWJhbmcocGFyc2VkKTtcblxuICAgIC8vIFdlIGRvbid0IG5lZWQgYSBzaGVsbCBpZiB0aGUgY29tbWFuZCBmaWxlbmFtZSBpcyBhbiBleGVjdXRhYmxlXG4gICAgY29uc3QgbmVlZHNTaGVsbCA9ICFpc0V4ZWN1dGFibGVSZWdFeHAudGVzdChjb21tYW5kRmlsZSk7XG5cbiAgICAvLyBJZiBhIHNoZWxsIGlzIHJlcXVpcmVkLCB1c2UgY21kLmV4ZSBhbmQgdGFrZSBjYXJlIG9mIGVzY2FwaW5nIGV2ZXJ5dGhpbmcgY29ycmVjdGx5XG4gICAgLy8gTm90ZSB0aGF0IGBmb3JjZVNoZWxsYCBpcyBhbiBoaWRkZW4gb3B0aW9uIHVzZWQgb25seSBpbiB0ZXN0c1xuICAgIGlmIChwYXJzZWQub3B0aW9ucy5mb3JjZVNoZWxsIHx8IG5lZWRzU2hlbGwpIHtcbiAgICAgICAgLy8gTmVlZCB0byBkb3VibGUgZXNjYXBlIG1ldGEgY2hhcnMgaWYgdGhlIGNvbW1hbmQgaXMgYSBjbWQtc2hpbSBsb2NhdGVkIGluIGBub2RlX21vZHVsZXMvLmJpbi9gXG4gICAgICAgIC8vIFRoZSBjbWQtc2hpbSBzaW1wbHkgY2FsbHMgZXhlY3V0ZSB0aGUgcGFja2FnZSBiaW4gZmlsZSB3aXRoIE5vZGVKUywgcHJveHlpbmcgYW55IGFyZ3VtZW50XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIGVzY2FwZSBvZiBtZXRhY2hhcnMgd2l0aCBeIGdldHMgaW50ZXJwcmV0ZWQgd2hlbiB0aGUgY21kLmV4ZSBpcyBmaXJzdCBjYWxsZWQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZG91YmxlIGVzY2FwZSB0aGVtXG4gICAgICAgIGNvbnN0IG5lZWRzRG91YmxlRXNjYXBlTWV0YUNoYXJzID0gaXNDbWRTaGltUmVnRXhwLnRlc3QoY29tbWFuZEZpbGUpO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwb3NpeCBwYXRocyBpbnRvIE9TIGNvbXBhdGlibGUgcGF0aHMgKGUuZy46IGZvby9iYXIgLT4gZm9vXFxiYXIpXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyBmYWlsIHdpdGggRU5PRU5UIGluIHRob3NlIGNhc2VzXG4gICAgICAgIHBhcnNlZC5jb21tYW5kID0gcGF0aC5ub3JtYWxpemUocGFyc2VkLmNvbW1hbmQpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjb21tYW5kICYgYXJndW1lbnRzXG4gICAgICAgIHBhcnNlZC5jb21tYW5kID0gZXNjYXBlLmNvbW1hbmQocGFyc2VkLmNvbW1hbmQpO1xuICAgICAgICBwYXJzZWQuYXJncyA9IHBhcnNlZC5hcmdzLm1hcCgoYXJnKSA9PiBlc2NhcGUuYXJndW1lbnQoYXJnLCBuZWVkc0RvdWJsZUVzY2FwZU1ldGFDaGFycykpO1xuXG4gICAgICAgIGNvbnN0IHNoZWxsQ29tbWFuZCA9IFtwYXJzZWQuY29tbWFuZF0uY29uY2F0KHBhcnNlZC5hcmdzKS5qb2luKCcgJyk7XG5cbiAgICAgICAgcGFyc2VkLmFyZ3MgPSBbJy9kJywgJy9zJywgJy9jJywgYFwiJHtzaGVsbENvbW1hbmR9XCJgXTtcbiAgICAgICAgcGFyc2VkLmNvbW1hbmQgPSBwcm9jZXNzLmVudi5jb21zcGVjIHx8ICdjbWQuZXhlJztcbiAgICAgICAgcGFyc2VkLm9wdGlvbnMud2luZG93c1ZlcmJhdGltQXJndW1lbnRzID0gdHJ1ZTsgLy8gVGVsbCBub2RlJ3Mgc3Bhd24gdGhhdCB0aGUgYXJndW1lbnRzIGFyZSBhbHJlYWR5IGVzY2FwZWRcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBwYXJzZShjb21tYW5kLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgLy8gTm9ybWFsaXplIGFyZ3VtZW50cywgc2ltaWxhciB0byBub2RlanNcbiAgICBpZiAoYXJncyAmJiAhQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBvcHRpb25zID0gYXJncztcbiAgICAgICAgYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgYXJncyA9IGFyZ3MgPyBhcmdzLnNsaWNlKDApIDogW107IC8vIENsb25lIGFycmF5IHRvIGF2b2lkIGNoYW5naW5nIHRoZSBvcmlnaW5hbFxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgLy8gQ2xvbmUgb2JqZWN0IHRvIGF2b2lkIGNoYW5naW5nIHRoZSBvcmlnaW5hbFxuXG4gICAgLy8gQnVpbGQgb3VyIHBhcnNlZCBvYmplY3RcbiAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICAgIGNvbW1hbmQsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZpbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBEZWxlZ2F0ZSBmdXJ0aGVyIHBhcnNpbmcgdG8gc2hlbGwgb3Igbm9uLXNoZWxsXG4gICAgcmV0dXJuIG9wdGlvbnMuc2hlbGwgPyBwYXJzZWQgOiBwYXJzZU5vblNoZWxsKHBhcnNlZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFNlZSBodHRwOi8vd3d3LnJvYnZhbmRlcndvdWRlLmNvbS9lc2NhcGVjaGFycy5waHBcbmNvbnN0IG1ldGFDaGFyc1JlZ0V4cCA9IC8oWygpXFxdWyUhXlwiYDw+Jnw7LCAqP10pL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbW1hbmQoYXJnKSB7XG4gICAgLy8gRXNjYXBlIG1ldGEgY2hhcnNcbiAgICBhcmcgPSBhcmcucmVwbGFjZShtZXRhQ2hhcnNSZWdFeHAsICdeJDEnKTtcblxuICAgIHJldHVybiBhcmc7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUFyZ3VtZW50KGFyZywgZG91YmxlRXNjYXBlTWV0YUNoYXJzKSB7XG4gICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICBhcmcgPSBgJHthcmd9YDtcblxuICAgIC8vIEFsZ29yaXRobSBiZWxvdyBpcyBiYXNlZCBvbiBodHRwczovL3FudG0ub3JnL2NtZFxuXG4gICAgLy8gU2VxdWVuY2Ugb2YgYmFja3NsYXNoZXMgZm9sbG93ZWQgYnkgYSBkb3VibGUgcXVvdGU6XG4gICAgLy8gZG91YmxlIHVwIGFsbCB0aGUgYmFja3NsYXNoZXMgYW5kIGVzY2FwZSB0aGUgZG91YmxlIHF1b3RlXG4gICAgYXJnID0gYXJnLnJlcGxhY2UoLyhcXFxcKilcIi9nLCAnJDEkMVxcXFxcIicpO1xuXG4gICAgLy8gU2VxdWVuY2Ugb2YgYmFja3NsYXNoZXMgZm9sbG93ZWQgYnkgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgLy8gKHdoaWNoIHdpbGwgYmVjb21lIGEgZG91YmxlIHF1b3RlIGxhdGVyKTpcbiAgICAvLyBkb3VibGUgdXAgYWxsIHRoZSBiYWNrc2xhc2hlc1xuICAgIGFyZyA9IGFyZy5yZXBsYWNlKC8oXFxcXCopJC8sICckMSQxJyk7XG5cbiAgICAvLyBBbGwgb3RoZXIgYmFja3NsYXNoZXMgb2NjdXIgbGl0ZXJhbGx5XG5cbiAgICAvLyBRdW90ZSB0aGUgd2hvbGUgdGhpbmc6XG4gICAgYXJnID0gYFwiJHthcmd9XCJgO1xuXG4gICAgLy8gRXNjYXBlIG1ldGEgY2hhcnNcbiAgICBhcmcgPSBhcmcucmVwbGFjZShtZXRhQ2hhcnNSZWdFeHAsICdeJDEnKTtcblxuICAgIC8vIERvdWJsZSBlc2NhcGUgbWV0YSBjaGFycyBpZiBuZWNlc3NhcnlcbiAgICBpZiAoZG91YmxlRXNjYXBlTWV0YUNoYXJzKSB7XG4gICAgICAgIGFyZyA9IGFyZy5yZXBsYWNlKG1ldGFDaGFyc1JlZ0V4cCwgJ14kMScpO1xuICAgIH1cblxuICAgIHJldHVybiBhcmc7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbW1hbmQgPSBlc2NhcGVDb21tYW5kO1xubW9kdWxlLmV4cG9ydHMuYXJndW1lbnQgPSBlc2NhcGVBcmd1bWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgc2hlYmFuZ0NvbW1hbmQgPSByZXF1aXJlKCdzaGViYW5nLWNvbW1hbmQnKTtcblxuZnVuY3Rpb24gcmVhZFNoZWJhbmcoY29tbWFuZCkge1xuICAgIC8vIFJlYWQgdGhlIGZpcnN0IDE1MCBieXRlcyBmcm9tIHRoZSBmaWxlXG4gICAgY29uc3Qgc2l6ZSA9IDE1MDtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSk7XG5cbiAgICBsZXQgZmQ7XG5cbiAgICB0cnkge1xuICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKGNvbW1hbmQsICdyJyk7XG4gICAgICAgIGZzLnJlYWRTeW5jKGZkLCBidWZmZXIsIDAsIHNpemUsIDApO1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogRW1wdHkgKi8gfVxuXG4gICAgLy8gQXR0ZW1wdCB0byBleHRyYWN0IHNoZWJhbmcgKG51bGwgaXMgcmV0dXJuZWQgaWYgbm90IGEgc2hlYmFuZylcbiAgICByZXR1cm4gc2hlYmFuZ0NvbW1hbmQoYnVmZmVyLnRvU3RyaW5nKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRTaGViYW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgd2hpY2ggPSByZXF1aXJlKCd3aGljaCcpO1xuY29uc3QgZ2V0UGF0aEtleSA9IHJlcXVpcmUoJ3BhdGgta2V5Jyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21tYW5kQXR0ZW1wdChwYXJzZWQsIHdpdGhvdXRQYXRoRXh0KSB7XG4gICAgY29uc3QgZW52ID0gcGFyc2VkLm9wdGlvbnMuZW52IHx8IHByb2Nlc3MuZW52O1xuICAgIGNvbnN0IGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgY29uc3QgaGFzQ3VzdG9tQ3dkID0gcGFyc2VkLm9wdGlvbnMuY3dkICE9IG51bGw7XG4gICAgLy8gV29ya2VyIHRocmVhZHMgZG8gbm90IGhhdmUgcHJvY2Vzcy5jaGRpcigpXG4gICAgY29uc3Qgc2hvdWxkU3dpdGNoQ3dkID0gaGFzQ3VzdG9tQ3dkICYmIHByb2Nlc3MuY2hkaXIgIT09IHVuZGVmaW5lZCAmJiAhcHJvY2Vzcy5jaGRpci5kaXNhYmxlZDtcblxuICAgIC8vIElmIGEgY3VzdG9tIGBjd2RgIHdhcyBzcGVjaWZpZWQsIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBwcm9jZXNzIGN3ZFxuICAgIC8vIGJlY2F1c2UgYHdoaWNoYCB3aWxsIGRvIHN0YXQgY2FsbHMgYnV0IGRvZXMgbm90IHN1cHBvcnQgYSBjdXN0b20gY3dkXG4gICAgaWYgKHNob3VsZFN3aXRjaEN3ZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvY2Vzcy5jaGRpcihwYXJzZWQub3B0aW9ucy5jd2QpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8qIEVtcHR5ICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZWQ7XG5cbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlZCA9IHdoaWNoLnN5bmMocGFyc2VkLmNvbW1hbmQsIHtcbiAgICAgICAgICAgIHBhdGg6IGVudltnZXRQYXRoS2V5KHsgZW52IH0pXSxcbiAgICAgICAgICAgIHBhdGhFeHQ6IHdpdGhvdXRQYXRoRXh0ID8gcGF0aC5kZWxpbWl0ZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogRW1wdHkgKi9cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoc2hvdWxkU3dpdGNoQ3dkKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmNoZGlyKGN3ZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgcmVzb2x2ZWQsIGVuc3VyZSB0aGF0IGFuIGFic29sdXRlIHBhdGggaXMgcmV0dXJuZWRcbiAgICAvLyBOb3RlIHRoYXQgd2hlbiBhIGN1c3RvbSBgY3dkYCB3YXMgdXNlZCwgd2UgbmVlZCB0byByZXNvbHZlIHRvIGFuIGFic29sdXRlIHBhdGggYmFzZWQgb24gaXRcbiAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSBwYXRoLnJlc29sdmUoaGFzQ3VzdG9tQ3dkID8gcGFyc2VkLm9wdGlvbnMuY3dkIDogJycsIHJlc29sdmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21tYW5kKHBhcnNlZCkge1xuICAgIHJldHVybiByZXNvbHZlQ29tbWFuZEF0dGVtcHQocGFyc2VkKSB8fCByZXNvbHZlQ29tbWFuZEF0dGVtcHQocGFyc2VkLCB0cnVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlQ29tbWFuZDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQoLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5ZWRTdHJlYW07XG5mdW5jdGlvbiBEZWxheWVkU3RyZWFtKCkge1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMTAyNCAqIDEwMjQ7XG4gIHRoaXMucGF1c2VTdHJlYW0gPSB0cnVlO1xuXG4gIHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQgPSBmYWxzZTtcbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMgPSBbXTtcbn1cbnV0aWwuaW5oZXJpdHMoRGVsYXllZFN0cmVhbSwgU3RyZWFtKTtcblxuRGVsYXllZFN0cmVhbS5jcmVhdGUgPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGRlbGF5ZWRTdHJlYW0gPSBuZXcgdGhpcygpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGRlbGF5ZWRTdHJlYW1bb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgfVxuXG4gIGRlbGF5ZWRTdHJlYW0uc291cmNlID0gc291cmNlO1xuXG4gIHZhciByZWFsRW1pdCA9IHNvdXJjZS5lbWl0O1xuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGF5ZWRTdHJlYW0uX2hhbmRsZUVtaXQoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVhbEVtaXQuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcbiAgaWYgKGRlbGF5ZWRTdHJlYW0ucGF1c2VTdHJlYW0pIHtcbiAgICBzb3VyY2UucGF1c2UoKTtcbiAgfVxuXG4gIHJldHVybiBkZWxheWVkU3RyZWFtO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLCAncmVhZGFibGUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVhZGFibGU7XG4gIH1cbn0pO1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2Uuc2V0RW5jb2RpbmcuYXBwbHkodGhpcy5zb3VyY2UsIGFyZ3VtZW50cyk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICB9XG5cbiAgdGhpcy5zb3VyY2UucmVzdW1lKCk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNvdXJjZS5wYXVzZSgpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG5cbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLl9idWZmZXJlZEV2ZW50cyA9IFtdO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IFN0cmVhbS5wcm90b3R5cGUucGlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLnJlc3VtZSgpO1xuICByZXR1cm4gcjtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFbWl0ID0gZnVuY3Rpb24oYXJncykge1xuICBpZiAodGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFyZ3NbMF0gPT09ICdkYXRhJykge1xuICAgIHRoaXMuZGF0YVNpemUgKz0gYXJnc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQoKTtcbiAgfVxuXG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzLnB1c2goYXJncyk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCA9IHRydWU7XG4gIHZhciBtZXNzYWdlID1cbiAgICAnRGVsYXllZFN0cmVhbSNtYXhEYXRhU2l6ZSBvZiAnICsgdGhpcy5tYXhEYXRhU2l6ZSArICcgYnl0ZXMgZXhjZWVkZWQuJ1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbn07XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDaGlsZFByb2Nlc3MgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gM1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblx0dmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlYWRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpO1xuXHR9O1xuXG5cdHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VuZXh0dGljayk7XG5cdH07XG5cblx0dmFyIG9uY2xvc2VuZXh0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChjYW5jZWxsZWQpIHJldHVybjtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiAocnMuZW5kZWQgJiYgIXJzLmRlc3Ryb3llZCkpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHRcdGlmICh3cml0YWJsZSAmJiAhKHdzICYmICh3cy5lbmRlZCAmJiAhd3MuZGVzdHJveWVkKSkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdH07XG5cblx0dmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0fTtcblxuXHRpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcblx0XHRzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7XG5cdFx0ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHR9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtc1xuXHRcdHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdH1cblxuXHRpZiAoaXNDaGlsZFByb2Nlc3Moc3RyZWFtKSkgc3RyZWFtLm9uKCdleGl0Jywgb25leGl0KTtcblxuXHRzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcblx0c3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGNhbmNlbGxlZCA9IHRydWU7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY2hpbGRQcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuY29uc3QgY3Jvc3NTcGF3biA9IHJlcXVpcmUoJ2Nyb3NzLXNwYXduJyk7XG5jb25zdCBzdHJpcEZpbmFsTmV3bGluZSA9IHJlcXVpcmUoJ3N0cmlwLWZpbmFsLW5ld2xpbmUnKTtcbmNvbnN0IG5wbVJ1blBhdGggPSByZXF1aXJlKCducG0tcnVuLXBhdGgnKTtcbmNvbnN0IG9uZXRpbWUgPSByZXF1aXJlKCdvbmV0aW1lJyk7XG5jb25zdCBtYWtlRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpO1xuY29uc3Qgbm9ybWFsaXplU3RkaW8gPSByZXF1aXJlKCcuL2xpYi9zdGRpbycpO1xuY29uc3Qge3NwYXduZWRLaWxsLCBzcGF3bmVkQ2FuY2VsLCBzZXR1cFRpbWVvdXQsIHZhbGlkYXRlVGltZW91dCwgc2V0RXhpdEhhbmRsZXJ9ID0gcmVxdWlyZSgnLi9saWIva2lsbCcpO1xuY29uc3Qge2hhbmRsZUlucHV0LCBnZXRTcGF3bmVkUmVzdWx0LCBtYWtlQWxsU3RyZWFtLCB2YWxpZGF0ZUlucHV0U3luY30gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbmNvbnN0IHttZXJnZVByb21pc2UsIGdldFNwYXduZWRQcm9taXNlfSA9IHJlcXVpcmUoJy4vbGliL3Byb21pc2UnKTtcbmNvbnN0IHtqb2luQ29tbWFuZCwgcGFyc2VDb21tYW5kLCBnZXRFc2NhcGVkQ29tbWFuZH0gPSByZXF1aXJlKCcuL2xpYi9jb21tYW5kJyk7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0JVRkZFUiA9IDEwMDAgKiAxMDAwICogMTAwO1xuXG5jb25zdCBnZXRFbnYgPSAoe2VudjogZW52T3B0aW9uLCBleHRlbmRFbnYsIHByZWZlckxvY2FsLCBsb2NhbERpciwgZXhlY1BhdGh9KSA9PiB7XG5cdGNvbnN0IGVudiA9IGV4dGVuZEVudiA/IHsuLi5wcm9jZXNzLmVudiwgLi4uZW52T3B0aW9ufSA6IGVudk9wdGlvbjtcblxuXHRpZiAocHJlZmVyTG9jYWwpIHtcblx0XHRyZXR1cm4gbnBtUnVuUGF0aC5lbnYoe2VudiwgY3dkOiBsb2NhbERpciwgZXhlY1BhdGh9KTtcblx0fVxuXG5cdHJldHVybiBlbnY7XG59O1xuXG5jb25zdCBoYW5kbGVBcmd1bWVudHMgPSAoZmlsZSwgYXJncywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHBhcnNlZCA9IGNyb3NzU3Bhd24uX3BhcnNlKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuXHRmaWxlID0gcGFyc2VkLmNvbW1hbmQ7XG5cdGFyZ3MgPSBwYXJzZWQuYXJncztcblx0b3B0aW9ucyA9IHBhcnNlZC5vcHRpb25zO1xuXG5cdG9wdGlvbnMgPSB7XG5cdFx0bWF4QnVmZmVyOiBERUZBVUxUX01BWF9CVUZGRVIsXG5cdFx0YnVmZmVyOiB0cnVlLFxuXHRcdHN0cmlwRmluYWxOZXdsaW5lOiB0cnVlLFxuXHRcdGV4dGVuZEVudjogdHJ1ZSxcblx0XHRwcmVmZXJMb2NhbDogZmFsc2UsXG5cdFx0bG9jYWxEaXI6IG9wdGlvbnMuY3dkIHx8IHByb2Nlc3MuY3dkKCksXG5cdFx0ZXhlY1BhdGg6IHByb2Nlc3MuZXhlY1BhdGgsXG5cdFx0ZW5jb2Rpbmc6ICd1dGY4Jyxcblx0XHRyZWplY3Q6IHRydWUsXG5cdFx0Y2xlYW51cDogdHJ1ZSxcblx0XHRhbGw6IGZhbHNlLFxuXHRcdHdpbmRvd3NIaWRlOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRvcHRpb25zLmVudiA9IGdldEVudihvcHRpb25zKTtcblxuXHRvcHRpb25zLnN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0aW9ucyk7XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgcGF0aC5iYXNlbmFtZShmaWxlLCAnLmV4ZScpID09PSAnY21kJykge1xuXHRcdC8vICMxMTZcblx0XHRhcmdzLnVuc2hpZnQoJy9xJyk7XG5cdH1cblxuXHRyZXR1cm4ge2ZpbGUsIGFyZ3MsIG9wdGlvbnMsIHBhcnNlZH07XG59O1xuXG5jb25zdCBoYW5kbGVPdXRwdXQgPSAob3B0aW9ucywgdmFsdWUsIGVycm9yKSA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG5cdFx0Ly8gV2hlbiBgZXhlY2Euc3luYygpYCBlcnJvcnMsIHdlIG5vcm1hbGl6ZSBpdCB0byAnJyB0byBtaW1pYyBgZXhlY2EoKWBcblx0XHRyZXR1cm4gZXJyb3IgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICcnO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuc3RyaXBGaW5hbE5ld2xpbmUpIHtcblx0XHRyZXR1cm4gc3RyaXBGaW5hbE5ld2xpbmUodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZXhlY2EgPSAoZmlsZSwgYXJncywgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBwYXJzZWQgPSBoYW5kbGVBcmd1bWVudHMoZmlsZSwgYXJncywgb3B0aW9ucyk7XG5cdGNvbnN0IGNvbW1hbmQgPSBqb2luQ29tbWFuZChmaWxlLCBhcmdzKTtcblx0Y29uc3QgZXNjYXBlZENvbW1hbmQgPSBnZXRFc2NhcGVkQ29tbWFuZChmaWxlLCBhcmdzKTtcblxuXHR2YWxpZGF0ZVRpbWVvdXQocGFyc2VkLm9wdGlvbnMpO1xuXG5cdGxldCBzcGF3bmVkO1xuXHR0cnkge1xuXHRcdHNwYXduZWQgPSBjaGlsZFByb2Nlc3Muc3Bhd24ocGFyc2VkLmZpbGUsIHBhcnNlZC5hcmdzLCBwYXJzZWQub3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gRW5zdXJlIHRoZSByZXR1cm5lZCBlcnJvciBpcyBhbHdheXMgYm90aCBhIHByb21pc2UgYW5kIGEgY2hpbGQgcHJvY2Vzc1xuXHRcdGNvbnN0IGR1bW15U3Bhd25lZCA9IG5ldyBjaGlsZFByb2Nlc3MuQ2hpbGRQcm9jZXNzKCk7XG5cdFx0Y29uc3QgZXJyb3JQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKHtcblx0XHRcdGVycm9yLFxuXHRcdFx0c3Rkb3V0OiAnJyxcblx0XHRcdHN0ZGVycjogJycsXG5cdFx0XHRhbGw6ICcnLFxuXHRcdFx0Y29tbWFuZCxcblx0XHRcdGVzY2FwZWRDb21tYW5kLFxuXHRcdFx0cGFyc2VkLFxuXHRcdFx0dGltZWRPdXQ6IGZhbHNlLFxuXHRcdFx0aXNDYW5jZWxlZDogZmFsc2UsXG5cdFx0XHRraWxsZWQ6IGZhbHNlXG5cdFx0fSkpO1xuXHRcdHJldHVybiBtZXJnZVByb21pc2UoZHVtbXlTcGF3bmVkLCBlcnJvclByb21pc2UpO1xuXHR9XG5cblx0Y29uc3Qgc3Bhd25lZFByb21pc2UgPSBnZXRTcGF3bmVkUHJvbWlzZShzcGF3bmVkKTtcblx0Y29uc3QgdGltZWRQcm9taXNlID0gc2V0dXBUaW1lb3V0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLCBzcGF3bmVkUHJvbWlzZSk7XG5cdGNvbnN0IHByb2Nlc3NEb25lID0gc2V0RXhpdEhhbmRsZXIoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHRpbWVkUHJvbWlzZSk7XG5cblx0Y29uc3QgY29udGV4dCA9IHtpc0NhbmNlbGVkOiBmYWxzZX07XG5cblx0c3Bhd25lZC5raWxsID0gc3Bhd25lZEtpbGwuYmluZChudWxsLCBzcGF3bmVkLmtpbGwuYmluZChzcGF3bmVkKSk7XG5cdHNwYXduZWQuY2FuY2VsID0gc3Bhd25lZENhbmNlbC5iaW5kKG51bGwsIHNwYXduZWQsIGNvbnRleHQpO1xuXG5cdGNvbnN0IGhhbmRsZVByb21pc2UgPSBhc3luYyAoKSA9PiB7XG5cdFx0Y29uc3QgW3tlcnJvciwgZXhpdENvZGUsIHNpZ25hbCwgdGltZWRPdXR9LCBzdGRvdXRSZXN1bHQsIHN0ZGVyclJlc3VsdCwgYWxsUmVzdWx0XSA9IGF3YWl0IGdldFNwYXduZWRSZXN1bHQoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHByb2Nlc3NEb25lKTtcblx0XHRjb25zdCBzdGRvdXQgPSBoYW5kbGVPdXRwdXQocGFyc2VkLm9wdGlvbnMsIHN0ZG91dFJlc3VsdCk7XG5cdFx0Y29uc3Qgc3RkZXJyID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCBzdGRlcnJSZXN1bHQpO1xuXHRcdGNvbnN0IGFsbCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgYWxsUmVzdWx0KTtcblxuXHRcdGlmIChlcnJvciB8fCBleGl0Q29kZSAhPT0gMCB8fCBzaWduYWwgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IHJldHVybmVkRXJyb3IgPSBtYWtlRXJyb3Ioe1xuXHRcdFx0XHRlcnJvcixcblx0XHRcdFx0ZXhpdENvZGUsXG5cdFx0XHRcdHNpZ25hbCxcblx0XHRcdFx0c3Rkb3V0LFxuXHRcdFx0XHRzdGRlcnIsXG5cdFx0XHRcdGFsbCxcblx0XHRcdFx0Y29tbWFuZCxcblx0XHRcdFx0ZXNjYXBlZENvbW1hbmQsXG5cdFx0XHRcdHBhcnNlZCxcblx0XHRcdFx0dGltZWRPdXQsXG5cdFx0XHRcdGlzQ2FuY2VsZWQ6IGNvbnRleHQuaXNDYW5jZWxlZCxcblx0XHRcdFx0a2lsbGVkOiBzcGF3bmVkLmtpbGxlZFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghcGFyc2VkLm9wdGlvbnMucmVqZWN0KSB7XG5cdFx0XHRcdHJldHVybiByZXR1cm5lZEVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyByZXR1cm5lZEVycm9yO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRjb21tYW5kLFxuXHRcdFx0ZXNjYXBlZENvbW1hbmQsXG5cdFx0XHRleGl0Q29kZTogMCxcblx0XHRcdHN0ZG91dCxcblx0XHRcdHN0ZGVycixcblx0XHRcdGFsbCxcblx0XHRcdGZhaWxlZDogZmFsc2UsXG5cdFx0XHR0aW1lZE91dDogZmFsc2UsXG5cdFx0XHRpc0NhbmNlbGVkOiBmYWxzZSxcblx0XHRcdGtpbGxlZDogZmFsc2Vcblx0XHR9O1xuXHR9O1xuXG5cdGNvbnN0IGhhbmRsZVByb21pc2VPbmNlID0gb25ldGltZShoYW5kbGVQcm9taXNlKTtcblxuXHRoYW5kbGVJbnB1dChzcGF3bmVkLCBwYXJzZWQub3B0aW9ucy5pbnB1dCk7XG5cblx0c3Bhd25lZC5hbGwgPSBtYWtlQWxsU3RyZWFtKHNwYXduZWQsIHBhcnNlZC5vcHRpb25zKTtcblxuXHRyZXR1cm4gbWVyZ2VQcm9taXNlKHNwYXduZWQsIGhhbmRsZVByb21pc2VPbmNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhlY2E7XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoZmlsZSwgYXJncywgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBwYXJzZWQgPSBoYW5kbGVBcmd1bWVudHMoZmlsZSwgYXJncywgb3B0aW9ucyk7XG5cdGNvbnN0IGNvbW1hbmQgPSBqb2luQ29tbWFuZChmaWxlLCBhcmdzKTtcblx0Y29uc3QgZXNjYXBlZENvbW1hbmQgPSBnZXRFc2NhcGVkQ29tbWFuZChmaWxlLCBhcmdzKTtcblxuXHR2YWxpZGF0ZUlucHV0U3luYyhwYXJzZWQub3B0aW9ucyk7XG5cblx0bGV0IHJlc3VsdDtcblx0dHJ5IHtcblx0XHRyZXN1bHQgPSBjaGlsZFByb2Nlc3Muc3Bhd25TeW5jKHBhcnNlZC5maWxlLCBwYXJzZWQuYXJncywgcGFyc2VkLm9wdGlvbnMpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHRocm93IG1ha2VFcnJvcih7XG5cdFx0XHRlcnJvcixcblx0XHRcdHN0ZG91dDogJycsXG5cdFx0XHRzdGRlcnI6ICcnLFxuXHRcdFx0YWxsOiAnJyxcblx0XHRcdGNvbW1hbmQsXG5cdFx0XHRlc2NhcGVkQ29tbWFuZCxcblx0XHRcdHBhcnNlZCxcblx0XHRcdHRpbWVkT3V0OiBmYWxzZSxcblx0XHRcdGlzQ2FuY2VsZWQ6IGZhbHNlLFxuXHRcdFx0a2lsbGVkOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0Y29uc3Qgc3Rkb3V0ID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCByZXN1bHQuc3Rkb3V0LCByZXN1bHQuZXJyb3IpO1xuXHRjb25zdCBzdGRlcnIgPSBoYW5kbGVPdXRwdXQocGFyc2VkLm9wdGlvbnMsIHJlc3VsdC5zdGRlcnIsIHJlc3VsdC5lcnJvcik7XG5cblx0aWYgKHJlc3VsdC5lcnJvciB8fCByZXN1bHQuc3RhdHVzICE9PSAwIHx8IHJlc3VsdC5zaWduYWwgIT09IG51bGwpIHtcblx0XHRjb25zdCBlcnJvciA9IG1ha2VFcnJvcih7XG5cdFx0XHRzdGRvdXQsXG5cdFx0XHRzdGRlcnIsXG5cdFx0XHRlcnJvcjogcmVzdWx0LmVycm9yLFxuXHRcdFx0c2lnbmFsOiByZXN1bHQuc2lnbmFsLFxuXHRcdFx0ZXhpdENvZGU6IHJlc3VsdC5zdGF0dXMsXG5cdFx0XHRjb21tYW5kLFxuXHRcdFx0ZXNjYXBlZENvbW1hbmQsXG5cdFx0XHRwYXJzZWQsXG5cdFx0XHR0aW1lZE91dDogcmVzdWx0LmVycm9yICYmIHJlc3VsdC5lcnJvci5jb2RlID09PSAnRVRJTUVET1VUJyxcblx0XHRcdGlzQ2FuY2VsZWQ6IGZhbHNlLFxuXHRcdFx0a2lsbGVkOiByZXN1bHQuc2lnbmFsICE9PSBudWxsXG5cdFx0fSk7XG5cblx0XHRpZiAoIXBhcnNlZC5vcHRpb25zLnJlamVjdCkge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjb21tYW5kLFxuXHRcdGVzY2FwZWRDb21tYW5kLFxuXHRcdGV4aXRDb2RlOiAwLFxuXHRcdHN0ZG91dCxcblx0XHRzdGRlcnIsXG5cdFx0ZmFpbGVkOiBmYWxzZSxcblx0XHR0aW1lZE91dDogZmFsc2UsXG5cdFx0aXNDYW5jZWxlZDogZmFsc2UsXG5cdFx0a2lsbGVkOiBmYWxzZVxuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29tbWFuZCA9IChjb21tYW5kLCBvcHRpb25zKSA9PiB7XG5cdGNvbnN0IFtmaWxlLCAuLi5hcmdzXSA9IHBhcnNlQ29tbWFuZChjb21tYW5kKTtcblx0cmV0dXJuIGV4ZWNhKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29tbWFuZFN5bmMgPSAoY29tbWFuZCwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBbZmlsZSwgLi4uYXJnc10gPSBwYXJzZUNvbW1hbmQoY29tbWFuZCk7XG5cdHJldHVybiBleGVjYS5zeW5jKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMubm9kZSA9IChzY3JpcHRQYXRoLCBhcmdzLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKGFyZ3MgJiYgIUFycmF5LmlzQXJyYXkoYXJncykgJiYgdHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnKSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3M7XG5cdFx0YXJncyA9IFtdO1xuXHR9XG5cblx0Y29uc3Qgc3RkaW8gPSBub3JtYWxpemVTdGRpby5ub2RlKG9wdGlvbnMpO1xuXHRjb25zdCBkZWZhdWx0RXhlY0FyZ3YgPSBwcm9jZXNzLmV4ZWNBcmd2LmZpbHRlcihhcmcgPT4gIWFyZy5zdGFydHNXaXRoKCctLWluc3BlY3QnKSk7XG5cblx0Y29uc3Qge1xuXHRcdG5vZGVQYXRoID0gcHJvY2Vzcy5leGVjUGF0aCxcblx0XHRub2RlT3B0aW9ucyA9IGRlZmF1bHRFeGVjQXJndlxuXHR9ID0gb3B0aW9ucztcblxuXHRyZXR1cm4gZXhlY2EoXG5cdFx0bm9kZVBhdGgsXG5cdFx0W1xuXHRcdFx0Li4ubm9kZU9wdGlvbnMsXG5cdFx0XHRzY3JpcHRQYXRoLFxuXHRcdFx0Li4uKEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW10pXG5cdFx0XSxcblx0XHR7XG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0c3RkaW46IHVuZGVmaW5lZCxcblx0XHRcdHN0ZG91dDogdW5kZWZpbmVkLFxuXHRcdFx0c3RkZXJyOiB1bmRlZmluZWQsXG5cdFx0XHRzdGRpbyxcblx0XHRcdHNoZWxsOiBmYWxzZVxuXHRcdH1cblx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBub3JtYWxpemVBcmdzID0gKGZpbGUsIGFyZ3MgPSBbXSkgPT4ge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHtcblx0XHRyZXR1cm4gW2ZpbGVdO1xuXHR9XG5cblx0cmV0dXJuIFtmaWxlLCAuLi5hcmdzXTtcbn07XG5cbmNvbnN0IE5PX0VTQ0FQRV9SRUdFWFAgPSAvXltcXHcuLV0rJC87XG5jb25zdCBET1VCTEVfUVVPVEVTX1JFR0VYUCA9IC9cIi9nO1xuXG5jb25zdCBlc2NhcGVBcmcgPSBhcmcgPT4ge1xuXHRpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgfHwgTk9fRVNDQVBFX1JFR0VYUC50ZXN0KGFyZykpIHtcblx0XHRyZXR1cm4gYXJnO1xuXHR9XG5cblx0cmV0dXJuIGBcIiR7YXJnLnJlcGxhY2UoRE9VQkxFX1FVT1RFU19SRUdFWFAsICdcXFxcXCInKX1cImA7XG59O1xuXG5jb25zdCBqb2luQ29tbWFuZCA9IChmaWxlLCBhcmdzKSA9PiB7XG5cdHJldHVybiBub3JtYWxpemVBcmdzKGZpbGUsIGFyZ3MpLmpvaW4oJyAnKTtcbn07XG5cbmNvbnN0IGdldEVzY2FwZWRDb21tYW5kID0gKGZpbGUsIGFyZ3MpID0+IHtcblx0cmV0dXJuIG5vcm1hbGl6ZUFyZ3MoZmlsZSwgYXJncykubWFwKGFyZyA9PiBlc2NhcGVBcmcoYXJnKSkuam9pbignICcpO1xufTtcblxuY29uc3QgU1BBQ0VTX1JFR0VYUCA9IC8gKy9nO1xuXG4vLyBIYW5kbGUgYGV4ZWNhLmNvbW1hbmQoKWBcbmNvbnN0IHBhcnNlQ29tbWFuZCA9IGNvbW1hbmQgPT4ge1xuXHRjb25zdCB0b2tlbnMgPSBbXTtcblx0Zm9yIChjb25zdCB0b2tlbiBvZiBjb21tYW5kLnRyaW0oKS5zcGxpdChTUEFDRVNfUkVHRVhQKSkge1xuXHRcdC8vIEFsbG93IHNwYWNlcyB0byBiZSBlc2NhcGVkIGJ5IGEgYmFja3NsYXNoIGlmIG5vdCBtZWFudCBhcyBhIGRlbGltaXRlclxuXHRcdGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdGlmIChwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4uZW5kc1dpdGgoJ1xcXFwnKSkge1xuXHRcdFx0Ly8gTWVyZ2UgcHJldmlvdXMgdG9rZW4gd2l0aCBjdXJyZW50IG9uZVxuXHRcdFx0dG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IGAke3ByZXZpb3VzVG9rZW4uc2xpY2UoMCwgLTEpfSAke3Rva2VufWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRva2Vucy5wdXNoKHRva2VuKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG9rZW5zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGpvaW5Db21tYW5kLFxuXHRnZXRFc2NhcGVkQ29tbWFuZCxcblx0cGFyc2VDb21tYW5kXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge3NpZ25hbHNCeU5hbWV9ID0gcmVxdWlyZSgnaHVtYW4tc2lnbmFscycpO1xuXG5jb25zdCBnZXRFcnJvclByZWZpeCA9ICh7dGltZWRPdXQsIHRpbWVvdXQsIGVycm9yQ29kZSwgc2lnbmFsLCBzaWduYWxEZXNjcmlwdGlvbiwgZXhpdENvZGUsIGlzQ2FuY2VsZWR9KSA9PiB7XG5cdGlmICh0aW1lZE91dCkge1xuXHRcdHJldHVybiBgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH0gbWlsbGlzZWNvbmRzYDtcblx0fVxuXG5cdGlmIChpc0NhbmNlbGVkKSB7XG5cdFx0cmV0dXJuICd3YXMgY2FuY2VsZWQnO1xuXHR9XG5cblx0aWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGBmYWlsZWQgd2l0aCAke2Vycm9yQ29kZX1gO1xuXHR9XG5cblx0aWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGB3YXMga2lsbGVkIHdpdGggJHtzaWduYWx9ICgke3NpZ25hbERlc2NyaXB0aW9ufSlgO1xuXHR9XG5cblx0aWYgKGV4aXRDb2RlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gYGZhaWxlZCB3aXRoIGV4aXQgY29kZSAke2V4aXRDb2RlfWA7XG5cdH1cblxuXHRyZXR1cm4gJ2ZhaWxlZCc7XG59O1xuXG5jb25zdCBtYWtlRXJyb3IgPSAoe1xuXHRzdGRvdXQsXG5cdHN0ZGVycixcblx0YWxsLFxuXHRlcnJvcixcblx0c2lnbmFsLFxuXHRleGl0Q29kZSxcblx0Y29tbWFuZCxcblx0ZXNjYXBlZENvbW1hbmQsXG5cdHRpbWVkT3V0LFxuXHRpc0NhbmNlbGVkLFxuXHRraWxsZWQsXG5cdHBhcnNlZDoge29wdGlvbnM6IHt0aW1lb3V0fX1cbn0pID0+IHtcblx0Ly8gYHNpZ25hbGAgYW5kIGBleGl0Q29kZWAgZW1pdHRlZCBvbiBgc3Bhd25lZC5vbignZXhpdCcpYCBldmVudCBjYW4gYmUgYG51bGxgLlxuXHQvLyBXZSBub3JtYWxpemUgdGhlbSB0byBgdW5kZWZpbmVkYFxuXHRleGl0Q29kZSA9IGV4aXRDb2RlID09PSBudWxsID8gdW5kZWZpbmVkIDogZXhpdENvZGU7XG5cdHNpZ25hbCA9IHNpZ25hbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHNpZ25hbDtcblx0Y29uc3Qgc2lnbmFsRGVzY3JpcHRpb24gPSBzaWduYWwgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNpZ25hbHNCeU5hbWVbc2lnbmFsXS5kZXNjcmlwdGlvbjtcblxuXHRjb25zdCBlcnJvckNvZGUgPSBlcnJvciAmJiBlcnJvci5jb2RlO1xuXG5cdGNvbnN0IHByZWZpeCA9IGdldEVycm9yUHJlZml4KHt0aW1lZE91dCwgdGltZW91dCwgZXJyb3JDb2RlLCBzaWduYWwsIHNpZ25hbERlc2NyaXB0aW9uLCBleGl0Q29kZSwgaXNDYW5jZWxlZH0pO1xuXHRjb25zdCBleGVjYU1lc3NhZ2UgPSBgQ29tbWFuZCAke3ByZWZpeH06ICR7Y29tbWFuZH1gO1xuXHRjb25zdCBpc0Vycm9yID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycm9yKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcblx0Y29uc3Qgc2hvcnRNZXNzYWdlID0gaXNFcnJvciA/IGAke2V4ZWNhTWVzc2FnZX1cXG4ke2Vycm9yLm1lc3NhZ2V9YCA6IGV4ZWNhTWVzc2FnZTtcblx0Y29uc3QgbWVzc2FnZSA9IFtzaG9ydE1lc3NhZ2UsIHN0ZGVyciwgc3Rkb3V0XS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cblx0aWYgKGlzRXJyb3IpIHtcblx0XHRlcnJvci5vcmlnaW5hbE1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuXHRcdGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHR9IGVsc2Uge1xuXHRcdGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG5cblx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuXHRlcnJvci5jb21tYW5kID0gY29tbWFuZDtcblx0ZXJyb3IuZXNjYXBlZENvbW1hbmQgPSBlc2NhcGVkQ29tbWFuZDtcblx0ZXJyb3IuZXhpdENvZGUgPSBleGl0Q29kZTtcblx0ZXJyb3Iuc2lnbmFsID0gc2lnbmFsO1xuXHRlcnJvci5zaWduYWxEZXNjcmlwdGlvbiA9IHNpZ25hbERlc2NyaXB0aW9uO1xuXHRlcnJvci5zdGRvdXQgPSBzdGRvdXQ7XG5cdGVycm9yLnN0ZGVyciA9IHN0ZGVycjtcblxuXHRpZiAoYWxsICE9PSB1bmRlZmluZWQpIHtcblx0XHRlcnJvci5hbGwgPSBhbGw7XG5cdH1cblxuXHRpZiAoJ2J1ZmZlcmVkRGF0YScgaW4gZXJyb3IpIHtcblx0XHRkZWxldGUgZXJyb3IuYnVmZmVyZWREYXRhO1xuXHR9XG5cblx0ZXJyb3IuZmFpbGVkID0gdHJ1ZTtcblx0ZXJyb3IudGltZWRPdXQgPSBCb29sZWFuKHRpbWVkT3V0KTtcblx0ZXJyb3IuaXNDYW5jZWxlZCA9IGlzQ2FuY2VsZWQ7XG5cdGVycm9yLmtpbGxlZCA9IGtpbGxlZCAmJiAhdGltZWRPdXQ7XG5cblx0cmV0dXJuIGVycm9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdzaWduYWwtZXhpdCcpO1xuXG5jb25zdCBERUZBVUxUX0ZPUkNFX0tJTExfVElNRU9VVCA9IDEwMDAgKiA1O1xuXG4vLyBNb25rZXktcGF0Y2hlcyBgY2hpbGRQcm9jZXNzLmtpbGwoKWAgdG8gYWRkIGBmb3JjZUtpbGxBZnRlclRpbWVvdXRgIGJlaGF2aW9yXG5jb25zdCBzcGF3bmVkS2lsbCA9IChraWxsLCBzaWduYWwgPSAnU0lHVEVSTScsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCBraWxsUmVzdWx0ID0ga2lsbChzaWduYWwpO1xuXHRzZXRLaWxsVGltZW91dChraWxsLCBzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpO1xuXHRyZXR1cm4ga2lsbFJlc3VsdDtcbn07XG5cbmNvbnN0IHNldEtpbGxUaW1lb3V0ID0gKGtpbGwsIHNpZ25hbCwgb3B0aW9ucywga2lsbFJlc3VsdCkgPT4ge1xuXHRpZiAoIXNob3VsZEZvcmNlS2lsbChzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdGltZW91dCA9IGdldEZvcmNlS2lsbEFmdGVyVGltZW91dChvcHRpb25zKTtcblx0Y29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdGtpbGwoJ1NJR0tJTEwnKTtcblx0fSwgdGltZW91dCk7XG5cblx0Ly8gR3VhcmRlZCBiZWNhdXNlIHRoZXJlJ3Mgbm8gYC51bnJlZigpYCB3aGVuIGBleGVjYWAgaXMgdXNlZCBpbiB0aGUgcmVuZGVyZXJcblx0Ly8gcHJvY2VzcyBpbiBFbGVjdHJvbi4gVGhpcyBjYW5ub3QgYmUgdGVzdGVkIHNpbmNlIHdlIGRvbid0IHJ1biB0ZXN0cyBpblxuXHQvLyBFbGVjdHJvbi5cblx0Ly8gaXN0YW5idWwgaWdub3JlIGVsc2Vcblx0aWYgKHQudW5yZWYpIHtcblx0XHR0LnVucmVmKCk7XG5cdH1cbn07XG5cbmNvbnN0IHNob3VsZEZvcmNlS2lsbCA9IChzaWduYWwsIHtmb3JjZUtpbGxBZnRlclRpbWVvdXR9LCBraWxsUmVzdWx0KSA9PiB7XG5cdHJldHVybiBpc1NpZ3Rlcm0oc2lnbmFsKSAmJiBmb3JjZUtpbGxBZnRlclRpbWVvdXQgIT09IGZhbHNlICYmIGtpbGxSZXN1bHQ7XG59O1xuXG5jb25zdCBpc1NpZ3Rlcm0gPSBzaWduYWwgPT4ge1xuXHRyZXR1cm4gc2lnbmFsID09PSBvcy5jb25zdGFudHMuc2lnbmFscy5TSUdURVJNIHx8XG5cdFx0KHR5cGVvZiBzaWduYWwgPT09ICdzdHJpbmcnICYmIHNpZ25hbC50b1VwcGVyQ2FzZSgpID09PSAnU0lHVEVSTScpO1xufTtcblxuY29uc3QgZ2V0Rm9yY2VLaWxsQWZ0ZXJUaW1lb3V0ID0gKHtmb3JjZUtpbGxBZnRlclRpbWVvdXQgPSB0cnVlfSkgPT4ge1xuXHRpZiAoZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0ID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIERFRkFVTFRfRk9SQ0VfS0lMTF9USU1FT1VUO1xuXHR9XG5cblx0aWYgKCFOdW1iZXIuaXNGaW5pdGUoZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0KSB8fCBmb3JjZUtpbGxBZnRlclRpbWVvdXQgPCAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIFxcYGZvcmNlS2lsbEFmdGVyVGltZW91dFxcYCBvcHRpb24gdG8gYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290IFxcYCR7Zm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fVxcYCAoJHt0eXBlb2YgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fSlgKTtcblx0fVxuXG5cdHJldHVybiBmb3JjZUtpbGxBZnRlclRpbWVvdXQ7XG59O1xuXG4vLyBgY2hpbGRQcm9jZXNzLmNhbmNlbCgpYFxuY29uc3Qgc3Bhd25lZENhbmNlbCA9IChzcGF3bmVkLCBjb250ZXh0KSA9PiB7XG5cdGNvbnN0IGtpbGxSZXN1bHQgPSBzcGF3bmVkLmtpbGwoKTtcblxuXHRpZiAoa2lsbFJlc3VsdCkge1xuXHRcdGNvbnRleHQuaXNDYW5jZWxlZCA9IHRydWU7XG5cdH1cbn07XG5cbmNvbnN0IHRpbWVvdXRLaWxsID0gKHNwYXduZWQsIHNpZ25hbCwgcmVqZWN0KSA9PiB7XG5cdHNwYXduZWQua2lsbChzaWduYWwpO1xuXHRyZWplY3QoT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1RpbWVkIG91dCcpLCB7dGltZWRPdXQ6IHRydWUsIHNpZ25hbH0pKTtcbn07XG5cbi8vIGB0aW1lb3V0YCBvcHRpb24gaGFuZGxpbmdcbmNvbnN0IHNldHVwVGltZW91dCA9IChzcGF3bmVkLCB7dGltZW91dCwga2lsbFNpZ25hbCA9ICdTSUdURVJNJ30sIHNwYXduZWRQcm9taXNlKSA9PiB7XG5cdGlmICh0aW1lb3V0ID09PSAwIHx8IHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBzcGF3bmVkUHJvbWlzZTtcblx0fVxuXG5cdGxldCB0aW1lb3V0SWQ7XG5cdGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGltZW91dEtpbGwoc3Bhd25lZCwga2lsbFNpZ25hbCwgcmVqZWN0KTtcblx0XHR9LCB0aW1lb3V0KTtcblx0fSk7XG5cblx0Y29uc3Qgc2FmZVNwYXduZWRQcm9taXNlID0gc3Bhd25lZFByb21pc2UuZmluYWxseSgoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBzYWZlU3Bhd25lZFByb21pc2VdKTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlVGltZW91dCA9ICh7dGltZW91dH0pID0+IHtcblx0aWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCAmJiAoIU51bWJlci5pc0Zpbml0ZSh0aW1lb3V0KSB8fCB0aW1lb3V0IDwgMCkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgXFxgdGltZW91dFxcYCBvcHRpb24gdG8gYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290IFxcYCR7dGltZW91dH1cXGAgKCR7dHlwZW9mIHRpbWVvdXR9KWApO1xuXHR9XG59O1xuXG4vLyBgY2xlYW51cGAgb3B0aW9uIGhhbmRsaW5nXG5jb25zdCBzZXRFeGl0SGFuZGxlciA9IGFzeW5jIChzcGF3bmVkLCB7Y2xlYW51cCwgZGV0YWNoZWR9LCB0aW1lZFByb21pc2UpID0+IHtcblx0aWYgKCFjbGVhbnVwIHx8IGRldGFjaGVkKSB7XG5cdFx0cmV0dXJuIHRpbWVkUHJvbWlzZTtcblx0fVxuXG5cdGNvbnN0IHJlbW92ZUV4aXRIYW5kbGVyID0gb25FeGl0KCgpID0+IHtcblx0XHRzcGF3bmVkLmtpbGwoKTtcblx0fSk7XG5cblx0cmV0dXJuIHRpbWVkUHJvbWlzZS5maW5hbGx5KCgpID0+IHtcblx0XHRyZW1vdmVFeGl0SGFuZGxlcigpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzcGF3bmVkS2lsbCxcblx0c3Bhd25lZENhbmNlbCxcblx0c2V0dXBUaW1lb3V0LFxuXHR2YWxpZGF0ZVRpbWVvdXQsXG5cdHNldEV4aXRIYW5kbGVyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuYXRpdmVQcm9taXNlUHJvdG90eXBlID0gKGFzeW5jICgpID0+IHt9KSgpLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0gWyd0aGVuJywgJ2NhdGNoJywgJ2ZpbmFsbHknXS5tYXAocHJvcGVydHkgPT4gW1xuXHRwcm9wZXJ0eSxcblx0UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgcHJvcGVydHkpXG5dKTtcblxuLy8gVGhlIHJldHVybiB2YWx1ZSBpcyBhIG1peGluIG9mIGBjaGlsZFByb2Nlc3NgIGFuZCBgUHJvbWlzZWBcbmNvbnN0IG1lcmdlUHJvbWlzZSA9IChzcGF3bmVkLCBwcm9taXNlKSA9PiB7XG5cdGZvciAoY29uc3QgW3Byb3BlcnR5LCBkZXNjcmlwdG9yXSBvZiBkZXNjcmlwdG9ycykge1xuXHRcdC8vIFN0YXJ0aW5nIHRoZSBtYWluIGBwcm9taXNlYCBpcyBkZWZlcnJlZCB0byBhdm9pZCBjb25zdW1pbmcgc3RyZWFtc1xuXHRcdGNvbnN0IHZhbHVlID0gdHlwZW9mIHByb21pc2UgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0KC4uLmFyZ3MpID0+IFJlZmxlY3QuYXBwbHkoZGVzY3JpcHRvci52YWx1ZSwgcHJvbWlzZSgpLCBhcmdzKSA6XG5cdFx0XHRkZXNjcmlwdG9yLnZhbHVlLmJpbmQocHJvbWlzZSk7XG5cblx0XHRSZWZsZWN0LmRlZmluZVByb3BlcnR5KHNwYXduZWQsIHByb3BlcnR5LCB7Li4uZGVzY3JpcHRvciwgdmFsdWV9KTtcblx0fVxuXG5cdHJldHVybiBzcGF3bmVkO1xufTtcblxuLy8gVXNlIHByb21pc2VzIGluc3RlYWQgb2YgYGNoaWxkX3Byb2Nlc3NgIGV2ZW50c1xuY29uc3QgZ2V0U3Bhd25lZFByb21pc2UgPSBzcGF3bmVkID0+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRzcGF3bmVkLm9uKCdleGl0JywgKGV4aXRDb2RlLCBzaWduYWwpID0+IHtcblx0XHRcdHJlc29sdmUoe2V4aXRDb2RlLCBzaWduYWx9KTtcblx0XHR9KTtcblxuXHRcdHNwYXduZWQub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHR9KTtcblxuXHRcdGlmIChzcGF3bmVkLnN0ZGluKSB7XG5cdFx0XHRzcGF3bmVkLnN0ZGluLm9uKCdlcnJvcicsIGVycm9yID0+IHtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bWVyZ2VQcm9taXNlLFxuXHRnZXRTcGF3bmVkUHJvbWlzZVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYWxpYXNlcyA9IFsnc3RkaW4nLCAnc3Rkb3V0JywgJ3N0ZGVyciddO1xuXG5jb25zdCBoYXNBbGlhcyA9IG9wdGlvbnMgPT4gYWxpYXNlcy5zb21lKGFsaWFzID0+IG9wdGlvbnNbYWxpYXNdICE9PSB1bmRlZmluZWQpO1xuXG5jb25zdCBub3JtYWxpemVTdGRpbyA9IG9wdGlvbnMgPT4ge1xuXHRpZiAoIW9wdGlvbnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB7c3RkaW99ID0gb3B0aW9ucztcblxuXHRpZiAoc3RkaW8gPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBhbGlhc2VzLm1hcChhbGlhcyA9PiBvcHRpb25zW2FsaWFzXSk7XG5cdH1cblxuXHRpZiAoaGFzQWxpYXMob3B0aW9ucykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEl0J3Mgbm90IHBvc3NpYmxlIHRvIHByb3ZpZGUgXFxgc3RkaW9cXGAgaW4gY29tYmluYXRpb24gd2l0aCBvbmUgb2YgJHthbGlhc2VzLm1hcChhbGlhcyA9PiBgXFxgJHthbGlhc31cXGBgKS5qb2luKCcsICcpfWApO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBzdGRpbyA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gc3RkaW87XG5cdH1cblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoc3RkaW8pKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RkaW9cXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgQXJyYXlcXGAsIGdvdCBcXGAke3R5cGVvZiBzdGRpb31cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KHN0ZGlvLmxlbmd0aCwgYWxpYXNlcy5sZW5ndGgpO1xuXHRyZXR1cm4gQXJyYXkuZnJvbSh7bGVuZ3RofSwgKHZhbHVlLCBpbmRleCkgPT4gc3RkaW9baW5kZXhdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplU3RkaW87XG5cbi8vIGBpcGNgIGlzIHB1c2hlZCB1bmxlc3MgaXQgaXMgYWxyZWFkeSBwcmVzZW50XG5tb2R1bGUuZXhwb3J0cy5ub2RlID0gb3B0aW9ucyA9PiB7XG5cdGNvbnN0IHN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0aW9ucyk7XG5cblx0aWYgKHN0ZGlvID09PSAnaXBjJykge1xuXHRcdHJldHVybiAnaXBjJztcblx0fVxuXG5cdGlmIChzdGRpbyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzdGRpbyA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gW3N0ZGlvLCBzdGRpbywgc3RkaW8sICdpcGMnXTtcblx0fVxuXG5cdGlmIChzdGRpby5pbmNsdWRlcygnaXBjJykpIHtcblx0XHRyZXR1cm4gc3RkaW87XG5cdH1cblxuXHRyZXR1cm4gWy4uLnN0ZGlvLCAnaXBjJ107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbmNvbnN0IGdldFN0cmVhbSA9IHJlcXVpcmUoJ2dldC1zdHJlYW0nKTtcbmNvbnN0IG1lcmdlU3RyZWFtID0gcmVxdWlyZSgnbWVyZ2Utc3RyZWFtJyk7XG5cbi8vIGBpbnB1dGAgb3B0aW9uXG5jb25zdCBoYW5kbGVJbnB1dCA9IChzcGF3bmVkLCBpbnB1dCkgPT4ge1xuXHQvLyBDaGVja2luZyBmb3Igc3RkaW4gaXMgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yNjg1MlxuXHQvLyBAdG9kbyByZW1vdmUgYHx8IHNwYXduZWQuc3RkaW4gPT09IHVuZGVmaW5lZGAgb25jZSB3ZSBkcm9wIHN1cHBvcnQgZm9yIE5vZGUuanMgPD0xMi4yLjBcblx0aWYgKGlucHV0ID09PSB1bmRlZmluZWQgfHwgc3Bhd25lZC5zdGRpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGlzU3RyZWFtKGlucHV0KSkge1xuXHRcdGlucHV0LnBpcGUoc3Bhd25lZC5zdGRpbik7XG5cdH0gZWxzZSB7XG5cdFx0c3Bhd25lZC5zdGRpbi5lbmQoaW5wdXQpO1xuXHR9XG59O1xuXG4vLyBgYWxsYCBpbnRlcmxlYXZlcyBgc3Rkb3V0YCBhbmQgYHN0ZGVycmBcbmNvbnN0IG1ha2VBbGxTdHJlYW0gPSAoc3Bhd25lZCwge2FsbH0pID0+IHtcblx0aWYgKCFhbGwgfHwgKCFzcGF3bmVkLnN0ZG91dCAmJiAhc3Bhd25lZC5zdGRlcnIpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgbWl4ZWQgPSBtZXJnZVN0cmVhbSgpO1xuXG5cdGlmIChzcGF3bmVkLnN0ZG91dCkge1xuXHRcdG1peGVkLmFkZChzcGF3bmVkLnN0ZG91dCk7XG5cdH1cblxuXHRpZiAoc3Bhd25lZC5zdGRlcnIpIHtcblx0XHRtaXhlZC5hZGQoc3Bhd25lZC5zdGRlcnIpO1xuXHR9XG5cblx0cmV0dXJuIG1peGVkO1xufTtcblxuLy8gT24gZmFpbHVyZSwgYHJlc3VsdC5zdGRvdXR8c3RkZXJyfGFsbGAgc2hvdWxkIGNvbnRhaW4gdGhlIGN1cnJlbnRseSBidWZmZXJlZCBzdHJlYW1cbmNvbnN0IGdldEJ1ZmZlcmVkRGF0YSA9IGFzeW5jIChzdHJlYW0sIHN0cmVhbVByb21pc2UpID0+IHtcblx0aWYgKCFzdHJlYW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzdHJlYW0uZGVzdHJveSgpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGF3YWl0IHN0cmVhbVByb21pc2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIGVycm9yLmJ1ZmZlcmVkRGF0YTtcblx0fVxufTtcblxuY29uc3QgZ2V0U3RyZWFtUHJvbWlzZSA9IChzdHJlYW0sIHtlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXJ9KSA9PiB7XG5cdGlmICghc3RyZWFtIHx8ICFidWZmZXIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoZW5jb2RpbmcpIHtcblx0XHRyZXR1cm4gZ2V0U3RyZWFtKHN0cmVhbSwge2VuY29kaW5nLCBtYXhCdWZmZXJ9KTtcblx0fVxuXG5cdHJldHVybiBnZXRTdHJlYW0uYnVmZmVyKHN0cmVhbSwge21heEJ1ZmZlcn0pO1xufTtcblxuLy8gUmV0cmlldmUgcmVzdWx0IG9mIGNoaWxkIHByb2Nlc3M6IGV4aXQgY29kZSwgc2lnbmFsLCBlcnJvciwgc3RyZWFtcyAoc3Rkb3V0L3N0ZGVyci9hbGwpXG5jb25zdCBnZXRTcGF3bmVkUmVzdWx0ID0gYXN5bmMgKHtzdGRvdXQsIHN0ZGVyciwgYWxsfSwge2VuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcn0sIHByb2Nlc3NEb25lKSA9PiB7XG5cdGNvbnN0IHN0ZG91dFByb21pc2UgPSBnZXRTdHJlYW1Qcm9taXNlKHN0ZG91dCwge2VuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcn0pO1xuXHRjb25zdCBzdGRlcnJQcm9taXNlID0gZ2V0U3RyZWFtUHJvbWlzZShzdGRlcnIsIHtlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXJ9KTtcblx0Y29uc3QgYWxsUHJvbWlzZSA9IGdldFN0cmVhbVByb21pc2UoYWxsLCB7ZW5jb2RpbmcsIGJ1ZmZlciwgbWF4QnVmZmVyOiBtYXhCdWZmZXIgKiAyfSk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoW3Byb2Nlc3NEb25lLCBzdGRvdXRQcm9taXNlLCBzdGRlcnJQcm9taXNlLCBhbGxQcm9taXNlXSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFtcblx0XHRcdHtlcnJvciwgc2lnbmFsOiBlcnJvci5zaWduYWwsIHRpbWVkT3V0OiBlcnJvci50aW1lZE91dH0sXG5cdFx0XHRnZXRCdWZmZXJlZERhdGEoc3Rkb3V0LCBzdGRvdXRQcm9taXNlKSxcblx0XHRcdGdldEJ1ZmZlcmVkRGF0YShzdGRlcnIsIHN0ZGVyclByb21pc2UpLFxuXHRcdFx0Z2V0QnVmZmVyZWREYXRhKGFsbCwgYWxsUHJvbWlzZSlcblx0XHRdKTtcblx0fVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dFN5bmMgPSAoe2lucHV0fSkgPT4ge1xuXHRpZiAoaXNTdHJlYW0oaW5wdXQpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBpbnB1dGAgb3B0aW9uIGNhbm5vdCBiZSBhIHN0cmVhbSBpbiBzeW5jIG1vZGUnKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGhhbmRsZUlucHV0LFxuXHRtYWtlQWxsU3RyZWFtLFxuXHRnZXRTcGF3bmVkUmVzdWx0LFxuXHR2YWxpZGF0ZUlucHV0U3luY1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge1Bhc3NUaHJvdWdoOiBQYXNzVGhyb3VnaFN0cmVhbX0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvcHRpb25zID0+IHtcblx0b3B0aW9ucyA9IHsuLi5vcHRpb25zfTtcblxuXHRjb25zdCB7YXJyYXl9ID0gb3B0aW9ucztcblx0bGV0IHtlbmNvZGluZ30gPSBvcHRpb25zO1xuXHRjb25zdCBpc0J1ZmZlciA9IGVuY29kaW5nID09PSAnYnVmZmVyJztcblx0bGV0IG9iamVjdE1vZGUgPSBmYWxzZTtcblxuXHRpZiAoYXJyYXkpIHtcblx0XHRvYmplY3RNb2RlID0gIShlbmNvZGluZyB8fCBpc0J1ZmZlcik7XG5cdH0gZWxzZSB7XG5cdFx0ZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cdH1cblxuXHRpZiAoaXNCdWZmZXIpIHtcblx0XHRlbmNvZGluZyA9IG51bGw7XG5cdH1cblxuXHRjb25zdCBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2hTdHJlYW0oe29iamVjdE1vZGV9KTtcblxuXHRpZiAoZW5jb2RpbmcpIHtcblx0XHRzdHJlYW0uc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuXHR9XG5cblx0bGV0IGxlbmd0aCA9IDA7XG5cdGNvbnN0IGNodW5rcyA9IFtdO1xuXG5cdHN0cmVhbS5vbignZGF0YScsIGNodW5rID0+IHtcblx0XHRjaHVua3MucHVzaChjaHVuayk7XG5cblx0XHRpZiAob2JqZWN0TW9kZSkge1xuXHRcdFx0bGVuZ3RoID0gY2h1bmtzLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcblx0XHR9XG5cdH0pO1xuXG5cdHN0cmVhbS5nZXRCdWZmZXJlZFZhbHVlID0gKCkgPT4ge1xuXHRcdGlmIChhcnJheSkge1xuXHRcdFx0cmV0dXJuIGNodW5rcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXNCdWZmZXIgPyBCdWZmZXIuY29uY2F0KGNodW5rcywgbGVuZ3RoKSA6IGNodW5rcy5qb2luKCcnKTtcblx0fTtcblxuXHRzdHJlYW0uZ2V0QnVmZmVyZWRMZW5ndGggPSAoKSA9PiBsZW5ndGg7XG5cblx0cmV0dXJuIHN0cmVhbTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7Y29uc3RhbnRzOiBCdWZmZXJDb25zdGFudHN9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHtwcm9taXNpZnl9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgYnVmZmVyU3RyZWFtID0gcmVxdWlyZSgnLi9idWZmZXItc3RyZWFtJyk7XG5cbmNvbnN0IHN0cmVhbVBpcGVsaW5lUHJvbWlzaWZpZWQgPSBwcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcblxuY2xhc3MgTWF4QnVmZmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCdtYXhCdWZmZXIgZXhjZWVkZWQnKTtcblx0XHR0aGlzLm5hbWUgPSAnTWF4QnVmZmVyRXJyb3InO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0cmVhbShpbnB1dFN0cmVhbSwgb3B0aW9ucykge1xuXHRpZiAoIWlucHV0U3RyZWFtKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmVhbScpO1xuXHR9XG5cblx0b3B0aW9ucyA9IHtcblx0XHRtYXhCdWZmZXI6IEluZmluaXR5LFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRjb25zdCB7bWF4QnVmZmVyfSA9IG9wdGlvbnM7XG5cdGNvbnN0IHN0cmVhbSA9IGJ1ZmZlclN0cmVhbShvcHRpb25zKTtcblxuXHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgcmVqZWN0UHJvbWlzZSA9IGVycm9yID0+IHtcblx0XHRcdC8vIERvbid0IHJldHJpZXZlIGFuIG92ZXJzaXplZCBidWZmZXIuXG5cdFx0XHRpZiAoZXJyb3IgJiYgc3RyZWFtLmdldEJ1ZmZlcmVkTGVuZ3RoKCkgPD0gQnVmZmVyQ29uc3RhbnRzLk1BWF9MRU5HVEgpIHtcblx0XHRcdFx0ZXJyb3IuYnVmZmVyZWREYXRhID0gc3RyZWFtLmdldEJ1ZmZlcmVkVmFsdWUoKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHR9O1xuXG5cdFx0KGFzeW5jICgpID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHN0cmVhbVBpcGVsaW5lUHJvbWlzaWZpZWQoaW5wdXRTdHJlYW0sIHN0cmVhbSk7XG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHJlamVjdFByb21pc2UoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pKCk7XG5cblx0XHRzdHJlYW0ub24oJ2RhdGEnLCAoKSA9PiB7XG5cdFx0XHRpZiAoc3RyZWFtLmdldEJ1ZmZlcmVkTGVuZ3RoKCkgPiBtYXhCdWZmZXIpIHtcblx0XHRcdFx0cmVqZWN0UHJvbWlzZShuZXcgTWF4QnVmZmVyRXJyb3IoKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHJlYW0uZ2V0QnVmZmVyZWRWYWx1ZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN0cmVhbTtcbm1vZHVsZS5leHBvcnRzLmJ1ZmZlciA9IChzdHJlYW0sIG9wdGlvbnMpID0+IGdldFN0cmVhbShzdHJlYW0sIHsuLi5vcHRpb25zLCBlbmNvZGluZzogJ2J1ZmZlcid9KTtcbm1vZHVsZS5leHBvcnRzLmFycmF5ID0gKHN0cmVhbSwgb3B0aW9ucykgPT4gZ2V0U3RyZWFtKHN0cmVhbSwgey4uLm9wdGlvbnMsIGFycmF5OiB0cnVlfSk7XG5tb2R1bGUuZXhwb3J0cy5NYXhCdWZmZXJFcnJvciA9IE1heEJ1ZmZlckVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB2YWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgWE1MUGFyc2VyID0gcmVxdWlyZSgnLi94bWxwYXJzZXIvWE1MUGFyc2VyJyk7XG5jb25zdCBYTUxCdWlsZGVyID0gcmVxdWlyZSgnLi94bWxidWlsZGVyL2pzb24yeG1sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBYTUxQYXJzZXI6IFhNTFBhcnNlcixcbiAgWE1MVmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gIFhNTEJ1aWxkZXI6IFhNTEJ1aWxkZXJcbn0iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5hbWVTdGFydENoYXIgPSAnOkEtWmEtel9cXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG5jb25zdCBuYW1lQ2hhciA9IG5hbWVTdGFydENoYXIgKyAnXFxcXC0uXFxcXGRcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5jb25zdCBuYW1lUmVnZXhwID0gJ1snICsgbmFtZVN0YXJ0Q2hhciArICddWycgKyBuYW1lQ2hhciArICddKidcbmNvbnN0IHJlZ2V4TmFtZSA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZVJlZ2V4cCArICckJyk7XG5cbmNvbnN0IGdldEFsbE1hdGNoZXMgPSBmdW5jdGlvbihzdHJpbmcsIHJlZ2V4KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICB3aGlsZSAobWF0Y2gpIHtcbiAgICBjb25zdCBhbGxtYXRjaGVzID0gW107XG4gICAgYWxsbWF0Y2hlcy5zdGFydEluZGV4ID0gcmVnZXgubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IG1hdGNoLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBhbGxtYXRjaGVzLnB1c2gobWF0Y2hbaW5kZXhdKTtcbiAgICB9XG4gICAgbWF0Y2hlcy5wdXNoKGFsbG1hdGNoZXMpO1xuICAgIG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxuY29uc3QgaXNOYW1lID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoID0gcmVnZXhOYW1lLmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuICEobWF0Y2ggPT09IG51bGwgfHwgdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJyk7XG59O1xuXG5leHBvcnRzLmlzRXhpc3QgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5leHBvcnRzLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBDb3B5IGFsbCB0aGUgcHJvcGVydGllcyBvZiBhIGludG8gYi5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IGFcbiAqL1xuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKHRhcmdldCwgYSwgYXJyYXlNb2RlKSB7XG4gIGlmIChhKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpOyAvLyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBvd24gcHJvcGVydGllc1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFycmF5TW9kZSA9PT0gJ3N0cmljdCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleXNbaV1dID0gWyBhW2tleXNbaV1dIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBhW2tleXNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qIGV4cG9ydHMubWVyZ2UgPWZ1bmN0aW9uIChiLGEpe1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihiLGEpO1xufSAqL1xuXG5leHBvcnRzLmdldFZhbHVlID0gZnVuY3Rpb24odikge1xuICBpZiAoZXhwb3J0cy5pc0V4aXN0KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vLyBjb25zdCBmYWtlQ2FsbCA9IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYTt9O1xuLy8gY29uc3QgZmFrZUNhbGxOb1JldHVybiA9IGZ1bmN0aW9uKCkge307XG5cbmV4cG9ydHMuaXNOYW1lID0gaXNOYW1lO1xuZXhwb3J0cy5nZXRBbGxNYXRjaGVzID0gZ2V0QWxsTWF0Y2hlcztcbmV4cG9ydHMubmFtZVJlZ2V4cCA9IG5hbWVSZWdleHA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsbG93Qm9vbGVhbkF0dHJpYnV0ZXM6IGZhbHNlLCAvL0EgdGFnIGNhbiBoYXZlIGF0dHJpYnV0ZXMgd2l0aG91dCBhbnkgdmFsdWVcbiAgdW5wYWlyZWRUYWdzOiBbXVxufTtcblxuLy9jb25zdCB0YWdzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCI8XFxcXC8/KFtcXFxcdzpcXFxcLV9cXC5dKylcXFxccypcXC8/PlwiLFwiZ1wiKTtcbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoeG1sRGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSxcIlwiKTsvL21ha2UgaXQgc2luZ2xlIGxpbmVcbiAgLy94bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC8oXlxccyo8XFw/eG1sLio/XFw/PikvZyxcIlwiKTsvL1JlbW92ZSBYTUwgc3RhcnRpbmcgdGFnXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKDwhRE9DVFlQRVtcXHNcXHdcXFwiXFwuXFwvXFwtXFw6XSsoXFxbLipcXF0pKlxccyo+KS9nLFwiXCIpOy8vUmVtb3ZlIERPQ1RZUEVcbiAgY29uc3QgdGFncyA9IFtdO1xuICBsZXQgdGFnRm91bmQgPSBmYWxzZTtcblxuICAvL2luZGljYXRlcyB0aGF0IHRoZSByb290IHRhZyBoYXMgYmVlbiBjbG9zZWQgKGFrYS4gZGVwdGggMCBoYXMgYmVlbiByZWFjaGVkKVxuICBsZXQgcmVhY2hlZFJvb3QgPSBmYWxzZTtcblxuICBpZiAoeG1sRGF0YVswXSA9PT0gJ1xcdWZlZmYnKSB7XG4gICAgLy8gY2hlY2sgZm9yIGJ5dGUgb3JkZXIgbWFyayAoQk9NKVxuICAgIHhtbERhdGEgPSB4bWxEYXRhLnN1YnN0cigxKTtcbiAgfVxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmIHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG4gICAgICBpKz0yO1xuICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLGkpO1xuICAgICAgaWYgKGkuZXJyKSByZXR1cm4gaTtcbiAgICB9ZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAvL3N0YXJ0aW5nIG9mIHRhZ1xuICAgICAgLy9yZWFkIHVudGlsIHlvdSByZWFjaCB0byAnPicgYXZvaWRpbmcgYW55ICc+JyBpbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIGxldCB0YWdTdGFydFBvcyA9IGk7XG4gICAgICBpKys7XG4gICAgICBcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnIScpIHtcbiAgICAgICAgaSA9IHJlYWRDb21tZW50QW5kQ0RBVEEoeG1sRGF0YSwgaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsb3NpbmdUYWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICcvJykge1xuICAgICAgICAgIC8vY2xvc2luZyB0YWdcbiAgICAgICAgICBjbG9zaW5nVGFnID0gdHJ1ZTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWFkIHRhZ25hbWVcbiAgICAgICAgbGV0IHRhZ05hbWUgPSAnJztcbiAgICAgICAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aCAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICc+JyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICcgJyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXHQnICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xcbicgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFxyJzsgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgIHRhZ05hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50cmltKCk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGFnTmFtZSk7XG5cbiAgICAgICAgaWYgKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlc1xuICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cmluZygwLCB0YWdOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsaWRhdGVUYWdOYW1lKHRhZ05hbWUpKSB7XG4gICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICBpZiAodGFnTmFtZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtc2cgPSBcIkludmFsaWQgc3BhY2UgYWZ0ZXIgJzwnLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2cgPSBcIlRhZyAnXCIrdGFnTmFtZStcIicgaXMgYW4gaW52YWxpZCBuYW1lLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBtc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkQXR0cmlidXRlU3RyKHhtbERhdGEsIGkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZXMgZm9yICdcIit0YWdOYW1lK1wiJyBoYXZlIG9wZW4gcXVvdGUuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0dHJTdHIgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGkgPSByZXN1bHQuaW5kZXg7XG5cbiAgICAgICAgaWYgKGF0dHJTdHJbYXR0clN0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgY29uc3QgYXR0clN0clN0YXJ0ID0gaSAtIGF0dHJTdHIubGVuZ3RoO1xuICAgICAgICAgIGF0dHJTdHIgPSBhdHRyU3RyLnN1YnN0cmluZygwLCBhdHRyU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyhhdHRyU3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGFnRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy9jb250aW51ZTsgLy90ZXh0IG1heSBwcmVzZW50cyBhZnRlciBzZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGF0dHJTdHJTdGFydCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2luZ1RhZykge1xuICAgICAgICAgIGlmICghcmVzdWx0LnRhZ0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgZG9lc24ndCBoYXZlIHByb3BlciBjbG9zaW5nLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0clN0ci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgY2FuJ3QgaGF2ZSBhdHRyaWJ1dGVzIG9yIGludmFsaWQgc3RhcnRpbmcuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvdGcgPSB0YWdzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgIT09IG90Zy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgIGxldCBvcGVuUG9zID0gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIG90Zy50YWdTdGFydFBvcyk7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBjbG9zaW5nIHRhZyAnXCIrb3RnLnRhZ05hbWUrXCInIChvcGVuZWQgaW4gbGluZSBcIitvcGVuUG9zLmxpbmUrXCIsIGNvbCBcIitvcGVuUG9zLmNvbCtcIikgaW5zdGVhZCBvZiBjbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicuXCIsXG4gICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIHRhZ1N0YXJ0UG9zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSB0YWdzLCB3ZSByZWFjaGVkIHRoZSByb290IGxldmVsLlxuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmVhY2hlZFJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGlzVmFsaWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkgLSBhdHRyU3RyLmxlbmd0aCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2lmIHRoZSByb290IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQgYmVmb3JlIC4uLlxuICAgICAgICAgIGlmIChyZWFjaGVkUm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ011bHRpcGxlIHBvc3NpYmxlIHJvb3Qgbm9kZXMgZm91bmQuJywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYob3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgLy9kb24ndCBwdXNoIGludG8gc3RhY2tcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFncy5wdXNoKHt0YWdOYW1lLCB0YWdTdGFydFBvc30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWdGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NraXAgdGFnIHRleHQgdmFsdWVcbiAgICAgICAgLy9JdCBtYXkgaW5jbHVkZSBjb21tZW50cyBhbmQgQ0RBVEEgdmFsdWVcbiAgICAgICAgZm9yIChpKys7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICAgICAgaWYgKHhtbERhdGFbaSArIDFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgLy9jb21tZW50IG9yIENBREFUQVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGkgPSByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpKzFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLCArK2kpO1xuICAgICAgICAgICAgICBpZiAoaS5lcnIpIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICcmJykge1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJBbXAgPSB2YWxpZGF0ZUFtcGVyc2FuZCh4bWxEYXRhLCBpKTtcbiAgICAgICAgICAgIGlmIChhZnRlckFtcCA9PSAtMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnJicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgICAgaSA9IGFmdGVyQW1wO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYgKHJlYWNoZWRSb290ID09PSB0cnVlICYmICFpc1doaXRlU3BhY2UoeG1sRGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgXCJFeHRyYSB0ZXh0IGF0IHRoZSBlbmRcIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9lbmQgb2YgcmVhZGluZyB0YWcgdGV4dCB2YWx1ZVxuICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggaXNXaGl0ZVNwYWNlKHhtbERhdGFbaV0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnXCIreG1sRGF0YVtpXStcIicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGFnRm91bmQpIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnU3RhcnQgdGFnIGV4cGVjdGVkLicsIDEpO1xuICB9ZWxzZSBpZiAodGFncy5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJVbmNsb3NlZCB0YWcgJ1wiK3RhZ3NbMF0udGFnTmFtZStcIicuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdzWzBdLnRhZ1N0YXJ0UG9zKSk7XG4gIH1lbHNlIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsIFwiSW52YWxpZCAnXCIrXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGFncy5tYXAodCA9PiB0LnRhZ05hbWUpLCBudWxsLCA0KS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKStcbiAgICAgICAgICBcIicgZm91bmQuXCIsIHtsaW5lOiAxLCBjb2w6IDF9KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoYXIpe1xuICByZXR1cm4gY2hhciA9PT0gJyAnIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICdcXG4nICB8fCBjaGFyID09PSAnXFxyJztcbn1cbi8qKlxuICogUmVhZCBQcm9jZXNzaW5nIGluc3N0cnVjdGlvbnMgYW5kIHNraXBcbiAqIEBwYXJhbSB7Kn0geG1sRGF0YVxuICogQHBhcmFtIHsqfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRQSSh4bWxEYXRhLCBpKSB7XG4gIGNvbnN0IHN0YXJ0ID0gaTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT0gJz8nIHx8IHhtbERhdGFbaV0gPT0gJyAnKSB7XG4gICAgICAvL3RhZ25hbWVcbiAgICAgIGNvbnN0IHRhZ25hbWUgPSB4bWxEYXRhLnN1YnN0cihzdGFydCwgaSAtIHN0YXJ0KTtcbiAgICAgIGlmIChpID4gNSAmJiB0YWduYW1lID09PSAneG1sJykge1xuICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnWE1MIGRlY2xhcmF0aW9uIGFsbG93ZWQgb25seSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LicsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT0gJz8nICYmIHhtbERhdGFbaSArIDFdID09ICc+Jykge1xuICAgICAgICAvL2NoZWNrIGlmIHZhbGlkIGF0dHJpYnV0IHN0cmluZ1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpIHtcbiAgaWYgKHhtbERhdGEubGVuZ3RoID4gaSArIDUgJiYgeG1sRGF0YVtpICsgMV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJy0nKSB7XG4gICAgLy9jb21tZW50XG4gICAgZm9yIChpICs9IDM7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDFdID09PSAnLScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICc+Jykge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB4bWxEYXRhLmxlbmd0aCA+IGkgKyA4ICYmXG4gICAgeG1sRGF0YVtpICsgMV0gPT09ICdEJyAmJlxuICAgIHhtbERhdGFbaSArIDJdID09PSAnTycgJiZcbiAgICB4bWxEYXRhW2kgKyAzXSA9PT0gJ0MnICYmXG4gICAgeG1sRGF0YVtpICsgNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDVdID09PSAnWScgJiZcbiAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ1AnICYmXG4gICAgeG1sRGF0YVtpICsgN10gPT09ICdFJ1xuICApIHtcbiAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICBmb3IgKGkgKz0gODsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgaWYgKGFuZ2xlQnJhY2tldHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHhtbERhdGEubGVuZ3RoID4gaSArIDkgJiZcbiAgICB4bWxEYXRhW2kgKyAxXSA9PT0gJ1snICYmXG4gICAgeG1sRGF0YVtpICsgMl0gPT09ICdDJyAmJlxuICAgIHhtbERhdGFbaSArIDNdID09PSAnRCcgJiZcbiAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDZdID09PSAnQScgJiZcbiAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ1snXG4gICkge1xuICAgIGZvciAoaSArPSA4OyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICddJyAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJ10nICYmIHhtbERhdGFbaSArIDJdID09PSAnPicpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuY29uc3QgZG91YmxlUXVvdGUgPSAnXCInO1xuY29uc3Qgc2luZ2xlUXVvdGUgPSBcIidcIjtcblxuLyoqXG4gKiBLZWVwIHJlYWRpbmcgeG1sRGF0YSB1bnRpbCAnPCcgaXMgZm91bmQgb3V0c2lkZSB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVTdHIoeG1sRGF0YSwgaSkge1xuICBsZXQgYXR0clN0ciA9ICcnO1xuICBsZXQgc3RhcnRDaGFyID0gJyc7XG4gIGxldCB0YWdDbG9zZWQgPSBmYWxzZTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09IGRvdWJsZVF1b3RlIHx8IHhtbERhdGFbaV0gPT09IHNpbmdsZVF1b3RlKSB7XG4gICAgICBpZiAoc3RhcnRDaGFyID09PSAnJykge1xuICAgICAgICBzdGFydENoYXIgPSB4bWxEYXRhW2ldO1xuICAgICAgfSBlbHNlIGlmIChzdGFydENoYXIgIT09IHhtbERhdGFbaV0pIHtcbiAgICAgICAgLy9pZiB2YXVlIGlzIGVuY2xvc2VkIHdpdGggZG91YmxlIHF1b3RlIHRoZW4gc2luZ2xlIHF1b3RlcyBhcmUgYWxsb3dlZCBpbnNpZGUgdGhlIHZhbHVlIGFuZCB2aWNlIHZlcnNhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydENoYXIgPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgaWYgKHN0YXJ0Q2hhciA9PT0gJycpIHtcbiAgICAgICAgdGFnQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJTdHIgKz0geG1sRGF0YVtpXTtcbiAgfVxuICBpZiAoc3RhcnRDaGFyICE9PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGF0dHJTdHIsXG4gICAgaW5kZXg6IGksXG4gICAgdGFnQ2xvc2VkOiB0YWdDbG9zZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBTZWxlY3QgYWxsIHRoZSBhdHRyaWJ1dGVzIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRBdHRyU3RyUmVneHAgPSBuZXcgUmVnRXhwKCcoXFxcXHMqKShbXlxcXFxzPV0rKShcXFxccyo9KT8oXFxcXHMqKFtcXCdcIl0pKChbXFxcXHNcXFxcU10pKj8pXFxcXDUpPycsICdnJyk7XG5cbi8vYXR0ciwgPVwic2RcIiwgYT1cImFtaXQnc1wiLCBhPVwic2RcImI9XCJzYWZcIiwgYWIgIGNkPVwiXCJcblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucykge1xuICAvL2NvbnNvbGUubG9nKFwic3RhcnQ6XCIrYXR0clN0citcIjplbmRcIik7XG5cbiAgLy9pZihhdHRyU3RyLnRyaW0oKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlOyAvL2VtcHR5IHN0cmluZ1xuXG4gIGNvbnN0IG1hdGNoZXMgPSB1dGlsLmdldEFsbE1hdGNoZXMoYXR0clN0ciwgdmFsaWRBdHRyU3RyUmVneHApO1xuICBjb25zdCBhdHRyTmFtZXMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWF0Y2hlc1tpXVsxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vbm9zcGFjZSBiZWZvcmUgYXR0cmlidXRlIG5hbWU6IGE9XCJzZFwiYj1cInNhZlwiXG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGhhcyBubyBzcGFjZSBpbiBzdGFydGluZy5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpXG4gICAgfSBlbHNlIGlmIChtYXRjaGVzW2ldWzNdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2hlc1tpXVs0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGlzIHdpdGhvdXQgdmFsdWUuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXNbaV1bM10gPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5hbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAvL2luZGVwZW5kZW50IGF0dHJpYnV0ZTogYWJcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcImJvb2xlYW4gYXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBpcyBub3QgYWxsb3dlZC5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgICAvKiBlbHNlIGlmKG1hdGNoZXNbaV1bNl0gPT09IHVuZGVmaW5lZCl7Ly9hdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZTogYWI9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycjogeyBjb2RlOlwiSW52YWxpZEF0dHJcIixtc2c6XCJhdHRyaWJ1dGUgXCIgKyBtYXRjaGVzW2ldWzJdICsgXCIgaGFzIG5vIHZhbHVlIGFzc2lnbmVkLlwifX07XG4gICAgICAgICAgICAgICAgfSAqL1xuICAgIGNvbnN0IGF0dHJOYW1lID0gbWF0Y2hlc1tpXVsyXTtcbiAgICBpZiAoIXZhbGlkYXRlQXR0ck5hbWUoYXR0ck5hbWUpKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK2F0dHJOYW1lK1wiJyBpcyBhbiBpbnZhbGlkIG5hbWUuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gICAgaWYgKCFhdHRyTmFtZXMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSB7XG4gICAgICAvL2NoZWNrIGZvciBkdXBsaWNhdGUgYXR0cmlidXRlLlxuICAgICAgYXR0ck5hbWVzW2F0dHJOYW1lXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrYXR0ck5hbWUrXCInIGlzIHJlcGVhdGVkLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kKHhtbERhdGEsIGkpIHtcbiAgbGV0IHJlID0gL1xcZC87XG4gIGlmICh4bWxEYXRhW2ldID09PSAneCcpIHtcbiAgICBpKys7XG4gICAgcmUgPSAvW1xcZGEtZkEtRl0vO1xuICB9XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgICByZXR1cm4gaTtcbiAgICBpZiAoIXhtbERhdGFbaV0ubWF0Y2gocmUpKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFtcGVyc2FuZCh4bWxEYXRhLCBpKSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI2R0LWNoYXJyZWZcbiAgaSsrO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgIHJldHVybiAtMTtcbiAgaWYgKHhtbERhdGFbaV0gPT09ICcjJykge1xuICAgIGkrKztcbiAgICByZXR1cm4gdmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQoeG1sRGF0YSwgaSk7XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrLCBjb3VudCsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0ubWF0Y2goL1xcdy8pICYmIGNvdW50IDwgMjApXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRFcnJvck9iamVjdChjb2RlLCBtZXNzYWdlLCBsaW5lTnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgZXJyOiB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgbXNnOiBtZXNzYWdlLFxuICAgICAgbGluZTogbGluZU51bWJlci5saW5lIHx8IGxpbmVOdW1iZXIsXG4gICAgICBjb2w6IGxpbmVOdW1iZXIuY29sLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXR0ck5hbWUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIHV0aWwuaXNOYW1lKGF0dHJOYW1lKTtcbn1cblxuLy8gY29uc3Qgc3RhcnRzV2l0aFhNTCA9IC9eeG1sL2k7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFnTmFtZSh0YWduYW1lKSB7XG4gIHJldHVybiB1dGlsLmlzTmFtZSh0YWduYW1lKSAvKiAmJiAhdGFnbmFtZS5tYXRjaChzdGFydHNXaXRoWE1MKSAqLztcbn1cblxuLy90aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGxpbmUgbnVtYmVyIGZvciB0aGUgY2hhcmFjdGVyIGF0IHRoZSBnaXZlbiBpbmRleFxuZnVuY3Rpb24gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGluZGV4KSB7XG4gIGNvbnN0IGxpbmVzID0geG1sRGF0YS5zdWJzdHJpbmcoMCwgaW5kZXgpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHJldHVybiB7XG4gICAgbGluZTogbGluZXMubGVuZ3RoLFxuXG4gICAgLy8gY29sdW1uIG51bWJlciBpcyBsYXN0IGxpbmUncyBsZW5ndGggKyAxLCBiZWNhdXNlIGNvbHVtbiBudW1iZXJpbmcgc3RhcnRzIGF0IDE6XG4gICAgY29sOiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxXG4gIH07XG59XG5cbi8vdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIG1hdGNoIHdpdGhpbiBhdHRyU3RyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaCkge1xuICByZXR1cm4gbWF0Y2guc3RhcnRJbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vcGFyc2UgRW1wdHkgTm9kZSBhcyBzZWxmIGNsb3Npbmcgbm9kZVxuY29uc3QgYnVpbGRGcm9tT3JkZXJlZEpzID0gcmVxdWlyZSgnLi9vcmRlcmVkSnMyWG1sJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhdHRyaWJ1dGVOYW1lUHJlZml4OiAnQF8nLFxuICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZSxcbiAgdGV4dE5vZGVOYW1lOiAnI3RleHQnLFxuICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICBjZGF0YVByb3BOYW1lOiBmYWxzZSxcbiAgZm9ybWF0OiBmYWxzZSxcbiAgaW5kZW50Qnk6ICcgICcsXG4gIHN1cHByZXNzRW1wdHlOb2RlOiBmYWxzZSxcbiAgc3VwcHJlc3NVbnBhaXJlZE5vZGU6IHRydWUsXG4gIHN1cHByZXNzQm9vbGVhbkF0dHJpYnV0ZXM6IHRydWUsXG4gIHRhZ1ZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbihrZXksIGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgYXR0cmlidXRlVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKGF0dHJOYW1lLCBhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHByZXNlcnZlT3JkZXI6IGZhbHNlLFxuICBjb21tZW50UHJvcE5hbWU6IGZhbHNlLFxuICB1bnBhaXJlZFRhZ3M6IFtdLFxuICBlbnRpdGllczogW1xuICAgIHsgcmVnZXg6IG5ldyBSZWdFeHAoXCImXCIsIFwiZ1wiKSwgdmFsOiBcIiZhbXA7XCIgfSwvL2l0IG11c3QgYmUgb24gdG9wXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIj5cIiwgXCJnXCIpLCB2YWw6IFwiJmd0O1wiIH0sXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIjxcIiwgXCJnXCIpLCB2YWw6IFwiJmx0O1wiIH0sXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIlxcJ1wiLCBcImdcIiksIHZhbDogXCImYXBvcztcIiB9LFxuICAgIHsgcmVnZXg6IG5ldyBSZWdFeHAoXCJcXFwiXCIsIFwiZ1wiKSwgdmFsOiBcIiZxdW90O1wiIH1cbiAgXSxcbiAgcHJvY2Vzc0VudGl0aWVzOiB0cnVlLFxuICBzdG9wTm9kZXM6IFtdLFxuICB0cmFuc2Zvcm1UYWdOYW1lOiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIEJ1aWxkZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQXR0cmlidXRlcyB8fCB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSBmdW5jdGlvbigvKmEqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyUHJlZml4TGVuID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXgubGVuZ3RoO1xuICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSBpc0F0dHJpYnV0ZTtcbiAgfVxuXG4gIHRoaXMucHJvY2Vzc1RleHRPck9iak5vZGUgPSBwcm9jZXNzVGV4dE9yT2JqTm9kZVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0KSB7XG4gICAgdGhpcy5pbmRlbnRhdGUgPSBpbmRlbnRhdGU7XG4gICAgdGhpcy50YWdFbmRDaGFyID0gJz5cXG4nO1xuICAgIHRoaXMubmV3TGluZSA9ICdcXG4nO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5kZW50YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICB0aGlzLnRhZ0VuZENoYXIgPSAnPic7XG4gICAgdGhpcy5uZXdMaW5lID0gJyc7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnN1cHByZXNzRW1wdHlOb2RlKSB7XG4gICAgdGhpcy5idWlsZFRleHROb2RlID0gYnVpbGRFbXB0eVRleHROb2RlO1xuICAgIHRoaXMuYnVpbGRPYmpOb2RlID0gYnVpbGRFbXB0eU9iak5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5idWlsZFRleHROb2RlID0gYnVpbGRUZXh0VmFsTm9kZTtcbiAgICB0aGlzLmJ1aWxkT2JqTm9kZSA9IGJ1aWxkT2JqZWN0Tm9kZTtcbiAgfVxuXG4gIHRoaXMuYnVpbGRUZXh0VmFsTm9kZSA9IGJ1aWxkVGV4dFZhbE5vZGU7XG4gIHRoaXMuYnVpbGRPYmplY3ROb2RlID0gYnVpbGRPYmplY3ROb2RlO1xuXG4gIHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUgPSByZXBsYWNlRW50aXRpZXNWYWx1ZTtcbiAgdGhpcy5idWlsZEF0dHJQYWlyU3RyID0gYnVpbGRBdHRyUGFpclN0cjtcbn1cblxuQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihqT2JqKSB7XG4gIGlmKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU9yZGVyKXtcbiAgICByZXR1cm4gYnVpbGRGcm9tT3JkZXJlZEpzKGpPYmosIHRoaXMub3B0aW9ucyk7XG4gIH1lbHNlIHtcbiAgICBpZihBcnJheS5pc0FycmF5KGpPYmopICYmIHRoaXMub3B0aW9ucy5hcnJheU5vZGVOYW1lICYmIHRoaXMub3B0aW9ucy5hcnJheU5vZGVOYW1lLmxlbmd0aCA+IDEpe1xuICAgICAgak9iaiA9IHtcbiAgICAgICAgW3RoaXMub3B0aW9ucy5hcnJheU5vZGVOYW1lXSA6IGpPYmpcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuajJ4KGpPYmosIDApLnZhbDtcbiAgfVxufTtcblxuQnVpbGRlci5wcm90b3R5cGUuajJ4ID0gZnVuY3Rpb24oak9iaiwgbGV2ZWwpIHtcbiAgbGV0IGF0dHJTdHIgPSAnJztcbiAgbGV0IHZhbCA9ICcnO1xuICBmb3IgKGxldCBrZXkgaW4gak9iaikge1xuICAgIGlmICh0eXBlb2Ygak9ialtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gc3VwcmVzcyB1bmRlZmluZWQgbm9kZVxuICAgIH0gZWxzZSBpZiAoak9ialtrZXldID09PSBudWxsKSB7XG4gICAgICBpZihrZXlbMF0gPT09IFwiP1wiKSB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgZWxzZSB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgLy8gdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICB9IGVsc2UgaWYgKGpPYmpba2V5XSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHZhbCArPSB0aGlzLmJ1aWxkVGV4dE5vZGUoak9ialtrZXldLCBrZXksICcnLCBsZXZlbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygak9ialtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgLy9wcmVtaXRpdmUgdHlwZVxuICAgICAgY29uc3QgYXR0ciA9IHRoaXMuaXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgIGF0dHJTdHIgKz0gdGhpcy5idWlsZEF0dHJQYWlyU3RyKGF0dHIsICcnICsgak9ialtrZXldKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgLy90YWcgdmFsdWVcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSkge1xuICAgICAgICAgIGxldCBuZXd2YWwgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3Ioa2V5LCAnJyArIGpPYmpba2V5XSk7XG4gICAgICAgICAgdmFsICs9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUobmV3dmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgKz0gdGhpcy5idWlsZFRleHROb2RlKGpPYmpba2V5XSwga2V5LCAnJywgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGpPYmpba2V5XSkpIHtcbiAgICAgIC8vcmVwZWF0ZWQgbm9kZXNcbiAgICAgIGNvbnN0IGFyckxlbiA9IGpPYmpba2V5XS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFyckxlbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBqT2JqW2tleV1bal07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBzdXByZXNzIHVuZGVmaW5lZCBub2RlXG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmKGtleVswXSA9PT0gXCI/XCIpIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnPycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgICAgICAgZWxzZSB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgICAgIC8vIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnLycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFsICs9IHRoaXMucHJvY2Vzc1RleHRPck9iak5vZGUoaXRlbSwga2V5LCBsZXZlbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgKz0gdGhpcy5idWlsZFRleHROb2RlKGl0ZW0sIGtleSwgJycsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL25lc3RlZCBub2RlXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUgJiYga2V5ID09PSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgICAgICBjb25zdCBLcyA9IE9iamVjdC5rZXlzKGpPYmpba2V5XSk7XG4gICAgICAgIGNvbnN0IEwgPSBLcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTDsgaisrKSB7XG4gICAgICAgICAgYXR0clN0ciArPSB0aGlzLmJ1aWxkQXR0clBhaXJTdHIoS3Nbal0sICcnICsgak9ialtrZXldW0tzW2pdXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCArPSB0aGlzLnByb2Nlc3NUZXh0T3JPYmpOb2RlKGpPYmpba2V5XSwga2V5LCBsZXZlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHthdHRyU3RyOiBhdHRyU3RyLCB2YWw6IHZhbH07XG59O1xuXG5mdW5jdGlvbiBidWlsZEF0dHJQYWlyU3RyKGF0dHJOYW1lLCB2YWwpe1xuICB2YWwgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IoYXR0ck5hbWUsICcnICsgdmFsKTtcbiAgdmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh2YWwpO1xuICBpZiAodGhpcy5vcHRpb25zLnN1cHByZXNzQm9vbGVhbkF0dHJpYnV0ZXMgJiYgdmFsID09PSBcInRydWVcIikge1xuICAgIHJldHVybiAnICcgKyBhdHRyTmFtZTtcbiAgfSBlbHNlIHJldHVybiAnICcgKyBhdHRyTmFtZSArICc9XCInICsgdmFsICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1RleHRPck9iak5vZGUgKG9iamVjdCwga2V5LCBsZXZlbCkge1xuICBjb25zdCByZXN1bHQgPSB0aGlzLmoyeChvYmplY3QsIGxldmVsICsgMSk7XG4gIGlmIChvYmplY3RbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0gIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkVGV4dE5vZGUob2JqZWN0W3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdLCBrZXksIHJlc3VsdC5hdHRyU3RyLCBsZXZlbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRPYmpOb2RlKHJlc3VsdC52YWwsIGtleSwgcmVzdWx0LmF0dHJTdHIsIGxldmVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZE9iamVjdE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKSB7XG4gIGxldCB0YWdFbmRFeHAgPSAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICBsZXQgcGlDbG9zaW5nQ2hhciA9IFwiXCI7XG4gIFxuICBpZihrZXlbMF0gPT09IFwiP1wiKSB7XG4gICAgcGlDbG9zaW5nQ2hhciA9IFwiP1wiO1xuICAgIHRhZ0VuZEV4cCA9IFwiXCI7XG4gIH1cblxuICBpZiAoYXR0clN0ciAmJiB2YWwuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgIHJldHVybiAoIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArICBrZXkgKyBhdHRyU3RyICsgcGlDbG9zaW5nQ2hhciArICc+JyArIHZhbCArIHRhZ0VuZEV4cCApO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSAmJiBwaUNsb3NpbmdDaGFyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyBgPCEtLSR7dmFsfS0tPmAgKyB0aGlzLm5ld0xpbmU7XG4gIH1lbHNlIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArIHBpQ2xvc2luZ0NoYXIgKyB0aGlzLnRhZ0VuZENoYXIgK1xuICAgICAgdmFsICtcbiAgICAgIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIHRhZ0VuZEV4cCAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRW1wdHlPYmpOb2RlKHZhbCwga2V5LCBhdHRyU3RyLCBsZXZlbCkge1xuICBpZiAodmFsICE9PSAnJykge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkT2JqZWN0Tm9kZSh2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpO1xuICB9IGVsc2Uge1xuICAgIGlmKGtleVswXSA9PT0gXCI/XCIpIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0cisgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIGVsc2UgcmV0dXJuICB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGV4dFZhbE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSAhPT0gZmFsc2UgJiYga2V5ID09PSB0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyBgPCFbQ0RBVEFbJHt2YWx9XV0+YCArICB0aGlzLm5ld0xpbmU7XG4gIH1lbHNlIGlmICh0aGlzLm9wdGlvbnMuY29tbWVudFByb3BOYW1lICE9PSBmYWxzZSAmJiBrZXkgPT09IHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgYDwhLS0ke3ZhbH0tLT5gICsgIHRoaXMubmV3TGluZTtcbiAgfWVsc2V7XG4gICAgbGV0IHRleHRWYWx1ZSA9IHRoaXMub3B0aW9ucy50YWdWYWx1ZVByb2Nlc3NvcihrZXksIHZhbCk7XG4gICAgdGV4dFZhbHVlID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh0ZXh0VmFsdWUpO1xuICBcbiAgICBpZiggdGV4dFZhbHVlID09PSAnJyAmJiB0aGlzLm9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2Yoa2V5KSAhPT0gLTEpeyAvL3VucGFpcmVkXG4gICAgICBpZih0aGlzLm9wdGlvbnMuc3VwcHJlc3NVbnBhaXJlZE5vZGUpe1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBcIi9cIiArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIH1cbiAgICB9IGVsc2V7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgJz4nICtcbiAgICAgICAgIHRleHRWYWx1ZSArXG4gICAgICAgICc8LycgKyBrZXkgKyB0aGlzLnRhZ0VuZENoYXIgICk7XG4gICAgfVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlKXtcbiAgaWYodGV4dFZhbHVlICYmIHRleHRWYWx1ZS5sZW5ndGggPiAwICYmIHRoaXMub3B0aW9ucy5wcm9jZXNzRW50aXRpZXMpe1xuICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLm9wdGlvbnMuZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMub3B0aW9ucy5lbnRpdGllc1tpXTtcbiAgICAgIHRleHRWYWx1ZSA9IHRleHRWYWx1ZS5yZXBsYWNlKGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRW1wdHlUZXh0Tm9kZSh2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYoIHZhbCA9PT0gJycgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGtleSkgIT09IC0xKXsgLy91bnBhaXJlZFxuICAgIGlmKHRoaXMub3B0aW9ucy5zdXBwcmVzc1VucGFpcmVkTm9kZSl7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIFwiL1wiICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1cbiAgfWVsc2UgaWYgKHZhbCAhPT0gJycpIHsgLy9lbXB0eVxuICAgIHJldHVybiB0aGlzLmJ1aWxkVGV4dFZhbE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjsgLy9QSSB0YWdcbiAgICBlbHNlIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICcvJyArIHRoaXMudGFnRW5kQ2hhcjsgLy9ub3JtYWxcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRlbnRhdGUobGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRlbnRCeS5yZXBlYXQobGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZShuYW1lIC8qLCBvcHRpb25zKi8pIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCh0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCkpIHtcbiAgICByZXR1cm4gbmFtZS5zdWJzdHIodGhpcy5hdHRyUHJlZml4TGVuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyO1xuIiwiY29uc3QgRU9MID0gXCJcXG5cIjtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGpBcnJheSBcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRvWG1sKGpBcnJheSwgb3B0aW9ucyl7XG4gICAgcmV0dXJuIGFyclRvU3RyKCBqQXJyYXksIG9wdGlvbnMsIFwiXCIsIDApO1xufVxuXG5mdW5jdGlvbiBhcnJUb1N0cihhcnIsIG9wdGlvbnMsIGpQYXRoLCBsZXZlbCl7XG4gICAgbGV0IHhtbFN0ciA9IFwiXCI7XG5cbiAgICBsZXQgaW5kZW50YXRpb24gPSBcIlwiO1xuICAgIGlmKG9wdGlvbnMuZm9ybWF0ICYmIG9wdGlvbnMuaW5kZW50QnkubGVuZ3RoID4gMCl7Ly9UT0RPOiB0aGlzIGxvZ2ljIGNhbiBiZSBhdm9pZGVkIGZvciBlYWNoIGNhbGxcbiAgICAgICAgaW5kZW50YXRpb24gPSBFT0wgKyBcIlwiICsgb3B0aW9ucy5pbmRlbnRCeS5yZXBlYXQobGV2ZWwpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IGFycltpXTtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHByb3BOYW1lKHRhZ09iaik7XG4gICAgICAgIGxldCBuZXdKUGF0aCA9IFwiXCI7XG4gICAgICAgIGlmKGpQYXRoLmxlbmd0aCA9PT0gMCkgbmV3SlBhdGggPSB0YWdOYW1lXG4gICAgICAgIGVsc2UgbmV3SlBhdGggPSBgJHtqUGF0aH0uJHt0YWdOYW1lfWA7XG5cbiAgICAgICAgaWYodGFnTmFtZSA9PT0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUpe1xuICAgICAgICAgICAgbGV0IHRhZ1RleHQgPSB0YWdPYmpbdGFnTmFtZV07XG4gICAgICAgICAgICBpZighaXNTdG9wTm9kZShuZXdKUGF0aCwgb3B0aW9ucykpe1xuICAgICAgICAgICAgICAgIHRhZ1RleHQgPSBvcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKCB0YWdOYW1lLCB0YWdUZXh0KTtcbiAgICAgICAgICAgICAgICB0YWdUZXh0ID0gcmVwbGFjZUVudGl0aWVzVmFsdWUodGFnVGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxTdHIgKz0gaW5kZW50YXRpb24gKyB0YWdUZXh0O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1lbHNlIGlmKCB0YWdOYW1lID09PSBvcHRpb25zLmNkYXRhUHJvcE5hbWUpe1xuICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uICsgYDwhW0NEQVRBWyR7dGFnT2JqW3RhZ05hbWVdWzBdW29wdGlvbnMudGV4dE5vZGVOYW1lXX1dXT5gO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1lbHNlIGlmKCB0YWdOYW1lID09PSBvcHRpb25zLmNvbW1lbnRQcm9wTmFtZSl7XG4gICAgICAgICAgICB4bWxTdHIgKz0gaW5kZW50YXRpb24gKyBgPCEtLSR7dGFnT2JqW3RhZ05hbWVdWzBdW29wdGlvbnMudGV4dE5vZGVOYW1lXX0tLT5gO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1lbHNlIGlmKCB0YWdOYW1lWzBdID09PSBcIj9cIil7XG4gICAgICAgICAgICBjb25zdCBhdHRTdHIgPSBhdHRyX3RvX3N0cih0YWdPYmpbXCI6QFwiXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wSW5kID0gdGFnTmFtZSA9PT0gXCI/eG1sXCIgPyBcIlwiIDogaW5kZW50YXRpb247XG4gICAgICAgICAgICBsZXQgcGlUZXh0Tm9kZU5hbWUgPSB0YWdPYmpbdGFnTmFtZV1bMF1bb3B0aW9ucy50ZXh0Tm9kZU5hbWVdO1xuICAgICAgICAgICAgcGlUZXh0Tm9kZU5hbWUgPSBwaVRleHROb2RlTmFtZS5sZW5ndGggIT09IDAgPyBcIiBcIiArIHBpVGV4dE5vZGVOYW1lIDogXCJcIjsgLy9yZW1vdmUgZXh0cmEgc3BhY2luZ1xuICAgICAgICAgICAgeG1sU3RyICs9IHRlbXBJbmQgKyBgPCR7dGFnTmFtZX0ke3BpVGV4dE5vZGVOYW1lfSR7YXR0U3RyfT8+YDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dFN0ciA9IGF0dHJfdG9fc3RyKHRhZ09ialtcIjpAXCJdLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHRhZ1N0YXJ0ID0gIGluZGVudGF0aW9uICsgYDwke3RhZ05hbWV9JHthdHRTdHJ9YDtcbiAgICAgICAgbGV0IHRhZ1ZhbHVlID0gYXJyVG9TdHIodGFnT2JqW3RhZ05hbWVdLCBvcHRpb25zLCBuZXdKUGF0aCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgaWYob3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgaWYob3B0aW9ucy5zdXBwcmVzc1VucGFpcmVkTm9kZSkgIHhtbFN0ciArPSB0YWdTdGFydCArIFwiPlwiOyBcbiAgICAgICAgICAgIGVsc2UgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCIvPlwiOyBcbiAgICAgICAgfWVsc2UgaWYoICghdGFnVmFsdWUgfHwgdGFnVmFsdWUubGVuZ3RoID09PSAwKSAmJiBvcHRpb25zLnN1cHByZXNzRW1wdHlOb2RlKXsgXG4gICAgICAgICAgICB4bWxTdHIgKz0gdGFnU3RhcnQgKyBcIi8+XCI7IFxuICAgICAgICB9ZWxzZXsgXG4gICAgICAgICAgICAvL1RPRE86IG5vZGUgd2l0aCBvbmx5IHRleHQgdmFsdWUgc2hvdWxkIG5vdCBwYXJzZSB0aGUgdGV4dCB2YWx1ZSBpbiBuZXh0IGxpbmVcbiAgICAgICAgICAgIHhtbFN0ciArPSB0YWdTdGFydCArIGA+JHt0YWdWYWx1ZX0ke2luZGVudGF0aW9ufTwvJHt0YWdOYW1lfT5gIDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geG1sU3RyO1xufVxuXG5mdW5jdGlvbiBwcm9wTmFtZShvYmope1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG5mdW5jdGlvbiBhdHRyX3RvX3N0cihhdHRyTWFwLCBvcHRpb25zKXtcbiAgICBsZXQgYXR0clN0ciA9IFwiXCI7XG4gICAgaWYoYXR0ck1hcCAmJiAhb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzKXtcbiAgICAgICAgZm9yIChsZXQgYXR0ciBpbiBhdHRyTWFwKXtcbiAgICAgICAgICAgIGxldCBhdHRyVmFsID0gb3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcihhdHRyLCBhdHRyTWFwW2F0dHJdKTtcbiAgICAgICAgICAgIGF0dHJWYWwgPSByZXBsYWNlRW50aXRpZXNWYWx1ZShhdHRyVmFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmKGF0dHJWYWwgPT09IHRydWUgJiYgb3B0aW9ucy5zdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzKXtcbiAgICAgICAgICAgICAgICBhdHRyU3RyKz0gYCAke2F0dHIuc3Vic3RyKG9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeC5sZW5ndGgpfWA7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBhdHRyU3RyKz0gYCAke2F0dHIuc3Vic3RyKG9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeC5sZW5ndGgpfT1cIiR7YXR0clZhbH1cImA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJTdHI7XG59XG5cbmZ1bmN0aW9uIGlzU3RvcE5vZGUoalBhdGgsIG9wdGlvbnMpe1xuICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsalBhdGgubGVuZ3RoIC0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgbGV0IHRhZ05hbWUgPSBqUGF0aC5zdWJzdHIoalBhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgZm9yKGxldCBpbmRleCBpbiBvcHRpb25zLnN0b3BOb2Rlcyl7XG4gICAgICAgIGlmKG9wdGlvbnMuc3RvcE5vZGVzW2luZGV4XSA9PT0galBhdGggfHwgb3B0aW9ucy5zdG9wTm9kZXNbaW5kZXhdID09PSBcIiouXCIrdGFnTmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlLCBvcHRpb25zKXtcbiAgICBpZih0ZXh0VmFsdWUgJiYgdGV4dFZhbHVlLmxlbmd0aCA+IDAgJiYgb3B0aW9ucy5wcm9jZXNzRW50aXRpZXMpe1xuICAgICAgZm9yIChsZXQgaT0wOyBpPCBvcHRpb25zLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IG9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICAgIHRleHRWYWx1ZSA9IHRleHRWYWx1ZS5yZXBsYWNlKGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0VmFsdWU7XG4gIH1cbm1vZHVsZS5leHBvcnRzID0gdG9YbWw7IiwiLy9UT0RPOiBoYW5kbGUgY29tbWVudHNcbmZ1bmN0aW9uIHJlYWREb2NUeXBlKHhtbERhdGEsIGkpe1xuICAgIFxuICAgIGNvbnN0IGVudGl0aWVzID0ge307XG4gICAgaWYoIHhtbERhdGFbaSArIDNdID09PSAnTycgJiZcbiAgICAgICAgIHhtbERhdGFbaSArIDRdID09PSAnQycgJiZcbiAgICAgICAgIHhtbERhdGFbaSArIDVdID09PSAnVCcgJiZcbiAgICAgICAgIHhtbERhdGFbaSArIDZdID09PSAnWScgJiZcbiAgICAgICAgIHhtbERhdGFbaSArIDddID09PSAnUCcgJiZcbiAgICAgICAgIHhtbERhdGFbaSArIDhdID09PSAnRScpXG4gICAgeyAgICBcbiAgICAgICAgaSA9IGkrOTtcbiAgICAgICAgbGV0IGFuZ2xlQnJhY2tldHNDb3VudCA9IDE7XG4gICAgICAgIGxldCBoYXNCb2R5ID0gZmFsc2UsIGVudGl0eSA9IGZhbHNlLCBjb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBleHAgPSBcIlwiO1xuICAgICAgICBmb3IoO2k8eG1sRGF0YS5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICBpZiggaGFzQm9keSAmJiBcbiAgICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krMl0gPT09ICdFJyAmJlxuICAgICAgICAgICAgICAgICAgICAgeG1sRGF0YVtpKzNdID09PSAnTicgJiZcbiAgICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs0XSA9PT0gJ1QnICYmXG4gICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krNV0gPT09ICdJJyAmJlxuICAgICAgICAgICAgICAgICAgICAgeG1sRGF0YVtpKzZdID09PSAnVCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs3XSA9PT0gJ1knXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCBoYXNCb2R5ICYmIFxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgICAgICAgICAgICAgICAgICAgeG1sRGF0YVtpKzJdID09PSAnRScgJiZcbiAgICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSszXSA9PT0gJ0wnICYmXG4gICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krNF0gPT09ICdFJyAmJlxuICAgICAgICAgICAgICAgICAgICAgeG1sRGF0YVtpKzVdID09PSAnTScgJiZcbiAgICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs2XSA9PT0gJ0UnICYmXG4gICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krN10gPT09ICdOJyAmJlxuICAgICAgICAgICAgICAgICAgICAgeG1sRGF0YVtpKzhdID09PSAnVCdcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgICAgICAvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCBoYXNCb2R5ICYmIFxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krMl0gPT09ICdBJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krM10gPT09ICdUJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krNF0gPT09ICdUJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krNV0gPT09ICdMJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krNl0gPT09ICdJJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krN10gPT09ICdTJyAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxEYXRhW2krOF0gPT09ICdUJ1xuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgIC8vTm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoIGhhc0JvZHkgJiYgXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSsyXSA9PT0gJ04nICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSszXSA9PT0gJ08nICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs0XSA9PT0gJ1QnICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs1XSA9PT0gJ0EnICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs2XSA9PT0gJ1QnICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs3XSA9PT0gJ0knICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs4XSA9PT0gJ08nICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSs5XSA9PT0gJ04nXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgLy9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZiggLy9jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSsyXSA9PT0gJy0nICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbERhdGFbaSszXSA9PT0gJy0nXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRE9DVFlQRVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgZXhwID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgaWYoY29tbWVudCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCB4bWxEYXRhW2kgLSAxXSA9PT0gXCItXCIgJiYgeG1sRGF0YVtpIC0gMl0gPT09IFwiLVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgWE1MIGNvbW1lbnQgaW4gRE9DVFlQRWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoZW50aXR5KXtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbnRpdHlFeHAoZXhwLCBlbnRpdGllcyk7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGVCcmFja2V0c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YVtpXSA9PT0gJ1snKXtcbiAgICAgICAgICAgICAgICBoYXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGV4cCArPSB4bWxEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFuZ2xlQnJhY2tldHNDb3VudCAhPT0gMCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY2xvc2VkIERPQ1RZUEVgKTtcbiAgICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVGFnIGluc3RlYWQgb2YgRE9DVFlQRWApO1xuICAgIH1cbiAgICByZXR1cm4ge2VudGl0aWVzLCBpfTtcbn1cblxuY29uc3QgZW50aXR5UmVnZXggPSBSZWdFeHAoXCJeXFxcXHMoW2EtekEtejAtMF0rKVsgXFx0XShbJ1xcXCJdKShbXiZdKylcXFxcMlwiKTtcbmZ1bmN0aW9uIHBhcnNlRW50aXR5RXhwKGV4cCwgZW50aXRpZXMpe1xuICAgIGNvbnN0IG1hdGNoID0gZW50aXR5UmVnZXguZXhlYyhleHApO1xuICAgIGlmKG1hdGNoKXtcbiAgICAgICAgZW50aXRpZXNbIG1hdGNoWzFdIF0gPSB7XG4gICAgICAgICAgICByZWd4IDogUmVnRXhwKCBgJiR7bWF0Y2hbMV19O2AsXCJnXCIpLFxuICAgICAgICAgICAgdmFsOiBtYXRjaFszXVxuICAgICAgICB9O1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gcmVhZERvY1R5cGU7IiwiXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwcmVzZXJ2ZU9yZGVyOiBmYWxzZSxcbiAgICBhdHRyaWJ1dGVOYW1lUHJlZml4OiAnQF8nLFxuICAgIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGZhbHNlLFxuICAgIHRleHROb2RlTmFtZTogJyN0ZXh0JyxcbiAgICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICAgIHJlbW92ZU5TUHJlZml4OiBmYWxzZSwgLy8gcmVtb3ZlIE5TIGZyb20gdGFnIG5hbWUgb3IgYXR0cmlidXRlIG5hbWUgaWYgdHJ1ZVxuICAgIGFsbG93Qm9vbGVhbkF0dHJpYnV0ZXM6IGZhbHNlLCAvL2EgdGFnIGNhbiBoYXZlIGF0dHJpYnV0ZXMgd2l0aG91dCBhbnkgdmFsdWVcbiAgICAvL2lnbm9yZVJvb3RFbGVtZW50IDogZmFsc2UsXG4gICAgcGFyc2VUYWdWYWx1ZTogdHJ1ZSxcbiAgICBwYXJzZUF0dHJpYnV0ZVZhbHVlOiBmYWxzZSxcbiAgICB0cmltVmFsdWVzOiB0cnVlLCAvL1RyaW0gc3RyaW5nIHZhbHVlcyBvZiB0YWcgYW5kIGF0dHJpYnV0ZXNcbiAgICBjZGF0YVByb3BOYW1lOiBmYWxzZSxcbiAgICBudW1iZXJQYXJzZU9wdGlvbnM6IHtcbiAgICAgIGhleDogdHJ1ZSxcbiAgICAgIGxlYWRpbmdaZXJvczogdHJ1ZVxuICAgIH0sXG4gICAgdGFnVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKHRhZ05hbWUsIHZhbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuICAgIGF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbihhdHRyTmFtZSwgdmFsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgc3RvcE5vZGVzOiBbXSwgLy9uZXN0ZWQgdGFncyB3aWxsIG5vdCBiZSBwYXJzZWQgZXZlbiBmb3IgZXJyb3JzXG4gICAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IGZhbHNlLFxuICAgIGlzQXJyYXk6ICgpID0+IGZhbHNlLFxuICAgIGNvbW1lbnRQcm9wTmFtZTogZmFsc2UsXG4gICAgdW5wYWlyZWRUYWdzOiBbXSxcbiAgICBwcm9jZXNzRW50aXRpZXM6IHRydWUsXG4gICAgaHRtbEVudGl0aWVzOiBmYWxzZSxcbiAgICBpZ25vcmVEZWNsYXJhdGlvbjogZmFsc2UsXG4gICAgaWdub3JlUGlUYWdzOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1UYWdOYW1lOiBmYWxzZSxcbn07XG4gICBcbmNvbnN0IGJ1aWxkT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5idWlsZE9wdGlvbnMgPSBidWlsZE9wdGlvbnM7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7IiwiJ3VzZSBzdHJpY3QnO1xuLy8vQHRzLWNoZWNrXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB4bWxOb2RlID0gcmVxdWlyZSgnLi94bWxOb2RlJyk7XG5jb25zdCByZWFkRG9jVHlwZSA9IHJlcXVpcmUoXCIuL0RvY1R5cGVSZWFkZXJcIik7XG5jb25zdCB0b051bWJlciA9IHJlcXVpcmUoXCJzdHJudW1cIik7XG5cbmNvbnN0IHJlZ3ggPVxuICAnPCgoIVxcXFxbQ0RBVEFcXFxcWyhbXFxcXHNcXFxcU10qPykoXV0+KSl8KChOQU1FOik/KE5BTUUpKShbXj5dKik+fCgoXFxcXC8pKE5BTUUpXFxcXHMqPikpKFtePF0qKSdcbiAgLnJlcGxhY2UoL05BTUUvZywgdXRpbC5uYW1lUmVnZXhwKTtcblxuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvP1tcXFxcdzpcXFxcLVxcLl9dKykoW14+XSopPihcXFxccypcIitjZGF0YVJlZ3grXCIpKihbXjxdKyk/XCIsXCJnXCIpO1xuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvPykoKFxcXFx3KjopPyhbXFxcXHc6XFxcXC1cXC5fXSspKShbXj5dKik+KFtePF0qKShcIitjZGF0YVJlZ3grXCIoW148XSopKSooW148XSspP1wiLFwiZ1wiKTtcblxuY2xhc3MgT3JkZXJlZE9ialBhcnNlcntcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLnRhZ3NOb2RlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmRvY1R5cGVFbnRpdGllcyA9IHt9O1xuICAgIHRoaXMubGFzdEVudGl0aWVzID0ge1xuICAgICAgXCJhcG9zXCIgOiB7IHJlZ2V4OiAvJihhcG9zfCMzOXwjeDI3KTsvZywgdmFsIDogXCInXCJ9LFxuICAgICAgXCJndFwiIDogeyByZWdleDogLyYoZ3R8IzYyfCN4M0UpOy9nLCB2YWwgOiBcIj5cIn0sXG4gICAgICBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjB8I3gzQyk7L2csIHZhbCA6IFwiPFwifSxcbiAgICAgIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzR8I3gyMik7L2csIHZhbCA6IFwiXFxcIlwifSxcbiAgICB9O1xuICAgIHRoaXMuYW1wRW50aXR5ID0geyByZWdleDogLyYoYW1wfCMzOHwjeDI2KTsvZywgdmFsIDogXCImXCJ9O1xuICAgIHRoaXMuaHRtbEVudGl0aWVzID0ge1xuICAgICAgXCJzcGFjZVwiOiB7IHJlZ2V4OiAvJihuYnNwfCMxNjApOy9nLCB2YWw6IFwiIFwiIH0sXG4gICAgICAvLyBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjApOy9nLCB2YWw6IFwiPFwiIH0sXG4gICAgICAvLyBcImd0XCIgOiB7IHJlZ2V4OiAvJihndHwjNjIpOy9nLCB2YWw6IFwiPlwiIH0sXG4gICAgICAvLyBcImFtcFwiIDogeyByZWdleDogLyYoYW1wfCMzOCk7L2csIHZhbDogXCImXCIgfSxcbiAgICAgIC8vIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzQpOy9nLCB2YWw6IFwiXFxcIlwiIH0sXG4gICAgICAvLyBcImFwb3NcIiA6IHsgcmVnZXg6IC8mKGFwb3N8IzM5KTsvZywgdmFsOiBcIidcIiB9LFxuICAgICAgXCJjZW50XCIgOiB7IHJlZ2V4OiAvJihjZW50fCMxNjIpOy9nLCB2YWw6IFwiwqJcIiB9LFxuICAgICAgXCJwb3VuZFwiIDogeyByZWdleDogLyYocG91bmR8IzE2Myk7L2csIHZhbDogXCLCo1wiIH0sXG4gICAgICBcInllblwiIDogeyByZWdleDogLyYoeWVufCMxNjUpOy9nLCB2YWw6IFwiwqVcIiB9LFxuICAgICAgXCJldXJvXCIgOiB7IHJlZ2V4OiAvJihldXJvfCM4MzY0KTsvZywgdmFsOiBcIuKCrFwiIH0sXG4gICAgICBcImNvcHlyaWdodFwiIDogeyByZWdleDogLyYoY29weXwjMTY5KTsvZywgdmFsOiBcIsKpXCIgfSxcbiAgICAgIFwicmVnXCIgOiB7IHJlZ2V4OiAvJihyZWd8IzE3NCk7L2csIHZhbDogXCLCrlwiIH0sXG4gICAgICBcImluclwiIDogeyByZWdleDogLyYoaW5yfCM4Mzc3KTsvZywgdmFsOiBcIuKCuVwiIH0sXG4gICAgfTtcbiAgICB0aGlzLmFkZEV4dGVybmFsRW50aXRpZXMgPSBhZGRFeHRlcm5hbEVudGl0aWVzO1xuICAgIHRoaXMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbiAgICB0aGlzLnBhcnNlVGV4dERhdGEgPSBwYXJzZVRleHREYXRhO1xuICAgIHRoaXMucmVzb2x2ZU5hbWVTcGFjZSA9IHJlc29sdmVOYW1lU3BhY2U7XG4gICAgdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAgPSBidWlsZEF0dHJpYnV0ZXNNYXA7XG4gICAgdGhpcy5pc0l0U3RvcE5vZGUgPSBpc0l0U3RvcE5vZGU7XG4gICAgdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlO1xuICAgIHRoaXMucmVhZFN0b3BOb2RlRGF0YSA9IHJlYWRTdG9wTm9kZURhdGE7XG4gICAgdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnID0gc2F2ZVRleHRUb1BhcmVudFRhZztcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGFkZEV4dGVybmFsRW50aXRpZXMoZXh0ZXJuYWxFbnRpdGllcyl7XG4gIGNvbnN0IGVudEtleXMgPSBPYmplY3Qua2V5cyhleHRlcm5hbEVudGl0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZW50ID0gZW50S2V5c1tpXTtcbiAgICB0aGlzLmxhc3RFbnRpdGllc1tlbnRdID0ge1xuICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKFwiJlwiK2VudCtcIjtcIixcImdcIiksXG4gICAgICAgdmFsIDogZXh0ZXJuYWxFbnRpdGllc1tlbnRdXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBqUGF0aFxuICogQHBhcmFtIHtib29sZWFufSBkb250VHJpbVxuICogQHBhcmFtIHtib29sZWFufSBoYXNBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVhZk5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlRW50aXRpZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VUZXh0RGF0YSh2YWwsIHRhZ05hbWUsIGpQYXRoLCBkb250VHJpbSwgaGFzQXR0cmlidXRlcywgaXNMZWFmTm9kZSwgZXNjYXBlRW50aXRpZXMpIHtcbiAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmltVmFsdWVzICYmICFkb250VHJpbSkge1xuICAgICAgdmFsID0gdmFsLnRyaW0oKTtcbiAgICB9XG4gICAgaWYodmFsLmxlbmd0aCA+IDApe1xuICAgICAgaWYoIWVzY2FwZUVudGl0aWVzKSB2YWwgPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKHZhbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld3ZhbCA9IHRoaXMub3B0aW9ucy50YWdWYWx1ZVByb2Nlc3Nvcih0YWdOYW1lLCB2YWwsIGpQYXRoLCBoYXNBdHRyaWJ1dGVzLCBpc0xlYWZOb2RlKTtcbiAgICAgIGlmKG5ld3ZhbCA9PT0gbnVsbCB8fCBuZXd2YWwgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIC8vZG9uJ3QgcGFyc2VcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1lbHNlIGlmKHR5cGVvZiBuZXd2YWwgIT09IHR5cGVvZiB2YWwgfHwgbmV3dmFsICE9PSB2YWwpe1xuICAgICAgICAvL292ZXJ3cml0ZVxuICAgICAgICByZXR1cm4gbmV3dmFsO1xuICAgICAgfWVsc2UgaWYodGhpcy5vcHRpb25zLnRyaW1WYWx1ZXMpe1xuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2YWwsIHRoaXMub3B0aW9ucy5wYXJzZVRhZ1ZhbHVlLCB0aGlzLm9wdGlvbnMubnVtYmVyUGFyc2VPcHRpb25zKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zdCB0cmltbWVkVmFsID0gdmFsLnRyaW0oKTtcbiAgICAgICAgaWYodHJpbW1lZFZhbCA9PT0gdmFsKXtcbiAgICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2YWwsIHRoaXMub3B0aW9ucy5wYXJzZVRhZ1ZhbHVlLCB0aGlzLm9wdGlvbnMubnVtYmVyUGFyc2VPcHRpb25zKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTmFtZVNwYWNlKHRhZ25hbWUpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVOU1ByZWZpeCkge1xuICAgIGNvbnN0IHRhZ3MgPSB0YWduYW1lLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgcHJlZml4ID0gdGFnbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIGlmICh0YWdzWzBdID09PSAneG1sbnMnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGFnbmFtZSA9IHByZWZpeCArIHRhZ3NbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWduYW1lO1xufVxuXG4vL1RPRE86IGNoYW5nZSByZWdleCB0byBjYXB0dXJlIE5TXG4vL2NvbnN0IGF0dHJzUmVneCA9IG5ldyBSZWdFeHAoXCIoW1xcXFx3XFxcXC1cXFxcLlxcXFw6XSspXFxcXHMqPVxcXFxzKihbJ1xcXCJdKSgoLnxcXG4pKj8pXFxcXDJcIixcImdtXCIpO1xuY29uc3QgYXR0cnNSZWd4ID0gbmV3IFJlZ0V4cCgnKFteXFxcXHM9XSspXFxcXHMqKD1cXFxccyooW1xcJ1wiXSkoW1xcXFxzXFxcXFNdKj8pXFxcXDMpPycsICdnbScpO1xuXG5mdW5jdGlvbiBidWlsZEF0dHJpYnV0ZXNNYXAoYXR0clN0ciwgalBhdGgpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlQXR0cmlidXRlcyAmJiB0eXBlb2YgYXR0clN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBhdHRyU3RyID0gYXR0clN0ci5yZXBsYWNlKC9cXHI/XFxuL2csICcgJyk7XG4gICAgLy9hdHRyU3RyID0gYXR0clN0ciB8fCBhdHRyU3RyLnRyaW0oKTtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSB1dGlsLmdldEFsbE1hdGNoZXMoYXR0clN0ciwgYXR0cnNSZWd4KTtcbiAgICBjb25zdCBsZW4gPSBtYXRjaGVzLmxlbmd0aDsgLy9kb24ndCBtYWtlIGl0IGlubGluZVxuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnJlc29sdmVOYW1lU3BhY2UobWF0Y2hlc1tpXVsxXSk7XG4gICAgICBsZXQgb2xkVmFsID0gbWF0Y2hlc1tpXVs0XTtcbiAgICAgIGNvbnN0IGFOYW1lID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXggKyBhdHRyTmFtZTtcbiAgICAgIGlmIChhdHRyTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9sZFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmltVmFsdWVzKSB7XG4gICAgICAgICAgICBvbGRWYWwgPSBvbGRWYWwudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbGRWYWwgPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKG9sZFZhbCk7XG4gICAgICAgICAgY29uc3QgbmV3VmFsID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yKGF0dHJOYW1lLCBvbGRWYWwsIGpQYXRoKTtcbiAgICAgICAgICBpZihuZXdWYWwgPT09IG51bGwgfHwgbmV3VmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgLy9kb24ndCBwYXJzZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gb2xkVmFsO1xuICAgICAgICAgIH1lbHNlIGlmKHR5cGVvZiBuZXdWYWwgIT09IHR5cGVvZiBvbGRWYWwgfHwgbmV3VmFsICE9PSBvbGRWYWwpe1xuICAgICAgICAgICAgLy9vdmVyd3JpdGVcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IG5ld1ZhbDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vcGFyc2VcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IHBhcnNlVmFsdWUoXG4gICAgICAgICAgICAgIG9sZFZhbCxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhcnNlQXR0cmlidXRlVmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cnNbYU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIU9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lKSB7XG4gICAgICBjb25zdCBhdHRyQ29sbGVjdGlvbiA9IHt9O1xuICAgICAgYXR0ckNvbGxlY3Rpb25bdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWVdID0gYXR0cnM7XG4gICAgICByZXR1cm4gYXR0ckNvbGxlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG5jb25zdCBwYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbERhdGEpIHtcbiAgeG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTsgLy9UT0RPOiByZW1vdmUgdGhpcyBsaW5lXG4gIGNvbnN0IHhtbE9iaiA9IG5ldyB4bWxOb2RlKCcheG1sJyk7XG4gIGxldCBjdXJyZW50Tm9kZSA9IHhtbE9iajtcbiAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgbGV0IGpQYXRoID0gXCJcIjtcbiAgZm9yKGxldCBpPTA7IGk8IHhtbERhdGEubGVuZ3RoOyBpKyspey8vZm9yIGVhY2ggY2hhciBpbiBYTUwgZGF0YVxuICAgIGNvbnN0IGNoID0geG1sRGF0YVtpXTtcbiAgICBpZihjaCA9PT0gJzwnKXtcbiAgICAgIC8vIGNvbnN0IG5leHRJbmRleCA9IGkrMTtcbiAgICAgIC8vIGNvbnN0IF8ybmRDaGFyID0geG1sRGF0YVtuZXh0SW5kZXhdO1xuICAgICAgaWYoIHhtbERhdGFbaSsxXSA9PT0gJy8nKSB7Ly9DbG9zaW5nIFRhZ1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj5cIiwgaSwgXCJDbG9zaW5nIFRhZyBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICBsZXQgdGFnTmFtZSA9IHhtbERhdGEuc3Vic3RyaW5nKGkrMixjbG9zZUluZGV4KS50cmltKCk7XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KXtcbiAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIFxuICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMudGFnc05vZGVTdGFjay5wb3AoKTsvL2F2b2lkIHJlY3Vyc3Npb24sIHNldCB0aGUgcGFyZW50IHRhZyBzY29wZVxuICAgICAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgICAgIGkgPSBjbG9zZUluZGV4O1xuICAgICAgfSBlbHNlIGlmKCB4bWxEYXRhW2krMV0gPT09ICc/Jykge1xuXG4gICAgICAgIGxldCB0YWdEYXRhID0gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIGZhbHNlLCBcIj8+XCIpO1xuICAgICAgICBpZighdGFnRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiUGkgVGFnIGlzIG5vdCBjbG9zZWQuXCIpO1xuXG4gICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuICAgICAgICBpZiggKHRoaXMub3B0aW9ucy5pZ25vcmVEZWNsYXJhdGlvbiAmJiB0YWdEYXRhLnRhZ05hbWUgPT09IFwiP3htbFwiKSB8fCB0aGlzLm9wdGlvbnMuaWdub3JlUGlUYWdzKXtcblxuICAgICAgICB9ZWxzZXtcbiAgXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnRGF0YS50YWdOYW1lKTtcbiAgICAgICAgICBjaGlsZE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIFwiXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKHRhZ0RhdGEudGFnTmFtZSAhPT0gdGFnRGF0YS50YWdFeHAgJiYgdGFnRGF0YS5hdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0RhdGEudGFnRXhwLCBqUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnROb2RlLmFkZENoaWxkKGNoaWxkTm9kZSk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaSA9IHRhZ0RhdGEuY2xvc2VJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSs0LCBcIkNvbW1lbnQgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSl7XG4gICAgICAgICAgY29uc3QgY29tbWVudCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA0LCBlbmRJbmRleCAtIDIpO1xuXG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSwgWyB7IFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSA6IGNvbW1lbnQgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gZW5kSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFEJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKTtcbiAgICAgICAgdGhpcy5kb2NUeXBlRW50aXRpZXMgPSByZXN1bHQuZW50aXRpZXM7XG4gICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgIH1lbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykge1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIkNEQVRBIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgY29uc3QgdGFnRXhwID0geG1sRGF0YS5zdWJzdHJpbmcoaSArIDksY2xvc2VJbmRleCk7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgLy9jZGF0YSBzaG91bGQgYmUgc2V0IGV2ZW4gaWYgaXQgaXMgMCBsZW5ndGggc3RyaW5nXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKXtcbiAgICAgICAgICAvLyBsZXQgdmFsID0gdGhpcy5wYXJzZVRleHREYXRhKHRhZ0V4cCwgdGhpcy5vcHRpb25zLmNkYXRhUHJvcE5hbWUsIGpQYXRoICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIC8vIGlmKCF2YWwpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lLCBbIHsgW3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdIDogdGFnRXhwIH0gXSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnRXhwLCBjdXJyZW50Tm9kZS50YWduYW1lLCBqUGF0aCwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmKHZhbCA9PSB1bmRlZmluZWQpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGkgPSBjbG9zZUluZGV4ICsgMjtcbiAgICAgIH1lbHNlIHsvL09wZW5pbmcgdGFnXG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgdGhpcy4gb3B0aW9ucy5yZW1vdmVOU1ByZWZpeCk7XG4gICAgICAgIGxldCB0YWdOYW1lPSByZXN1bHQudGFnTmFtZTtcbiAgICAgICAgbGV0IHRhZ0V4cCA9IHJlc3VsdC50YWdFeHA7XG4gICAgICAgIGxldCBhdHRyRXhwUHJlc2VudCA9IHJlc3VsdC5hdHRyRXhwUHJlc2VudDtcbiAgICAgICAgbGV0IGNsb3NlSW5kZXggPSByZXN1bHQuY2xvc2VJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUpIHtcbiAgICAgICAgICB0YWdOYW1lID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vc2F2ZSB0ZXh0IGFzIGNoaWxkIG5vZGVcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIHRleHREYXRhKSB7XG4gICAgICAgICAgaWYoY3VycmVudE5vZGUudGFnbmFtZSAhPT0gJyF4bWwnKXtcbiAgICAgICAgICAgIC8vd2hlbiBuZXN0ZWQgdGFnIGlzIGZvdW5kXG4gICAgICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodGFnTmFtZSAhPT0geG1sT2JqLnRhZ25hbWUpe1xuICAgICAgICAgIGpQYXRoICs9IGpQYXRoID8gXCIuXCIgKyB0YWdOYW1lIDogdGFnTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgbGFzdCB0YWcgd2FzIHVucGFpcmVkIHRhZ1xuICAgICAgICBjb25zdCBsYXN0VGFnID0gY3VycmVudE5vZGU7XG4gICAgICAgIGlmKGxhc3RUYWcgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGxhc3RUYWcudGFnbmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0l0U3RvcE5vZGUodGhpcy5vcHRpb25zLnN0b3BOb2RlcywgalBhdGgsIHRhZ05hbWUpKSB7IC8vVE9ETzogbmFtZXNwYWNlXG4gICAgICAgICAgbGV0IHRhZ0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIC8vc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9ib29sZWFuIHRhZ1xuICAgICAgICAgIGVsc2UgaWYodGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSl7XG4gICAgICAgICAgICBpID0gcmVzdWx0LmNsb3NlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vbm9ybWFsIHRhZ1xuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAvL3JlYWQgdW50aWwgY2xvc2luZyB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZFN0b3BOb2RlRGF0YSh4bWxEYXRhLCB0YWdOYW1lLCBjbG9zZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZighcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZW5kIG9mICR7dGFnTmFtZX1gKTtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSByZXN1bHQudGFnQ29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdOYW1lKTtcbiAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdFeHAsIGpQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGFnQ29udGVudCkge1xuICAgICAgICAgICAgdGFnQ29udGVudCA9IHRoaXMucGFyc2VUZXh0RGF0YSh0YWdDb250ZW50LCB0YWdOYW1lLCBqUGF0aCwgdHJ1ZSwgYXR0ckV4cFByZXNlbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICAgIGNoaWxkTm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgdGFnQ29udGVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgfWVsc2V7XG4gIC8vc2VsZkNsb3NpbmcgdGFnXG4gICAgICAgICAgaWYodGFnRXhwLmxlbmd0aCA+IDAgJiYgdGFnRXhwLmxhc3RJbmRleE9mKFwiL1wiKSA9PT0gdGFnRXhwLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgaWYodGFnTmFtZVt0YWdOYW1lLmxlbmd0aCAtIDFdID09PSBcIi9cIil7IC8vcmVtb3ZlIHRyYWlsaW5nICcvJ1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoMCwgdGFnTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnTmFtZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0YWdFeHAgPSB0YWdFeHAuc3Vic3RyKDAsIHRhZ0V4cC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdOYW1lKTtcbiAgICAgICAgICAgIGlmKHRhZ05hbWUgIT09IHRhZ0V4cCAmJiBhdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgLy9vcGVuaW5nIHRhZ1xuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSggdGFnTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnRhZ3NOb2RlU3RhY2sucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRhZ05hbWUgIT09IHRhZ0V4cCAmJiBhdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHREYXRhID0gXCJcIjtcbiAgICAgICAgICBpID0gY2xvc2VJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgdGV4dERhdGEgKz0geG1sRGF0YVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHhtbE9iai5jaGlsZDtcbn1cblxuY29uc3QgcmVwbGFjZUVudGl0aWVzVmFsdWUgPSBmdW5jdGlvbih2YWwpe1xuXG4gIGlmKHRoaXMub3B0aW9ucy5wcm9jZXNzRW50aXRpZXMpe1xuICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmRvY1R5cGVFbnRpdGllcyl7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmRvY1R5cGVFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCBlbnRpdHkucmVneCwgZW50aXR5LnZhbCk7XG4gICAgfVxuICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmxhc3RFbnRpdGllcyl7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmxhc3RFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCBlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgICBpZih0aGlzLm9wdGlvbnMuaHRtbEVudGl0aWVzKXtcbiAgICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmh0bWxFbnRpdGllcyl7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuaHRtbEVudGl0aWVzW2VudGl0eU5hbWVdO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ2V4LCBlbnRpdHkudmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoIHRoaXMuYW1wRW50aXR5LnJlZ2V4LCB0aGlzLmFtcEVudGl0eS52YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBzYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgsIGlzTGVhZk5vZGUpIHtcbiAgaWYgKHRleHREYXRhKSB7IC8vc3RvcmUgcHJldmlvdXNseSBjb2xsZWN0ZWQgZGF0YSBhcyB0ZXh0Tm9kZVxuICAgIGlmKGlzTGVhZk5vZGUgPT09IHVuZGVmaW5lZCkgaXNMZWFmTm9kZSA9IE9iamVjdC5rZXlzKGN1cnJlbnROb2RlLmNoaWxkKS5sZW5ndGggPT09IDBcbiAgICBcbiAgICB0ZXh0RGF0YSA9IHRoaXMucGFyc2VUZXh0RGF0YSh0ZXh0RGF0YSxcbiAgICAgIGN1cnJlbnROb2RlLnRhZ25hbWUsXG4gICAgICBqUGF0aCxcbiAgICAgIGZhbHNlLFxuICAgICAgY3VycmVudE5vZGVbXCI6QFwiXSA/IE9iamVjdC5rZXlzKGN1cnJlbnROb2RlW1wiOkBcIl0pLmxlbmd0aCAhPT0gMCA6IGZhbHNlLFxuICAgICAgaXNMZWFmTm9kZSk7XG5cbiAgICBpZiAodGV4dERhdGEgIT09IHVuZGVmaW5lZCAmJiB0ZXh0RGF0YSAhPT0gXCJcIilcbiAgICAgIGN1cnJlbnROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCB0ZXh0RGF0YSk7XG4gICAgdGV4dERhdGEgPSBcIlwiO1xuICB9XG4gIHJldHVybiB0ZXh0RGF0YTtcbn1cblxuLy9UT0RPOiB1c2UgalBhdGggdG8gc2ltcGxpZnkgdGhlIGxvZ2ljXG4vKipcbiAqIFxuICogQHBhcmFtIHtzdHJpbmdbXX0gc3RvcE5vZGVzIFxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFRhZ05hbWUgXG4gKi9cbmZ1bmN0aW9uIGlzSXRTdG9wTm9kZShzdG9wTm9kZXMsIGpQYXRoLCBjdXJyZW50VGFnTmFtZSl7XG4gIGNvbnN0IGFsbE5vZGVzRXhwID0gXCIqLlwiICsgY3VycmVudFRhZ05hbWU7XG4gIGZvciAoY29uc3Qgc3RvcE5vZGVQYXRoIGluIHN0b3BOb2Rlcykge1xuICAgIGNvbnN0IHN0b3BOb2RlRXhwID0gc3RvcE5vZGVzW3N0b3BOb2RlUGF0aF07XG4gICAgaWYoIGFsbE5vZGVzRXhwID09PSBzdG9wTm9kZUV4cCB8fCBqUGF0aCA9PT0gc3RvcE5vZGVFeHAgICkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRhZyBFeHByZXNzaW9uIGFuZCB3aGVyZSBpdCBpcyBlbmRpbmcgaGFuZGxpbmcgc2luZ2xlLWRvYnVsZSBxdW90ZXMgc2l0dWF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRGF0YSBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIHN0YXJ0aW5nIGluZGV4XG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gdGFnRXhwV2l0aENsb3NpbmdJbmRleCh4bWxEYXRhLCBpLCBjbG9zaW5nQ2hhciA9IFwiPlwiKXtcbiAgbGV0IGF0dHJCb3VuZGFyeTtcbiAgbGV0IHRhZ0V4cCA9IFwiXCI7XG4gIGZvciAobGV0IGluZGV4ID0gaTsgaW5kZXggPCB4bWxEYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBjaCA9IHhtbERhdGFbaW5kZXhdO1xuICAgIGlmIChhdHRyQm91bmRhcnkpIHtcbiAgICAgICAgaWYgKGNoID09PSBhdHRyQm91bmRhcnkpIGF0dHJCb3VuZGFyeSA9IFwiXCI7Ly9yZXNldFxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgIGF0dHJCb3VuZGFyeSA9IGNoO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IGNsb3NpbmdDaGFyWzBdKSB7XG4gICAgICBpZihjbG9zaW5nQ2hhclsxXSl7XG4gICAgICAgIGlmKHhtbERhdGFbaW5kZXggKyAxXSA9PT0gY2xvc2luZ0NoYXJbMV0pe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0YWdFeHAsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHRhZ0V4cCxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHQnKSB7XG4gICAgICBjaCA9IFwiIFwiXG4gICAgfVxuICAgIHRhZ0V4cCArPSBjaDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIHN0ciwgaSwgZXJyTXNnKXtcbiAgY29uc3QgY2xvc2luZ0luZGV4ID0geG1sRGF0YS5pbmRleE9mKHN0ciwgaSk7XG4gIGlmKGNsb3NpbmdJbmRleCA9PT0gLTEpe1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpXG4gIH1lbHNle1xuICAgIHJldHVybiBjbG9zaW5nSW5kZXggKyBzdHIubGVuZ3RoIC0gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkVGFnRXhwKHhtbERhdGEsaSwgcmVtb3ZlTlNQcmVmaXgsIGNsb3NpbmdDaGFyID0gXCI+XCIpe1xuICBjb25zdCByZXN1bHQgPSB0YWdFeHBXaXRoQ2xvc2luZ0luZGV4KHhtbERhdGEsIGkrMSwgY2xvc2luZ0NoYXIpO1xuICBpZighcmVzdWx0KSByZXR1cm47XG4gIGxldCB0YWdFeHAgPSByZXN1bHQuZGF0YTtcbiAgY29uc3QgY2xvc2VJbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSB0YWdFeHAuc2VhcmNoKC9cXHMvKTtcbiAgbGV0IHRhZ05hbWUgPSB0YWdFeHA7XG4gIGxldCBhdHRyRXhwUHJlc2VudCA9IHRydWU7XG4gIGlmKHNlcGFyYXRvckluZGV4ICE9PSAtMSl7Ly9zZXBhcmF0ZSB0YWcgbmFtZSBhbmQgYXR0cmlidXRlcyBleHByZXNzaW9uXG4gICAgdGFnTmFtZSA9IHRhZ0V4cC5zdWJzdHIoMCwgc2VwYXJhdG9ySW5kZXgpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIHRhZ0V4cCA9IHRhZ0V4cC5zdWJzdHIoc2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgfVxuXG4gIGlmKHJlbW92ZU5TUHJlZml4KXtcbiAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgIGF0dHJFeHBQcmVzZW50ID0gdGFnTmFtZSAhPT0gcmVzdWx0LmRhdGEuc3Vic3RyKGNvbG9uSW5kZXggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgdGFnRXhwOiB0YWdFeHAsXG4gICAgY2xvc2VJbmRleDogY2xvc2VJbmRleCxcbiAgICBhdHRyRXhwUHJlc2VudDogYXR0ckV4cFByZXNlbnQsXG4gIH1cbn1cbi8qKlxuICogZmluZCBwYWlyZWQgdGFnIGZvciBhIHN0b3Agbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGEgXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFxuICovXG5mdW5jdGlvbiByZWFkU3RvcE5vZGVEYXRhKHhtbERhdGEsIHRhZ05hbWUsIGkpe1xuICBjb25zdCBzdGFydEluZGV4ID0gaTtcbiAgLy8gU3RhcnRpbmcgYXQgMSBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgYW4gb3BlbiB0YWdcbiAgbGV0IG9wZW5UYWdDb3VudCA9IDE7XG5cbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYoIHhtbERhdGFbaV0gPT09IFwiPFwiKXsgXG4gICAgICBpZiAoeG1sRGF0YVtpKzFdID09PSBcIi9cIikgey8vY2xvc2UgdGFnXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI+XCIsIGksIGAke3RhZ05hbWV9IGlzIG5vdCBjbG9zZWRgKTtcbiAgICAgICAgICBsZXQgY2xvc2VUYWdOYW1lID0geG1sRGF0YS5zdWJzdHJpbmcoaSsyLGNsb3NlSW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICBpZihjbG9zZVRhZ05hbWUgPT09IHRhZ05hbWUpe1xuICAgICAgICAgICAgb3BlblRhZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAob3BlblRhZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFnQ29udGVudDogeG1sRGF0YS5zdWJzdHJpbmcoc3RhcnRJbmRleCwgaSksXG4gICAgICAgICAgICAgICAgaSA6IGNsb3NlSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhW2krMV0gPT09ICc/JykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj8+XCIsIGkrMSwgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAzKSA9PT0gJyEtLScpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSszLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDIpID09PSAnIVsnKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiXV0+XCIsIGksIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIikgLSAyO1xuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWdEYXRhID0gcmVhZFRhZ0V4cCh4bWxEYXRhLCBpLCAnPicpXG5cbiAgICAgICAgICBpZiAodGFnRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgb3BlblRhZ05hbWUgPSB0YWdEYXRhICYmIHRhZ0RhdGEudGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSA9PT0gdGFnTmFtZSAmJiB0YWdEYXRhLnRhZ0V4cFt0YWdEYXRhLnRhZ0V4cC5sZW5ndGgtMV0gIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaT10YWdEYXRhLmNsb3NlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH0vL2VuZCBmb3IgbG9vcFxufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHZhbCwgc2hvdWxkUGFyc2UsIG9wdGlvbnMpIHtcbiAgaWYgKHNob3VsZFBhcnNlICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgLy9jb25zb2xlLmxvZyhvcHRpb25zKVxuICAgIGNvbnN0IG5ld3ZhbCA9IHZhbC50cmltKCk7XG4gICAgaWYobmV3dmFsID09PSAndHJ1ZScgKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIGlmKG5ld3ZhbCA9PT0gJ2ZhbHNlJyApIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIHJldHVybiB0b051bWJlcih2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmICh1dGlsLmlzRXhpc3QodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gT3JkZXJlZE9ialBhcnNlcjtcbiIsImNvbnN0IHsgYnVpbGRPcHRpb25zfSA9IHJlcXVpcmUoXCIuL09wdGlvbnNCdWlsZGVyXCIpO1xuY29uc3QgT3JkZXJlZE9ialBhcnNlciA9IHJlcXVpcmUoXCIuL09yZGVyZWRPYmpQYXJzZXJcIik7XG5jb25zdCB7IHByZXR0aWZ5fSA9IHJlcXVpcmUoXCIuL25vZGUyanNvblwiKTtcbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcicpO1xuXG5jbGFzcyBYTUxQYXJzZXJ7XG4gICAgXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxFbnRpdGllcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBidWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBYTUwgZGF0cyB0byBKUyBvYmplY3QgXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSB4bWxEYXRhIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHZhbGlkYXRpb25PcHRpb24gXG4gICAgICovXG4gICAgcGFyc2UoeG1sRGF0YSx2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgaWYodHlwZW9mIHhtbERhdGEgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YS50b1N0cmluZyl7XG4gICAgICAgICAgICB4bWxEYXRhID0geG1sRGF0YS50b1N0cmluZygpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlhNTCBkYXRhIGlzIGFjY2VwdGVkIGluIFN0cmluZyBvciBCeXRlc1tdIGZvcm0uXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHZhbGlkYXRpb25PcHRpb24pe1xuICAgICAgICAgICAgaWYodmFsaWRhdGlvbk9wdGlvbiA9PT0gdHJ1ZSkgdmFsaWRhdGlvbk9wdGlvbiA9IHt9OyAvL3ZhbGlkYXRlIHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZSh4bWxEYXRhLCB2YWxpZGF0aW9uT3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIGAke3Jlc3VsdC5lcnIubXNnfToke3Jlc3VsdC5lcnIubGluZX06JHtyZXN1bHQuZXJyLmNvbH1gIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPYmpQYXJzZXIgPSBuZXcgT3JkZXJlZE9ialBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBvcmRlcmVkT2JqUGFyc2VyLmFkZEV4dGVybmFsRW50aXRpZXModGhpcy5leHRlcm5hbEVudGl0aWVzKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFJlc3VsdCA9IG9yZGVyZWRPYmpQYXJzZXIucGFyc2VYbWwoeG1sRGF0YSk7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU9yZGVyIHx8IG9yZGVyZWRSZXN1bHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9yZGVyZWRSZXN1bHQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIHByZXR0aWZ5KG9yZGVyZWRSZXN1bHQsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIEVudGl0eSB3aGljaCBpcyBub3QgYnkgZGVmYXVsdCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICAgICovXG4gICAgYWRkRW50aXR5KGtleSwgdmFsdWUpe1xuICAgICAgICBpZih2YWx1ZS5pbmRleE9mKFwiJlwiKSAhPT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5IHZhbHVlIGNhbid0IGhhdmUgJyYnXCIpXG4gICAgICAgIH1lbHNlIGlmKGtleS5pbmRleE9mKFwiJlwiKSAhPT0gLTEgfHwga2V5LmluZGV4T2YoXCI7XCIpICE9PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgbXVzdCBiZSBzZXQgd2l0aG91dCAnJicgYW5kICc7Jy4gRWcuIHVzZSAnI3hEJyBmb3IgJyYjeEQ7J1wiKVxuICAgICAgICB9ZWxzZSBpZih2YWx1ZSA9PT0gXCImXCIpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IHdpdGggdmFsdWUgJyYnIGlzIG5vdCBwZXJtaXR0ZWRcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5leHRlcm5hbEVudGl0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYTUxQYXJzZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFxuICogQHBhcmFtIHthcnJheX0gbm9kZSBcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHByZXR0aWZ5KG5vZGUsIG9wdGlvbnMpe1xuICByZXR1cm4gY29tcHJlc3MoIG5vZGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFxuICogQHBhcmFtIHthcnJheX0gYXJyIFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGggXG4gKiBAcmV0dXJucyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3MoYXJyLCBvcHRpb25zLCBqUGF0aCl7XG4gIGxldCB0ZXh0O1xuICBjb25zdCBjb21wcmVzc2VkT2JqID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnT2JqID0gYXJyW2ldO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcE5hbWUodGFnT2JqKTtcbiAgICBsZXQgbmV3SnBhdGggPSBcIlwiO1xuICAgIGlmKGpQYXRoID09PSB1bmRlZmluZWQpIG5ld0pwYXRoID0gcHJvcGVydHk7XG4gICAgZWxzZSBuZXdKcGF0aCA9IGpQYXRoICsgXCIuXCIgKyBwcm9wZXJ0eTtcblxuICAgIGlmKHByb3BlcnR5ID09PSBvcHRpb25zLnRleHROb2RlTmFtZSl7XG4gICAgICBpZih0ZXh0ID09PSB1bmRlZmluZWQpIHRleHQgPSB0YWdPYmpbcHJvcGVydHldO1xuICAgICAgZWxzZSB0ZXh0ICs9IFwiXCIgKyB0YWdPYmpbcHJvcGVydHldO1xuICAgIH1lbHNlIGlmKHByb3BlcnR5ID09PSB1bmRlZmluZWQpe1xuICAgICAgY29udGludWU7XG4gICAgfWVsc2UgaWYodGFnT2JqW3Byb3BlcnR5XSl7XG4gICAgICBcbiAgICAgIGxldCB2YWwgPSBjb21wcmVzcyh0YWdPYmpbcHJvcGVydHldLCBvcHRpb25zLCBuZXdKcGF0aCk7XG4gICAgICBjb25zdCBpc0xlYWYgPSBpc0xlYWZUYWcodmFsLCBvcHRpb25zKTtcblxuICAgICAgaWYodGFnT2JqW1wiOkBcIl0pe1xuICAgICAgICBhc3NpZ25BdHRyaWJ1dGVzKCB2YWwsIHRhZ09ialtcIjpAXCJdLCBuZXdKcGF0aCwgb3B0aW9ucyk7XG4gICAgICB9ZWxzZSBpZihPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMSAmJiB2YWxbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdICE9PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuYWx3YXlzQ3JlYXRlVGV4dE5vZGUpe1xuICAgICAgICB2YWwgPSB2YWxbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdO1xuICAgICAgfWVsc2UgaWYoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDApe1xuICAgICAgICBpZihvcHRpb25zLmFsd2F5c0NyZWF0ZVRleHROb2RlKSB2YWxbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gXCJcIjtcbiAgICAgICAgZWxzZSB2YWwgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBpZihjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkICYmIGNvbXByZXNzZWRPYmouaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGNvbXByZXNzZWRPYmpbcHJvcGVydHldKSkge1xuICAgICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSBbIGNvbXByZXNzZWRPYmpbcHJvcGVydHldIF07XG4gICAgICAgIH1cbiAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0ucHVzaCh2YWwpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIC8vVE9ETzogaWYgYSBub2RlIGlzIG5vdCBhbiBhcnJheSwgdGhlbiBjaGVjayBpZiBpdCBzaG91bGQgYmUgYW4gYXJyYXlcbiAgICAgICAgLy9hbHNvIGRldGVybWluZSBpZiBpdCBpcyBhIGxlYWYgbm9kZVxuICAgICAgICBpZiAob3B0aW9ucy5pc0FycmF5KHByb3BlcnR5LCBuZXdKcGF0aCwgaXNMZWFmICkpIHtcbiAgICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSA9IFt2YWxdO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfVxuICAvLyBpZih0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkgY29tcHJlc3NlZE9ialtvcHRpb25zLnRleHROb2RlTmFtZV0gPSB0ZXh0O1xuICBpZih0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIil7XG4gICAgaWYodGV4dC5sZW5ndGggPiAwKSBjb21wcmVzc2VkT2JqW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IHRleHQ7XG4gIH1lbHNlIGlmKHRleHQgIT09IHVuZGVmaW5lZCkgY29tcHJlc3NlZE9ialtvcHRpb25zLnRleHROb2RlTmFtZV0gPSB0ZXh0O1xuICByZXR1cm4gY29tcHJlc3NlZE9iajtcbn1cblxuZnVuY3Rpb24gcHJvcE5hbWUob2JqKXtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYoa2V5ICE9PSBcIjpAXCIpIHJldHVybiBrZXk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlcyhvYmosIGF0dHJNYXAsIGpwYXRoLCBvcHRpb25zKXtcbiAgaWYgKGF0dHJNYXApIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXR0ck1hcCk7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHJyTmFtZSA9IGtleXNbaV07XG4gICAgICBpZiAob3B0aW9ucy5pc0FycmF5KGF0cnJOYW1lLCBqcGF0aCArIFwiLlwiICsgYXRyck5hbWUsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIG9ialthdHJyTmFtZV0gPSBbIGF0dHJNYXBbYXRyck5hbWVdIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbYXRyck5hbWVdID0gYXR0ck1hcFthdHJyTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGVhZlRhZyhvYmosIG9wdGlvbnMpe1xuICBjb25zdCBwcm9wQ291bnQgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgaWYoIHByb3BDb3VudCA9PT0gMCB8fCAocHJvcENvdW50ID09PSAxICYmIG9ialtvcHRpb25zLnRleHROb2RlTmFtZV0pICkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMucHJldHRpZnkgPSBwcmV0dGlmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgWG1sTm9kZXtcbiAgY29uc3RydWN0b3IodGFnbmFtZSkge1xuICAgIHRoaXMudGFnbmFtZSA9IHRhZ25hbWU7XG4gICAgdGhpcy5jaGlsZCA9IFtdOyAvL25lc3RlZCB0YWdzLCB0ZXh0LCBjZGF0YSwgY29tbWVudHMgaW4gb3JkZXJcbiAgICB0aGlzW1wiOkBcIl0gPSB7fTsgLy9hdHRyaWJ1dGVzIG1hcFxuICB9XG4gIGFkZChrZXksdmFsKXtcbiAgICAvLyB0aGlzLmNoaWxkLnB1c2goIHtuYW1lIDoga2V5LCB2YWw6IHZhbCwgaXNDZGF0YTogaXNDZGF0YSB9KTtcbiAgICB0aGlzLmNoaWxkLnB1c2goIHtba2V5XTogdmFsIH0pO1xuICB9XG4gIGFkZENoaWxkKG5vZGUpIHtcbiAgICBpZihub2RlW1wiOkBcIl0gJiYgT2JqZWN0LmtleXMobm9kZVtcIjpAXCJdKS5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCwgW1wiOkBcIl06IG5vZGVbXCI6QFwiXSB9KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCB9KTtcbiAgICB9XG4gIH07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWG1sTm9kZTsiLCJ2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuXG4vLyBtYWtlIGl0IGEgU3RyZWFtXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXG4gKiBDYW4gYmUgdXNlZCB0byBzdWJtaXQgZm9ybXNcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxuICovXG5mdW5jdGlvbiBGb3JtRGF0YShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZUxlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSA9IFtdO1xuXG4gIENvbWJpbmVkU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG59XG5cbkZvcm1EYXRhLkxJTkVfQlJFQUsgPSAnXFxyXFxuJztcbkZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBhbGxvdyBmaWxlbmFtZSBhcyBzaW5nbGUgb3B0aW9uXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZmlsZW5hbWU6IG9wdGlvbnN9O1xuICB9XG5cbiAgdmFyIGFwcGVuZCA9IENvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQuYmluZCh0aGlzKTtcblxuICAvLyBhbGwgdGhhdCBzdHJlYW15IGJ1c2luZXNzIGNhbid0IGhhbmRsZSBudW1iZXJzXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVsaXhnZS9ub2RlLWZvcm0tZGF0YS9pc3N1ZXMvMzhcbiAgaWYgKHV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBQbGVhc2UgY29udmVydCB5b3VyIGFycmF5IGludG8gc3RyaW5nXG4gICAgLy8gdGhlIHdheSB3ZWIgc2VydmVyIGV4cGVjdHMgaXRcbiAgICB0aGlzLl9lcnJvcihuZXcgRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuX211bHRpUGFydEhlYWRlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKCk7XG5cbiAgYXBwZW5kKGhlYWRlcik7XG4gIGFwcGVuZCh2YWx1ZSk7XG4gIGFwcGVuZChmb290ZXIpO1xuXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB2YWx1ZUxlbmd0aCA9IDA7XG5cbiAgLy8gdXNlZCB3LyBnZXRMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuICAvLyBlLmcuIGZvciBzdHJlYW1pbmcgZGlyZWN0bHkgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIsXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXG4gIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XG5cbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cbiAgICBCdWZmZXIuYnl0ZUxlbmd0aChoZWFkZXIpICtcbiAgICBGb3JtRGF0YS5MSU5FX0JSRUFLLmxlbmd0aDtcblxuICAvLyBlbXB0eSBvciBlaXRoZXIgZG9lc24ndCBoYXZlIHBhdGggb3Igbm90IGFuIGh0dHAgcmVzcG9uc2Ugb3Igbm90IGEgc3RyZWFtXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBubyBuZWVkIHRvIGJvdGhlciB3aXRoIHRoZSBsZW5ndGhcbiAgaWYgKCFvcHRpb25zLmtub3duTGVuZ3RoKSB7XG4gICAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlLnB1c2godmFsdWUpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xlbmd0aFJldHJpZXZlciA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaykge1xuXG4gIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZmQnKSkge1xuXG4gICAgLy8gdGFrZSByZWFkIHJhbmdlIGludG8gYSBhY2NvdW50XG4gICAgLy8gYGVuZGAgPSBJbmZpbml0eSDigJM+IHJlYWQgZmlsZSB0aWxsIHRoZSBlbmRcbiAgICAvL1xuICAgIC8vIFRPRE86IExvb2tzIGxpa2UgdGhlcmUgaXMgYnVnIGluIE5vZGUgZnMuY3JlYXRlUmVhZFN0cmVhbVxuICAgIC8vIGl0IGRvZXNuJ3QgcmVzcGVjdCBgZW5kYCBvcHRpb25zIHdpdGhvdXQgYHN0YXJ0YCBvcHRpb25zXG4gICAgLy8gRml4IGl0IHdoZW4gbm9kZSBmaXhlcyBpdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzc4MTlcbiAgICBpZiAodmFsdWUuZW5kICE9IHVuZGVmaW5lZCAmJiB2YWx1ZS5lbmQgIT0gSW5maW5pdHkgJiYgdmFsdWUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIHdoZW4gZW5kIHNwZWNpZmllZFxuICAgICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgcmFuZ2VcbiAgICAgIC8vIGluY2x1c2l2ZSwgc3RhcnRzIHdpdGggMFxuICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUuZW5kICsgMSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCkpO1xuXG4gICAgLy8gbm90IHRoYXQgZmFzdCBzbm9vcHlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RpbGwgbmVlZCB0byBmZXRjaCBmaWxlIHNpemUgZnJvbSBmc1xuICAgICAgZnMuc3RhdCh2YWx1ZS5wYXRoLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcblxuICAgICAgICB2YXIgZmlsZVNpemU7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZpbmFsIHNpemUgYmFzZWQgb24gdGhlIHJhbmdlIG9wdGlvbnNcbiAgICAgICAgZmlsZVNpemUgPSBzdGF0LnNpemUgLSAodmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IDApO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlU2l6ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgLy8gb3IgaHR0cCByZXNwb25zZVxuICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgK3ZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuXG4gIC8vIG9yIHJlcXVlc3Qgc3RyZWFtIGh0dHA6Ly9naXRodWIuY29tL21pa2VhbC9yZXF1ZXN0XG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBNb2R1bGUnKSkge1xuICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcbiAgICB2YWx1ZS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFsdWUucGF1c2UoKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsICtyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9KTtcbiAgICB2YWx1ZS5yZXN1bWUoKTtcblxuICAvLyBzb21ldGhpbmcgZWxzZVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCdVbmtub3duIHN0cmVhbScpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBjdXN0b20gaGVhZGVyIHNwZWNpZmllZCAoYXMgc3RyaW5nKT9cbiAgLy8gaXQgYmVjb21lcyByZXNwb25zaWJsZSBmb3IgYm91bmRhcnlcbiAgLy8gKGUuZy4gdG8gaGFuZGxlIGV4dHJhIENSTEZzIG9uIC5ORVQgc2VydmVycylcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvcHRpb25zLmhlYWRlcjtcbiAgfVxuXG4gIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50RGlzcG9zaXRpb24odmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9nZXRDb250ZW50VHlwZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIHZhciBoZWFkZXJzICA9IHtcbiAgICAvLyBhZGQgY3VzdG9tIGRpc3Bvc2l0aW9uIGFzIHRoaXJkIGVsZW1lbnQgb3Iga2VlcCBpdCB0d28gZWxlbWVudHMgaWYgbm90XG4gICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBbJ2Zvcm0tZGF0YScsICduYW1lPVwiJyArIGZpZWxkICsgJ1wiJ10uY29uY2F0KGNvbnRlbnREaXNwb3NpdGlvbiB8fCBbXSksXG4gICAgLy8gaWYgbm8gY29udGVudCB0eXBlLiBhbGxvdyBpdCB0byBiZSBlbXB0eSBhcnJheVxuICAgICdDb250ZW50LVR5cGUnOiBbXS5jb25jYXQoY29udGVudFR5cGUgfHwgW10pXG4gIH07XG5cbiAgLy8gYWxsb3cgY3VzdG9tIGhlYWRlcnMuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ29iamVjdCcpIHtcbiAgICBwb3B1bGF0ZShoZWFkZXJzLCBvcHRpb25zLmhlYWRlcik7XG4gIH1cblxuICB2YXIgaGVhZGVyO1xuICBmb3IgKHZhciBwcm9wIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgIGhlYWRlciA9IGhlYWRlcnNbcHJvcF07XG5cbiAgICAvLyBza2lwIG51bGxpc2ggaGVhZGVycy5cbiAgICBpZiAoaGVhZGVyID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYWxsIGhlYWRlcnMgdG8gYXJyYXlzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIgPSBbaGVhZGVyXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbm9uLWVtcHR5IGhlYWRlcnMuXG4gICAgaWYgKGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIGNvbnRlbnRzICs9IHByb3AgKyAnOiAnICsgaGVhZGVyLmpvaW4oJzsgJykgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgRm9ybURhdGEuTElORV9CUkVBSyArIGNvbnRlbnRzICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudERpc3Bvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcblxuICB2YXIgZmlsZW5hbWVcbiAgICAsIGNvbnRlbnREaXNwb3NpdGlvblxuICAgIDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsZXBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVwYXRoIGZvciByZWxhdGl2ZSBwYXRoc1xuICAgIGZpbGVuYW1lID0gcGF0aC5ub3JtYWxpemUob3B0aW9ucy5maWxlcGF0aCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVuYW1lIHRha2UgcHJlY2VkZW5jZVxuICAgIC8vIGZvcm1pZGFibGUgYW5kIHRoZSBicm93c2VyIGFkZCBhIG5hbWUgcHJvcGVydHlcbiAgICAvLyBmcy0gYW5kIHJlcXVlc3QtIHN0cmVhbXMgaGF2ZSBwYXRoIHByb3BlcnR5XG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgIC8vIG9yIHRyeSBodHRwIHJlc3BvbnNlXG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHZhbHVlLmNsaWVudC5faHR0cE1lc3NhZ2UucGF0aCB8fCAnJyk7XG4gIH1cblxuICBpZiAoZmlsZW5hbWUpIHtcbiAgICBjb250ZW50RGlzcG9zaXRpb24gPSAnZmlsZW5hbWU9XCInICsgZmlsZW5hbWUgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnREaXNwb3NpdGlvbjtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIC8vIHVzZSBjdXN0b20gY29udGVudC10eXBlIGFib3ZlIGFsbFxuICB2YXIgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXG4gIC8vIG9yIHRyeSBgbmFtZWAgZnJvbSBmb3JtaWRhYmxlLCBicm93c2VyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUubmFtZSkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUubmFtZSk7XG4gIH1cblxuICAvLyBvciB0cnkgYHBhdGhgIGZyb20gZnMtLCByZXF1ZXN0LSBzdHJlYW1zXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucGF0aCkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUucGF0aCk7XG4gIH1cblxuICAvLyBvciBpZiBpdCdzIGh0dHAtcmVwb25zZVxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY29udGVudFR5cGUgPSB2YWx1ZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgfVxuXG4gIC8vIG9yIGd1ZXNzIGl0IGZyb20gdGhlIGZpbGVwYXRoIG9yIGZpbGVuYW1lXG4gIGlmICghY29udGVudFR5cGUgJiYgKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSkpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUgaWYgYHZhbHVlYCBpcyBub3Qgc2ltcGxlIHZhbHVlXG4gIGlmICghY29udGVudFR5cGUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgY29udGVudFR5cGUgPSBGb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50VHlwZTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XG5cbiAgICB2YXIgbGFzdFBhcnQgPSAodGhpcy5fc3RyZWFtcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChsYXN0UGFydCkge1xuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xuICAgIH1cblxuICAgIG5leHQoZm9vdGVyKTtcbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sYXN0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcjtcbiAgdmFyIGZvcm1IZWFkZXJzID0ge1xuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxuICB9O1xuXG4gIGZvciAoaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XG4gICAgaWYgKHVzZXJIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgIGZvcm1IZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHVzZXJIZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1IZWFkZXJzO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnNldEJvdW5kYXJ5ID0gZnVuY3Rpb24oYm91bmRhcnkpIHtcbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2JvdW5kYXJ5KSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVCb3VuZGFyeSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIuYWxsb2MoIDAgKTtcbiAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRCb3VuZGFyeSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgZm9ybSBjb250ZW50LiBBZGQgTGluZSBicmVha3MgdG8gdGhlIGVuZCBvZiBkYXRhLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc3RyZWFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAvLyBBZGQgY29udGVudCB0byB0aGUgYnVmZmVyLlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHRoaXMuX3N0cmVhbXNbaV0pKSB7XG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgdGhpcy5fc3RyZWFtc1tpXV0pO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX3N0cmVhbXNbaV0pXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBicmVhayBhZnRlciBjb250ZW50LlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJlYW1zW2ldICE9PSAnc3RyaW5nJyB8fCB0aGlzLl9zdHJlYW1zW2ldLnN1YnN0cmluZyggMiwgYm91bmRhcnkubGVuZ3RoICsgMiApICE9PSBib3VuZGFyeSkge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKEZvcm1EYXRhLkxJTkVfQlJFQUspXSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCB0aGUgZm9vdGVyIGFuZCByZXR1cm4gdGhlIEJ1ZmZlciBvYmplY3QuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgQnVmZmVyLmZyb20odGhpcy5fbGFzdEJvdW5kYXJ5KCkpXSApO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZW5lcmF0ZUJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgZ2VuZXJhdGVzIGEgNTAgY2hhcmFjdGVyIGJvdW5kYXJ5IHNpbWlsYXIgdG8gdGhvc2UgdXNlZCBieSBGaXJlZm94LlxuICAvLyBUaGV5IGFyZSBvcHRpbWl6ZWQgZm9yIGJveWVyLW1vb3JlIHBhcnNpbmcuXG4gIHZhciBib3VuZGFyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgIGJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XG4gIH1cblxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xufTtcblxuLy8gTm90ZTogZ2V0TGVuZ3RoU3luYyBET0VTTidUIGNhbGN1bGF0ZSBzdHJlYW1zIGxlbmd0aFxuLy8gQXMgd29ya2Fyb3VuZCBvbmUgY2FuIGNhbGN1bGF0ZSBmaWxlIHNpemUgbWFudWFsbHlcbi8vIGFuZCBhZGQgaXQgYXMga25vd25MZW5ndGggb3B0aW9uXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIC8vIERvbid0IGdldCBjb25mdXNlZCwgdGhlcmUgYXJlIDMgXCJpbnRlcm5hbFwiIHN0cmVhbXMgZm9yIGVhY2gga2V5dmFsIHBhaXJcbiAgLy8gc28gaXQgYmFzaWNhbGx5IGNoZWNrcyBpZiB0aGVyZSBpcyBhbnkgdmFsdWUgYWRkZWQgdG8gdGhlIGZvcm1cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzQwXG4gIGlmICghdGhpcy5oYXNLbm93bkxlbmd0aCgpKSB7XG4gICAgLy8gU29tZSBhc3luYyBsZW5ndGggcmV0cmlldmVycyBhcmUgcHJlc2VudFxuICAgIC8vIHRoZXJlZm9yZSBzeW5jaHJvbm91cyBsZW5ndGggY2FsY3VsYXRpb24gaXMgZmFsc2UuXG4gICAgLy8gUGxlYXNlIHVzZSBnZXRMZW5ndGgoY2FsbGJhY2spIHRvIGdldCBwcm9wZXIgbGVuZ3RoXG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHByb3BlciBsZW5ndGggaW4gc3luY2hyb25vdXMgd2F5LicpKTtcbiAgfVxuXG4gIHJldHVybiBrbm93bkxlbmd0aDtcbn07XG5cbi8vIFB1YmxpYyBBUEkgdG8gY2hlY2sgaWYgbGVuZ3RoIG9mIGFkZGVkIHZhbHVlcyBpcyBrbm93blxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzE5NlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzI2MlxuRm9ybURhdGEucHJvdG90eXBlLmhhc0tub3duTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNLbm93bkxlbmd0aCA9IHRydWU7XG5cbiAgaWYgKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcbiAgICBoYXNLbm93bkxlbmd0aCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tub3duTGVuZ3RoO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCF0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKHRoaXMsIG51bGwsIGtub3duTGVuZ3RoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmNraXQucGFyYWxsZWwodGhpcy5fdmFsdWVzVG9NZWFzdXJlLCB0aGlzLl9sZW5ndGhSZXRyaWV2ZXIsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGtub3duTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNiKG51bGwsIGtub3duTGVuZ3RoKTtcbiAgfSk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuICB2YXIgcmVxdWVzdFxuICAgICwgb3B0aW9uc1xuICAgICwgZGVmYXVsdHMgPSB7bWV0aG9kOiAncG9zdCd9XG4gICAgO1xuXG4gIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xuICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxuICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnc3RyaW5nJykge1xuXG4gICAgcGFyYW1zID0gcGFyc2VVcmwocGFyYW1zKTtcbiAgICBvcHRpb25zID0gcG9wdWxhdGUoe1xuICAgICAgcG9ydDogcGFyYW1zLnBvcnQsXG4gICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXG4gICAgICBob3N0OiBwYXJhbXMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbDogcGFyYW1zLnByb3RvY29sXG4gICAgfSwgZGVmYXVsdHMpO1xuXG4gIC8vIHVzZSBjdXN0b20gcGFyYW1zXG4gIH0gZWxzZSB7XG5cbiAgICBvcHRpb25zID0gcG9wdWxhdGUocGFyYW1zLCBkZWZhdWx0cyk7XG4gICAgLy8gaWYgbm8gcG9ydCBwcm92aWRlZCB1c2UgZGVmYXVsdCBvbmVcbiAgICBpZiAoIW9wdGlvbnMucG9ydCkge1xuICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGF0IGdvb2QgY29kZSBpbiBnZXRIZWFkZXJzIHRvIHNvbWUgdXNlXG4gIG9wdGlvbnMuaGVhZGVycyA9IHRoaXMuZ2V0SGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG5cbiAgLy8gaHR0cHMgaWYgc3BlY2lmaWVkLCBmYWxsYmFjayB0byBodHRwIGluIGFueSBvdGhlciBjYXNlXG4gIGlmIChvcHRpb25zLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGdldCBjb250ZW50IGxlbmd0aCBhbmQgZmlyZSBhd2F5XG4gIHRoaXMuZ2V0TGVuZ3RoKGZ1bmN0aW9uKGVyciwgbGVuZ3RoKSB7XG4gICAgaWYgKGVyciAmJiBlcnIgIT09ICdVbmtub3duIHN0cmVhbScpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpcGUocmVxdWVzdCk7XG4gICAgaWYgKGNiKSB7XG4gICAgICB2YXIgb25SZXNwb25zZTtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXNwb25jZSkge1xuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcblxuICAgICAgICByZXR1cm4gY2IuY2FsbCh0aGlzLCBlcnJvciwgcmVzcG9uY2UpO1xuICAgICAgfTtcblxuICAgICAgb25SZXNwb25zZSA9IGNhbGxiYWNrLmJpbmQodGhpcywgbnVsbCk7XG5cbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbiIsIi8vIHBvcHVsYXRlcyBtaXNzaW5nIHZhbHVlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuXG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKVxuICB7XG4gICAgZHN0W3Byb3BdID0gZHN0W3Byb3BdIHx8IHNyY1twcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRzdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7UGFzc1Rocm91Z2g6IFBhc3NUaHJvdWdoU3RyZWFtfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdGlvbnMgPT4ge1xuXHRvcHRpb25zID0gey4uLm9wdGlvbnN9O1xuXG5cdGNvbnN0IHthcnJheX0gPSBvcHRpb25zO1xuXHRsZXQge2VuY29kaW5nfSA9IG9wdGlvbnM7XG5cdGNvbnN0IGlzQnVmZmVyID0gZW5jb2RpbmcgPT09ICdidWZmZXInO1xuXHRsZXQgb2JqZWN0TW9kZSA9IGZhbHNlO1xuXG5cdGlmIChhcnJheSkge1xuXHRcdG9iamVjdE1vZGUgPSAhKGVuY29kaW5nIHx8IGlzQnVmZmVyKTtcblx0fSBlbHNlIHtcblx0XHRlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4Jztcblx0fVxuXG5cdGlmIChpc0J1ZmZlcikge1xuXHRcdGVuY29kaW5nID0gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaFN0cmVhbSh7b2JqZWN0TW9kZX0pO1xuXG5cdGlmIChlbmNvZGluZykge1xuXHRcdHN0cmVhbS5zZXRFbmNvZGluZyhlbmNvZGluZyk7XG5cdH1cblxuXHRsZXQgbGVuZ3RoID0gMDtcblx0Y29uc3QgY2h1bmtzID0gW107XG5cblx0c3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdGNodW5rcy5wdXNoKGNodW5rKTtcblxuXHRcdGlmIChvYmplY3RNb2RlKSB7XG5cdFx0XHRsZW5ndGggPSBjaHVua3MubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuXHRcdH1cblx0fSk7XG5cblx0c3RyZWFtLmdldEJ1ZmZlcmVkVmFsdWUgPSAoKSA9PiB7XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRyZXR1cm4gY2h1bmtzO1xuXHRcdH1cblxuXHRcdHJldHVybiBpc0J1ZmZlciA/IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpIDogY2h1bmtzLmpvaW4oJycpO1xuXHR9O1xuXG5cdHN0cmVhbS5nZXRCdWZmZXJlZExlbmd0aCA9ICgpID0+IGxlbmd0aDtcblxuXHRyZXR1cm4gc3RyZWFtO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtjb25zdGFudHM6IEJ1ZmZlckNvbnN0YW50c30gPSByZXF1aXJlKCdidWZmZXInKTtcbmNvbnN0IHB1bXAgPSByZXF1aXJlKCdwdW1wJyk7XG5jb25zdCBidWZmZXJTdHJlYW0gPSByZXF1aXJlKCcuL2J1ZmZlci1zdHJlYW0nKTtcblxuY2xhc3MgTWF4QnVmZmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCdtYXhCdWZmZXIgZXhjZWVkZWQnKTtcblx0XHR0aGlzLm5hbWUgPSAnTWF4QnVmZmVyRXJyb3InO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0cmVhbShpbnB1dFN0cmVhbSwgb3B0aW9ucykge1xuXHRpZiAoIWlucHV0U3RyZWFtKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzdHJlYW0nKSk7XG5cdH1cblxuXHRvcHRpb25zID0ge1xuXHRcdG1heEJ1ZmZlcjogSW5maW5pdHksXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IHttYXhCdWZmZXJ9ID0gb3B0aW9ucztcblxuXHRsZXQgc3RyZWFtO1xuXHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgcmVqZWN0UHJvbWlzZSA9IGVycm9yID0+IHtcblx0XHRcdC8vIERvbid0IHJldHJpZXZlIGFuIG92ZXJzaXplZCBidWZmZXIuXG5cdFx0XHRpZiAoZXJyb3IgJiYgc3RyZWFtLmdldEJ1ZmZlcmVkTGVuZ3RoKCkgPD0gQnVmZmVyQ29uc3RhbnRzLk1BWF9MRU5HVEgpIHtcblx0XHRcdFx0ZXJyb3IuYnVmZmVyZWREYXRhID0gc3RyZWFtLmdldEJ1ZmZlcmVkVmFsdWUoKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHR9O1xuXG5cdFx0c3RyZWFtID0gcHVtcChpbnB1dFN0cmVhbSwgYnVmZmVyU3RyZWFtKG9wdGlvbnMpLCBlcnJvciA9PiB7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0cmVqZWN0UHJvbWlzZShlcnJvcik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0cmVzb2x2ZSgpO1xuXHRcdH0pO1xuXG5cdFx0c3RyZWFtLm9uKCdkYXRhJywgKCkgPT4ge1xuXHRcdFx0aWYgKHN0cmVhbS5nZXRCdWZmZXJlZExlbmd0aCgpID4gbWF4QnVmZmVyKSB7XG5cdFx0XHRcdHJlamVjdFByb21pc2UobmV3IE1heEJ1ZmZlckVycm9yKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gc3RyZWFtLmdldEJ1ZmZlcmVkVmFsdWUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTdHJlYW07XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGdldFN0cmVhbTtcbm1vZHVsZS5leHBvcnRzLmJ1ZmZlciA9IChzdHJlYW0sIG9wdGlvbnMpID0+IGdldFN0cmVhbShzdHJlYW0sIHsuLi5vcHRpb25zLCBlbmNvZGluZzogJ2J1ZmZlcid9KTtcbm1vZHVsZS5leHBvcnRzLmFycmF5ID0gKHN0cmVhbSwgb3B0aW9ucykgPT4gZ2V0U3RyZWFtKHN0cmVhbSwgey4uLm9wdGlvbnMsIGFycmF5OiB0cnVlfSk7XG5tb2R1bGUuZXhwb3J0cy5NYXhCdWZmZXJFcnJvciA9IE1heEJ1ZmZlckVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmbGFnLCBhcmd2ID0gcHJvY2Vzcy5hcmd2KSA9PiB7XG5cdGNvbnN0IHByZWZpeCA9IGZsYWcuc3RhcnRzV2l0aCgnLScpID8gJycgOiAoZmxhZy5sZW5ndGggPT09IDEgPyAnLScgOiAnLS0nKTtcblx0Y29uc3QgcG9zaXRpb24gPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cdGNvbnN0IHRlcm1pbmF0b3JQb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZignLS0nKTtcblx0cmV0dXJuIHBvc2l0aW9uICE9PSAtMSAmJiAodGVybWluYXRvclBvc2l0aW9uID09PSAtMSB8fCBwb3NpdGlvbiA8IHRlcm1pbmF0b3JQb3NpdGlvbik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5ldF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgdGxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCB1cmxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXJsXCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IG9uY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHRvb3RhbGxuYXRlL29uY2VcIikpO1xuY29uc3QgYWdlbnRfYmFzZV8xID0gcmVxdWlyZShcImFnZW50LWJhc2VcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdodHRwLXByb3h5LWFnZW50Jyk7XG5mdW5jdGlvbiBpc0hUVFBTKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycgPyAvXmh0dHBzOj8kL2kudGVzdChwcm90b2NvbCkgOiBmYWxzZTtcbn1cbi8qKlxuICogVGhlIGBIdHRwUHJveHlBZ2VudGAgaW1wbGVtZW50cyBhbiBIVFRQIEFnZW50IHN1YmNsYXNzIHRoYXQgY29ubmVjdHNcbiAqIHRvIHRoZSBzcGVjaWZpZWQgXCJIVFRQIHByb3h5IHNlcnZlclwiIGluIG9yZGVyIHRvIHByb3h5IEhUVFAgcmVxdWVzdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuY2xhc3MgSHR0cFByb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRzKSB7XG4gICAgICAgIGxldCBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cyA9IHVybF8xLmRlZmF1bHQucGFyc2UoX29wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IF9vcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbiBIVFRQKFMpIHByb3h5IHNlcnZlciBgaG9zdGAgYW5kIGBwb3J0YCBtdXN0IGJlIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgbmV3IEh0dHBQcm94eUFnZW50IGluc3RhbmNlOiAlbycsIG9wdHMpO1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICAgICAgLy8gSWYgYHRydWVgLCB0aGVuIGNvbm5lY3QgdG8gdGhlIHByb3h5IHNlcnZlciBvdmVyIFRMUy5cbiAgICAgICAgLy8gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgdGhpcy5zZWN1cmVQcm94eSA9IG9wdHMuc2VjdXJlUHJveHkgfHwgaXNIVFRQUyhwcm94eS5wcm90b2NvbCk7XG4gICAgICAgIC8vIFByZWZlciBgaG9zdG5hbWVgIG92ZXIgYGhvc3RgLCBhbmQgc2V0IHRoZSBgcG9ydGAgaWYgbmVlZGVkLlxuICAgICAgICBwcm94eS5ob3N0ID0gcHJveHkuaG9zdG5hbWUgfHwgcHJveHkuaG9zdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm94eS5wb3J0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJveHkucG9ydCA9IHBhcnNlSW50KHByb3h5LnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3h5LnBvcnQgJiYgcHJveHkuaG9zdCkge1xuICAgICAgICAgICAgcHJveHkucG9ydCA9IHRoaXMuc2VjdXJlUHJveHkgPyA0NDMgOiA4MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJveHkuaG9zdCAmJiBwcm94eS5wYXRoKSB7XG4gICAgICAgICAgICAvLyBJZiBib3RoIGEgYGhvc3RgIGFuZCBgcGF0aGAgYXJlIHNwZWNpZmllZCB0aGVuIGl0J3MgbW9zdCBsaWtlbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXN1bHQgb2YgYSBgdXJsLnBhcnNlKClgIGNhbGwuLi4gd2UgbmVlZCB0byByZW1vdmUgdGhlXG4gICAgICAgICAgICAvLyBgcGF0aGAgcG9ydGlvbiBzbyB0aGF0IGBuZXQuY29ubmVjdCgpYCBkb2Vzbid0IGF0dGVtcHQgdG8gb3BlblxuICAgICAgICAgICAgLy8gdGhhdCBhcyBhIFVuaXggc29ja2V0IGZpbGUuXG4gICAgICAgICAgICBkZWxldGUgcHJveHkucGF0aDtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm94eS5wYXRobmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhXG4gICAgICogbmV3IEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsbGJhY2socmVxLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3h5LCBzZWN1cmVQcm94eSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHVybF8xLmRlZmF1bHQucGFyc2UocmVxLnBhdGgpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucHJvdG9jb2wgPSAnaHR0cDonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdCB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZC5wb3J0ID09IG51bGwgJiYgdHlwZW9mIG9wdHMucG9ydCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wb3J0ID0gU3RyaW5nKG9wdHMucG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VkLnBvcnQgPT09ICc4MCcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBwb3J0IGlzIDgwLCB0aGVuIHdlIGNhbiByZW1vdmUgdGhlIHBvcnQgc28gdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIjo4MFwiIHBvcnRpb24gaXMgbm90IG9uIHRoZSBwcm9kdWNlZCBVUkxcbiAgICAgICAgICAgICAgICBwYXJzZWQucG9ydCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBgaHR0cC5DbGllbnRSZXF1ZXN0YCBpbnN0YW5jZSdzIFwicGF0aFwiIGZpZWxkXG4gICAgICAgICAgICAvLyB0byB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQuXG4gICAgICAgICAgICByZXEucGF0aCA9IHVybF8xLmRlZmF1bHQuZm9ybWF0KHBhcnNlZCk7XG4gICAgICAgICAgICAvLyBJbmplY3QgdGhlIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0SGVhZGVyKCdQcm94eS1BdXRob3JpemF0aW9uJywgYEJhc2ljICR7QnVmZmVyLmZyb20ocHJveHkuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlci5cbiAgICAgICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgICAgICBpZiAoc2VjdXJlUHJveHkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSB0bHNfMS5kZWZhdWx0LmNvbm5lY3QocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gbmV0XzEuZGVmYXVsdC5jb25uZWN0KHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBodHRwIENsaWVudFJlcXVlc3QncyBpbnRlcm5hbCBgX2hlYWRlcmAgZmllbGRcbiAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIHNldC4gSWYgdGhpcyBpcyB0aGUgY2FzZSB0aGVuIHdlJ2xsIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHJlLWdlbmVyYXRlIHRoZSBzdHJpbmcgc2luY2Ugd2UganVzdCBjaGFuZ2VkIHRoZSBgcmVxLnBhdGhgLlxuICAgICAgICAgICAgaWYgKHJlcS5faGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0O1xuICAgICAgICAgICAgICAgIGxldCBlbmRPZkhlYWRlcnM7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1JlZ2VuZXJhdGluZyBzdG9yZWQgSFRUUCBoZWFkZXIgc3RyaW5nIGZvciByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgcmVxLl9oZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcS5faW1wbGljaXRIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxLm91dHB1dCAmJiByZXEub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSA8IDEyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdQYXRjaGluZyBjb25uZWN0aW9uIHdyaXRlKCkgb3V0cHV0IGJ1ZmZlciB3aXRoIHVwZGF0ZWQgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gcmVxLm91dHB1dFswXTtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZIZWFkZXJzID0gZmlyc3QuaW5kZXhPZignXFxyXFxuXFxyXFxuJykgKyA0O1xuICAgICAgICAgICAgICAgICAgICByZXEub3V0cHV0WzBdID0gcmVxLl9oZWFkZXIgKyBmaXJzdC5zdWJzdHJpbmcoZW5kT2ZIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ091dHB1dCBidWZmZXI6ICVvJywgcmVxLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS5vdXRwdXREYXRhICYmIHJlcS5vdXRwdXREYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSA+PSAxMlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnUGF0Y2hpbmcgY29ubmVjdGlvbiB3cml0ZSgpIG91dHB1dCBidWZmZXIgd2l0aCB1cGRhdGVkIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHJlcS5vdXRwdXREYXRhWzBdLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mSGVhZGVycyA9IGZpcnN0LmluZGV4T2YoJ1xcclxcblxcclxcbicpICsgNDtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm91dHB1dERhdGFbMF0uZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuX2hlYWRlciArIGZpcnN0LnN1YnN0cmluZyhlbmRPZkhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnT3V0cHV0IGJ1ZmZlcjogJW8nLCByZXEub3V0cHV0RGF0YVswXS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgc29ja2V0J3MgYGNvbm5lY3RgIGV2ZW50LCBzbyB0aGF0IHRoaXMgYGNhbGxiYWNrKClgXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiB0aHJvd3MgaW5zdGVhZCBvZiB0aGUgYGh0dHBgIHJlcXVlc3QgbWFjaGluZXJ5LiBUaGlzIGlzXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGkuZS4gYFBhY1Byb3h5QWdlbnRgIHdoaWNoIGRldGVybWluZXMgYSBmYWlsZWQgcHJveHlcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gdmlhIHRoZSBgY2FsbGJhY2soKWAgZnVuY3Rpb24gdGhyb3dpbmcuXG4gICAgICAgICAgICB5aWVsZCAoMCwgb25jZV8xLmRlZmF1bHQpKHNvY2tldCwgJ2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBQcm94eUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBhZ2VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FnZW50XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBQcm94eUFnZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdChvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlSHR0cFByb3h5QWdlbnQpIHtcbiAgICBjcmVhdGVIdHRwUHJveHlBZ2VudC5IdHRwUHJveHlBZ2VudCA9IGFnZW50XzEuZGVmYXVsdDtcbiAgICBjcmVhdGVIdHRwUHJveHlBZ2VudC5wcm90b3R5cGUgPSBhZ2VudF8xLmRlZmF1bHQucHJvdG90eXBlO1xufSkoY3JlYXRlSHR0cFByb3h5QWdlbnQgfHwgKGNyZWF0ZUh0dHBQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHR0cFByb3h5QWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmV0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5ldFwiKSk7XG5jb25zdCB0bHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGxzXCIpKTtcbmNvbnN0IHVybF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ1cmxcIikpO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UtcHJveHktcmVzcG9uc2VcIikpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoJ2h0dHBzLXByb3h5LWFnZW50OmFnZW50Jyk7XG4vKipcbiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0b1xuICogdGhlIHNwZWNpZmllZCBcIkhUVFAocykgcHJveHkgc2VydmVyXCIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuXG4gKlxuICogT3V0Z29pbmcgSFRUUCByZXF1ZXN0cyBhcmUgZmlyc3QgdHVubmVsZWQgdGhyb3VnaCB0aGUgcHJveHkgc2VydmVyIHVzaW5nIHRoZVxuICogYENPTk5FQ1RgIEhUVFAgcmVxdWVzdCBtZXRob2QgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLFxuICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlXG4gKiBIVFRQIHJlcXVlc3QgZnJvbSB0aGUgcHJveHkgc2VydmVyLlxuICpcbiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2VcbiAqIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuY2xhc3MgSHR0cHNQcm94eUFnZW50IGV4dGVuZHMgYWdlbnRfYmFzZV8xLkFnZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0cykge1xuICAgICAgICBsZXQgb3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBfb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmxfMS5kZWZhdWx0LnBhcnNlKF9vcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSBfb3B0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW4gSFRUUChTKSBwcm94eSBzZXJ2ZXIgYGhvc3RgIGFuZCBgcG9ydGAgbXVzdCBiZSBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ2NyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvJywgb3B0cyk7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBjb25zdCBwcm94eSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICAvLyBJZiBgdHJ1ZWAsIHRoZW4gY29ubmVjdCB0byB0aGUgcHJveHkgc2VydmVyIG92ZXIgVExTLlxuICAgICAgICAvLyBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICB0aGlzLnNlY3VyZVByb3h5ID0gb3B0cy5zZWN1cmVQcm94eSB8fCBpc0hUVFBTKHByb3h5LnByb3RvY29sKTtcbiAgICAgICAgLy8gUHJlZmVyIGBob3N0bmFtZWAgb3ZlciBgaG9zdGAsIGFuZCBzZXQgdGhlIGBwb3J0YCBpZiBuZWVkZWQuXG4gICAgICAgIHByb3h5Lmhvc3QgPSBwcm94eS5ob3N0bmFtZSB8fCBwcm94eS5ob3N0O1xuICAgICAgICBpZiAodHlwZW9mIHByb3h5LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwcm94eS5wb3J0ID0gcGFyc2VJbnQocHJveHkucG9ydCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJveHkucG9ydCAmJiBwcm94eS5ob3N0KSB7XG4gICAgICAgICAgICBwcm94eS5wb3J0ID0gdGhpcy5zZWN1cmVQcm94eSA/IDQ0MyA6IDgwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFMUE4gaXMgc3VwcG9ydGVkIGJ5IE5vZGUuanMgPj0gdjUuXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbmVnb3RpYXRlIGh0dHAvMS4xIGZvciBwcm94eSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBodHRwLzJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJlUHJveHkgJiYgISgnQUxQTlByb3RvY29scycgaW4gcHJveHkpKSB7XG4gICAgICAgICAgICBwcm94eS5BTFBOUHJvdG9jb2xzID0gWydodHRwIDEuMSddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm94eS5ob3N0ICYmIHByb3h5LnBhdGgpIHtcbiAgICAgICAgICAgIC8vIElmIGJvdGggYSBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgc3BlY2lmaWVkIHRoZW4gaXQncyBtb3N0IGxpa2VseVxuICAgICAgICAgICAgLy8gdGhlIHJlc3VsdCBvZiBhIGB1cmwucGFyc2UoKWAgY2FsbC4uLiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIGBwYXRoYCBwb3J0aW9uIHNvIHRoYXQgYG5ldC5jb25uZWN0KClgIGRvZXNuJ3QgYXR0ZW1wdCB0byBvcGVuXG4gICAgICAgICAgICAvLyB0aGF0IGFzIGEgVW5peCBzb2NrZXQgZmlsZS5cbiAgICAgICAgICAgIGRlbGV0ZSBwcm94eS5wYXRoO1xuICAgICAgICAgICAgZGVsZXRlIHByb3h5LnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG5vZGUtY29yZSBIVFRQIGNsaWVudCBsaWJyYXJ5IGlzIGNyZWF0aW5nIGFcbiAgICAgKiBuZXcgSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGFwaSBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxsYmFjayhyZXEsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJveHksIHNlY3VyZVByb3h5IH0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlci5cbiAgICAgICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgICAgICBpZiAoc2VjdXJlUHJveHkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSB0bHNfMS5kZWZhdWx0LmNvbm5lY3QocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGBuZXQuU29ja2V0YDogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gbmV0XzEuZGVmYXVsdC5jb25uZWN0KHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm94eS5oZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gYCR7b3B0cy5ob3N0fToke29wdHMucG9ydH1gO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBgQ09OTkVDVCAke2hvc3RuYW1lfSBIVFRQLzEuMVxcclxcbmA7XG4gICAgICAgICAgICAvLyBJbmplY3QgdGhlIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShwcm94eS5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBgSG9zdGAgaGVhZGVyIHNob3VsZCBvbmx5IGluY2x1ZGUgdGhlIHBvcnRcbiAgICAgICAgICAgIC8vIG51bWJlciB3aGVuIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBwb3J0LlxuICAgICAgICAgICAgbGV0IHsgaG9zdCwgcG9ydCwgc2VjdXJlRW5kcG9pbnQgfSA9IG9wdHM7XG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdFBvcnQocG9ydCwgc2VjdXJlRW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgaG9zdCArPSBgOiR7cG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5Ib3N0ID0gaG9zdDtcbiAgICAgICAgICAgIGhlYWRlcnMuQ29ubmVjdGlvbiA9ICdjbG9zZSc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkICs9IGAke25hbWV9OiAke2hlYWRlcnNbbmFtZV19XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3h5UmVzcG9uc2VQcm9taXNlID0gcGFyc2VfcHJveHlfcmVzcG9uc2VfMS5kZWZhdWx0KHNvY2tldCk7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7cGF5bG9hZH1cXHJcXG5gKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgYnVmZmVyZWQgfSA9IHlpZWxkIHByb3h5UmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCByZXN1bWUpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWUgfHwgb3B0cy5ob3N0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGxzXzEuZGVmYXVsdC5jb25uZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb21pdChvcHRzLCAnaG9zdCcsICdob3N0bmFtZScsICdwYXRoJywgJ3BvcnQnKSksIHsgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVybmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIG90aGVyIHN0YXR1cyBjb2RlIHRoYXQncyBub3QgMjAwLi4uIG5lZWQgdG8gcmUtcGxheSB0aGUgSFRUUFxuICAgICAgICAgICAgLy8gaGVhZGVyIFwiZGF0YVwiIGV2ZW50cyBvbnRvIHRoZSBzb2NrZXQgb25jZSB0aGUgSFRUUCBtYWNoaW5lcnkgaXNcbiAgICAgICAgICAgIC8vIGF0dGFjaGVkIHNvIHRoYXQgdGhlIG5vZGUgY29yZSBgaHR0cGAgY2FuIHBhcnNlIGFuZCBoYW5kbGUgdGhlXG4gICAgICAgICAgICAvLyBlcnJvciBzdGF0dXMgY29kZS5cbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBvcmlnaW5hbCBzb2NrZXQsIGFuZCBhIG5ldyBcImZha2VcIiBzb2NrZXQgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vIGluc3RlYWQsIHNvIHRoYXQgdGhlIHByb3h5IGRvZXNuJ3QgZ2V0IHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIHdyaXR0ZW4gdG8gaXQgKHdoaWNoIG1heSBjb250YWluIGBBdXRob3JpemF0aW9uYCBoZWFkZXJzIG9yIG90aGVyXG4gICAgICAgICAgICAvLyBzZW5zaXRpdmUgZGF0YSkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2hhY2tlcm9uZS5jb20vcmVwb3J0cy81NDE1MDJcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldF8xLmRlZmF1bHQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdhaXQgZm9yIHRoZSBcInNvY2tldFwiIGV2ZW50IHRvIHJlLXBsYXkgdGhlIFwiZGF0YVwiIGV2ZW50cy5cbiAgICAgICAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCAocykgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQocy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIFwiYnVmZmVyZWRcIiBCdWZmZXIgb250byB0aGUgZmFrZSBgc29ja2V0YCwgc2luY2UgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHBvaW50IHRoZSBIVFRQIG1vZHVsZSBtYWNoaW5lcnkgaGFzIGJlZW4gaG9va2VkIHVwIGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyLlxuICAgICAgICAgICAgICAgIHMucHVzaChidWZmZXJlZCk7XG4gICAgICAgICAgICAgICAgcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFrZVNvY2tldDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cHNQcm94eUFnZW50O1xuZnVuY3Rpb24gcmVzdW1lKHNvY2tldCkge1xuICAgIHNvY2tldC5yZXN1bWUoKTtcbn1cbmZ1bmN0aW9uIGlzRGVmYXVsdFBvcnQocG9ydCwgc2VjdXJlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKCFzZWN1cmUgJiYgcG9ydCA9PT0gODApIHx8IChzZWN1cmUgJiYgcG9ydCA9PT0gNDQzKSk7XG59XG5mdW5jdGlvbiBpc0hUVFBTKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycgPyAvXmh0dHBzOj8kL2kudGVzdChwcm90b2NvbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuY29uc3QgYWdlbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hZ2VudFwiKSk7XG5mdW5jdGlvbiBjcmVhdGVIdHRwc1Byb3h5QWdlbnQob3B0cykge1xuICAgIHJldHVybiBuZXcgYWdlbnRfMS5kZWZhdWx0KG9wdHMpO1xufVxuKGZ1bmN0aW9uIChjcmVhdGVIdHRwc1Byb3h5QWdlbnQpIHtcbiAgICBjcmVhdGVIdHRwc1Byb3h5QWdlbnQuSHR0cHNQcm94eUFnZW50ID0gYWdlbnRfMS5kZWZhdWx0O1xuICAgIGNyZWF0ZUh0dHBzUHJveHlBZ2VudC5wcm90b3R5cGUgPSBhZ2VudF8xLmRlZmF1bHQucHJvdG90eXBlO1xufSkoY3JlYXRlSHR0cHNQcm94eUFnZW50IHx8IChjcmVhdGVIdHRwc1Byb3h5QWdlbnQgPSB7fSkpO1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVIdHRwc1Byb3h5QWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdodHRwcy1wcm94eS1hZ2VudDpwYXJzZS1wcm94eS1yZXNwb25zZScpO1xuZnVuY3Rpb24gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVmZmVyIGFueSBIVFRQIHRyYWZmaWMgdGhhdCBoYXBwZW5zIHdpdGggdGhlIHByb3h5IGJlZm9yZSB3ZSBnZXRcbiAgICAgICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gXCIyMDBcIlxuICAgICAgICAvLyByZXNwb25zZSBjb2RlLCB0aGVuIHdlIGNhbiByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMgb24gdGhlIHNvY2tldCBvbmNlIHRoZVxuICAgICAgICAvLyBIVFRQIHBhcnNlciBpcyBob29rZWQgdXAuLi5cbiAgICAgICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gc29ja2V0LnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIG9uZGF0YShiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgncmVhZGFibGUnLCByZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25jbG9zZShlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKCdvbmNsb3NlIGhhZCBlcnJvciAlbycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZGVidWcoJ29uZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25kYXRhKGIpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChiKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBidWZmZXJlZC5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBidWZmZXJpbmdcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4nKTtcbiAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gYnVmZmVyZWQudG9TdHJpbmcoJ2FzY2lpJywgMCwgYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuJykpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICtmaXJzdExpbmUuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgICAgIGRlYnVnKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbycsIGZpcnN0TGluZSk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICAgIHNvY2tldC5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgIHJlYWQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlUHJveHlSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXByb3h5LXJlc3BvbnNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5TSUdOQUxTPXZvaWQgMDtcblxuY29uc3QgU0lHTkFMUz1bXG57XG5uYW1lOlwiU0lHSFVQXCIsXG5udW1iZXI6MSxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJUZXJtaW5hbCBjbG9zZWRcIixcbnN0YW5kYXJkOlwicG9zaXhcIn0sXG5cbntcbm5hbWU6XCJTSUdJTlRcIixcbm51bWJlcjoyLFxuYWN0aW9uOlwidGVybWluYXRlXCIsXG5kZXNjcmlwdGlvbjpcIlVzZXIgaW50ZXJydXB0aW9uIHdpdGggQ1RSTC1DXCIsXG5zdGFuZGFyZDpcImFuc2lcIn0sXG5cbntcbm5hbWU6XCJTSUdRVUlUXCIsXG5udW1iZXI6MyxcbmFjdGlvbjpcImNvcmVcIixcbmRlc2NyaXB0aW9uOlwiVXNlciBpbnRlcnJ1cHRpb24gd2l0aCBDVFJMLVxcXFxcIixcbnN0YW5kYXJkOlwicG9zaXhcIn0sXG5cbntcbm5hbWU6XCJTSUdJTExcIixcbm51bWJlcjo0LFxuYWN0aW9uOlwiY29yZVwiLFxuZGVzY3JpcHRpb246XCJJbnZhbGlkIG1hY2hpbmUgaW5zdHJ1Y3Rpb25cIixcbnN0YW5kYXJkOlwiYW5zaVwifSxcblxue1xubmFtZTpcIlNJR1RSQVBcIixcbm51bWJlcjo1LFxuYWN0aW9uOlwiY29yZVwiLFxuZGVzY3JpcHRpb246XCJEZWJ1Z2dlciBicmVha3BvaW50XCIsXG5zdGFuZGFyZDpcInBvc2l4XCJ9LFxuXG57XG5uYW1lOlwiU0lHQUJSVFwiLFxubnVtYmVyOjYsXG5hY3Rpb246XCJjb3JlXCIsXG5kZXNjcmlwdGlvbjpcIkFib3J0ZWRcIixcbnN0YW5kYXJkOlwiYW5zaVwifSxcblxue1xubmFtZTpcIlNJR0lPVFwiLFxubnVtYmVyOjYsXG5hY3Rpb246XCJjb3JlXCIsXG5kZXNjcmlwdGlvbjpcIkFib3J0ZWRcIixcbnN0YW5kYXJkOlwiYnNkXCJ9LFxuXG57XG5uYW1lOlwiU0lHQlVTXCIsXG5udW1iZXI6NyxcbmFjdGlvbjpcImNvcmVcIixcbmRlc2NyaXB0aW9uOlxuXCJCdXMgZXJyb3IgZHVlIHRvIG1pc2FsaWduZWQsIG5vbi1leGlzdGluZyBhZGRyZXNzIG9yIHBhZ2luZyBlcnJvclwiLFxuc3RhbmRhcmQ6XCJic2RcIn0sXG5cbntcbm5hbWU6XCJTSUdFTVRcIixcbm51bWJlcjo3LFxuYWN0aW9uOlwidGVybWluYXRlXCIsXG5kZXNjcmlwdGlvbjpcIkNvbW1hbmQgc2hvdWxkIGJlIGVtdWxhdGVkIGJ1dCBpcyBub3QgaW1wbGVtZW50ZWRcIixcbnN0YW5kYXJkOlwib3RoZXJcIn0sXG5cbntcbm5hbWU6XCJTSUdGUEVcIixcbm51bWJlcjo4LFxuYWN0aW9uOlwiY29yZVwiLFxuZGVzY3JpcHRpb246XCJGbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGVycm9yXCIsXG5zdGFuZGFyZDpcImFuc2lcIn0sXG5cbntcbm5hbWU6XCJTSUdLSUxMXCIsXG5udW1iZXI6OSxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJGb3JjZWQgdGVybWluYXRpb25cIixcbnN0YW5kYXJkOlwicG9zaXhcIixcbmZvcmNlZDp0cnVlfSxcblxue1xubmFtZTpcIlNJR1VTUjFcIixcbm51bWJlcjoxMCxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJBcHBsaWNhdGlvbi1zcGVjaWZpYyBzaWduYWxcIixcbnN0YW5kYXJkOlwicG9zaXhcIn0sXG5cbntcbm5hbWU6XCJTSUdTRUdWXCIsXG5udW1iZXI6MTEsXG5hY3Rpb246XCJjb3JlXCIsXG5kZXNjcmlwdGlvbjpcIlNlZ21lbnRhdGlvbiBmYXVsdFwiLFxuc3RhbmRhcmQ6XCJhbnNpXCJ9LFxuXG57XG5uYW1lOlwiU0lHVVNSMlwiLFxubnVtYmVyOjEyLFxuYWN0aW9uOlwidGVybWluYXRlXCIsXG5kZXNjcmlwdGlvbjpcIkFwcGxpY2F0aW9uLXNwZWNpZmljIHNpZ25hbFwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwifSxcblxue1xubmFtZTpcIlNJR1BJUEVcIixcbm51bWJlcjoxMyxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJCcm9rZW4gcGlwZSBvciBzb2NrZXRcIixcbnN0YW5kYXJkOlwicG9zaXhcIn0sXG5cbntcbm5hbWU6XCJTSUdBTFJNXCIsXG5udW1iZXI6MTQsXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiVGltZW91dCBvciB0aW1lclwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwifSxcblxue1xubmFtZTpcIlNJR1RFUk1cIixcbm51bWJlcjoxNSxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJUZXJtaW5hdGlvblwiLFxuc3RhbmRhcmQ6XCJhbnNpXCJ9LFxuXG57XG5uYW1lOlwiU0lHU1RLRkxUXCIsXG5udW1iZXI6MTYsXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiU3RhY2sgaXMgZW1wdHkgb3Igb3ZlcmZsb3dlZFwiLFxuc3RhbmRhcmQ6XCJvdGhlclwifSxcblxue1xubmFtZTpcIlNJR0NITERcIixcbm51bWJlcjoxNyxcbmFjdGlvbjpcImlnbm9yZVwiLFxuZGVzY3JpcHRpb246XCJDaGlsZCBwcm9jZXNzIHRlcm1pbmF0ZWQsIHBhdXNlZCBvciB1bnBhdXNlZFwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwifSxcblxue1xubmFtZTpcIlNJR0NMRFwiLFxubnVtYmVyOjE3LFxuYWN0aW9uOlwiaWdub3JlXCIsXG5kZXNjcmlwdGlvbjpcIkNoaWxkIHByb2Nlc3MgdGVybWluYXRlZCwgcGF1c2VkIG9yIHVucGF1c2VkXCIsXG5zdGFuZGFyZDpcIm90aGVyXCJ9LFxuXG57XG5uYW1lOlwiU0lHQ09OVFwiLFxubnVtYmVyOjE4LFxuYWN0aW9uOlwidW5wYXVzZVwiLFxuZGVzY3JpcHRpb246XCJVbnBhdXNlZFwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwiLFxuZm9yY2VkOnRydWV9LFxuXG57XG5uYW1lOlwiU0lHU1RPUFwiLFxubnVtYmVyOjE5LFxuYWN0aW9uOlwicGF1c2VcIixcbmRlc2NyaXB0aW9uOlwiUGF1c2VkXCIsXG5zdGFuZGFyZDpcInBvc2l4XCIsXG5mb3JjZWQ6dHJ1ZX0sXG5cbntcbm5hbWU6XCJTSUdUU1RQXCIsXG5udW1iZXI6MjAsXG5hY3Rpb246XCJwYXVzZVwiLFxuZGVzY3JpcHRpb246XCJQYXVzZWQgdXNpbmcgQ1RSTC1aIG9yIFxcXCJzdXNwZW5kXFxcIlwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwifSxcblxue1xubmFtZTpcIlNJR1RUSU5cIixcbm51bWJlcjoyMSxcbmFjdGlvbjpcInBhdXNlXCIsXG5kZXNjcmlwdGlvbjpcIkJhY2tncm91bmQgcHJvY2VzcyBjYW5ub3QgcmVhZCB0ZXJtaW5hbCBpbnB1dFwiLFxuc3RhbmRhcmQ6XCJwb3NpeFwifSxcblxue1xubmFtZTpcIlNJR0JSRUFLXCIsXG5udW1iZXI6MjEsXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiVXNlciBpbnRlcnJ1cHRpb24gd2l0aCBDVFJMLUJSRUFLXCIsXG5zdGFuZGFyZDpcIm90aGVyXCJ9LFxuXG57XG5uYW1lOlwiU0lHVFRPVVwiLFxubnVtYmVyOjIyLFxuYWN0aW9uOlwicGF1c2VcIixcbmRlc2NyaXB0aW9uOlwiQmFja2dyb3VuZCBwcm9jZXNzIGNhbm5vdCB3cml0ZSB0byB0ZXJtaW5hbCBvdXRwdXRcIixcbnN0YW5kYXJkOlwicG9zaXhcIn0sXG5cbntcbm5hbWU6XCJTSUdVUkdcIixcbm51bWJlcjoyMyxcbmFjdGlvbjpcImlnbm9yZVwiLFxuZGVzY3JpcHRpb246XCJTb2NrZXQgcmVjZWl2ZWQgb3V0LW9mLWJhbmQgZGF0YVwiLFxuc3RhbmRhcmQ6XCJic2RcIn0sXG5cbntcbm5hbWU6XCJTSUdYQ1BVXCIsXG5udW1iZXI6MjQsXG5hY3Rpb246XCJjb3JlXCIsXG5kZXNjcmlwdGlvbjpcIlByb2Nlc3MgdGltZWQgb3V0XCIsXG5zdGFuZGFyZDpcImJzZFwifSxcblxue1xubmFtZTpcIlNJR1hGU1pcIixcbm51bWJlcjoyNSxcbmFjdGlvbjpcImNvcmVcIixcbmRlc2NyaXB0aW9uOlwiRmlsZSB0b28gYmlnXCIsXG5zdGFuZGFyZDpcImJzZFwifSxcblxue1xubmFtZTpcIlNJR1ZUQUxSTVwiLFxubnVtYmVyOjI2LFxuYWN0aW9uOlwidGVybWluYXRlXCIsXG5kZXNjcmlwdGlvbjpcIlRpbWVvdXQgb3IgdGltZXJcIixcbnN0YW5kYXJkOlwiYnNkXCJ9LFxuXG57XG5uYW1lOlwiU0lHUFJPRlwiLFxubnVtYmVyOjI3LFxuYWN0aW9uOlwidGVybWluYXRlXCIsXG5kZXNjcmlwdGlvbjpcIlRpbWVvdXQgb3IgdGltZXJcIixcbnN0YW5kYXJkOlwiYnNkXCJ9LFxuXG57XG5uYW1lOlwiU0lHV0lOQ0hcIixcbm51bWJlcjoyOCxcbmFjdGlvbjpcImlnbm9yZVwiLFxuZGVzY3JpcHRpb246XCJUZXJtaW5hbCB3aW5kb3cgc2l6ZSBjaGFuZ2VkXCIsXG5zdGFuZGFyZDpcImJzZFwifSxcblxue1xubmFtZTpcIlNJR0lPXCIsXG5udW1iZXI6MjksXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiSS9PIGlzIGF2YWlsYWJsZVwiLFxuc3RhbmRhcmQ6XCJvdGhlclwifSxcblxue1xubmFtZTpcIlNJR1BPTExcIixcbm51bWJlcjoyOSxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJXYXRjaGVkIGV2ZW50XCIsXG5zdGFuZGFyZDpcIm90aGVyXCJ9LFxuXG57XG5uYW1lOlwiU0lHSU5GT1wiLFxubnVtYmVyOjI5LFxuYWN0aW9uOlwiaWdub3JlXCIsXG5kZXNjcmlwdGlvbjpcIlJlcXVlc3QgZm9yIHByb2Nlc3MgaW5mb3JtYXRpb25cIixcbnN0YW5kYXJkOlwib3RoZXJcIn0sXG5cbntcbm5hbWU6XCJTSUdQV1JcIixcbm51bWJlcjozMCxcbmFjdGlvbjpcInRlcm1pbmF0ZVwiLFxuZGVzY3JpcHRpb246XCJEZXZpY2UgcnVubmluZyBvdXQgb2YgcG93ZXJcIixcbnN0YW5kYXJkOlwic3lzdGVtdlwifSxcblxue1xubmFtZTpcIlNJR1NZU1wiLFxubnVtYmVyOjMxLFxuYWN0aW9uOlwiY29yZVwiLFxuZGVzY3JpcHRpb246XCJJbnZhbGlkIHN5c3RlbSBjYWxsXCIsXG5zdGFuZGFyZDpcIm90aGVyXCJ9LFxuXG57XG5uYW1lOlwiU0lHVU5VU0VEXCIsXG5udW1iZXI6MzEsXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiSW52YWxpZCBzeXN0ZW0gY2FsbFwiLFxuc3RhbmRhcmQ6XCJvdGhlclwifV07ZXhwb3J0cy5TSUdOQUxTPVNJR05BTFM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5zaWduYWxzQnlOdW1iZXI9ZXhwb3J0cy5zaWduYWxzQnlOYW1lPXZvaWQgMDt2YXIgX29zPXJlcXVpcmUoXCJvc1wiKTtcblxudmFyIF9zaWduYWxzPXJlcXVpcmUoXCIuL3NpZ25hbHMuanNcIik7XG52YXIgX3JlYWx0aW1lPXJlcXVpcmUoXCIuL3JlYWx0aW1lLmpzXCIpO1xuXG5cblxuY29uc3QgZ2V0U2lnbmFsc0J5TmFtZT1mdW5jdGlvbigpe1xuY29uc3Qgc2lnbmFscz0oMCxfc2lnbmFscy5nZXRTaWduYWxzKSgpO1xucmV0dXJuIHNpZ25hbHMucmVkdWNlKGdldFNpZ25hbEJ5TmFtZSx7fSk7XG59O1xuXG5jb25zdCBnZXRTaWduYWxCeU5hbWU9ZnVuY3Rpb24oXG5zaWduYWxCeU5hbWVNZW1vLFxue25hbWUsbnVtYmVyLGRlc2NyaXB0aW9uLHN1cHBvcnRlZCxhY3Rpb24sZm9yY2VkLHN0YW5kYXJkfSlcbntcbnJldHVybntcbi4uLnNpZ25hbEJ5TmFtZU1lbW8sXG5bbmFtZV06e25hbWUsbnVtYmVyLGRlc2NyaXB0aW9uLHN1cHBvcnRlZCxhY3Rpb24sZm9yY2VkLHN0YW5kYXJkfX07XG5cbn07XG5cbmNvbnN0IHNpZ25hbHNCeU5hbWU9Z2V0U2lnbmFsc0J5TmFtZSgpO2V4cG9ydHMuc2lnbmFsc0J5TmFtZT1zaWduYWxzQnlOYW1lO1xuXG5cblxuXG5jb25zdCBnZXRTaWduYWxzQnlOdW1iZXI9ZnVuY3Rpb24oKXtcbmNvbnN0IHNpZ25hbHM9KDAsX3NpZ25hbHMuZ2V0U2lnbmFscykoKTtcbmNvbnN0IGxlbmd0aD1fcmVhbHRpbWUuU0lHUlRNQVgrMTtcbmNvbnN0IHNpZ25hbHNBPUFycmF5LmZyb20oe2xlbmd0aH0sKHZhbHVlLG51bWJlcik9PlxuZ2V0U2lnbmFsQnlOdW1iZXIobnVtYmVyLHNpZ25hbHMpKTtcblxucmV0dXJuIE9iamVjdC5hc3NpZ24oe30sLi4uc2lnbmFsc0EpO1xufTtcblxuY29uc3QgZ2V0U2lnbmFsQnlOdW1iZXI9ZnVuY3Rpb24obnVtYmVyLHNpZ25hbHMpe1xuY29uc3Qgc2lnbmFsPWZpbmRTaWduYWxCeU51bWJlcihudW1iZXIsc2lnbmFscyk7XG5cbmlmKHNpZ25hbD09PXVuZGVmaW5lZCl7XG5yZXR1cm57fTtcbn1cblxuY29uc3R7bmFtZSxkZXNjcmlwdGlvbixzdXBwb3J0ZWQsYWN0aW9uLGZvcmNlZCxzdGFuZGFyZH09c2lnbmFsO1xucmV0dXJue1xuW251bWJlcl06e1xubmFtZSxcbm51bWJlcixcbmRlc2NyaXB0aW9uLFxuc3VwcG9ydGVkLFxuYWN0aW9uLFxuZm9yY2VkLFxuc3RhbmRhcmR9fTtcblxuXG59O1xuXG5cblxuY29uc3QgZmluZFNpZ25hbEJ5TnVtYmVyPWZ1bmN0aW9uKG51bWJlcixzaWduYWxzKXtcbmNvbnN0IHNpZ25hbD1zaWduYWxzLmZpbmQoKHtuYW1lfSk9Pl9vcy5jb25zdGFudHMuc2lnbmFsc1tuYW1lXT09PW51bWJlcik7XG5cbmlmKHNpZ25hbCE9PXVuZGVmaW5lZCl7XG5yZXR1cm4gc2lnbmFsO1xufVxuXG5yZXR1cm4gc2lnbmFscy5maW5kKHNpZ25hbEE9PnNpZ25hbEEubnVtYmVyPT09bnVtYmVyKTtcbn07XG5cbmNvbnN0IHNpZ25hbHNCeU51bWJlcj1nZXRTaWduYWxzQnlOdW1iZXIoKTtleHBvcnRzLnNpZ25hbHNCeU51bWJlcj1zaWduYWxzQnlOdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5TSUdSVE1BWD1leHBvcnRzLmdldFJlYWx0aW1lU2lnbmFscz12b2lkIDA7XG5jb25zdCBnZXRSZWFsdGltZVNpZ25hbHM9ZnVuY3Rpb24oKXtcbmNvbnN0IGxlbmd0aD1TSUdSVE1BWC1TSUdSVE1JTisxO1xucmV0dXJuIEFycmF5LmZyb20oe2xlbmd0aH0sZ2V0UmVhbHRpbWVTaWduYWwpO1xufTtleHBvcnRzLmdldFJlYWx0aW1lU2lnbmFscz1nZXRSZWFsdGltZVNpZ25hbHM7XG5cbmNvbnN0IGdldFJlYWx0aW1lU2lnbmFsPWZ1bmN0aW9uKHZhbHVlLGluZGV4KXtcbnJldHVybntcbm5hbWU6YFNJR1JUJHtpbmRleCsxfWAsXG5udW1iZXI6U0lHUlRNSU4raW5kZXgsXG5hY3Rpb246XCJ0ZXJtaW5hdGVcIixcbmRlc2NyaXB0aW9uOlwiQXBwbGljYXRpb24tc3BlY2lmaWMgc2lnbmFsIChyZWFsdGltZSlcIixcbnN0YW5kYXJkOlwicG9zaXhcIn07XG5cbn07XG5cbmNvbnN0IFNJR1JUTUlOPTM0O1xuY29uc3QgU0lHUlRNQVg9NjQ7ZXhwb3J0cy5TSUdSVE1BWD1TSUdSVE1BWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWx0aW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5nZXRTaWduYWxzPXZvaWQgMDt2YXIgX29zPXJlcXVpcmUoXCJvc1wiKTtcblxudmFyIF9jb3JlPXJlcXVpcmUoXCIuL2NvcmUuanNcIik7XG52YXIgX3JlYWx0aW1lPXJlcXVpcmUoXCIuL3JlYWx0aW1lLmpzXCIpO1xuXG5cblxuY29uc3QgZ2V0U2lnbmFscz1mdW5jdGlvbigpe1xuY29uc3QgcmVhbHRpbWVTaWduYWxzPSgwLF9yZWFsdGltZS5nZXRSZWFsdGltZVNpZ25hbHMpKCk7XG5jb25zdCBzaWduYWxzPVsuLi5fY29yZS5TSUdOQUxTLC4uLnJlYWx0aW1lU2lnbmFsc10ubWFwKG5vcm1hbGl6ZVNpZ25hbCk7XG5yZXR1cm4gc2lnbmFscztcbn07ZXhwb3J0cy5nZXRTaWduYWxzPWdldFNpZ25hbHM7XG5cblxuXG5cblxuXG5cbmNvbnN0IG5vcm1hbGl6ZVNpZ25hbD1mdW5jdGlvbih7XG5uYW1lLFxubnVtYmVyOmRlZmF1bHROdW1iZXIsXG5kZXNjcmlwdGlvbixcbmFjdGlvbixcbmZvcmNlZD1mYWxzZSxcbnN0YW5kYXJkfSlcbntcbmNvbnN0e1xuc2lnbmFsczp7W25hbWVdOmNvbnN0YW50U2lnbmFsfX09XG5fb3MuY29uc3RhbnRzO1xuY29uc3Qgc3VwcG9ydGVkPWNvbnN0YW50U2lnbmFsIT09dW5kZWZpbmVkO1xuY29uc3QgbnVtYmVyPXN1cHBvcnRlZD9jb25zdGFudFNpZ25hbDpkZWZhdWx0TnVtYmVyO1xucmV0dXJue25hbWUsbnVtYmVyLGRlc2NyaXB0aW9uLHN1cHBvcnRlZCxhY3Rpb24sZm9yY2VkLHN0YW5kYXJkfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYWxzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNTdHJlYW0gPSBzdHJlYW0gPT5cblx0c3RyZWFtICE9PSBudWxsICYmXG5cdHR5cGVvZiBzdHJlYW0gPT09ICdvYmplY3QnICYmXG5cdHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gJ2Z1bmN0aW9uJztcblxuaXNTdHJlYW0ud3JpdGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ud3JpdGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRlID09PSAnZnVuY3Rpb24nICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgPT09ICdvYmplY3QnO1xuXG5pc1N0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbShzdHJlYW0pICYmXG5cdHN0cmVhbS5yZWFkYWJsZSAhPT0gZmFsc2UgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl9yZWFkYWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0uZHVwbGV4ID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLndyaXRhYmxlKHN0cmVhbSkgJiZcblx0aXNTdHJlYW0ucmVhZGFibGUoc3RyZWFtKTtcblxuaXNTdHJlYW0udHJhbnNmb3JtID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLmR1cGxleChzdHJlYW0pICYmXG5cdHR5cGVvZiBzdHJlYW0uX3RyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmVhbTtcbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBjb3JlXG5pZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fCBnbG9iYWwuVEVTVElOR19XSU5ET1dTKSB7XG4gIGNvcmUgPSByZXF1aXJlKCcuL3dpbmRvd3MuanMnKVxufSBlbHNlIHtcbiAgY29yZSA9IHJlcXVpcmUoJy4vbW9kZS5qcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNleGVcbmlzZXhlLnN5bmMgPSBzeW5jXG5cbmZ1bmN0aW9uIGlzZXhlIChwYXRoLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGlmICghY2IpIHtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlzZXhlKHBhdGgsIG9wdGlvbnMgfHwge30sIGZ1bmN0aW9uIChlciwgaXMpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoaXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGNvcmUocGF0aCwgb3B0aW9ucyB8fCB7fSwgZnVuY3Rpb24gKGVyLCBpcykge1xuICAgIC8vIGlnbm9yZSBFQUNDRVMgYmVjYXVzZSB0aGF0IGp1c3QgbWVhbnMgd2UgYXJlbid0IGFsbG93ZWQgdG8gcnVuIGl0XG4gICAgaWYgKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBQ0NFUycgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUVycm9ycykge1xuICAgICAgICBlciA9IG51bGxcbiAgICAgICAgaXMgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBjYihlciwgaXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN5bmMgKHBhdGgsIG9wdGlvbnMpIHtcbiAgLy8gbXkga2luZ2RvbSBmb3IgYSBmaWx0ZXJlZCBjYXRjaFxuICB0cnkge1xuICAgIHJldHVybiBjb3JlLnN5bmMocGF0aCwgb3B0aW9ucyB8fCB7fSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUVycm9ycyB8fCBlci5jb2RlID09PSAnRUFDQ0VTJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzZXhlXG5pc2V4ZS5zeW5jID0gc3luY1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG5cbmZ1bmN0aW9uIGlzZXhlIChwYXRoLCBvcHRpb25zLCBjYikge1xuICBmcy5zdGF0KHBhdGgsIGZ1bmN0aW9uIChlciwgc3RhdCkge1xuICAgIGNiKGVyLCBlciA/IGZhbHNlIDogY2hlY2tTdGF0KHN0YXQsIG9wdGlvbnMpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBzeW5jIChwYXRoLCBvcHRpb25zKSB7XG4gIHJldHVybiBjaGVja1N0YXQoZnMuc3RhdFN5bmMocGF0aCksIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhdCAoc3RhdCwgb3B0aW9ucykge1xuICByZXR1cm4gc3RhdC5pc0ZpbGUoKSAmJiBjaGVja01vZGUoc3RhdCwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gY2hlY2tNb2RlIChzdGF0LCBvcHRpb25zKSB7XG4gIHZhciBtb2QgPSBzdGF0Lm1vZGVcbiAgdmFyIHVpZCA9IHN0YXQudWlkXG4gIHZhciBnaWQgPSBzdGF0LmdpZFxuXG4gIHZhciBteVVpZCA9IG9wdGlvbnMudWlkICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudWlkIDogcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKVxuICB2YXIgbXlHaWQgPSBvcHRpb25zLmdpZCAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmdpZCA6IHByb2Nlc3MuZ2V0Z2lkICYmIHByb2Nlc3MuZ2V0Z2lkKClcblxuICB2YXIgdSA9IHBhcnNlSW50KCcxMDAnLCA4KVxuICB2YXIgZyA9IHBhcnNlSW50KCcwMTAnLCA4KVxuICB2YXIgbyA9IHBhcnNlSW50KCcwMDEnLCA4KVxuICB2YXIgdWcgPSB1IHwgZ1xuXG4gIHZhciByZXQgPSAobW9kICYgbykgfHxcbiAgICAobW9kICYgZykgJiYgZ2lkID09PSBteUdpZCB8fFxuICAgIChtb2QgJiB1KSAmJiB1aWQgPT09IG15VWlkIHx8XG4gICAgKG1vZCAmIHVnKSAmJiBteVVpZCA9PT0gMFxuXG4gIHJldHVybiByZXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNleGVcbmlzZXhlLnN5bmMgPSBzeW5jXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcblxuZnVuY3Rpb24gY2hlY2tQYXRoRXh0IChwYXRoLCBvcHRpb25zKSB7XG4gIHZhciBwYXRoZXh0ID0gb3B0aW9ucy5wYXRoRXh0ICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMucGF0aEV4dCA6IHByb2Nlc3MuZW52LlBBVEhFWFRcblxuICBpZiAoIXBhdGhleHQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcGF0aGV4dCA9IHBhdGhleHQuc3BsaXQoJzsnKVxuICBpZiAocGF0aGV4dC5pbmRleE9mKCcnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aGV4dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGF0aGV4dFtpXS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHAgJiYgcGF0aC5zdWJzdHIoLXAubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGF0IChzdGF0LCBwYXRoLCBvcHRpb25zKSB7XG4gIGlmICghc3RhdC5pc1N5bWJvbGljTGluaygpICYmICFzdGF0LmlzRmlsZSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGNoZWNrUGF0aEV4dChwYXRoLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpc2V4ZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXIsIHN0YXQpIHtcbiAgICBjYihlciwgZXIgPyBmYWxzZSA6IGNoZWNrU3RhdChzdGF0LCBwYXRoLCBvcHRpb25zKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc3luYyAocGF0aCwgb3B0aW9ucykge1xuICByZXR1cm4gY2hlY2tTdGF0KGZzLnN0YXRTeW5jKHBhdGgpLCBwYXRoLCBvcHRpb25zKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuY29uc3QgTUFYID0gU3ltYm9sKCdtYXgnKVxuY29uc3QgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKVxuY29uc3QgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxuY29uc3QgQUxMT1dfU1RBTEUgPSBTeW1ib2woJ2FsbG93U3RhbGUnKVxuY29uc3QgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJylcbmNvbnN0IERJU1BPU0UgPSBTeW1ib2woJ2Rpc3Bvc2UnKVxuY29uc3QgTk9fRElTUE9TRV9PTl9TRVQgPSBTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbmNvbnN0IExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0JylcbmNvbnN0IENBQ0hFID0gU3ltYm9sKCdjYWNoZScpXG5jb25zdCBVUERBVEVfQUdFX09OX0dFVCA9IFN5bWJvbCgndXBkYXRlQWdlT25HZXQnKVxuXG5jb25zdCBuYWl2ZUxlbmd0aCA9ICgpID0+IDFcblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge31cblxuICAgIGlmIChvcHRpb25zLm1heCAmJiAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLm1heCA8IDApKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gICAgY29uc3QgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHlcblxuICAgIGNvbnN0IGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9ICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpID8gbmFpdmVMZW5ndGggOiBsY1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICAgIGlmIChvcHRpb25zLm1heEFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gICAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbiAgc2V0IG1heCAobUwpIHtcbiAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHlcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9XG5cbiAgc2V0IGFsbG93U3RhbGUgKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9XG4gIGdldCBhbGxvd1N0YWxlICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfVxuXG4gIHNldCBtYXhBZ2UgKG1BKSB7XG4gICAgaWYgKHR5cGVvZiBtQSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXhBZ2UgKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbiAgc2V0IGxlbmd0aENhbGN1bGF0b3IgKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcblxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0pXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbGVuZ3RoQ2FsY3VsYXRvciAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfVxuICBnZXQgaXRlbUNvdW50ICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9XG5cbiAgcmZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IG5leHRcbiAgICB9XG4gIH1cblxuICBrZXlzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsua2V5KVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsudmFsdWUpXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSkpXG4gICAgfVxuXG4gICAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICAgIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIH1cblxuICBkdW1wICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGhpdCA9PlxuICAgICAgaXNTdGFsZSh0aGlzLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGggPT4gaClcbiAgfVxuXG4gIGR1bXBMcnUgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcblxuICAgIGNvbnN0IG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gICAgY29uc3QgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICAgIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKVxuICAgICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICBpdGVtLm5vdyA9IG5vd1xuICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgICAgdGhpcy5nZXQoa2V5KVxuICAgICAgdHJpbSh0aGlzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAgIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gICAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKVxuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gICAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGhhcyAoa2V5KSB7XG4gICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KVxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbiAgfVxuXG4gIHBlZWsgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZGVsKHRoaXMsIG5vZGUpXG4gICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICB9XG5cbiAgbG9hZCAoYXJyKSB7XG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgICBmb3IgKGxldCBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCBoaXQgPSBhcnJbbF1cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcnVuZSAoKSB7XG4gICAgdGhpc1tDQUNIRV0uZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpKVxuICB9XG59XG5cbmNvbnN0IGdldCA9IChzZWxmLCBrZXksIGRvVXNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSlcbiAgICAgICAgICBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KClcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpdC52YWx1ZVxuICB9XG59XG5cbmNvbnN0IGlzU3RhbGUgPSAoc2VsZiwgaGl0KSA9PiB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgICA6IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxufVxuXG5jb25zdCB0cmltID0gc2VsZiA9PiB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWwgPSAoc2VsZiwgbm9kZSkgPT4ge1xuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSlcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuXG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuY2xhc3MgRW50cnkge1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGlzLm5vdyA9IG5vd1xuICAgIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbiAgfVxufVxuXG5jb25zdCBmb3JFYWNoU3RlcCA9IChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApID0+IHtcbiAgbGV0IGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgfVxuICBpZiAoaGl0KVxuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gICAgY29uc3QgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcblxuICAgIHJldHVybiAoXG4gICAgICBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fFxuICAgICAgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCIvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0KClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICAgIHRoaXMucmF3ID0gcmFuZ2VcbiAgICB0aGlzLnNldCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXRcbiAgICAgIC5tYXAoKGNvbXBzKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ3x8JylcbiAgICAgIC50cmltKClcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UudHJpbSgpXG5cbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykuam9pbignLCcpXG4gICAgY29uc3QgbWVtb0tleSA9IGBwYXJzZVJhbmdlOiR7bWVtb09wdHN9OiR7cmFuZ2V9YFxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRcbiAgICB9XG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBsZXQgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgaWYgKGxvb3NlKSB7XG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgcmFuZ2VMaXN0ID0gcmFuZ2VMaXN0LmZpbHRlcihjb21wID0+IHtcbiAgICAgICAgZGVidWcoJ2xvb3NlIGludmFsaWQgZmlsdGVyJywgY29tcCwgdGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gISFjb21wLm1hdGNoKHJlW3QuQ09NUEFSQVRPUkxPT1NFXSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGRlYnVnKCdyYW5nZSBsaXN0JywgcmFuZ2VMaXN0KVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpIHtcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgfVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKSB7XG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpXG5jb25zdCBjYWNoZSA9IG5ldyBMUlUoeyBtYXg6IDEwMDAgfSlcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jb21wYXJhdG9yJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3Qge1xuICByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgaXNOdWxsU2V0ID0gYyA9PiBjLnZhbHVlID09PSAnPDAuMC4wLTAnXG5jb25zdCBpc0FueSA9IGMgPT4gYy52YWx1ZSA9PT0gJydcblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmNvbnN0IGlzU2F0aXNmaWFibGUgPSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgY29uc3QgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeSgob3RoZXJDb21wYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuY29uc3QgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmNvbnN0IGlzWCA9IGlkID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMC0wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4wLjAuMSAtLT4gPj0wLjAuMSA8MC4xLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGMpID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGMsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIGNvbnN0IHhNID0gaXNYKE0pXG4gICAgY29uc3QgeG0gPSB4TSB8fCBpc1gobSlcbiAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKVxuICAgIGNvbnN0IGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndGx0ID09PSAnPCcpIHtcbiAgICAgICAgcHIgPSAnLTAnXG4gICAgICB9XG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gKGAke2Zyb219ICR7dG99YCkudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmIChjb21wYXJlSWRlbnRpZmllcnModGhpcy5wcmVyZWxlYXNlWzBdLCBpZGVudGlmaWVyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQoKVxuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmXG4gICAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBhcnNlKGAke21hdGNoWzJdfS4ke21hdGNoWzNdIHx8ICcwJ30uJHttYXRjaFs0XSB8fCAnMCd9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcihcbiAgICAgIHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIgPyB2ZXJzaW9uLnZlcnNpb24gOiB2ZXJzaW9uLFxuICAgICAgb3B0aW9uc1xuICAgICkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iLCJjb25zdCB7IE1BWF9MRU5HVEggfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGlkZW50aWZpZXJzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKVxuY29uc3QgY2xlYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpXG5jb25zdCBpbmMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKVxuY29uc3QgZGlmZiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKVxuY29uc3QgbWFqb3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpXG5jb25zdCBtaW5vciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJylcbmNvbnN0IHBhdGNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKVxuY29uc3QgcHJlcmVsZWFzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKVxuY29uc3QgcnNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgY29lcmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgdG9Db21wYXJhdG9ycyA9IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJylcbmNvbnN0IG1heFNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKVxuY29uc3QgbWluVmVyc2lvbiA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpXG5jb25zdCBndHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKVxuY29uc3QgbHRyID0gcmVxdWlyZSgnLi9yYW5nZXMvbHRyJylcbmNvbnN0IGludGVyc2VjdHMgPSByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJylcbmNvbnN0IHNpbXBsaWZ5UmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpXG5jb25zdCBzdWJzZXQgPSByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlLFxuICB2YWxpZCxcbiAgY2xlYW4sXG4gIGluYyxcbiAgZGlmZixcbiAgbWFqb3IsXG4gIG1pbm9yLFxuICBwYXRjaCxcbiAgcHJlcmVsZWFzZSxcbiAgY29tcGFyZSxcbiAgcmNvbXBhcmUsXG4gIGNvbXBhcmVMb29zZSxcbiAgY29tcGFyZUJ1aWxkLFxuICBzb3J0LFxuICByc29ydCxcbiAgZ3QsXG4gIGx0LFxuICBlcSxcbiAgbmVxLFxuICBndGUsXG4gIGx0ZSxcbiAgY21wLFxuICBjb2VyY2UsXG4gIENvbXBhcmF0b3IsXG4gIFJhbmdlLFxuICBzYXRpc2ZpZXMsXG4gIHRvQ29tcGFyYXRvcnMsXG4gIG1heFNhdGlzZnlpbmcsXG4gIG1pblNhdGlzZnlpbmcsXG4gIG1pblZlcnNpb24sXG4gIHZhbGlkUmFuZ2UsXG4gIG91dHNpZGUsXG4gIGd0cixcbiAgbHRyLFxuICBpbnRlcnNlY3RzLFxuICBzaW1wbGlmeVJhbmdlLFxuICBzdWJzZXQsXG4gIFNlbVZlcixcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiBjb25zdGFudHMuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLnJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXQgc28gd2UgYWx3YXlzIGdldCBhIGNvbnNpc3RlbnRcbi8vIG9iaiB3aXRoIGtleXMgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuY29uc3Qgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ11cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT5cbiAgIW9wdGlvbnMgPyB7fVxuICA6IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgbG9vc2U6IHRydWUgfVxuICA6IG9wdHMuZmlsdGVyKGsgPT4gb3B0aW9uc1trXSkucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgb1trXSA9IHRydWVcbiAgICByZXR1cm4gb1xuICB9LCB7fSlcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCB7IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJylcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJylcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBmaXJzdCA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0KSB7XG4gICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSlcbiAgfVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICB9IGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHN1YiA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJyldXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXVxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cbiAgICB9XG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBlcVNldC5hZGQoYy5zZW12ZXIpXG4gICAgfVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGd0bHRDb21wID09PSAwICYmIChndC5vcGVyYXRvciAhPT0gJz49JyB8fCBsdC5vcGVyYXRvciAhPT0gJzw9JykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gd2lsbCBpdGVyYXRlIG9uZSBvciB6ZXJvIHRpbWVzXG4gIGZvciAoY29uc3QgZXEgb2YgZXFTZXQpIHtcbiAgICBpZiAoZ3QgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGx0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgIGlmICghc2F0aXNmaWVzKGVxLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3Qub3BlcmF0b3IgPT09ICc+PScgJiYgIXNhdGlzZmllcyhndC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gJzw9JyAmJiAhc2F0aXNmaWVzKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wID4gMCA/IGFcbiAgICA6IGNvbXAgPCAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJz4nICYmIGEub3BlcmF0b3IgPT09ICc+PScgPyBiXG4gICAgOiBhXG59XG5cbi8vIDw9MS4yLjMgaXMgaGlnaGVyIHRoYW4gPDEuMi4zXG5jb25zdCBsb3dlckxUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qc3RyZWFtcy4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gW11cbiAgdmFyIG91dHB1dCAgPSBuZXcgUGFzc1Rocm91Z2goe29iamVjdE1vZGU6IHRydWV9KVxuXG4gIG91dHB1dC5zZXRNYXhMaXN0ZW5lcnMoMClcblxuICBvdXRwdXQuYWRkID0gYWRkXG4gIG91dHB1dC5pc0VtcHR5ID0gaXNFbXB0eVxuXG4gIG91dHB1dC5vbigndW5waXBlJywgcmVtb3ZlKVxuXG4gIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChhZGQpXG5cbiAgcmV0dXJuIG91dHB1dFxuXG4gIGZ1bmN0aW9uIGFkZCAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlLmZvckVhY2goYWRkKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICBzb3VyY2Uub25jZSgnZW5kJywgcmVtb3ZlLmJpbmQobnVsbCwgc291cmNlKSlcbiAgICBzb3VyY2Uub25jZSgnZXJyb3InLCBvdXRwdXQuZW1pdC5iaW5kKG91dHB1dCwgJ2Vycm9yJykpXG4gICAgc291cmNlLnBpcGUob3V0cHV0LCB7ZW5kOiBmYWxzZX0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiBzb3VyY2VzLmxlbmd0aCA9PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlIChzb3VyY2UpIHtcbiAgICBzb3VyY2VzID0gc291cmNlcy5maWx0ZXIoZnVuY3Rpb24gKGl0KSB7IHJldHVybiBpdCAhPT0gc291cmNlIH0pXG4gICAgaWYgKCFzb3VyY2VzLmxlbmd0aCAmJiBvdXRwdXQucmVhZGFibGUpIHsgb3V0cHV0LmVuZCgpIH1cbiAgfVxufVxuIiwiLyohXG4gKiBtaW1lLWRiXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1LTIwMjIgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RiLmpzb24nKVxuIiwiLyohXG4gKiBtaW1lLXR5cGVzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZGIgPSByZXF1aXJlKCdtaW1lLWRiJylcbnZhciBleHRuYW1lID0gcmVxdWlyZSgncGF0aCcpLmV4dG5hbWVcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRVhUUkFDVF9UWVBFX1JFR0VYUCA9IC9eXFxzKihbXjtcXHNdKikoPzo7fFxcc3wkKS9cbnZhciBURVhUX1RZUEVfUkVHRVhQID0gL150ZXh0XFwvL2lcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNoYXJzZXQgPSBjaGFyc2V0XG5leHBvcnRzLmNoYXJzZXRzID0geyBsb29rdXA6IGNoYXJzZXQgfVxuZXhwb3J0cy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG5leHBvcnRzLmV4dGVuc2lvbiA9IGV4dGVuc2lvblxuZXhwb3J0cy5leHRlbnNpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuZXhwb3J0cy5sb29rdXAgPSBsb29rdXBcbmV4cG9ydHMudHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8vIFBvcHVsYXRlIHRoZSBleHRlbnNpb25zL3R5cGVzIG1hcHNcbnBvcHVsYXRlTWFwcyhleHBvcnRzLmV4dGVuc2lvbnMsIGV4cG9ydHMudHlwZXMpXG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGNoYXJzZXQgZm9yIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjaGFyc2V0ICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBtZWRpYS10eXBlclxuICB2YXIgbWF0Y2ggPSBFWFRSQUNUX1RZUEVfUkVHRVhQLmV4ZWModHlwZSlcbiAgdmFyIG1pbWUgPSBtYXRjaCAmJiBkYlttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmIChtaW1lICYmIG1pbWUuY2hhcnNldCkge1xuICAgIHJldHVybiBtaW1lLmNoYXJzZXRcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdGV4dC8qIHRvIHV0Zi04XG4gIGlmIChtYXRjaCAmJiBURVhUX1RZUEVfUkVHRVhQLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bGwgQ29udGVudC1UeXBlIGhlYWRlciBnaXZlbiBhIE1JTUUgdHlwZSBvciBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY29udGVudFR5cGUgKHN0cikge1xuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBldmVuIGJlIGluIHRoaXMgbW9kdWxlP1xuICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pbWUgPSBzdHIuaW5kZXhPZignLycpID09PSAtMVxuICAgID8gZXhwb3J0cy5sb29rdXAoc3RyKVxuICAgIDogc3RyXG5cbiAgaWYgKCFtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgY29udGVudC10eXBlIG9yIG90aGVyIG1vZHVsZVxuICBpZiAobWltZS5pbmRleE9mKCdjaGFyc2V0JykgPT09IC0xKSB7XG4gICAgdmFyIGNoYXJzZXQgPSBleHBvcnRzLmNoYXJzZXQobWltZSlcbiAgICBpZiAoY2hhcnNldCkgbWltZSArPSAnOyBjaGFyc2V0PScgKyBjaGFyc2V0LnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIHJldHVybiBtaW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGV4dGVuc2lvbiBmb3IgYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuc2lvbiAodHlwZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgbWVkaWEtdHlwZXJcbiAgdmFyIG1hdGNoID0gRVhUUkFDVF9UWVBFX1JFR0VYUC5leGVjKHR5cGUpXG5cbiAgLy8gZ2V0IGV4dGVuc2lvbnNcbiAgdmFyIGV4dHMgPSBtYXRjaCAmJiBleHBvcnRzLmV4dGVuc2lvbnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV1cblxuICBpZiAoIWV4dHMgfHwgIWV4dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXh0c1swXVxufVxuXG4vKipcbiAqIExvb2t1cCB0aGUgTUlNRSB0eXBlIGZvciBhIGZpbGUgcGF0aC9leHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAocGF0aCkge1xuICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBnZXQgdGhlIGV4dGVuc2lvbiAoXCJleHRcIiBvciBcIi5leHRcIiBvciBmdWxsIHBhdGgpXG4gIHZhciBleHRlbnNpb24gPSBleHRuYW1lKCd4LicgKyBwYXRoKVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnN1YnN0cigxKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy50eXBlc1tleHRlbnNpb25dIHx8IGZhbHNlXG59XG5cbi8qKlxuICogUG9wdWxhdGUgdGhlIGV4dGVuc2lvbnMgYW5kIHR5cGVzIG1hcHMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWFwcyAoZXh0ZW5zaW9ucywgdHlwZXMpIHtcbiAgLy8gc291cmNlIHByZWZlcmVuY2UgKGxlYXN0IC0+IG1vc3QpXG4gIHZhciBwcmVmZXJlbmNlID0gWyduZ2lueCcsICdhcGFjaGUnLCB1bmRlZmluZWQsICdpYW5hJ11cblxuICBPYmplY3Qua2V5cyhkYikuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoTWltZVR5cGUgKHR5cGUpIHtcbiAgICB2YXIgbWltZSA9IGRiW3R5cGVdXG4gICAgdmFyIGV4dHMgPSBtaW1lLmV4dGVuc2lvbnNcblxuICAgIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG1pbWUgLT4gZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnNbdHlwZV0gPSBleHRzXG5cbiAgICAvLyBleHRlbnNpb24gLT4gbWltZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dHNbaV1cblxuICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0pIHtcbiAgICAgICAgdmFyIGZyb20gPSBwcmVmZXJlbmNlLmluZGV4T2YoZGJbdHlwZXNbZXh0ZW5zaW9uXV0uc291cmNlKVxuICAgICAgICB2YXIgdG8gPSBwcmVmZXJlbmNlLmluZGV4T2YobWltZS5zb3VyY2UpXG5cbiAgICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0gIT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nICYmXG4gICAgICAgICAgKGZyb20gPiB0byB8fCAoZnJvbSA9PT0gdG8gJiYgdHlwZXNbZXh0ZW5zaW9uXS5zdWJzdHIoMCwgMTIpID09PSAnYXBwbGljYXRpb24vJykpKSB7XG4gICAgICAgICAgLy8gc2tpcCB0aGUgcmVtYXBwaW5nXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIGV4dGVuc2lvbiAtPiBtaW1lXG4gICAgICB0eXBlc1tleHRlbnNpb25dID0gdHlwZVxuICAgIH1cbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZiA9IHJlcXVpcmUoJ0BzaW5kcmVzb3JodXMvZGYnKTtcbnZhciBwaWZ5ID0gcmVxdWlyZSgncGlmeScpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdwaW5raWUtcHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWxlKSB7XG5cdHJldHVybiBwaWZ5KGRmLmZpbGUsIFByb21pc2UpKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRyZXR1cm4gZGF0YS5tb3VudHBvaW50O1xuXHR9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hpbGRQcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuXG5mdW5jdGlvbiBydW4oYXJncywgY2IpIHtcblx0Y2hpbGRQcm9jZXNzLmV4ZWNGaWxlKCdkZicsIGFyZ3MsIGZ1bmN0aW9uIChlcnIsIHN0ZG91dCkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGNiKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2IobnVsbCwgc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJykuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0dmFyIGNsID0gZWwuc3BsaXQoL1xccysoPz1bXFxkXFwvXSkvKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZmlsZXN5c3RlbTogY2xbMF0sXG5cdFx0XHRcdHNpemU6IHBhcnNlSW50KGNsWzFdLCAxMCkgKiAxMDI0LFxuXHRcdFx0XHR1c2VkOiBwYXJzZUludChjbFsyXSwgMTApICogMTAyNCxcblx0XHRcdFx0YXZhaWxhYmxlOiBwYXJzZUludChjbFszXSwgMTApICogMTAyNCxcblx0XHRcdFx0Y2FwYWNpdHk6IHBhcnNlSW50KGNsWzRdLCAxMCkgLyAxMDAsXG5cdFx0XHRcdG1vdW50cG9pbnQ6IGNsWzVdXG5cdFx0XHR9O1xuXHRcdH0pKTtcblx0fSk7XG59O1xuXG52YXIgZGYgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjYikge1xuXHRydW4oWycta1AnXSwgY2IpO1xufTtcblxuZGYuZnMgPSBmdW5jdGlvbiAobmFtZSwgY2IpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignbmFtZSByZXF1aXJlZCcpO1xuXHR9XG5cblx0cnVuKFsnLWtQJ10sIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRjYihlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciByZXQ7XG5cblx0XHRkYXRhLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRpZiAoZWwuZmlsZXN5c3RlbSA9PT0gbmFtZSkge1xuXHRcdFx0XHRyZXQgPSBlbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNiKG51bGwsIHJldCk7XG5cdH0pO1xufTtcblxuZGYuZmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBjYikge1xuXHRpZiAodHlwZW9mIGZpbGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaWxlIHJlcXVpcmVkJyk7XG5cdH1cblxuXHRydW4oWycta1AnLCBmaWxlXSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGNiKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2IobnVsbCwgZGF0YVswXSk7XG5cdH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHByb2Nlc3NGbiA9IGZ1bmN0aW9uIChmbiwgUCwgb3B0cykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdH0pO1xuXHR9O1xufTtcblxudmFyIHBpZnkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIFAsIG9wdHMpIHtcblx0aWYgKHR5cGVvZiBQICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0b3B0cyA9IFA7XG5cdFx0UCA9IFByb21pc2U7XG5cdH1cblxuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0b3B0cy5leGNsdWRlID0gb3B0cy5leGNsdWRlIHx8IFsvLitTeW5jJC9dO1xuXG5cdHZhciBmaWx0ZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIG1hdGNoID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcblx0XHRcdHJldHVybiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0dmFyIHJldCA9IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgUCwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSA6IHt9O1xuXG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocmV0LCBrZXkpIHtcblx0XHR2YXIgeCA9IG9ialtrZXldO1xuXG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBQLCBvcHRzKSA6IHg7XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCByZXQpO1xufTtcblxucGlmeS5hbGwgPSBwaWZ5O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgcGF0aEtleSA9IHJlcXVpcmUoJ3BhdGgta2V5Jyk7XG5cbmNvbnN0IG5wbVJ1blBhdGggPSBvcHRpb25zID0+IHtcblx0b3B0aW9ucyA9IHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKCksXG5cdFx0cGF0aDogcHJvY2Vzcy5lbnZbcGF0aEtleSgpXSxcblx0XHRleGVjUGF0aDogcHJvY2Vzcy5leGVjUGF0aCxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cblx0bGV0IHByZXZpb3VzO1xuXHRsZXQgY3dkUGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCk7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXG5cdHdoaWxlIChwcmV2aW91cyAhPT0gY3dkUGF0aCkge1xuXHRcdHJlc3VsdC5wdXNoKHBhdGguam9pbihjd2RQYXRoLCAnbm9kZV9tb2R1bGVzLy5iaW4nKSk7XG5cdFx0cHJldmlvdXMgPSBjd2RQYXRoO1xuXHRcdGN3ZFBhdGggPSBwYXRoLnJlc29sdmUoY3dkUGF0aCwgJy4uJyk7XG5cdH1cblxuXHQvLyBFbnN1cmUgdGhlIHJ1bm5pbmcgYG5vZGVgIGJpbmFyeSBpcyB1c2VkXG5cdGNvbnN0IGV4ZWNQYXRoRGlyID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmV4ZWNQYXRoLCAnLi4nKTtcblx0cmVzdWx0LnB1c2goZXhlY1BhdGhEaXIpO1xuXG5cdHJldHVybiByZXN1bHQuY29uY2F0KG9wdGlvbnMucGF0aCkuam9pbihwYXRoLmRlbGltaXRlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5wbVJ1blBhdGg7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG5wbVJ1blBhdGg7XG5cbm1vZHVsZS5leHBvcnRzLmVudiA9IG9wdGlvbnMgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdGVudjogcHJvY2Vzcy5lbnYsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IGVudiA9IHsuLi5vcHRpb25zLmVudn07XG5cdGNvbnN0IHBhdGggPSBwYXRoS2V5KHtlbnZ9KTtcblxuXHRvcHRpb25zLnBhdGggPSBlbnZbcGF0aF07XG5cdGVudltwYXRoXSA9IG1vZHVsZS5leHBvcnRzKG9wdGlvbnMpO1xuXG5cdHJldHVybiBlbnY7XG59O1xuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5jb25zdCBjYWxsZWRGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBvbmV0aW1lID0gKGZ1bmN0aW9uXywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0bGV0IHJldHVyblZhbHVlO1xuXHRsZXQgY2FsbENvdW50ID0gMDtcblx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPic7XG5cblx0Y29uc3Qgb25ldGltZSA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCArK2NhbGxDb3VudCk7XG5cblx0XHRpZiAoY2FsbENvdW50ID09PSAxKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcblx0XHRcdGZ1bmN0aW9uXyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnRocm93ID09PSB0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRtaW1pY0ZuKG9uZXRpbWUsIGZ1bmN0aW9uXyk7XG5cdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgY2FsbENvdW50KTtcblxuXHRyZXR1cm4gb25ldGltZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb25ldGltZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcblxubW9kdWxlLmV4cG9ydHMuY2FsbENvdW50ID0gZnVuY3Rpb25fID0+IHtcblx0aWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG5cdH1cblxuXHRyZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbmZ1bmN0aW9uIGhvbWVkaXIoKSB7XG5cdHZhciBlbnYgPSBwcm9jZXNzLmVudjtcblx0dmFyIGhvbWUgPSBlbnYuSE9NRTtcblx0dmFyIHVzZXIgPSBlbnYuTE9HTkFNRSB8fCBlbnYuVVNFUiB8fCBlbnYuTE5BTUUgfHwgZW52LlVTRVJOQU1FO1xuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIGVudi5VU0VSUFJPRklMRSB8fCBlbnYuSE9NRURSSVZFICsgZW52LkhPTUVQQVRIIHx8IGhvbWUgfHwgbnVsbDtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuXHRcdHJldHVybiBob21lIHx8ICh1c2VyID8gJy9Vc2Vycy8nICsgdXNlciA6IG51bGwpO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcblx0XHRyZXR1cm4gaG9tZSB8fCAocHJvY2Vzcy5nZXR1aWQoKSA9PT0gMCA/ICcvcm9vdCcgOiAodXNlciA/ICcvaG9tZS8nICsgdXNlciA6IG51bGwpKTtcblx0fVxuXG5cdHJldHVybiBob21lIHx8IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIG9zLmhvbWVkaXIgPT09ICdmdW5jdGlvbicgPyBvcy5ob21lZGlyIDogaG9tZWRpcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoXG5cdHByb21pc2UsXG5cdG9uRmluYWxseSA9ICgoKSA9PiB7fSlcbikgPT4ge1xuXHRsZXQgdmFsdWU7XG5cdHRyeSB7XG5cdFx0dmFsdWUgPSBhd2FpdCBwcm9taXNlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGF3YWl0IG9uRmluYWxseSgpO1xuXHRcdHRocm93IGVycm9yO1xuXHR9XG5cblx0YXdhaXQgb25GaW5hbGx5KCk7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGhLZXkgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnYgfHwgcHJvY2Vzcy5lbnY7XG5cdGNvbnN0IHBsYXRmb3JtID0gb3B0aW9ucy5wbGF0Zm9ybSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xuXG5cdGlmIChwbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuXHRcdHJldHVybiAnUEFUSCc7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LmtleXMoZW52aXJvbm1lbnQpLnJldmVyc2UoKS5maW5kKGtleSA9PiBrZXkudG9VcHBlckNhc2UoKSA9PT0gJ1BBVEgnKSB8fCAnUGF0aCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhLZXk7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBhdGhLZXk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlIDogcmVxdWlyZSgncGlua2llJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQRU5ESU5HID0gJ3BlbmRpbmcnO1xudmFyIFNFVFRMRUQgPSAnc2V0dGxlZCc7XG52YXIgRlVMRklMTEVEID0gJ2Z1bGZpbGxlZCc7XG52YXIgUkVKRUNURUQgPSAncmVqZWN0ZWQnO1xudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7fTtcbnZhciBpc05vZGUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwucHJvY2Vzcy5lbWl0ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgYXN5bmNTZXRUaW1lciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnID8gc2V0VGltZW91dCA6IHNldEltbWVkaWF0ZTtcbnZhciBhc3luY1F1ZXVlID0gW107XG52YXIgYXN5bmNUaW1lcjtcblxuZnVuY3Rpb24gYXN5bmNGbHVzaCgpIHtcblx0Ly8gcnVuIHByb21pc2UgY2FsbGJhY2tzXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXN5bmNRdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdGFzeW5jUXVldWVbaV1bMF0oYXN5bmNRdWV1ZVtpXVsxXSk7XG5cdH1cblxuXHQvLyByZXNldCBhc3luYyBhc3luY1F1ZXVlXG5cdGFzeW5jUXVldWUgPSBbXTtcblx0YXN5bmNUaW1lciA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhc3luY0NhbGwoY2FsbGJhY2ssIGFyZykge1xuXHRhc3luY1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmddKTtcblxuXHRpZiAoIWFzeW5jVGltZXIpIHtcblx0XHRhc3luY1RpbWVyID0gdHJ1ZTtcblx0XHRhc3luY1NldFRpbWVyKGFzeW5jRmx1c2gsIDApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCBwcm9taXNlKSB7XG5cdGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG5cdFx0cmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuXHRcdHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZXNvbHZlcihyZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZWplY3RQcm9taXNlKGUpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHN1YnNjcmliZXIpIHtcblx0dmFyIG93bmVyID0gc3Vic2NyaWJlci5vd25lcjtcblx0dmFyIHNldHRsZWQgPSBvd25lci5fc3RhdGU7XG5cdHZhciB2YWx1ZSA9IG93bmVyLl9kYXRhO1xuXHR2YXIgY2FsbGJhY2sgPSBzdWJzY3JpYmVyW3NldHRsZWRdO1xuXHR2YXIgcHJvbWlzZSA9IHN1YnNjcmliZXIudGhlbjtcblxuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0dGxlZCA9IEZVTEZJTExFRDtcblx0XHR0cnkge1xuXHRcdFx0dmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmVqZWN0KHByb21pc2UsIGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG5cdFx0aWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuXHRcdFx0cmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG5cdFx0XHRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkge1xuXHR2YXIgcmVzb2x2ZWQ7XG5cblx0dHJ5IHtcblx0XHRpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0Ly8gdGhlbiBzaG91bGQgYmUgcmV0cmlldmVkIG9ubHkgb25jZVxuXHRcdFx0dmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuXG5cdFx0XHRpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhlbi5jYWxsKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdFx0aWYgKCFyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHZhbCkge1xuXHRcdFx0XHRcdFx0XHRmdWxmaWxsKHByb21pc2UsIHZhbCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKHByb21pc2UsIHZhbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRcdFx0aWYgKCFyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICghcmVzb2x2ZWQpIHtcblx0XHRcdHJlamVjdChwcm9taXNlLCBlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuXHRpZiAocHJvbWlzZSA9PT0gdmFsdWUgfHwgIWhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuXHRcdGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcblx0aWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG5cdFx0cHJvbWlzZS5fc3RhdGUgPSBTRVRUTEVEO1xuXHRcdHByb21pc2UuX2RhdGEgPSB2YWx1ZTtcblxuXHRcdGFzeW5jQ2FsbChwdWJsaXNoRnVsZmlsbG1lbnQsIHByb21pc2UpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcblx0aWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG5cdFx0cHJvbWlzZS5fc3RhdGUgPSBTRVRUTEVEO1xuXHRcdHByb21pc2UuX2RhdGEgPSByZWFzb247XG5cblx0XHRhc3luY0NhbGwocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG5cdHByb21pc2UuX3RoZW4gPSBwcm9taXNlLl90aGVuLmZvckVhY2goaW52b2tlQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwdWJsaXNoRnVsZmlsbG1lbnQocHJvbWlzZSkge1xuXHRwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblx0cHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG5cdHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG5cdHB1Ymxpc2gocHJvbWlzZSk7XG5cdGlmICghcHJvbWlzZS5faGFuZGxlZCAmJiBpc05vZGUpIHtcblx0XHRnbG9iYWwucHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCBwcm9taXNlLl9kYXRhLCBwcm9taXNlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBub3RpZnlSZWplY3Rpb25IYW5kbGVkKHByb21pc2UpIHtcblx0Z2xvYmFsLnByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xufVxuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG5cdGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHJlc29sdmVyICcgKyByZXNvbHZlciArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXG5cdGlmICh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA9PT0gZmFsc2UpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ1Byb21pc2VcXCc6IFBsZWFzZSB1c2UgdGhlIFxcJ25ld1xcJyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpO1xuXHR9XG5cblx0dGhpcy5fdGhlbiA9IFtdO1xuXG5cdGludm9rZVJlc29sdmVyKHJlc29sdmVyLCB0aGlzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG5cdF9zdGF0ZTogUEVORElORyxcblx0X3RoZW46IG51bGwsXG5cdF9kYXRhOiB1bmRlZmluZWQsXG5cdF9oYW5kbGVkOiBmYWxzZSxcblxuXHR0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcblx0XHR2YXIgc3Vic2NyaWJlciA9IHtcblx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0dGhlbjogbmV3IHRoaXMuY29uc3RydWN0b3IoTk9PUCksXG5cdFx0XHRmdWxmaWxsZWQ6IG9uRnVsZmlsbG1lbnQsXG5cdFx0XHRyZWplY3RlZDogb25SZWplY3Rpb25cblx0XHR9O1xuXG5cdFx0aWYgKChvblJlamVjdGlvbiB8fCBvbkZ1bGZpbGxtZW50KSAmJiAhdGhpcy5faGFuZGxlZCkge1xuXHRcdFx0dGhpcy5faGFuZGxlZCA9IHRydWU7XG5cdFx0XHRpZiAodGhpcy5fc3RhdGUgPT09IFJFSkVDVEVEICYmIGlzTm9kZSkge1xuXHRcdFx0XHRhc3luY0NhbGwobm90aWZ5UmVqZWN0aW9uSGFuZGxlZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3N0YXRlID09PSBGVUxGSUxMRUQgfHwgdGhpcy5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG5cdFx0XHQvLyBhbHJlYWR5IHJlc29sdmVkLCBjYWxsIGNhbGxiYWNrIGFzeW5jXG5cdFx0XHRhc3luY0NhbGwoaW52b2tlQ2FsbGJhY2ssIHN1YnNjcmliZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzdWJzY3JpYmVcblx0XHRcdHRoaXMuX3RoZW4ucHVzaChzdWJzY3JpYmVyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3Vic2NyaWJlci50aGVuO1xuXHR9LFxuXG5cdGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3Rpb24pIHtcblx0XHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcblx0fVxufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KHByb21pc2VzKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gUHJvbWlzZS5hbGwoKS4nKTtcblx0fVxuXG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHJlc3VsdHMgPSBbXTtcblx0XHR2YXIgcmVtYWluaW5nID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XG5cdFx0XHRyZW1haW5pbmcrKztcblx0XHRcdHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCEtLXJlbWFpbmluZykge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIHByb21pc2U7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG5cdFx0XHRpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSBwcm9taXNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghcmVtYWluaW5nKSB7XG5cdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KHByb21pc2VzKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gUHJvbWlzZS5yYWNlKCkuJyk7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuXHRcdFx0aWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmUocHJvbWlzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdHJlc29sdmUodmFsdWUpO1xuXHR9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHJlamVjdChyZWFzb24pO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpIC8vIHdlIG9ubHkgbmVlZCBmcyB0byBnZXQgdGhlIFJlYWRTdHJlYW0gYW5kIFdyaXRlU3RyZWFtIHByb3RvdHlwZXNcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIGFuY2llbnQgPSAvXnY/XFwuMC8udGVzdChwcm9jZXNzLnZlcnNpb24pXG5cbnZhciBpc0ZuID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbidcbn1cblxudmFyIGlzRlMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIGlmICghYW5jaWVudCkgcmV0dXJuIGZhbHNlIC8vIG5ld2VyIG5vZGUgdmVyc2lvbiBkbyBub3QgbmVlZCB0byBjYXJlIGFib3V0IGZzIGlzIGEgc3BlY2lhbCB3YXlcbiAgaWYgKCFmcykgcmV0dXJuIGZhbHNlIC8vIGJyb3dzZXJcbiAgcmV0dXJuIChzdHJlYW0gaW5zdGFuY2VvZiAoZnMuUmVhZFN0cmVhbSB8fCBub29wKSB8fCBzdHJlYW0gaW5zdGFuY2VvZiAoZnMuV3JpdGVTdHJlYW0gfHwgbm9vcCkpICYmIGlzRm4oc3RyZWFtLmNsb3NlKVxufVxuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiBpc0ZuKHN0cmVhbS5hYm9ydClcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uIChzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICB2YXIgY2xvc2VkID0gZmFsc2VcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgZW9zKHN0cmVhbSwge3JlYWRhYmxlOiByZWFkaW5nLCB3cml0YWJsZTogd3JpdGluZ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuXG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgaWYgKGlzRlMoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5jbG9zZShub29wKSAvLyB1c2UgY2xvc2UgZm9yIGZzIHN0cmVhbXMgdG8gYXZvaWQgZmQgbGVha3NcbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKSAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzRm4oc3RyZWFtLmRlc3Ryb3kpKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKVxuXG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFcnJvcignc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSlcbiAgfVxufVxuXG52YXIgY2FsbCA9IGZ1bmN0aW9uIChmbikge1xuICBmbigpXG59XG5cbnZhciBwaXBlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pXG59XG5cbnZhciBwdW1wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyZWFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgdmFyIGNhbGxiYWNrID0gaXNGbihzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gfHwgbm9vcCkgJiYgc3RyZWFtcy5wb3AoKSB8fCBub29wXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcigncHVtcCByZXF1aXJlcyB0d28gc3RyZWFtcyBwZXIgbWluaW11bScpXG5cbiAgdmFyIGVycm9yXG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDFcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwXG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyXG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpXG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuXG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpXG4gICAgICBjYWxsYmFjayhlcnJvcilcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHB1bXBcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHNoZWJhbmdSZWdleCA9IHJlcXVpcmUoJ3NoZWJhbmctcmVnZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoc3RyaW5nID0gJycpID0+IHtcblx0Y29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2goc2hlYmFuZ1JlZ2V4KTtcblxuXHRpZiAoIW1hdGNoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBbcGF0aCwgYXJndW1lbnRdID0gbWF0Y2hbMF0ucmVwbGFjZSgvIyEgPy8sICcnKS5zcGxpdCgnICcpO1xuXHRjb25zdCBiaW5hcnkgPSBwYXRoLnNwbGl0KCcvJykucG9wKCk7XG5cblx0aWYgKGJpbmFyeSA9PT0gJ2VudicpIHtcblx0XHRyZXR1cm4gYXJndW1lbnQ7XG5cdH1cblxuXHRyZXR1cm4gYXJndW1lbnQgPyBgJHtiaW5hcnl9ICR7YXJndW1lbnR9YCA6IGJpbmFyeTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IC9eIyEoLiopLztcbiIsIi8vIE5vdGU6IHNpbmNlIG55YyB1c2VzIHRoaXMgbW9kdWxlIHRvIG91dHB1dCBjb3ZlcmFnZSwgYW55IGxpbmVzXG4vLyB0aGF0IGFyZSBpbiB0aGUgZGlyZWN0IHN5bmMgZmxvdyBvZiBueWMncyBvdXRwdXRDb3ZlcmFnZSBhcmVcbi8vIGlnbm9yZWQsIHNpbmNlIHdlIGNhbiBuZXZlciBnZXQgY292ZXJhZ2UgZm9yIHRoZW0uXG4vLyBncmFiIGEgcmVmZXJlbmNlIHRvIG5vZGUncyByZWFsIHByb2Nlc3Mgb2JqZWN0IHJpZ2h0IGF3YXlcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3NcblxuY29uc3QgcHJvY2Vzc09rID0gZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgcmV0dXJuIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5yZWFsbHlFeGl0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb2Nlc3MubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb2Nlc3Mua2lsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnBpZCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vLyBzb21lIGtpbmQgb2Ygbm9uLW5vZGUgZW52aXJvbm1lbnQsIGp1c3Qgbm8tb3Bcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFwcm9jZXNzT2socHJvY2VzcykpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9XG4gIH1cbn0gZWxzZSB7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuICB2YXIgc2lnbmFscyA9IHJlcXVpcmUoJy4vc2lnbmFscy5qcycpXG4gIHZhciBpc1dpbiA9IC9ed2luL2kudGVzdChwcm9jZXNzLnBsYXRmb3JtKVxuXG4gIHZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIEVFICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgRUUgPSBFRS5FdmVudEVtaXR0ZXJcbiAgfVxuXG4gIHZhciBlbWl0dGVyXG4gIGlmIChwcm9jZXNzLl9fc2lnbmFsX2V4aXRfZW1pdHRlcl9fKSB7XG4gICAgZW1pdHRlciA9IHByb2Nlc3MuX19zaWduYWxfZXhpdF9lbWl0dGVyX19cbiAgfSBlbHNlIHtcbiAgICBlbWl0dGVyID0gcHJvY2Vzcy5fX3NpZ25hbF9leGl0X2VtaXR0ZXJfXyA9IG5ldyBFRSgpXG4gICAgZW1pdHRlci5jb3VudCA9IDBcbiAgICBlbWl0dGVyLmVtaXR0ZWQgPSB7fVxuICB9XG5cbiAgLy8gQmVjYXVzZSB0aGlzIGVtaXR0ZXIgaXMgYSBnbG9iYWwsIHdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIGlmIGFcbiAgLy8gcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIGxpYnJhcnkgZmFpbGVkIHRvIGVuYWJsZSBpbmZpbml0ZSBsaXN0ZW5lcnMuXG4gIC8vIEkga25vdyB3aGF0IHlvdSdyZSBhYm91dCB0byBzYXkuICBCdXQgbGl0ZXJhbGx5IGV2ZXJ5dGhpbmcgYWJvdXRcbiAgLy8gc2lnbmFsLWV4aXQgaXMgYSBjb21wcm9taXNlIHdpdGggZXZpbC4gIEdldCB1c2VkIHRvIGl0LlxuICBpZiAoIWVtaXR0ZXIuaW5maW5pdGUpIHtcbiAgICBlbWl0dGVyLnNldE1heExpc3RlbmVycyhJbmZpbml0eSlcbiAgICBlbWl0dGVyLmluZmluaXRlID0gdHJ1ZVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2IsIG9wdHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnYSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIGZvciBleGl0IGhhbmRsZXInKVxuXG4gICAgaWYgKGxvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGxvYWQoKVxuICAgIH1cblxuICAgIHZhciBldiA9ICdleGl0J1xuICAgIGlmIChvcHRzICYmIG9wdHMuYWx3YXlzTGFzdCkge1xuICAgICAgZXYgPSAnYWZ0ZXJleGl0J1xuICAgIH1cblxuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2LCBjYilcbiAgICAgIGlmIChlbWl0dGVyLmxpc3RlbmVycygnZXhpdCcpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgIGVtaXR0ZXIubGlzdGVuZXJzKCdhZnRlcmV4aXQnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdW5sb2FkKClcbiAgICAgIH1cbiAgICB9XG4gICAgZW1pdHRlci5vbihldiwgY2IpXG5cbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICB2YXIgdW5sb2FkID0gZnVuY3Rpb24gdW5sb2FkICgpIHtcbiAgICBpZiAoIWxvYWRlZCB8fCAhcHJvY2Vzc09rKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxvYWRlZCA9IGZhbHNlXG5cbiAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24gKHNpZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihzaWcsIHNpZ0xpc3RlbmVyc1tzaWddKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfSlcbiAgICBwcm9jZXNzLmVtaXQgPSBvcmlnaW5hbFByb2Nlc3NFbWl0XG4gICAgcHJvY2Vzcy5yZWFsbHlFeGl0ID0gb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdFxuICAgIGVtaXR0ZXIuY291bnQgLT0gMVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLnVubG9hZCA9IHVubG9hZFxuXG4gIHZhciBlbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnQsIGNvZGUsIHNpZ25hbCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbWl0dGVyLmVtaXR0ZWRbZXZlbnRdKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW1pdHRlci5lbWl0dGVkW2V2ZW50XSA9IHRydWVcbiAgICBlbWl0dGVyLmVtaXQoZXZlbnQsIGNvZGUsIHNpZ25hbClcbiAgfVxuXG4gIC8vIHsgPHNpZ25hbD46IDxsaXN0ZW5lciBmbj4sIC4uLiB9XG4gIHZhciBzaWdMaXN0ZW5lcnMgPSB7fVxuICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24gKHNpZykge1xuICAgIHNpZ0xpc3RlbmVyc1tzaWddID0gZnVuY3Rpb24gbGlzdGVuZXIgKCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgbGlzdGVuZXJzLCBhbiBleGl0IGlzIGNvbWluZyFcbiAgICAgIC8vIFNpbXBsZXN0IHdheTogcmVtb3ZlIHVzIGFuZCB0aGVuIHJlLXNlbmQgdGhlIHNpZ25hbC5cbiAgICAgIC8vIFdlIGtub3cgdGhhdCB0aGlzIHdpbGwga2lsbCB0aGUgcHJvY2Vzcywgc28gd2UgY2FuXG4gICAgICAvLyBzYWZlbHkgZW1pdCBub3cuXG4gICAgICB2YXIgbGlzdGVuZXJzID0gcHJvY2Vzcy5saXN0ZW5lcnMoc2lnKVxuICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IGVtaXR0ZXIuY291bnQpIHtcbiAgICAgICAgdW5sb2FkKClcbiAgICAgICAgZW1pdCgnZXhpdCcsIG51bGwsIHNpZylcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZW1pdCgnYWZ0ZXJleGl0JywgbnVsbCwgc2lnKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoaXNXaW4gJiYgc2lnID09PSAnU0lHSFVQJykge1xuICAgICAgICAgIC8vIFwiU0lHSFVQXCIgdGhyb3dzIGFuIGBFTk9TWVNgIGVycm9yIG9uIFdpbmRvd3MsXG4gICAgICAgICAgLy8gc28gdXNlIGEgc3VwcG9ydGVkIHNpZ25hbCBpbnN0ZWFkXG4gICAgICAgICAgc2lnID0gJ1NJR0lOVCdcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsIHNpZylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgbW9kdWxlLmV4cG9ydHMuc2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2lnbmFsc1xuICB9XG5cbiAgdmFyIGxvYWRlZCA9IGZhbHNlXG5cbiAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBpZiAobG9hZGVkIHx8ICFwcm9jZXNzT2soZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbG9hZGVkID0gdHJ1ZVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIG9uU2lnbmFsRXhpdCdzIHRoYXQgYXJlIGluIHBsYXkuXG4gICAgLy8gSXQncyBpbXBvcnRhbnQgc28gdGhhdCB3ZSBjYW4gY291bnQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mXG4gICAgLy8gbGlzdGVuZXJzIG9uIHNpZ25hbHMsIGFuZCBkb24ndCB3YWl0IGZvciB0aGUgb3RoZXIgb25lIHRvXG4gICAgLy8gaGFuZGxlIGl0IGluc3RlYWQgb2YgdXMuXG4gICAgZW1pdHRlci5jb3VudCArPSAxXG5cbiAgICBzaWduYWxzID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHNpZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvY2Vzcy5vbihzaWcsIHNpZ0xpc3RlbmVyc1tzaWddKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHByb2Nlc3MuZW1pdCA9IHByb2Nlc3NFbWl0XG4gICAgcHJvY2Vzcy5yZWFsbHlFeGl0ID0gcHJvY2Vzc1JlYWxseUV4aXRcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5sb2FkID0gbG9hZFxuXG4gIHZhciBvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0ID0gcHJvY2Vzcy5yZWFsbHlFeGl0XG4gIHZhciBwcm9jZXNzUmVhbGx5RXhpdCA9IGZ1bmN0aW9uIHByb2Nlc3NSZWFsbHlFeGl0IChjb2RlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcm9jZXNzT2soZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcHJvY2Vzcy5leGl0Q29kZSA9IGNvZGUgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gMFxuICAgIGVtaXQoJ2V4aXQnLCBwcm9jZXNzLmV4aXRDb2RlLCBudWxsKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZW1pdCgnYWZ0ZXJleGl0JywgcHJvY2Vzcy5leGl0Q29kZSwgbnVsbClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIG9yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQuY2FsbChwcm9jZXNzLCBwcm9jZXNzLmV4aXRDb2RlKVxuICB9XG5cbiAgdmFyIG9yaWdpbmFsUHJvY2Vzc0VtaXQgPSBwcm9jZXNzLmVtaXRcbiAgdmFyIHByb2Nlc3NFbWl0ID0gZnVuY3Rpb24gcHJvY2Vzc0VtaXQgKGV2LCBhcmcpIHtcbiAgICBpZiAoZXYgPT09ICdleGl0JyAmJiBwcm9jZXNzT2soZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGFyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb2Nlc3MuZXhpdENvZGUgPSBhcmdcbiAgICAgIH1cbiAgICAgIHZhciByZXQgPSBvcmlnaW5hbFByb2Nlc3NFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBlbWl0KCdleGl0JywgcHJvY2Vzcy5leGl0Q29kZSwgbnVsbClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBlbWl0KCdhZnRlcmV4aXQnLCBwcm9jZXNzLmV4aXRDb2RlLCBudWxsKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiByZXRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvY2Vzc0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gVGhpcyBpcyBub3QgdGhlIHNldCBvZiBhbGwgcG9zc2libGUgc2lnbmFscy5cbi8vXG4vLyBJdCBJUywgaG93ZXZlciwgdGhlIHNldCBvZiBhbGwgc2lnbmFscyB0aGF0IHRyaWdnZXJcbi8vIGFuIGV4aXQgb24gZWl0aGVyIExpbnV4IG9yIEJTRCBzeXN0ZW1zLiAgTGludXggaXMgYVxuLy8gc3VwZXJzZXQgb2YgdGhlIHNpZ25hbCBuYW1lcyBzdXBwb3J0ZWQgb24gQlNELCBhbmRcbi8vIHRoZSB1bmtub3duIHNpZ25hbHMganVzdCBmYWlsIHRvIHJlZ2lzdGVyLCBzbyB3ZSBjYW5cbi8vIGNhdGNoIHRoYXQgZWFzaWx5IGVub3VnaC5cbi8vXG4vLyBEb24ndCBib3RoZXIgd2l0aCBTSUdLSUxMLiAgSXQncyB1bmNhdGNoYWJsZSwgd2hpY2hcbi8vIG1lYW5zIHRoYXQgd2UgY2FuJ3QgZmlyZSBhbnkgY2FsbGJhY2tzIGFueXdheS5cbi8vXG4vLyBJZiBhIHVzZXIgZG9lcyBoYXBwZW4gdG8gcmVnaXN0ZXIgYSBoYW5kbGVyIG9uIGEgbm9uLVxuLy8gZmF0YWwgc2lnbmFsIGxpa2UgU0lHV0lOQ0ggb3Igc29tZXRoaW5nLCBhbmQgdGhlblxuLy8gZXhpdCwgaXQnbGwgZW5kIHVwIGZpcmluZyBgcHJvY2Vzcy5lbWl0KCdleGl0JylgLCBzb1xuLy8gdGhlIGhhbmRsZXIgd2lsbCBiZSBmaXJlZCBhbnl3YXkuXG4vL1xuLy8gU0lHQlVTLCBTSUdGUEUsIFNJR1NFR1YgYW5kIFNJR0lMTCwgd2hlbiBub3QgcmFpc2VkXG4vLyBhcnRpZmljaWFsbHksIGluaGVyZW50bHkgbGVhdmUgdGhlIHByb2Nlc3MgaW4gYVxuLy8gc3RhdGUgZnJvbSB3aGljaCBpdCBpcyBub3Qgc2FmZSB0byB0cnkgYW5kIGVudGVyIEpTXG4vLyBsaXN0ZW5lcnMuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ1NJR0FCUlQnLFxuICAnU0lHQUxSTScsXG4gICdTSUdIVVAnLFxuICAnU0lHSU5UJyxcbiAgJ1NJR1RFUk0nXG5dXG5cbmlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gIG1vZHVsZS5leHBvcnRzLnB1c2goXG4gICAgJ1NJR1ZUQUxSTScsXG4gICAgJ1NJR1hDUFUnLFxuICAgICdTSUdYRlNaJyxcbiAgICAnU0lHVVNSMicsXG4gICAgJ1NJR1RSQVAnLFxuICAgICdTSUdTWVMnLFxuICAgICdTSUdRVUlUJyxcbiAgICAnU0lHSU9UJ1xuICAgIC8vIHNob3VsZCBkZXRlY3QgcHJvZmlsZXIgYW5kIGVuYWJsZS9kaXNhYmxlIGFjY29yZGluZ2x5LlxuICAgIC8vIHNlZSAjMjFcbiAgICAvLyAnU0lHUFJPRidcbiAgKVxufVxuXG5pZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICBtb2R1bGUuZXhwb3J0cy5wdXNoKFxuICAgICdTSUdJTycsXG4gICAgJ1NJR1BPTEwnLFxuICAgICdTSUdQV1InLFxuICAgICdTSUdTVEtGTFQnLFxuICAgICdTSUdVTlVTRUQnXG4gIClcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBpbnB1dCA9PiB7XG5cdGNvbnN0IExGID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/ICdcXG4nIDogJ1xcbicuY2hhckNvZGVBdCgpO1xuXHRjb25zdCBDUiA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyAnXFxyJyA6ICdcXHInLmNoYXJDb2RlQXQoKTtcblxuXHRpZiAoaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV0gPT09IExGKSB7XG5cdFx0aW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpbnB1dC5sZW5ndGggLSAxKTtcblx0fVxuXG5cdGlmIChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gQ1IpIHtcblx0XHRpbnB1dCA9IGlucHV0LnNsaWNlKDAsIGlucHV0Lmxlbmd0aCAtIDEpO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufTtcbiIsImNvbnN0IGhleFJlZ2V4ID0gL15bLStdPzB4W2EtZkEtRjAtOV0rJC87XG5jb25zdCBudW1SZWdleCA9IC9eKFtcXC1cXCtdKT8oMCopKFxcLlswLTldKyhbZUVdXFwtP1swLTldKyk/fFswLTldKyhcXC5bMC05XSsoW2VFXVxcLT9bMC05XSspPyk/KSQvO1xuLy8gY29uc3Qgb2N0UmVnZXggPSAvMHhbYS16MC05XSsvO1xuLy8gY29uc3QgYmluUmVnZXggPSAvMHhbYS16MC05XSsvO1xuXG5cbi8vcG9seWZpbGxcbmlmICghTnVtYmVyLnBhcnNlSW50ICYmIHdpbmRvdy5wYXJzZUludCkge1xuICAgIE51bWJlci5wYXJzZUludCA9IHdpbmRvdy5wYXJzZUludDtcbn1cbmlmICghTnVtYmVyLnBhcnNlRmxvYXQgJiYgd2luZG93LnBhcnNlRmxvYXQpIHtcbiAgICBOdW1iZXIucGFyc2VGbG9hdCA9IHdpbmRvdy5wYXJzZUZsb2F0O1xufVxuXG4gIFxuY29uc3QgY29uc2lkZXIgPSB7XG4gICAgaGV4IDogIHRydWUsXG4gICAgbGVhZGluZ1plcm9zOiB0cnVlLFxuICAgIGRlY2ltYWxQb2ludDogXCJcXC5cIixcbiAgICBlTm90YXRpb246IHRydWVcbiAgICAvL3NraXBMaWtlOiAvcmVnZXgvXG59O1xuXG5mdW5jdGlvbiB0b051bWJlcihzdHIsIG9wdGlvbnMgPSB7fSl7XG4gICAgLy8gY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnNpZGVyKTtcbiAgICAvLyBpZihvcHQubGVhZGluZ1plcm9zID09PSBmYWxzZSl7XG4gICAgLy8gICAgIG9wdGlvbnMubGVhZGluZ1plcm9zID0gZmFsc2U7XG4gICAgLy8gfWVsc2UgaWYob3B0LmhleCA9PT0gZmFsc2Upe1xuICAgIC8vICAgICBvcHRpb25zLmhleCA9IGZhbHNlO1xuICAgIC8vIH1cblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb25zaWRlciwgb3B0aW9ucyApO1xuICAgIGlmKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIiApIHJldHVybiBzdHI7XG4gICAgXG4gICAgbGV0IHRyaW1tZWRTdHIgID0gc3RyLnRyaW0oKTtcbiAgICAvLyBpZih0cmltbWVkU3RyID09PSBcIjAuMFwiKSByZXR1cm4gMDtcbiAgICAvLyBlbHNlIGlmKHRyaW1tZWRTdHIgPT09IFwiKzAuMFwiKSByZXR1cm4gMDtcbiAgICAvLyBlbHNlIGlmKHRyaW1tZWRTdHIgPT09IFwiLTAuMFwiKSByZXR1cm4gLTA7XG5cbiAgICBpZihvcHRpb25zLnNraXBMaWtlICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5za2lwTGlrZS50ZXN0KHRyaW1tZWRTdHIpKSByZXR1cm4gc3RyO1xuICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4ICYmIGhleFJlZ2V4LnRlc3QodHJpbW1lZFN0cikpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0cmltbWVkU3RyLCAxNik7XG4gICAgLy8gfSBlbHNlIGlmIChvcHRpb25zLnBhcnNlT2N0ICYmIG9jdFJlZ2V4LnRlc3Qoc3RyKSkge1xuICAgIC8vICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHZhbCwgOCk7XG4gICAgLy8gfWVsc2UgaWYgKG9wdGlvbnMucGFyc2VCaW4gJiYgYmluUmVnZXgudGVzdChzdHIpKSB7XG4gICAgLy8gICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodmFsLCAyKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgLy9zZXBhcmF0ZSBuZWdhdGl2ZSBzaWduLCBsZWFkaW5nIHplcm9zLCBhbmQgcmVzdCBudW1iZXJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBudW1SZWdleC5leGVjKHRyaW1tZWRTdHIpO1xuICAgICAgICBpZihtYXRjaCl7XG4gICAgICAgICAgICBjb25zdCBzaWduID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nWmVyb3MgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGxldCBudW1UcmltbWVkQnlaZXJvcyA9IHRyaW1aZXJvcyhtYXRjaFszXSk7IC8vY29tcGxldGUgbnVtIHdpdGhvdXQgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgLy90cmltIGVuZGluZyB6ZXJvcyBmb3IgZmxvYXRpbmcgbnVtYmVyXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGVOb3RhdGlvbiA9IG1hdGNoWzRdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgICAgaWYoIW9wdGlvbnMubGVhZGluZ1plcm9zICYmIGxlYWRpbmdaZXJvcy5sZW5ndGggPiAwICYmIHNpZ24gJiYgdHJpbW1lZFN0clsyXSAhPT0gXCIuXCIpIHJldHVybiBzdHI7IC8vLTAxMjNcbiAgICAgICAgICAgIGVsc2UgaWYoIW9wdGlvbnMubGVhZGluZ1plcm9zICYmIGxlYWRpbmdaZXJvcy5sZW5ndGggPiAwICYmICFzaWduICYmIHRyaW1tZWRTdHJbMV0gIT09IFwiLlwiKSByZXR1cm4gc3RyOyAvLzAxMjNcbiAgICAgICAgICAgIGVsc2V7Ly9ubyBsZWFkaW5nIHplcm9zIG9yIGxlYWRpbmcgemVyb3MgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIodHJpbW1lZFN0cik7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtU3RyID0gXCJcIiArIG51bTtcbiAgICAgICAgICAgICAgICBpZihudW1TdHIuc2VhcmNoKC9bZUVdLykgIT09IC0xKXsgLy9naXZlbiBudW1iZXIgaXMgbG9uZyBhbmQgcGFyc2VkIHRvIGVOb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zLmVOb3RhdGlvbikgcmV0dXJuIG51bTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGVOb3RhdGlvbil7IC8vZ2l2ZW4gbnVtYmVyIGhhcyBlbm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucy5lTm90YXRpb24pIHJldHVybiBudW07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZih0cmltbWVkU3RyLmluZGV4T2YoXCIuXCIpICE9PSAtMSl7IC8vZmxvYXRpbmcgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGRlY2ltYWxQYXJ0ID0gbWF0Y2hbNV0uc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpbnRQYXJ0ID0gdHJpbW1lZFN0ci5zdWJzdHIoMCx0cmltbWVkU3RyLmluZGV4T2YoXCIuXCIpKTtcblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcCA9IG51bVN0ci5pbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgZ2l2ZW5JbnRQYXJ0ID0gbnVtU3RyLnN1YnN0cigwLHApO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBnaXZlbkRlY1BhcnQgPSBudW1TdHIuc3Vic3RyKHArMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bVN0ciA9PT0gXCIwXCIgJiYgKG51bVRyaW1tZWRCeVplcm9zID09PSBcIlwiKSApIHJldHVybiBudW07IC8vMC4wXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobnVtU3RyID09PSBudW1UcmltbWVkQnlaZXJvcykgcmV0dXJuIG51bTsgLy8wLjQ1Ni4gMC43OTAwMFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCBzaWduICYmIG51bVN0ciA9PT0gXCItXCIrbnVtVHJpbW1lZEJ5WmVyb3MpIHJldHVybiBudW07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobGVhZGluZ1plcm9zKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYobnVtVHJpbW1lZEJ5WmVyb3MgPT09IG51bVN0cil7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBpZihvcHRpb25zLmxlYWRpbmdaZXJvcykgcmV0dXJuIG51bTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGVsc2UgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgLy8gfWVsc2UgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYobnVtVHJpbW1lZEJ5WmVyb3MgPT09IG51bVN0cikgcmV0dXJuIG51bTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzaWduK251bVRyaW1tZWRCeVplcm9zID09PSBudW1TdHIpIHJldHVybiBudW07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih0cmltbWVkU3RyID09PSBudW1TdHIpIHJldHVybiBudW07XG4gICAgICAgICAgICAgICAgZWxzZSBpZih0cmltbWVkU3RyID09PSBzaWduK251bVN0cikgcmV0dXJuIG51bTtcbiAgICAgICAgICAgICAgICAvLyBlbHNle1xuICAgICAgICAgICAgICAgIC8vICAgICAvL251bWJlciB3aXRoICsvLSBzaWduXG4gICAgICAgICAgICAgICAgLy8gICAgIHRyaW1tZWRTdHIudGVzdCgvWy0rXVswLTldKTtcblxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBpZighZU5vdGF0aW9uICYmIHRyaW1tZWRTdHIgJiYgdHJpbW1lZFN0ciAhPT0gTnVtYmVyKHRyaW1tZWRTdHIpICkgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZXsgLy9ub24tbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gbnVtU3RyIHdpdGhvdXQgbGVhZGluZyB6ZXJvc1xuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRyaW1aZXJvcyhudW1TdHIpe1xuICAgIGlmKG51bVN0ciAmJiBudW1TdHIuaW5kZXhPZihcIi5cIikgIT09IC0xKXsvL2Zsb2F0XG4gICAgICAgIG51bVN0ciA9IG51bVN0ci5yZXBsYWNlKC8wKyQvLCBcIlwiKTsgLy9yZW1vdmUgZW5kaW5nIHplcm9zXG4gICAgICAgIGlmKG51bVN0ciA9PT0gXCIuXCIpICBudW1TdHIgPSBcIjBcIjtcbiAgICAgICAgZWxzZSBpZihudW1TdHJbMF0gPT09IFwiLlwiKSAgbnVtU3RyID0gXCIwXCIrbnVtU3RyO1xuICAgICAgICBlbHNlIGlmKG51bVN0cltudW1TdHIubGVuZ3RoLTFdID09PSBcIi5cIikgIG51bVN0ciA9IG51bVN0ci5zdWJzdHIoMCxudW1TdHIubGVuZ3RoLTEpO1xuICAgICAgICByZXR1cm4gbnVtU3RyO1xuICAgIH1cbiAgICByZXR1cm4gbnVtU3RyO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlclxuIiwidmFyIE5vZGUgPSB7XG4gIGNoaWxkOiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyksXG4gIGNyeXB0bzogcmVxdWlyZSgnY3J5cHRvJyksXG4gIGZzOiByZXF1aXJlKCdmcycpLFxuICBvczogcmVxdWlyZSgnb3MnKSxcbiAgcGF0aDogcmVxdWlyZSgncGF0aCcpLFxuICBwcm9jZXNzOiBwcm9jZXNzLFxuICB1dGlsOiByZXF1aXJlKCd1dGlsJylcbn07XG5cbmZ1bmN0aW9uIEF0dGVtcHQoaW5zdGFuY2UsIGVuZCkge1xuICB2YXIgcGxhdGZvcm0gPSBOb2RlLnByb2Nlc3MucGxhdGZvcm07XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHJldHVybiBNYWMoaW5zdGFuY2UsIGVuZCk7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JykgcmV0dXJuIExpbnV4KGluc3RhbmNlLCBlbmQpO1xuICBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHJldHVybiBXaW5kb3dzKGluc3RhbmNlLCBlbmQpO1xuICBlbmQobmV3IEVycm9yKCdQbGF0Zm9ybSBub3QgeWV0IHN1cHBvcnRlZC4nKSk7XG59XG5cbmZ1bmN0aW9uIEVzY2FwZURvdWJsZVF1b3RlcyhzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nLicpO1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbn1cblxuZnVuY3Rpb24gRXhlYygpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzLicpO1xuICB9XG4gIHZhciBjb21tYW5kID0gYXJndW1lbnRzWzBdO1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIgZW5kID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHR5cGVvZiBjb21tYW5kICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBzaG91bGQgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoTm9kZS51dGlsLmlzT2JqZWN0KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIGlmIChOb2RlLnV0aWwuaXNGdW5jdGlvbihhcmd1bWVudHNbMV0pKSB7XG4gICAgICBlbmQgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb3B0aW9ucyBvciBjYWxsYmFjay4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChOb2RlLnV0aWwuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBvcHRpb25zIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgaWYgKE5vZGUudXRpbC5pc0Z1bmN0aW9uKGFyZ3VtZW50c1syXSkpIHtcbiAgICAgIGVuZCA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBjYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgfVxuICBpZiAoL15zdWRvL2kudGVzdChjb21tYW5kKSkge1xuICAgIHJldHVybiBlbmQobmV3IEVycm9yKCdDb21tYW5kIHNob3VsZCBub3QgYmUgcHJlZml4ZWQgd2l0aCBcInN1ZG9cIi4nKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHRpdGxlID0gTm9kZS5wcm9jZXNzLnRpdGxlO1xuICAgIGlmIChWYWxpZE5hbWUodGl0bGUpKSB7XG4gICAgICBvcHRpb25zLm5hbWUgPSB0aXRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoJ3Byb2Nlc3MudGl0bGUgY2Fubm90IGJlIHVzZWQgYXMgYSB2YWxpZCBuYW1lLicpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIVZhbGlkTmFtZShvcHRpb25zLm5hbWUpKSB7XG4gICAgdmFyIGVycm9yID0gJyc7XG4gICAgZXJyb3IgKz0gJ29wdGlvbnMubmFtZSBtdXN0IGJlIGFscGhhbnVtZXJpYyBvbmx5ICc7XG4gICAgZXJyb3IgKz0gJyhzcGFjZXMgYXJlIGFsbG93ZWQpIGFuZCA8PSA3MCBjaGFyYWN0ZXJzLic7XG4gICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaWNucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaWNucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbmQobmV3IEVycm9yKCdvcHRpb25zLmljbnMgbXVzdCBiZSBhIHN0cmluZyBpZiBwcm92aWRlZC4nKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmljbnMudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoJ29wdGlvbnMuaWNucyBtdXN0IG5vdCBiZSBlbXB0eSBpZiBwcm92aWRlZC4nKSk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5lbnYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmVudiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBlbmQobmV3IEVycm9yKCdvcHRpb25zLmVudiBtdXN0IGJlIGFuIG9iamVjdCBpZiBwcm92aWRlZC4nKSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhvcHRpb25zLmVudikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZW5kKG5ldyBFcnJvcignb3B0aW9ucy5lbnYgbXVzdCBub3QgYmUgZW1wdHkgaWYgcHJvdmlkZWQuJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5lbnYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy5lbnZba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdvcHRpb25zLmVudiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgbXVzdCBiZSBzdHJpbmdzLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIkVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVzIHVzZWQgYnkgdGhlIHV0aWxpdGllcyBpbiB0aGUgU2hlbGwgYW5kXG4gICAgICAgIC8vIFV0aWxpdGllcyB2b2x1bWUgb2YgSUVFRSBTdGQgMTAwMy4xLTIwMDEgY29uc2lzdCBzb2xlbHkgb2YgdXBwZXJjYXNlXG4gICAgICAgIC8vIGxldHRlcnMsIGRpZ2l0cywgYW5kIHRoZSAnXycgKHVuZGVyc2NvcmUpIGZyb20gdGhlIGNoYXJhY3RlcnMgZGVmaW5lZFxuICAgICAgICAvLyBpbiBQb3J0YWJsZSBDaGFyYWN0ZXIgU2V0IGFuZCBkbyBub3QgYmVnaW4gd2l0aCBhIGRpZ2l0LiBPdGhlclxuICAgICAgICAvLyBjaGFyYWN0ZXJzIG1heSBiZSBwZXJtaXR0ZWQgYnkgYW4gaW1wbGVtZW50YXRpb247IGFwcGxpY2F0aW9ucyBzaGFsbFxuICAgICAgICAvLyB0b2xlcmF0ZSB0aGUgcHJlc2VuY2Ugb2Ygc3VjaCBuYW1lcy5cIlxuICAgICAgICBpZiAoIS9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBlbmQoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdvcHRpb25zLmVudiBoYXMgYW4gaW52YWxpZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lOiAnICtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoa2V5KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9bXFxyXFxuXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnb3B0aW9ucy5lbnYgaGFzIGFuIGludmFsaWQgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWU6ICcgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBwbGF0Zm9ybSA9IE5vZGUucHJvY2Vzcy5wbGF0Zm9ybTtcbiAgaWYgKHBsYXRmb3JtICE9PSAnZGFyd2luJyAmJiBwbGF0Zm9ybSAhPT0gJ2xpbnV4JyAmJiBwbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgIHJldHVybiBlbmQobmV3IEVycm9yKCdQbGF0Zm9ybSBub3QgeWV0IHN1cHBvcnRlZC4nKSk7XG4gIH1cbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICB1dWlkOiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkXG4gIH07XG4gIEF0dGVtcHQoaW5zdGFuY2UsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIExpbnV4KGluc3RhbmNlLCBlbmQpIHtcbiAgTGludXhCaW5hcnkoaW5zdGFuY2UsXG4gICAgZnVuY3Rpb24oZXJyb3IsIGJpbmFyeSkge1xuICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIHZhciBjb21tYW5kID0gW107XG4gICAgICAvLyBQcmVzZXJ2ZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5OlxuICAgICAgY29tbWFuZC5wdXNoKCdjZCBcIicgKyBFc2NhcGVEb3VibGVRdW90ZXMoTm9kZS5wcm9jZXNzLmN3ZCgpKSArICdcIjsnKTtcbiAgICAgIC8vIEV4cG9ydCBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2Uub3B0aW9ucy5lbnYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5zdGFuY2Uub3B0aW9ucy5lbnZba2V5XTtcbiAgICAgICAgY29tbWFuZC5wdXNoKCdleHBvcnQgJyArIGtleSArICc9XCInICsgRXNjYXBlRG91YmxlUXVvdGVzKHZhbHVlKSArICdcIjsnKTtcbiAgICAgIH1cbiAgICAgIGNvbW1hbmQucHVzaCgnXCInICsgRXNjYXBlRG91YmxlUXVvdGVzKGJpbmFyeSkgKyAnXCInKTtcbiAgICAgIGlmICgva2Rlc3Vkby9pLnRlc3QoYmluYXJ5KSkge1xuICAgICAgICBjb21tYW5kLnB1c2goXG4gICAgICAgICAgJy0tY29tbWVudCcsXG4gICAgICAgICAgJ1wiJyArIGluc3RhbmNlLm9wdGlvbnMubmFtZSArICcgd2FudHMgdG8gbWFrZSBjaGFuZ2VzLiAnICtcbiAgICAgICAgICAnRW50ZXIgeW91ciBwYXNzd29yZCB0byBhbGxvdyB0aGlzLlwiJ1xuICAgICAgICApO1xuICAgICAgICBjb21tYW5kLnB1c2goJy1kJyk7IC8vIERvIG5vdCBzaG93IHRoZSBjb21tYW5kIHRvIGJlIHJ1biBpbiB0aGUgZGlhbG9nLlxuICAgICAgICBjb21tYW5kLnB1c2goJy0tJyk7XG4gICAgICB9IGVsc2UgaWYgKC9wa2V4ZWMvaS50ZXN0KGJpbmFyeSkpIHtcbiAgICAgICAgY29tbWFuZC5wdXNoKCctLWRpc2FibGUtaW50ZXJuYWwtYWdlbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBtYWdpYyA9ICdTVURPUFJPTVBUXFxuJztcbiAgICAgIGNvbW1hbmQucHVzaChcbiAgICAgICAgJy9iaW4vYmFzaCAtYyBcImVjaG8gJyArIEVzY2FwZURvdWJsZVF1b3RlcyhtYWdpYy50cmltKCkpICsgJzsgJyArXG4gICAgICAgIEVzY2FwZURvdWJsZVF1b3RlcyhpbnN0YW5jZS5jb21tYW5kKSArXG4gICAgICAgICdcIidcbiAgICAgICk7XG4gICAgICBjb21tYW5kID0gY29tbWFuZC5qb2luKCcgJyk7XG4gICAgICBOb2RlLmNoaWxkLmV4ZWMoY29tbWFuZCwgeyBlbmNvZGluZzogJ3V0Zi04JywgbWF4QnVmZmVyOiBNQVhfQlVGRkVSIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgICAgIC8vIElTU1VFIDg4OlxuICAgICAgICAgIC8vIFdlIG11c3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBlbGV2YXRpb24gZXJyb3JzIGFuZCBjb21tYW5kIGVycm9ycy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEtERVNVRE86XG4gICAgICAgICAgLy8ga2Rlc3VkbyBwcm92aWRlcyBubyB3YXkgdG8gZG8gdGhpcy4gV2UgYWRkIGEgbWFnaWMgbWFya2VyIHRvIGtub3dcbiAgICAgICAgICAvLyBpZiBlbGV2YXRpb24gc3VjY2VlZGVkLiBBbnkgZXJyb3IgdGhlcmVhZnRlciBpcyBhIGNvbW1hbmQgZXJyb3IuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQS0VYRUM6XG4gICAgICAgICAgLy8gXCJVcG9uIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiwgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mXG4gICAgICAgICAgLy8gUFJPR1JBTS4gSWYgdGhlIGNhbGxpbmcgcHJvY2VzcyBpcyBub3QgYXV0aG9yaXplZCBvciBhblxuICAgICAgICAgIC8vIGF1dGhvcml6YXRpb24gY291bGQgbm90IGJlIG9idGFpbmVkIHRocm91Z2ggYXV0aGVudGljYXRpb24gb3IgYW5cbiAgICAgICAgICAvLyBlcnJvciBvY2N1cmVkLCBwa2V4ZWMgZXhpdHMgd2l0aCBhIHJldHVybiB2YWx1ZSBvZiAxMjcuIElmIHRoZVxuICAgICAgICAgIC8vIGF1dGhvcml6YXRpb24gY291bGQgbm90IGJlIG9idGFpbmVkIGJlY2F1c2UgdGhlIHVzZXIgZGlzbWlzc2VkIHRoZVxuICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGRpYWxvZywgcGtleGVjIGV4aXRzIHdpdGggYSByZXR1cm4gdmFsdWUgb2YgMTI2LlwiXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBkbyBub3QgcmVseSBvbiBwa2V4ZWMncyByZXR1cm4gb2YgMTI3IHNpbmNlIG91ciBtYWdpY1xuICAgICAgICAgIC8vIG1hcmtlciBpcyBtb3JlIHJlbGlhYmxlLCBhbmQgd2UgYWxyZWFkeSB1c2UgaXQgZm9yIGtkZXN1ZG8uXG4gICAgICAgICAgdmFyIGVsZXZhdGVkID0gc3Rkb3V0ICYmIHN0ZG91dC5zbGljZSgwLCBtYWdpYy5sZW5ndGgpID09PSBtYWdpYztcbiAgICAgICAgICBpZiAoZWxldmF0ZWQpIHN0ZG91dCA9IHN0ZG91dC5zbGljZShtYWdpYy5sZW5ndGgpO1xuICAgICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIHRoZSBlcnJvciBpZiBpdCBpcyBkZWZpbml0ZWx5IG5vdCBhIGNvbW1hbmQgZXJyb3I6XG4gICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGlmIHdlIGtub3cgdGhhdCB0aGUgY29tbWFuZCB3YXMgbmV2ZXIgZWxldmF0ZWQuXG4gICAgICAgICAgLy8gV2UgZG8gbm90IGluc3BlY3QgZXJyb3IgbWVzc2FnZXMgYmV5b25kIE5PX1BPTEtJVF9BR0VOVC5cbiAgICAgICAgICAvLyBXZSBjYW5ub3QgcmVseSBvbiBFbmdsaXNoIGVycm9ycyBiZWNhdXNlIG9mIGludGVybmF0aW9uYWxpemF0aW9uLlxuICAgICAgICAgIGlmIChlcnJvciAmJiAhZWxldmF0ZWQpIHtcbiAgICAgICAgICAgIGlmICgvTm8gYXV0aGVudGljYXRpb24gYWdlbnQgZm91bmQvLnRlc3Qoc3RkZXJyKSkge1xuICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gTk9fUE9MS0lUX0FHRU5UO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IFBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQoZXJyb3IsIHN0ZG91dCwgc3RkZXJyKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIExpbnV4QmluYXJ5KGluc3RhbmNlLCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gV2UgdXNlZCB0byBwcmVmZXIgZ2tzdWRvIG92ZXIgcGtleGVjIHNpbmNlIGl0IGVuYWJsZWQgYSBiZXR0ZXIgcHJvbXB0LlxuICAvLyBIb3dldmVyLCBna3N1ZG8gY2Fubm90IHJ1biBtdWx0aXBsZSBjb21tYW5kcyBjb25jdXJyZW50bHkuXG4gIHZhciBwYXRocyA9IFsnL3Vzci9iaW4va2Rlc3VkbycsICcvdXNyL2Jpbi9wa2V4ZWMnXTtcbiAgZnVuY3Rpb24gdGVzdCgpIHtcbiAgICBpZiAoaW5kZXggPT09IHBhdGhzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHBrZXhlYyBvciBrZGVzdWRvLicpKTtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleCsrXTtcbiAgICBOb2RlLmZzLnN0YXQocGF0aCxcbiAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRU5PVERJUicpIHJldHVybiB0ZXN0KCk7XG4gICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gdGVzdCgpO1xuICAgICAgICAgIGVuZChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kKHVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRlc3QoKTtcbn1cblxuZnVuY3Rpb24gTWFjKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICB2YXIgdGVtcCA9IE5vZGUub3MudG1wZGlyKCk7XG4gIGlmICghdGVtcCkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignb3MudG1wZGlyKCkgbm90IGRlZmluZWQuJykpO1xuICB2YXIgdXNlciA9IE5vZGUucHJvY2Vzcy5lbnYuVVNFUjsgLy8gQXBwbGV0IHNoZWxsIHNjcmlwdHMgcmVxdWlyZSAkVVNFUi5cbiAgaWYgKCF1c2VyKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdlbnZbXFwnVVNFUlxcJ10gbm90IGRlZmluZWQuJykpO1xuICBVVUlEKGluc3RhbmNlLFxuICAgIGZ1bmN0aW9uKGVycm9yLCB1dWlkKSB7XG4gICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICBpbnN0YW5jZS51dWlkID0gdXVpZDtcbiAgICAgIGluc3RhbmNlLnBhdGggPSBOb2RlLnBhdGguam9pbihcbiAgICAgICAgdGVtcCxcbiAgICAgICAgaW5zdGFuY2UudXVpZCxcbiAgICAgICAgaW5zdGFuY2Uub3B0aW9ucy5uYW1lICsgJy5hcHAnXG4gICAgICApO1xuICAgICAgZnVuY3Rpb24gZW5kKGVycm9yLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgICBSZW1vdmUoTm9kZS5wYXRoLmRpcm5hbWUoaW5zdGFuY2UucGF0aCksXG4gICAgICAgICAgZnVuY3Rpb24oZXJyb3JSZW1vdmUpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIGlmIChlcnJvclJlbW92ZSkgcmV0dXJuIGNhbGxiYWNrKGVycm9yUmVtb3ZlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIE1hY0FwcGxldChpbnN0YW5jZSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHN0ZG91dCwgc3RkZXJyKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yLCBzdGRvdXQsIHN0ZGVycik7XG4gICAgICAgICAgTWFjSWNvbihpbnN0YW5jZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICAgICAgICAgIE1hY1Byb3BlcnR5TGlzdChpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvciwgc3Rkb3V0LCBzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICAgICAgICAgICAgTWFjQ29tbWFuZChpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIE1hY09wZW4oaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvciwgc3Rkb3V0LCBzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yLCBzdGRvdXQsIHN0ZGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1hY1Jlc3VsdChpbnN0YW5jZSwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gTWFjQXBwbGV0KGluc3RhbmNlLCBlbmQpIHtcbiAgdmFyIHBhcmVudCA9IE5vZGUucGF0aC5kaXJuYW1lKGluc3RhbmNlLnBhdGgpO1xuICBOb2RlLmZzLm1rZGlyKHBhcmVudCxcbiAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIHZhciB6aXAgPSBOb2RlLnBhdGguam9pbihwYXJlbnQsICdzdWRvLXByb21wdC1hcHBsZXQuemlwJyk7XG4gICAgICBOb2RlLmZzLndyaXRlRmlsZSh6aXAsIEFQUExFVCwgJ2Jhc2U2NCcsXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IFtdO1xuICAgICAgICAgIGNvbW1hbmQucHVzaCgnL3Vzci9iaW4vdW56aXAnKTtcbiAgICAgICAgICBjb21tYW5kLnB1c2goJy1vJyk7IC8vIE92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgYXBwbGV0LlxuICAgICAgICAgIGNvbW1hbmQucHVzaCgnXCInICsgRXNjYXBlRG91YmxlUXVvdGVzKHppcCkgKyAnXCInKTtcbiAgICAgICAgICBjb21tYW5kLnB1c2goJy1kIFwiJyArIEVzY2FwZURvdWJsZVF1b3RlcyhpbnN0YW5jZS5wYXRoKSArICdcIicpO1xuICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kLmpvaW4oJyAnKTtcbiAgICAgICAgICBOb2RlLmNoaWxkLmV4ZWMoY29tbWFuZCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9LCBlbmQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gTWFjQ29tbWFuZChpbnN0YW5jZSwgZW5kKSB7XG4gIHZhciBwYXRoID0gTm9kZS5wYXRoLmpvaW4oXG4gICAgaW5zdGFuY2UucGF0aCxcbiAgICAnQ29udGVudHMnLFxuICAgICdNYWNPUycsXG4gICAgJ3N1ZG8tcHJvbXB0LWNvbW1hbmQnXG4gICk7XG4gIHZhciBzY3JpcHQgPSBbXTtcbiAgLy8gUHJlc2VydmUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeTpcbiAgLy8gV2UgZG8gdGhpcyBmb3IgY29tbWFuZHMgdGhhdCByZWx5IG9uIHJlbGF0aXZlIHBhdGhzLlxuICAvLyBUaGlzIHJ1bnMgaW4gYSBzdWJzaGVsbCBhbmQgd2lsbCBub3QgY2hhbmdlIHRoZSBjd2Qgb2Ygc3Vkby1wcm9tcHQtc2NyaXB0LlxuICBzY3JpcHQucHVzaCgnY2QgXCInICsgRXNjYXBlRG91YmxlUXVvdGVzKE5vZGUucHJvY2Vzcy5jd2QoKSkgKyAnXCInKTtcbiAgLy8gRXhwb3J0IGVudmlyb25tZW50IHZhcmlhYmxlczpcbiAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlLm9wdGlvbnMuZW52KSB7XG4gICAgdmFyIHZhbHVlID0gaW5zdGFuY2Uub3B0aW9ucy5lbnZba2V5XTtcbiAgICBzY3JpcHQucHVzaCgnZXhwb3J0ICcgKyBrZXkgKyAnPVwiJyArIEVzY2FwZURvdWJsZVF1b3Rlcyh2YWx1ZSkgKyAnXCInKTtcbiAgfVxuICBzY3JpcHQucHVzaChpbnN0YW5jZS5jb21tYW5kKTtcbiAgc2NyaXB0ID0gc2NyaXB0LmpvaW4oJ1xcbicpO1xuICBOb2RlLmZzLndyaXRlRmlsZShwYXRoLCBzY3JpcHQsICd1dGYtOCcsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIE1hY0ljb24oaW5zdGFuY2UsIGVuZCkge1xuICBpZiAoIWluc3RhbmNlLm9wdGlvbnMuaWNucykgcmV0dXJuIGVuZCgpO1xuICBOb2RlLmZzLnJlYWRGaWxlKGluc3RhbmNlLm9wdGlvbnMuaWNucyxcbiAgICBmdW5jdGlvbihlcnJvciwgYnVmZmVyKSB7XG4gICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgdmFyIGljbnMgPSBOb2RlLnBhdGguam9pbihcbiAgICAgICAgaW5zdGFuY2UucGF0aCxcbiAgICAgICAgJ0NvbnRlbnRzJyxcbiAgICAgICAgJ1Jlc291cmNlcycsXG4gICAgICAgICdhcHBsZXQuaWNucydcbiAgICAgICk7XG4gICAgICBOb2RlLmZzLndyaXRlRmlsZShpY25zLCBidWZmZXIsIGVuZCk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBNYWNPcGVuKGluc3RhbmNlLCBlbmQpIHtcbiAgLy8gV2UgbXVzdCBydW4gdGhlIGJpbmFyeSBkaXJlY3RseSBzbyB0aGF0IHRoZSBjd2Qgd2lsbCBhcHBseS5cbiAgdmFyIGJpbmFyeSA9IE5vZGUucGF0aC5qb2luKGluc3RhbmNlLnBhdGgsICdDb250ZW50cycsICdNYWNPUycsICdhcHBsZXQnKTtcbiAgLy8gV2UgbXVzdCBzZXQgdGhlIGN3ZCBzbyB0aGF0IHRoZSBBcHBsZVNjcmlwdCBjYW4gZmluZCB0aGUgc2hlbGwgc2NyaXB0cy5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgY3dkOiBOb2RlLnBhdGguZGlybmFtZShiaW5hcnkpLFxuICAgIGVuY29kaW5nOiAndXRmLTgnXG4gIH07XG4gIC8vIFdlIHVzZSB0aGUgcmVsYXRpdmUgcGF0aCByYXRoZXIgdGhhbiB0aGUgYWJzb2x1dGUgcGF0aC4gVGhlIGluc3RhbmNlLnBhdGhcbiAgLy8gbWF5IGNvbnRhaW4gc3BhY2VzIHdoaWNoIHRoZSBjd2QgY2FuIGhhbmRsZSwgYnV0IHdoaWNoIGV4ZWMoKSBjYW5ub3QuXG4gIE5vZGUuY2hpbGQuZXhlYygnLi8nICsgTm9kZS5wYXRoLmJhc2VuYW1lKGJpbmFyeSksIG9wdGlvbnMsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIE1hY1Byb3BlcnR5TGlzdChpbnN0YW5jZSwgZW5kKSB7XG4gIC8vIFZhbHVlIG11c3QgYmUgaW4gc2luZ2xlIHF1b3RlcyAobm90IGRvdWJsZSBxdW90ZXMpIGFjY29yZGluZyB0byBtYW4gZW50cnkuXG4gIC8vIGUuZy4gZGVmYXVsdHMgd3JpdGUgY29tLmNvbXBhbnluYW1lLmFwcG5hbWUgXCJEZWZhdWx0IENvbG9yXCIgJygyNTUsIDAsIDApJ1xuICAvLyBUaGUgZGVmYXVsdHMgY29tbWFuZCB3aWxsIGJlIGNoYW5nZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZSB0byBvbmx5XG4gIC8vIG9wZXJhdGUgb24gcHJlZmVyZW5jZXMgZG9tYWlucy4gR2VuZXJhbCBwbGlzdCBtYW5pcHVsYXRpb24gdXRpbGl0aWVzIHdpbGxcbiAgLy8gYmUgZm9sZGVkIGludG8gYSBkaWZmZXJlbnQgY29tbWFuZC1saW5lIHByb2dyYW0uXG4gIHZhciBwbGlzdCA9IE5vZGUucGF0aC5qb2luKGluc3RhbmNlLnBhdGgsICdDb250ZW50cycsICdJbmZvLnBsaXN0Jyk7XG4gIHZhciBwYXRoID0gRXNjYXBlRG91YmxlUXVvdGVzKHBsaXN0KTtcbiAgdmFyIGtleSA9IEVzY2FwZURvdWJsZVF1b3RlcygnQ0ZCdW5kbGVOYW1lJyk7XG4gIHZhciB2YWx1ZSA9IGluc3RhbmNlLm9wdGlvbnMubmFtZSArICcgUGFzc3dvcmQgUHJvbXB0JztcbiAgaWYgKC8nLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBlbmQobmV3IEVycm9yKCdWYWx1ZSBzaG91bGQgbm90IGNvbnRhaW4gc2luZ2xlIHF1b3Rlcy4nKSk7XG4gIH1cbiAgdmFyIGNvbW1hbmQgPSBbXTtcbiAgY29tbWFuZC5wdXNoKCcvdXNyL2Jpbi9kZWZhdWx0cycpO1xuICBjb21tYW5kLnB1c2goJ3dyaXRlJyk7XG4gIGNvbW1hbmQucHVzaCgnXCInICsgcGF0aCArICdcIicpO1xuICBjb21tYW5kLnB1c2goJ1wiJyArIGtleSArICdcIicpO1xuICBjb21tYW5kLnB1c2goXCInXCIgKyB2YWx1ZSArIFwiJ1wiKTsgLy8gV2UgbXVzdCB1c2Ugc2luZ2xlIHF1b3RlcyBmb3IgdmFsdWUuXG4gIGNvbW1hbmQgPSBjb21tYW5kLmpvaW4oJyAnKTtcbiAgTm9kZS5jaGlsZC5leGVjKGNvbW1hbmQsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gTWFjUmVzdWx0KGluc3RhbmNlLCBlbmQpIHtcbiAgdmFyIGN3ZCA9IE5vZGUucGF0aC5qb2luKGluc3RhbmNlLnBhdGgsICdDb250ZW50cycsICdNYWNPUycpO1xuICBOb2RlLmZzLnJlYWRGaWxlKE5vZGUucGF0aC5qb2luKGN3ZCwgJ2NvZGUnKSwgJ3V0Zi04JyxcbiAgICBmdW5jdGlvbihlcnJvciwgY29kZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGVuZChuZXcgRXJyb3IoUEVSTUlTU0lPTl9ERU5JRUQpKTtcbiAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE5vZGUuZnMucmVhZEZpbGUoTm9kZS5wYXRoLmpvaW4oY3dkLCAnc3Rkb3V0JyksICd1dGYtOCcsXG4gICAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgICAgICAgIE5vZGUuZnMucmVhZEZpbGUoTm9kZS5wYXRoLmpvaW4oY3dkLCAnc3RkZXJyJyksICd1dGYtOCcsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yLCBzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBwYXJzZUludChjb2RlLnRyaW0oKSwgMTApOyAvLyBJbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lLlxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBlbmQodW5kZWZpbmVkLCBzdGRvdXQsIHN0ZGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ29tbWFuZCBmYWlsZWQ6ICcgKyBpbnN0YW5jZS5jb21tYW5kICsgJ1xcbicgKyBzdGRlcnJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgIGVuZChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBSZW1vdmUocGF0aCwgZW5kKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgfHwgIXBhdGgudHJpbSgpKSB7XG4gICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoJ0FyZ3VtZW50IHBhdGggbm90IGRlZmluZWQuJykpO1xuICB9XG4gIHZhciBjb21tYW5kID0gW107XG4gIGlmIChOb2RlLnByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBpZiAoL1wiLy50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gZW5kKG5ldyBFcnJvcignQXJndW1lbnQgcGF0aCBjYW5ub3QgY29udGFpbiBkb3VibGUtcXVvdGVzLicpKTtcbiAgICB9XG4gICAgY29tbWFuZC5wdXNoKCdybWRpciAvcyAvcSBcIicgKyBwYXRoICsgJ1wiJyk7XG4gIH0gZWxzZSB7XG4gICAgY29tbWFuZC5wdXNoKCcvYmluL3JtJyk7XG4gICAgY29tbWFuZC5wdXNoKCctcmYnKTtcbiAgICBjb21tYW5kLnB1c2goJ1wiJyArIEVzY2FwZURvdWJsZVF1b3RlcyhOb2RlLnBhdGgubm9ybWFsaXplKHBhdGgpKSArICdcIicpO1xuICB9XG4gIGNvbW1hbmQgPSBjb21tYW5kLmpvaW4oJyAnKTtcbiAgTm9kZS5jaGlsZC5leGVjKGNvbW1hbmQsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gVVVJRChpbnN0YW5jZSwgZW5kKSB7XG4gIE5vZGUuY3J5cHRvLnJhbmRvbUJ5dGVzKDI1NixcbiAgICBmdW5jdGlvbihlcnJvciwgcmFuZG9tKSB7XG4gICAgICBpZiAoZXJyb3IpIHJhbmRvbSA9IERhdGUubm93KCkgKyAnJyArIE1hdGgucmFuZG9tKCk7XG4gICAgICB2YXIgaGFzaCA9IE5vZGUuY3J5cHRvLmNyZWF0ZUhhc2goJ1NIQTI1NicpO1xuICAgICAgaGFzaC51cGRhdGUoJ3N1ZG8tcHJvbXB0LTMnKTtcbiAgICAgIGhhc2gudXBkYXRlKGluc3RhbmNlLm9wdGlvbnMubmFtZSk7XG4gICAgICBoYXNoLnVwZGF0ZShpbnN0YW5jZS5jb21tYW5kKTtcbiAgICAgIGhhc2gudXBkYXRlKHJhbmRvbSk7XG4gICAgICB2YXIgdXVpZCA9IGhhc2guZGlnZXN0KCdoZXgnKS5zbGljZSgtMzIpO1xuICAgICAgaWYgKCF1dWlkIHx8IHR5cGVvZiB1dWlkICE9PSAnc3RyaW5nJyB8fCB1dWlkLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBjcml0aWNhbCB0byBlbnN1cmUgd2UgZG9uJ3QgcmVtb3ZlIHRoZSB3cm9uZyB0ZW1wIGRpcmVjdG9yeS5cbiAgICAgICAgcmV0dXJuIGVuZChuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgdmFsaWQgVVVJRC4nKSk7XG4gICAgICB9XG4gICAgICBlbmQodW5kZWZpbmVkLCB1dWlkKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFZhbGlkTmFtZShzdHJpbmcpIHtcbiAgLy8gV2UgdXNlIDcwIGNoYXJhY3RlcnMgYXMgYSBsaW1pdCB0byBzaWRlLXN0ZXAgYW55IGlzc3VlcyB3aXRoIFVuaWNvZGVcbiAgLy8gbm9ybWFsaXphdGlvbiBmb3JtIGNhdXNpbmcgYSAyNTUgY2hhcmFjdGVyIHN0cmluZyB0byBleGNlZWQgdGhlIGZzIGxpbWl0LlxuICBpZiAoIS9eW2EtejAtOSBdKyQvaS50ZXN0KHN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgaWYgKHN0cmluZy50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzdHJpbmcubGVuZ3RoID4gNzApIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdpbmRvd3MoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gIHZhciB0ZW1wID0gTm9kZS5vcy50bXBkaXIoKTtcbiAgaWYgKCF0ZW1wKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdvcy50bXBkaXIoKSBub3QgZGVmaW5lZC4nKSk7XG4gIFVVSUQoaW5zdGFuY2UsXG4gICAgZnVuY3Rpb24oZXJyb3IsIHV1aWQpIHtcbiAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIGluc3RhbmNlLnV1aWQgPSB1dWlkO1xuICAgICAgaW5zdGFuY2UucGF0aCA9IE5vZGUucGF0aC5qb2luKHRlbXAsIGluc3RhbmNlLnV1aWQpO1xuICAgICAgaWYgKC9cIi8udGVzdChpbnN0YW5jZS5wYXRoKSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgZG91YmxlIHF1b3RlcyB0byBiZSByZXNlcnZlZCBvbiBXaW5kb3dzLlxuICAgICAgICAvLyBFdmVuIHNvLCB3ZSB0ZXN0IGZvciB0aGlzIGFuZCBhYm9ydCBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKCdpbnN0YW5jZS5wYXRoIGNhbm5vdCBjb250YWluIGRvdWJsZS1xdW90ZXMuJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLnBhdGhFbGV2YXRlID0gTm9kZS5wYXRoLmpvaW4oaW5zdGFuY2UucGF0aCwgJ2VsZXZhdGUudmJzJyk7XG4gICAgICBpbnN0YW5jZS5wYXRoRXhlY3V0ZSA9IE5vZGUucGF0aC5qb2luKGluc3RhbmNlLnBhdGgsICdleGVjdXRlLmJhdCcpO1xuICAgICAgaW5zdGFuY2UucGF0aENvbW1hbmQgPSBOb2RlLnBhdGguam9pbihpbnN0YW5jZS5wYXRoLCAnY29tbWFuZC5iYXQnKTtcbiAgICAgIGluc3RhbmNlLnBhdGhTdGRvdXQgPSBOb2RlLnBhdGguam9pbihpbnN0YW5jZS5wYXRoLCAnc3Rkb3V0Jyk7XG4gICAgICBpbnN0YW5jZS5wYXRoU3RkZXJyID0gTm9kZS5wYXRoLmpvaW4oaW5zdGFuY2UucGF0aCwgJ3N0ZGVycicpO1xuICAgICAgaW5zdGFuY2UucGF0aFN0YXR1cyA9IE5vZGUucGF0aC5qb2luKGluc3RhbmNlLnBhdGgsICdzdGF0dXMnKTtcbiAgICAgIE5vZGUuZnMubWtkaXIoaW5zdGFuY2UucGF0aCxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgZnVuY3Rpb24gZW5kKGVycm9yLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgICAgICAgUmVtb3ZlKGluc3RhbmNlLnBhdGgsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclJlbW92ZSkgcmV0dXJuIGNhbGxiYWNrKGVycm9yUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHN0ZG91dCwgc3RkZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgV2luZG93c1dyaXRlRXhlY3V0ZVNjcmlwdChpbnN0YW5jZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICAgICAgICAgIFdpbmRvd3NXcml0ZUNvbW1hbmRTY3JpcHQoaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICAgICAgICAgICAgICBXaW5kb3dzRWxldmF0ZShpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHN0ZG91dCwgc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yLCBzdGRvdXQsIHN0ZGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgV2luZG93c1dhaXRGb3JTdGF0dXMoaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBXaW5kb3dzUmVzdWx0KGluc3RhbmNlLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBXaW5kb3dzRWxldmF0ZShpbnN0YW5jZSwgZW5kKSB7XG4gIC8vIFdlIHVzZWQgdG8gdXNlIHRoaXMgZm9yIGV4ZWN1dGluZyBlbGV2YXRlLnZiczpcbiAgLy8gdmFyIGNvbW1hbmQgPSAnY3NjcmlwdC5leGUgLy9Ob0xvZ28gXCInICsgaW5zdGFuY2UucGF0aEVsZXZhdGUgKyAnXCInO1xuICB2YXIgY29tbWFuZCA9IFtdO1xuICBjb21tYW5kLnB1c2goJ3Bvd2Vyc2hlbGwuZXhlJyk7XG4gIGNvbW1hbmQucHVzaCgnU3RhcnQtUHJvY2VzcycpO1xuICBjb21tYW5kLnB1c2goJy1GaWxlUGF0aCcpO1xuICAvLyBFc2NhcGUgY2hhcmFjdGVycyBmb3IgY21kIHVzaW5nIGRvdWJsZSBxdW90ZXM6XG4gIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIGZvciBQb3dlclNoZWxsIHVzaW5nIHNpbmdsZSBxdW90ZXM6XG4gIC8vIEVzY2FwZSBzaW5nbGUgcXVvdGVzIGZvciBQb3dlclNoZWxsIHVzaW5nIGJhY2t0aWNrOlxuICAvLyBTZWU6IGh0dHBzOi8vc3M2NC5jb20vcHMvc3ludGF4LWVzYy5odG1sXG4gIGNvbW1hbmQucHVzaCgnXCJcXCcnICsgaW5zdGFuY2UucGF0aEV4ZWN1dGUucmVwbGFjZSgvJy9nLCBcImAnXCIpICsgJ1xcJ1wiJyk7XG4gIGNvbW1hbmQucHVzaCgnLVdpbmRvd1N0eWxlIGhpZGRlbicpO1xuICBjb21tYW5kLnB1c2goJy1WZXJiIHJ1bkFzJyk7XG4gIGNvbW1hbmQgPSBjb21tYW5kLmpvaW4oJyAnKTtcbiAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZC5leGVjKGNvbW1hbmQsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSxcbiAgICBmdW5jdGlvbihlcnJvciwgc3Rkb3V0LCBzdGRlcnIpIHtcbiAgICAgIC8vIFdlIHVzZWQgdG8gcmV0dXJuIFBFUk1JU1NJT05fREVOSUVEIG9ubHkgZm9yIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW5pbmdcbiAgICAgIC8vIHRoZSBzdHJpbmcgJ2NhbmNlbGVkIGJ5IHRoZSB1c2VyJy4gSG93ZXZlciwgV2luZG93cyBpbnRlcm5hdGlvbmFsaXplc1xuICAgICAgLy8gZXJyb3IgbWVzc2FnZXMgKGlzc3VlIDk2KSBzbyBub3cgd2UgbXVzdCBhc3N1bWUgYWxsIGVycm9ycyBoZXJlIGFyZVxuICAgICAgLy8gcGVybWlzc2lvbiBlcnJvcnMuIFRoaXMgc2VlbXMgcmVhc29uYWJsZSwgZ2l2ZW4gdGhhdCB3ZSBhbHJlYWR5IHJ1biB0aGVcbiAgICAgIC8vIHVzZXIncyBjb21tYW5kIGluIGEgc3Vic2hlbGwuXG4gICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQobmV3IEVycm9yKFBFUk1JU1NJT05fREVOSUVEKSwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgZW5kKCk7XG4gICAgfVxuICApO1xuICBjaGlsZC5zdGRpbi5lbmQoKTsgLy8gT3RoZXJ3aXNlIFBvd2VyU2hlbGwgd2FpdHMgaW5kZWZpbml0ZWx5IG9uIFdpbmRvd3MgNy5cbn1cblxuZnVuY3Rpb24gV2luZG93c1Jlc3VsdChpbnN0YW5jZSwgZW5kKSB7XG4gIE5vZGUuZnMucmVhZEZpbGUoaW5zdGFuY2UucGF0aFN0YXR1cywgJ3V0Zi04JyxcbiAgICBmdW5jdGlvbihlcnJvciwgY29kZSkge1xuICAgICAgaWYgKGVycm9yKSByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIE5vZGUuZnMucmVhZEZpbGUoaW5zdGFuY2UucGF0aFN0ZG91dCwgJ3V0Zi04JyxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICAgICAgTm9kZS5mcy5yZWFkRmlsZShpbnN0YW5jZS5wYXRoU3RkZXJyLCAndXRmLTgnLFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHN0ZGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgICBjb2RlID0gcGFyc2VJbnQoY29kZS50cmltKCksIDEwKTtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlbmQodW5kZWZpbmVkLCBzdGRvdXQsIHN0ZGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQ29tbWFuZCBmYWlsZWQ6ICcgKyBpbnN0YW5jZS5jb21tYW5kICsgJ1xcclxcbicgKyBzdGRlcnJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGVuZChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFdpbmRvd3NXYWl0Rm9yU3RhdHVzKGluc3RhbmNlLCBlbmQpIHtcbiAgLy8gVkJTY3JpcHQgY2Fubm90IHdhaXQgZm9yIHRoZSBlbGV2YXRlZCBwcm9jZXNzIHRvIGZpbmlzaCBzbyB3ZSBoYXZlIHRvIHBvbGwuXG4gIC8vIFZCU2NyaXB0IGNhbm5vdCByZXR1cm4gZXJyb3IgY29kZSBpZiB1c2VyIGRvZXMgbm90IGdyYW50IHBlcm1pc3Npb24uXG4gIC8vIFBvd2VyU2hlbGwgY2FuIGJlIHVzZWQgdG8gZWxldmF0ZSBhbmQgd2FpdCBvbiBXaW5kb3dzIDEwLlxuICAvLyBQb3dlclNoZWxsIGNhbiBiZSB1c2VkIHRvIGVsZXZhdGUgb24gV2luZG93cyA3IGJ1dCBpdCBjYW5ub3Qgd2FpdC5cbiAgLy8gcG93ZXJzaGVsbC5leGUgU3RhcnQtUHJvY2VzcyBjbWQuZXhlIC1WZXJiIHJ1bkFzIC1XYWl0XG4gIE5vZGUuZnMuc3RhdChpbnN0YW5jZS5wYXRoU3RhdHVzLFxuICAgIGZ1bmN0aW9uKGVycm9yLCBzdGF0cykge1xuICAgICAgaWYgKChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnRU5PRU5UJykgfHwgc3RhdHMuc2l6ZSA8IDIpIHtcbiAgICAgICAgLy8gUmV0cnkgaWYgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgZmluaXNoZWQgd3JpdGluZy5cbiAgICAgICAgLy8gV2UgZXhwZWN0IGEgZmlsZSBzaXplIG9mIDIuIFRoYXQgc2hvdWxkIGNvdmVyIGF0IGxlYXN0IFwiMFxcclwiLlxuICAgICAgICAvLyBXZSB1c2UgYSAxIHNlY29uZCB0aW1lb3V0IHRvIGtlZXAgYSBsaWdodCBmb290cHJpbnQgZm9yIGxvbmctbGl2ZWRcbiAgICAgICAgLy8gc3Vkby1wcm9tcHQgcHJvY2Vzc2VzLlxuICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSWYgYWRtaW5pc3RyYXRvciBoYXMgbm8gcGFzc3dvcmQgYW5kIHVzZXIgY2xpY2tzIFllcywgdGhlblxuICAgICAgICAgICAgLy8gUG93ZXJTaGVsbCByZXR1cm5zIG5vIGVycm9yIGFuZCBleGVjdXRlIChhbmQgY29tbWFuZCkgbmV2ZXIgcnVucy5cbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIHRoYXQgY29tbWFuZCBvdXRwdXQgaGFzIGJlZW4gcmVkaXJlY3RlZCB0byBzdGRvdXQgZmlsZTpcbiAgICAgICAgICAgIE5vZGUuZnMuc3RhdChpbnN0YW5jZS5wYXRoU3Rkb3V0LFxuICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGVuZChuZXcgRXJyb3IoUEVSTUlTU0lPTl9ERU5JRUQpKTtcbiAgICAgICAgICAgICAgICBXaW5kb3dzV2FpdEZvclN0YXR1cyhpbnN0YW5jZSwgZW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDEwMDBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gV2luZG93c1dyaXRlQ29tbWFuZFNjcmlwdChpbnN0YW5jZSwgZW5kKSB7XG4gIHZhciBjd2QgPSBOb2RlLnByb2Nlc3MuY3dkKCk7XG4gIGlmICgvXCIvLnRlc3QoY3dkKSkge1xuICAgIC8vIFdlIGV4cGVjdCBkb3VibGUgcXVvdGVzIHRvIGJlIHJlc2VydmVkIG9uIFdpbmRvd3MuXG4gICAgLy8gRXZlbiBzbywgd2UgdGVzdCBmb3IgdGhpcyBhbmQgYWJvcnQgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICByZXR1cm4gZW5kKG5ldyBFcnJvcigncHJvY2Vzcy5jd2QoKSBjYW5ub3QgY29udGFpbiBkb3VibGUtcXVvdGVzLicpKTtcbiAgfVxuICB2YXIgc2NyaXB0ID0gW107XG4gIHNjcmlwdC5wdXNoKCdAZWNobyBvZmYnKTtcbiAgLy8gU2V0IGNvZGUgcGFnZSB0byBVVEYtODpcbiAgc2NyaXB0LnB1c2goJ2NoY3AgNjUwMDE+bnVsJyk7XG4gIC8vIFByZXNlcnZlIGN1cnJlbnQgd29ya2luZyBkaXJlY3Rvcnk6XG4gIC8vIFdlIHBhc3MgL2QgYXMgYW4gb3B0aW9uIGluIGNhc2UgdGhlIGN3ZCBpcyBvbiBhbm90aGVyIGRyaXZlIChpc3N1ZSA3MCkuXG4gIHNjcmlwdC5wdXNoKCdjZCAvZCBcIicgKyBjd2QgKyAnXCInKTtcbiAgLy8gRXhwb3J0IGVudmlyb25tZW50IHZhcmlhYmxlczpcbiAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlLm9wdGlvbnMuZW52KSB7XG4gICAgLy8gXCJUaGUgY2hhcmFjdGVycyA8LCA+LCB8LCAmLCBeIGFyZSBzcGVjaWFsIGNvbW1hbmQgc2hlbGwgY2hhcmFjdGVycywgYW5kXG4gICAgLy8gdGhleSBtdXN0IGJlIHByZWNlZGVkIGJ5IHRoZSBlc2NhcGUgY2hhcmFjdGVyICheKSBvciBlbmNsb3NlZCBpblxuICAgIC8vIHF1b3RhdGlvbiBtYXJrcy4gSWYgeW91IHVzZSBxdW90YXRpb24gbWFya3MgdG8gZW5jbG9zZSBhIHN0cmluZyB0aGF0XG4gICAgLy8gY29udGFpbnMgb25lIG9mIHRoZSBzcGVjaWFsIGNoYXJhY3RlcnMsIHRoZSBxdW90YXRpb24gbWFya3MgYXJlIHNldCBhc1xuICAgIC8vIHBhcnQgb2YgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlLlwiXG4gICAgLy8gSW4gb3RoZXIgd29yZHMsIFdpbmRvd3MgYXNzaWducyBldmVyeXRoaW5nIHRoYXQgZm9sbG93cyB0aGUgZXF1YWxzIHNpZ25cbiAgICAvLyB0byB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlLCB3aGVyZWFzIFVuaXggc3lzdGVtcyBpZ25vcmUgZG91YmxlIHF1b3Rlcy5cbiAgICB2YXIgdmFsdWUgPSBpbnN0YW5jZS5vcHRpb25zLmVudltrZXldO1xuICAgIHNjcmlwdC5wdXNoKCdzZXQgJyArIGtleSArICc9JyArIHZhbHVlLnJlcGxhY2UoLyhbPD5cXFxcfCZeXSkvZywgJ14kMScpKTtcbiAgfVxuICBzY3JpcHQucHVzaChpbnN0YW5jZS5jb21tYW5kKTtcbiAgc2NyaXB0ID0gc2NyaXB0LmpvaW4oJ1xcclxcbicpO1xuICBOb2RlLmZzLndyaXRlRmlsZShpbnN0YW5jZS5wYXRoQ29tbWFuZCwgc2NyaXB0LCAndXRmLTgnLCBlbmQpO1xufVxuXG5mdW5jdGlvbiBXaW5kb3dzV3JpdGVFbGV2YXRlU2NyaXB0KGluc3RhbmNlLCBlbmQpIHtcbiAgLy8gV2UgZG8gbm90IHVzZSBWQlNjcmlwdCB0byBlbGV2YXRlIHNpbmNlIGl0IGRvZXMgbm90IHJldHVybiBhbiBlcnJvciBpZlxuICAvLyB0aGUgdXNlciBkb2VzIG5vdCBncmFudCBwZXJtaXNzaW9uLiBUaGlzIGlzIGhlcmUgZm9yIHJlZmVyZW5jZS5cbiAgLy8gdmFyIHNjcmlwdCA9IFtdO1xuICAvLyBzY3JpcHQucHVzaCgnU2V0IG9ialNoZWxsID0gQ3JlYXRlT2JqZWN0KFwiU2hlbGwuQXBwbGljYXRpb25cIiknKTtcbiAgLy8gc2NyaXB0LnB1c2goXG4gIC8vICdvYmpTaGVsbC5TaGVsbEV4ZWN1dGUgXCInICsgaW5zdGFuY2UucGF0aEV4ZWN1dGUgKyAnXCIsIFwiXCIsIFwiXCIsIFwicnVuYXNcIiwgMCdcbiAgLy8gKTtcbiAgLy8gc2NyaXB0ID0gc2NyaXB0LmpvaW4oJ1xcclxcbicpO1xuICAvLyBOb2RlLmZzLndyaXRlRmlsZShpbnN0YW5jZS5wYXRoRWxldmF0ZSwgc2NyaXB0LCAndXRmLTgnLCBlbmQpO1xufVxuXG5mdW5jdGlvbiBXaW5kb3dzV3JpdGVFeGVjdXRlU2NyaXB0KGluc3RhbmNlLCBlbmQpIHtcbiAgdmFyIHNjcmlwdCA9IFtdO1xuICBzY3JpcHQucHVzaCgnQGVjaG8gb2ZmJyk7XG4gIHNjcmlwdC5wdXNoKFxuICAgICdjYWxsIFwiJyArIGluc3RhbmNlLnBhdGhDb21tYW5kICsgJ1wiJyArXG4gICAgJyA+IFwiJyArIGluc3RhbmNlLnBhdGhTdGRvdXQgKyAnXCIgMj4gXCInICsgaW5zdGFuY2UucGF0aFN0ZGVyciArICdcIidcbiAgKTtcbiAgc2NyaXB0LnB1c2goJyhlY2hvICVFUlJPUkxFVkVMJSkgPiBcIicgKyBpbnN0YW5jZS5wYXRoU3RhdHVzICsgJ1wiJyk7XG4gIHNjcmlwdCA9IHNjcmlwdC5qb2luKCdcXHJcXG4nKTtcbiAgTm9kZS5mcy53cml0ZUZpbGUoaW5zdGFuY2UucGF0aEV4ZWN1dGUsIHNjcmlwdCwgJ3V0Zi04JywgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZXhlYyA9IEV4ZWM7XG5cbi8vIFdlIHVzZWQgdG8gZXhwZWN0IHRoYXQgYXBwbGV0LmFwcCB3b3VsZCBiZSBpbmNsdWRlZCB3aXRoIHRoaXMgbW9kdWxlLlxuLy8gVGhpcyBjb3VsZCBub3QgYmUgY29waWVkIHdoZW4gc3Vkby1wcm9tcHQgd2FzIHBhY2thZ2VkIHdpdGhpbiBhbiBhc2FyIGZpbGUuXG4vLyBXZSBub3cgc3RvcmUgYXBwbGV0LmFwcCBhcyBhIHppcCBmaWxlIGluIGJhc2U2NCB3aXRoaW4gaW5kZXguanMgaW5zdGVhZC5cbi8vIFRvIHJlY3JlYXRlOiBcInppcCAtciAuLi9hcHBsZXQuemlwIENvbnRlbnRzXCIgKHdpdGggYXBwbGV0LmFwcCBhcyBDV0QpLlxuLy8gVGhlIHppcCBmaWxlIG11c3Qgbm90IGluY2x1ZGUgYXBwbGV0LmFwcCBhcyB0aGUgcm9vdCBkaXJlY3Rvcnkgc28gdGhhdCB3ZVxuLy8gY2FuIGV4dHJhY3QgaXQgZGlyZWN0bHkgdG8gdGhlIHRhcmdldCBhcHAgZGlyZWN0b3J5LlxudmFyIEFQUExFVCA9ICdVRXNEQkFvQUFBQUFBTzFZY0VjQUFBQUFBQUFBQUFBQUFBQUpBQndBUTI5dWRHVnVkSE12VlZRSkFBUE5uRWxXTFpFUVYzVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEF3UVVBQUFBQ0FDZ2VYQkhsSGFHcUtFQkFBQytBd0FBRXdBY0FFTnZiblJsYm5SekwwbHVabTh1Y0d4cGMzUlZWQWtBQTF6V1NWWXRrUkJYZFhnTEFBRUU5UUVBQUFRVUFBQUFmWk5SYjVzd0ZJV2ZsMS9CZUE5T3BTbXFKa3FWQkNKRm9wMVZ5S1E5VGE1OVM2d2EyN05OQ2Z2MU0wbmFKV1RzRVhPK2M4Kzl2bzd2OTdVSTNzQllydVJkZUJQTndnQWtWWXpMNmk3Y2x1dnBiWGlmVE9MUDZiZFYrUU5uZ1JiY3VnQnZsL2xtRllSVGhCWmFDMEFvTGRNQTU1dWlETHdIUXRsakdJUTc1L1JYaE5xMmpVaXZpcWlxZTZGRjJDZ054blc1TjV0NklHS09oYjdNMGYwaWpqOWxuTHBrOGlsK2hTNVpyWmVOWkFJV1FxajJnZStCNVlvU3dYOFQ1eEVibzE3a3RjNDBnSVpRQ204Z2xLNUJ1aWVvdlA1RGJwM3hIU2Vackh5Q1hZeE8zd00rMndOdEhIa1dNQVFQL2JreGJrT1ZYUE14S3VLMER6NkNNaCtXdjNBd1E5Z1BNN0lOVTFOdFZLM0hhOHNYbGZvQittNko2YjRmUnp2MG1rZXpNZjZSMUZlNU1iRzJWWVlGK0wrbE1hR3ZwSUt5MDFjT0M0enpNYXpZS2VOT1FZdURZa2pmak1jdGVDV0phOHcvWmkydWd1YkZBNWU4YnVxaXN3N3FVODFsdHpCMHh4M1FDNS9URmg3Si9lMzg1L3pMKzcrL3dXYlIvTHdJT2wvZHZIaUNYdzAzWUZmRVBKOWR3c1d1NXNWMmt3bm9kM1FvZUxlTDBlR2RKSk0vVUVzREJBb0FBQUFBQUhTQmprZ0FBQUFBQUFBQUFBQUFBQUFQQUJ3QVEyOXVkR1Z1ZEhNdlRXRmpUMU12VlZRSkFBTWJwUTlYTFpFUVYzVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEF3UVVBQUFBQ0FCVkhCZEg3RGs0S1RJSUFBRElZUUFBRlFBY0FFTnZiblJsYm5SekwwMWhZMDlUTDJGd2NHeGxkRlZVQ1FBRE1pUFpWVk9sRDFkMWVBc0FBUVQxQVFBQUJCUUFBQUR0bkc5c0hFY1Z3R2Z0aTdNMS9yT05MTlZ0WEhxcHpzaXBpcytwSE9TV0ZPekVtMjVhdDNYckpJMm96YksrVy9zdXVkczc5dmFTdUNLU3BhT0l4UnkxK05TUFJQQWhsV2o3QVZSYVFDV3BUUnorQ0VvK1JTS0NDaG80SzY3a1ZoVXlBZVY0YjNmV3QxN2ZYWnFLRmdIdnA4ek8zL2RtZG1mUG10bDVMNys4L3VQWEdXTU5FTFpDYUdSTWdtakhJbHhhQkNpYmRjb0dzZXdDbGpHQ0lBaUNJQWlDSUFpQ0lQN3IrTTIxZDY3empiL3pFYUFkd3IxYkdIdVdNUUgyLzJ3QWdxcU9EajBrZjBGKzhuR2ZvRlJiSjhwOVUwQzVnL0tSZ3dFWnFaTEdmcmZ3d0p4K0xQMmtWV2tlbEQ5ekoyTmZCcjFuV3QyeHJoTmlzeFdaM0V4Nk1wTlNjMVorc29xT08rNWk3Sk1ZdDd2ajlCQzVqaVpYQndpckNUMlYxYzBxT2daQXh3TVl0OWNiUnl4bm1VbGp1c2E5bUtCakdPTjJ0Z0cvUGxYTkd5ZVNSbHhOR2xPWktqcGVCUjBLeHNGeCtNQjdWSnk1R0I0Nk9PU3JDTFBLZkVqckgzL2dGcnkrNHpPcHVIOHNtK1ZGNXNyVzZsdFZqWlEzSFZuTDNLUkRETHNmbE1TQURweUR5anVSMHVycDZBQWRIUmdIZE9EOWlPczZZcGwwT21QVXVwZWVjT1cxOU9zUUFtbjN0ekJ5NExGSDVPRUQzanowTWJZb3VNOEQ0NjBCT2RUWENhRUY2dHNnTGtGOEdlSlBRQmoxNlJiNFBUZjV4bDJOSDRKOGE1VnkxTjNGM09jWnplZk1hQ281R2VWVHVKMlA0Y1VmL2FINXFiYlA3My91dHBmZWV2ZGJMendmWWZ5K1E4MHdvR2FuLzFFK2xqby83MDNnNzdJYU9KWTQ3OXQ1cnFGTERhZzlPamFUcy9SMGRDUTVhV3JtVEhTL3FhWDFFeG56V0M2NkwyUHFZN3A1UEJuVGM3MVRYbm4wc0c3bWtoa2pGeDNhMElMMzBlL3JReEIrRVhMNjhKNEJCTGU3M3IyOThEeVNrNXRsR1B0SlkxQm1PaFpUYzcyN1BCSDJLZStaaEYzNW5UeVA4MG9RQkVFUUJQRlJjSlRaVndwdnJ4WldwTG1Ka04wVktUNHEyaU9SVUdGQk9QZm5CdUZYOW5oRUxPRzY3ZjFEOXBXeHB3NFhWcnJtVGtseitaWTVXZnd1cm0vdDNmZmk5Y0UrdU00MXZZYmJqMmZQNWtOWHQ5c1hpb3B3VlJqNnhoUGxyMTYwbXR0ZnVWaTRGczJ2WHYycmZjNXU3VWVaZnhRK3k0cFBoL0pycHlVVUJqbXJvZnptYWRHWEtmMGV1aTdLSy9ad0pMUVVpdVJBZSttTFVGUSt0RktVVjNucGQ3QVU5eXR6OGlxSWlYWW9Vbm9Cc3FkeERiWGszQ1hjUm92OWxZaG9XNUVRakJ4YjROb1NZOWlRc3ZuNStRU3V1c3JkdUF5YkwzZUhJSUliTHF5SVM5Q0hsWTNsb0I4cmxkVkt1TGZ5T3NFMSthNnpoVVZ4WXNGcDNBbXF6OHRyN0x6OGR6YTFKRjhUbUMzL3N5aXZZVnRjZnhjV095Y1dRRHZ1TGNyZG5jNjF5N21HbldzRXJnbXNYRGJLNVRLa3NjbnlwSnZHaHN1SDNUUTJYMzdZVGFQUTh1Y3c3VzZ0MUxSMlRGZmpla3FiMFNHVGllZFRPbXowa2xaU1N5V2YwVTAxcHFWU3VmWEdtVGhzanMyME9wVTNZcmp1eGJudTR1K0dQOGIxTE82UGNYMkw0UTYrdjhRMDd1OWFRRkx5NzFDa3Q1NFRJZmpmTmR6ZkRrTVloVEFPSVhIWGgzOXZDWUlnQ0lJZ0NJSWdDSUw0ejNObSs4NC9DaTFObjhiMHJ5SHNnYkJYMXJiZ09YRDdMWkp6TnRyQzAvZ0ZxWU9uOGNzUS9HT05ndVFjaFBYemN2eSs5Q0J6dms4NEh4a08rdEpIM2JSejVGYjBwYi9uUzMvZmwvNkJMLzJhTDQzZmFMenozV2JtanU4VzVwNnB0dGFvUjlUSGpneVowekVlSDJlcXFtYk56TFNocFhWSXB4T3FmbEtQNVMxZFRlaGFYRGVacWh2SGsyYkdZT28rTFpYYWwwbG5NNFp1V01QSlhGYXpZZ21tUHA3VmpXRjlTc3VuclBWYTFIcE1uMGxQbTJyOGhHWk8zYWVhK25ReVorbW1tdE5qRnA1aTRvRzBsVENoRStlRGoycG04bGJTZ0RGb2xuNHlDUnAwMHpReUVEbVp0QlpMYkd4bmFuSHpnV2gwOTJkMjllL3V2Ky9mK0RJUUJFRVFCRUVRQkVFUS83UDgxclgvRnhvWm0vWHMvNVVtdFA4UE8vVzNNOWZHdktvUEFFZllYTFFKMUhPcG1rK0FKeDgwT09iNW0vVVJHRzl6OWMzNzhyVnM5RjE1dFBYUDFkUzN3dlZ0QytROS9INERGWDIxZlFjWTl6dm85ZVhyajYrK0QwQWYxemZxeTlleXgzZjE2UW5WTWF5dWZyK3pYTitzTDk5WVJ4L082OWVyK1JkSWdYa054SnY5RGZCVERJeExQYTZadWRyNmVuejVldU82a2U5Qmo3VFJ6cjBub0srSmJjemZ5QTloZ092cjlPWDk4dDU3WE5GWDN5ZGhsT3NMKzJUOCtvSy91Y3J2Tk9DZkVIYmJYaEFxZWViTEIvMFY3b1lwNytQdDhQc1pXbmwxK3VyUnBBbjdTVUNjWUJYL2hrdGg5NWtkMmNGWWxsWDNieEI0K3hDcnpjQ082djRQYlh6bzFmd2JFTS9INGRzL2YvbkNnWkgrOGsrajB2TlB2N0psejdxUFExUEZ4K0ZWUG9aNzZvemo0Mks4N1lQOS9jVDd4dWY5VWZwU2VQME1zSnZ6cDBBOC80ZzN3Kzc4ZWY0UitGNFFCRUVRQlBIL3cxR20yRmVVd3R1cnl0d3BVU25tSmZ0YTRRM2gzSjhhRmVFOXhmN2QxWkJTT0NjcWhmdFovbStZS3VHNndWNHFhUXpkR0VEMFoyakovenBhOVpjZWdqSUY3ZmtWYUlCcnQxMW5KeFlPT2VwWHBQUHlLanN2dnl0T0xjbnZDV3hKZmg4N1YreFRhMHJ4MUtwajBhOFVGcVdKaFhMM2ZnSHQ5eFhuK3JDejdCb3AzcmtURWtOajVlN2JJWjdITlJaYi9rdTVYRTZnNThIeVpVemRqNm1MamgxL1BidDdYTXQ1ZHZmdnRMbDFGYnY3QnRiaHJ0eUVQVzZWMDM4SDF5RTg4eVFUVGtxQzFMSlZuSWVhQ05lN2RyM3NFUEVlNmxDYjlMV0dmYTNlZnZORzhwZTVmRjhOZVc4ZzNuN2pDSSsveE9PRVZIMTlLdkY5b3VkSEgybi9ZT3RZZ2lBSWdpQUlnaUFJZ2lBK2ZtNjlteDNhTzhiWXRrSG4veGx3RHE4bmt3YWF2ejloOXN3emMrRFd3UnJtNzFBNUNKVlZqZUNoVHRrMjZGcXd1MGZ4UWpVTCs5dnFIVlYvS0M1M09VZCtiSnhWZkJrdzcvZ3pDTzVwcjNkT0svZytXVVFEZVpsVi9BMlFSd0o1VEhqbjEveGNkOUJmaGxUMUtiZ3BWd0xuK1cyYW1HcjIvLzhDVUVzREJCUUFBQUFJQUFWSGowZ2E3RllqZlFFQUFLb0NBQUFoQUJ3QVEyOXVkR1Z1ZEhNdlRXRmpUMU12YzNWa2J5MXdjbTl0Y0hRdGMyTnlhWEIwVlZRSkFBT0prQkJYaXBBUVYzVjRDd0FCQlBVQkFBQUVGQUFBQUkxU08wOGNNUkR1OTFjTUhJS0d4VUI1eFNHRVVxVGxGS1dNdlBZY2ErRVhuakdYeTYvUGVOY2cwcVZheStQdk9iczVVNU9MYXRJMER4dllJd05WbTRCZFFHSWRNaHhTa2F1SjhLMWk3Rk9qdlNkd0IyQSsvV0puWHBFSmRFR3dqdlRrMFc2SGhUVzhXbGRnektEZWRWRjJVZzJ0TG43c3Z6M0REcFRGZHhXcjkzQy91N3diVktXeW9EaFZNLzhYWkFPUE9YdmNtK0l5WHhHY2l6ZWFVY2EwWEoxRDBDZlFubEV5c0UyVndidUlJMGJyNGd2ZENNRjM3bTlJb0MzOStveFRPMkVwUzhvWkpkdFJTMGFJS1k1L3NDUW95TFZFTU1raTZHaGwwQkdOOVNldUlDa1BJY3RYREhERFNCOW9HRVFpMXlaV1VBZGE4RVpuSWNSL2VJT09WYW8rOVRyYmtwWUZqTG1ra0hrMEtZU0d2ZHQxMi9lNzFjUDZIczJjNE9KQmVtdHNZdXNwbFZYK0dMSFE3REtrUTA5OC9aRjM4ZExFcFJDZU5VTWxNVzkwQklzZWVRa1d0dXUycUttSXlESEN1cUZ1bzFOMTFVZC8xQ2Y2Q0hiN1NmeGxkMkFUa2xRb1VHRURBY3RmWjUzMjZXVTc0Ry9IY0R2OEJWQkxBd1FLQUFBQUFBRHRXSEJIcWlBR2V3Z0FBQUFJQUFBQUVBQWNBRU52Ym5SbGJuUnpMMUJyWjBsdVptOVZWQWtBQTgyY1NWWXFrUkJYZFhnTEFBRUU5UUVBQUFRVUFBQUFRVkJRVEdGd2JIUlFTd01FQ2dBQUFBQUFtM2x3UndBQUFBQUFBQUFBQUFBQUFCTUFIQUJEYjI1MFpXNTBjeTlTWlhOdmRYSmpaWE12VlZRSkFBTlcxa2xXTFpFUVYzVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEF3UVVBQUFBQ0FDQWVYQkhmcm55c2ZZR0FBQWYzQUFBSGdBY0FFTnZiblJsYm5SekwxSmxjMjkxY21ObGN5OWhjSEJzWlhRdWFXTnVjMVZVQ1FBREg5WkpWbkdsRDFkMWVBc0FBUVQxQVFBQUJCUUFBQUR0M1hrODFIa2N4L0h2YjV5Vm81YkdzVmxLYmNwUlJxRmxHWkdTNUppa1JCSWRJME9adHRNWmxvcWlZd3JWakQxVXFKYVVva1RSdWJHNzJiWlZqcVIxVlpOanAyWEVHbzlIKzlndCs5aC85dEh4OEg3TjQvZnc1TUhqWWVhUHorUDcrUDd4L2JMOWdyaUVQTkJtKzAwMUowUytaYnZML05tS3d6V0hFMElVSGViWXVSRkNFY2tqTDl2L3hTdmsyRXBDcEJYWnRyWXVEcmEyT2k0aHdTdlpnU3NJTVU5TWRQZGVQY1pkMWFxUXUwcDNmRGtyY0ZycyttUFdpaE1VOXk2Y2xwNVhFRkZkYlJyRWN6Q3RHdGZrTDNwV2Z2Qkd1YmxKNGN0MDUxa3VvY1l0YWFxbGwvSWpkZlIrVjc1dmxUZGwvL0FKVlpVNmVsWjVmMFM3Tk8zTWFFMnhNRWxoRitUVXJIZ1cybkZZZUdUcnMvT3JoREpONXpNWDhaSlZLWHJxU1VNMVJqMDNibmY4NS9wSk1YRUNOZGwwRDFjdGZlL2o4MmltemlNMm5sbFNhM3Q1cTgrdlAxZjM4ay9rMjJ1TjFsbW52ZnowYjhkR3hPK21uaDkxdjdXQjJ0S2RyRzNkNHZtSmFIbFR2akd6ZE1xV2N3Lzlmcm5DdFFwUFpLOXNNS2kvRXkvanpncUlQekJ5OS9kbGY5Z3JpSTIvdStzamNBcG96V3g2L05YeXRDK3FCVGxyaGI2OWZFN0o2dGdPenBXakZTbDhxeGlocjVkWWYvcUV4b2V1cFk2WmUvajJQZkwxYXpoaFo4ZlUzZWVsSlkreWxrMTZVSk42S21PVTBNNHIrNzVjWmhIL214Tm5kb3dOYjR3eDdUQ29ONHl2TUd1OHlTcTVsNVc1dCt4UXlZYlMvT21lN2UwVzBzWGJDNWFrdGwwTEVYTllSOW9iSDdkTVQ3MjFkYk5kVC9lRnpYTkVZU0g4R1UrYlE1czZZbmlHY2ozZkh0Z1hQYm8wT2o0aTNkNUcxRmpmbS9OZzdrZ3BqUUROeHc0UlJudStWbG95NVpFM0o2T3B3bEZCemF4UzI1SGUyaDNsSnVpek83MHpKUExVWXRrczE0UkU1eXJEOHkydFhhNWw1V3FoL05CWTA2eW9pQ0xGMDhOazlBNU9qYnM0M0dtUjFDaC9QYVpzTGYzZTZ1UFJTcklNMVJPcUdqdDgwbGVxZmR4WWJObitXVjdLN1pLaXkvdDZyMS8zaWU0NlY1NDMyVC9PYWhzOVY3Tm5WemI5em9xMnJGZ3ZQeFhyY0FNem12V25Ham9mL1JwZHNaVGhJRXBleDZER2JkNWg2U1RhT3laWHhWL1lmVzl1NEt5bGxtWjNYMTVJTUhITFNKdFZQU092VUxDc3oyVHlQQy9XTDlrR1NtZS8xTDAxU1N6amZiSG5xaytPVjdPQm1ldlplbzNEQlI3bFhUNWRyVDBNa1g1UHdEZDFFUTBlYmZraDF6eS9MOHlkZCtWSjRDTHVSbmROanV3ait2TWZVOHEybDJsMXJHdHI4RkMyRCtmZFNHazgxZWx0dVRqWVNNaysrNEJNZDBEWFFvMzVpWGJabmRHZGNYa0dGeWVHNmIyOGV2RjIyTTJ3MjJIbFlTWGV0R1NMVzRjZkZUMDBXcXZOOWJrcUN1alE5S3pkU3Qrc25yK3FtYmNtZSs1WTNjRFJuOUJETHBzK2RQVmx0RTlVa1BlYjZYb3ZpbmVpVlV6blR6bnl1WmFTbi9adlI4VmVSVVlMcWUzaUhGcW5VNis3KzRMbXRmc21hUzBNZGpJdnNsRkpHRy9ybjdEUGRNR0xjeDRkNmVQMk96OTJZNDlrV2JCVWp1ZFUyaWpIbmM3WUlPRFF4RDFhUHg4UHluVnIrY212Sm95MitNNW5RYTJLdDBkdmRQeHA3M0xOVTZhVGVha3RUZkhIMUwrOFBtL1hhbFpjRmNmell4bGhUZWZ1empSR29iTEtFcVBaaDhRS3hVWFdiVS9FUnZXNzhnaHZUR1RVTmQwZzlZcWJjalV5NWgweFZibjNTN1NTNTRTT3FLdDg4VVIwcVp1eEtmeGxaZk9EVW01Mm8ySGtHVE9MdzVkcWhldnZXakg3c3NpcXhBaEt3QTkxZDFuV0c5dy9HSkljN0d3V2JLS2UvbUFzR1JxWEJiODdQMTBqSDgvMExZNmtwR1FWMUtjdUF3QUFlQ3Q0TGlWRldSSktzNERKNnA5R3hHSFdmTHVUTTVkdDYxL3B6Q0NFN3ZMbVNvZEdKTS9BU3FkelUyVTNWanBZNldDbGc1WE9JQ3VkVWFJM1Zqb2N1V0NzZEFBQUFBQUFBQUFBQUFBQUFENW8xR21yMDU0VFNvcVd4UHZuZnJMeFZFSWMyOS9jVDVZbWttZGdQemxDU3o4YSs4bllUOForTXZhVEI5bFBacEpYKzhsUmt0RnlSZERGMG02SWRjRjJNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUM4ZGREOEc1b0prVXVRbkFYd252eExBQUFBQUREa0VGVVJSY2tWRTZySXYrVGIxMDc4TWlaRWV0dWJKMzRSSGNremNPSVhkOHVXVHB6NGhSTy9jT0lYVHZ3YTVNUXZvaWRaNVM4YTloOG5mbDFRVmhpcFE2anl5V2V1dlRhQkdQM0Q1ZndnRTRncGVRWW1VQ1o3WFEwbUVDWVFKaEFtMEdBVHlPZlZtWU9VNHNBZE5pK2NPVXBtLzljZE52MkRpOGtrRk4zbVlPdHJnOHNFMTR4aWNHRndZWERobWxFQUFENXcvT3MxbzhiVGNNMG9WanBZNldDbGcydEdBUUFBQUFBQUFBQUFBQUFBZ0wvd2I5ZU1CcG93K3I4MTd5Ti9md25KZjMzUDVnNzhuV29mRVpOWEQzdTk1R2RTa2gzbzEzNS9hTDJpM3ZsL2dIZi83dDU5b0RsbkRTSFM4Z1FoTkdRTDh1V3M2UCtpd1BZTER1SU96QVJxeU0rRTlRT2ZBM1BJZnc0SUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhORDcwSjlRU3dNRUZBQUFBQWdBN1Zod1IvZFlwbFpBQUFBQWFnRUFBQjRBSEFCRGIyNTBaVzUwY3k5U1pYTnZkWEpqWlhNdllYQndiR1YwTG5KemNtTlZWQWtBQTgyY1NWWlRwUTlYZFhnTEFBRUU5UUVBQUFRVUFBQUFZMkJnWkdCZ1lGUUJFaURzeGpEeWdKUURQbGttRUlFYVJwSkFRZzhrTEFNTUw4Ymk1T0lxSUZ1b3VLQTRBMGpMTVREOC93K1M1QWRyQjdQbEJJQUVBRkJMQXdRS0FBQUFBQUR0V0hCSEFBQUFBQUFBQUFBQUFBQUFKQUFjQUVOdmJuUmxiblJ6TDFKbGMyOTFjbU5sY3k5a1pYTmpjbWx3ZEdsdmJpNXlkR1prTDFWVUNRQUR6WnhKVmkyUkVGZDFlQXNBQVFUMUFRQUFCQlFBQUFCUVN3TUVGQUFBQUFnQTdWaHdSelBMTlU5VEFBQUFaZ0FBQUNzQUhBQkRiMjUwWlc1MGN5OVNaWE52ZFhKalpYTXZaR1Z6WTNKcGNIUnBiMjR1Y25SbVpDOVVXRlF1Y25SbVZWUUpBQVBObkVsV1U2VVBWM1Y0Q3dBQkJQVUJBQUFFRkFBQUFDV0pPdzZBSUJBRmUwOERDQlZYMlFiV2haZ1ExdkNwQ0hjWHRIa3premVndENEQjVYcC9nMCtVeWloQVJuYjcwa0wvVWJ2ZmZZcGpRT0RjbWs5ektYTGlzdHhDb1VzWkE3RVE1UzArZFZxMDg1Z3ZVRXNEQkFvQUFBQUFBSWVCamtnQUFBQUFBQUFBQUFBQUFBQWJBQndBUTI5dWRHVnVkSE12VW1WemIzVnlZMlZ6TDFOamNtbHdkSE12VlZRSkFBTTlwUTlYTFpFUVYzVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEF3UVVBQUFBQ0FBSmdJNUlDbDVsaVRVQkFBRE1BUUFBSkFBY0FFTnZiblJsYm5SekwxSmxjMjkxY21ObGN5OVRZM0pwY0hSekwyMWhhVzR1YzJOd2RGVlVDUUFEY2FJUFYxT2xEMWQxZUFzQUFRVDFBUUFBQkJRQUFBQjlVTXRPQWtFUXJObGRkOWRoSDNEejZOR1lpUElKSGpUeExDWmVGOWlEY1hFSkMwUnZmb0kvNHNFZkl2b0hQRVFFaGJJSHZPb2swMVUxNmVtdTd2T2thRjJkWHU3WHFyVVRjeU1BVGt4Q3dZS3RoQ0FVYm1jaUFROE8xMXlGY0dCZmJGLzRqUjI0V21Ddldqd1VlWHFmTnV0bjEzWHlFZVlZSGtxS2FtK2tnaGRKR2ZVQ3Z3SWZCNmppR0FYNmFDSEhFVHJvQ3JZRmU2SUtORVhmR09YQ2hjMHY3SEtwQlJ6ZFNGcnRFTHZidW1LVkM4MEYvRklqendlOWJqOTF1WlJ1WEp1d0FpTGpOaTdEbHN4UGFKU1VBTXJDRk9lYWMzR2ZwSU5lbm5RNmQvMHNBNHo3Snh6S2lWQ0NWK1lIQXM3NEx1dUlPTlVpLy80UklvQzYzY3pySWJZUVMzUEZpY1dKY1RNVHYxSkhtb2NtUk9MSjQ1Z2p6Zkh2WEpxamY3Wlo0UlQrNjF1YUJiRGlwR2gyWmFuQmNqaDgvZ0ZRU3dFQ0hnTUtBQUFBQUFEdFdIQkhBQUFBQUFBQUFBQUFBQUFBQ1FBWUFBQUFBQUFBQUJBQTdVRUFBQUFBUTI5dWRHVnVkSE12VlZRRkFBUE5uRWxXZFhnTEFBRUU5UUVBQUFRVUFBQUFVRXNCQWg0REZBQUFBQWdBb0hsd1I1UjJocWloQVFBQXZnTUFBQk1BR0FBQUFBQUFBUUFBQUtTQlF3QUFBRU52Ym5SbGJuUnpMMGx1Wm04dWNHeHBjM1JWVkFVQUExeldTVloxZUFzQUFRVDFBUUFBQkJRQUFBQlFTd0VDSGdNS0FBQUFBQUIwZ1k1SUFBQUFBQUFBQUFBQUFBQUFEd0FZQUFBQUFBQUFBQkFBN1VFeEFnQUFRMjl1ZEdWdWRITXZUV0ZqVDFNdlZWUUZBQU1icFE5WGRYZ0xBQUVFOVFFQUFBUVVBQUFBVUVzQkFoNERGQUFBQUFnQVZSd1hSK3c1T0NreUNBQUF5R0VBQUJVQUdBQUFBQUFBQUFBQUFPMkJlZ0lBQUVOdmJuUmxiblJ6TDAxaFkwOVRMMkZ3Y0d4bGRGVlVCUUFETWlQWlZYVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEFRSWVBeFFBQUFBSUFBVkhqMGdhN0ZZamZRRUFBS29DQUFBaEFCZ0FBQUFBQUFFQUFBRHRnZnNLQUFCRGIyNTBaVzUwY3k5TllXTlBVeTl6ZFdSdkxYQnliMjF3ZEMxelkzSnBjSFJWVkFVQUE0bVFFRmQxZUFzQUFRVDFBUUFBQkJRQUFBQlFTd0VDSGdNS0FBQUFBQUR0V0hCSHFpQUdld2dBQUFBSUFBQUFFQUFZQUFBQUFBQUJBQUFBcElIVERBQUFRMjl1ZEdWdWRITXZVR3RuU1c1bWIxVlVCUUFEelp4SlZuVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEFRSWVBd29BQUFBQUFKdDVjRWNBQUFBQUFBQUFBQUFBQUFBVEFCZ0FBQUFBQUFBQUVBRHRRU1VOQUFCRGIyNTBaVzUwY3k5U1pYTnZkWEpqWlhNdlZWUUZBQU5XMWtsV2RYZ0xBQUVFOVFFQUFBUVVBQUFBVUVzQkFoNERGQUFBQUFnQWdIbHdSMzY1OHJIMkJnQUFIOXdBQUI0QUdBQUFBQUFBQUFBQUFLU0JjZzBBQUVOdmJuUmxiblJ6TDFKbGMyOTFjbU5sY3k5aGNIQnNaWFF1YVdOdWMxVlVCUUFESDlaSlZuVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEFRSWVBeFFBQUFBSUFPMVljRWYzV0taV1FBQUFBR29CQUFBZUFCZ0FBQUFBQUFBQUFBQ2tnY0FVQUFCRGIyNTBaVzUwY3k5U1pYTnZkWEpqWlhNdllYQndiR1YwTG5KemNtTlZWQVVBQTgyY1NWWjFlQXNBQVFUMUFRQUFCQlFBQUFCUVN3RUNIZ01LQUFBQUFBRHRXSEJIQUFBQUFBQUFBQUFBQUFBQUpBQVlBQUFBQUFBQUFCQUE3VUZZRlFBQVEyOXVkR1Z1ZEhNdlVtVnpiM1Z5WTJWekwyUmxjMk55YVhCMGFXOXVMbkowWm1RdlZWUUZBQVBObkVsV2RYZ0xBQUVFOVFFQUFBUVVBQUFBVUVzQkFoNERGQUFBQUFnQTdWaHdSelBMTlU5VEFBQUFaZ0FBQUNzQUdBQUFBQUFBQVFBQUFLU0J0aFVBQUVOdmJuUmxiblJ6TDFKbGMyOTFjbU5sY3k5a1pYTmpjbWx3ZEdsdmJpNXlkR1prTDFSWVZDNXlkR1pWVkFVQUE4MmNTVloxZUFzQUFRVDFBUUFBQkJRQUFBQlFTd0VDSGdNS0FBQUFBQUNIZ1k1SUFBQUFBQUFBQUFBQUFBQUFHd0FZQUFBQUFBQUFBQkFBN1VGdUZnQUFRMjl1ZEdWdWRITXZVbVZ6YjNWeVkyVnpMMU5qY21sd2RITXZWVlFGQUFNOXBROVhkWGdMQUFFRTlRRUFBQVFVQUFBQVVFc0JBaDRERkFBQUFBZ0FDWUNPU0FwZVpZazFBUUFBekFFQUFDUUFHQUFBQUFBQUFBQUFBS1NCd3hZQUFFTnZiblJsYm5SekwxSmxjMjkxY21ObGN5OVRZM0pwY0hSekwyMWhhVzR1YzJOd2RGVlVCUUFEY2FJUFYzVjRDd0FCQlBVQkFBQUVGQUFBQUZCTEJRWUFBQUFBRFFBTkFOd0VBQUJXR0FBQUFBQT0nO1xuXG52YXIgUEVSTUlTU0lPTl9ERU5JRUQgPSAnVXNlciBkaWQgbm90IGdyYW50IHBlcm1pc3Npb24uJztcbnZhciBOT19QT0xLSVRfQUdFTlQgPSAnTm8gcG9sa2l0IGF1dGhlbnRpY2F0aW9uIGFnZW50IGZvdW5kLic7XG5cbi8vIFNlZSBpc3N1ZSA2NjpcbnZhciBNQVhfQlVGRkVSID0gMTM0MjE3NzI4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykgfHxcblx0aGFzRmxhZygnY29sb3I9bmV2ZXInKSkge1xuXHRmb3JjZUNvbG9yID0gMDtcbn0gZWxzZSBpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0Zm9yY2VDb2xvciA9IDE7XG59XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRpZiAoZW52LkZPUkNFX0NPTE9SID09PSAndHJ1ZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMTtcblx0fSBlbHNlIGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICdmYWxzZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMDtcblx0fSBlbHNlIHtcblx0XHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgfHwgMDtcblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3MgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knLCAnR0lUSFVCX0FDVElPTlMnLCAnQlVJTERLSVRFJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKGVudi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0pIHtcblx0Y29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbSwgc3RyZWFtICYmIHN0cmVhbS5pc1RUWSk7XG5cdHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG5cdHN0ZG91dDogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG5cdHN0ZGVycjogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDIpKSlcbn07XG4iLCJleHBvcnQgY29uc3QgRGVmYXVsdFZhbHVlcyA9IHtcclxuICAgIGVuYWJsZUNvbG9yUGlja2VyOiB0cnVlLFxyXG4gICAgZW5hYmxlTWVkaWFDb250cm9sczogdHJ1ZSxcclxuICAgIGVuYWJsZVJ1bk9uTG9naW46IHRydWUsXHJcbiAgICBlbmFibGVDbGlwYm9hcmRTeW5jOiBmYWxzZSxcclxuICAgIGF6dXJlU3RvcmFnZUFjY291bnQ6IFwiXCIsXHJcbiAgICBhenVyZVNBU1Rva2VuOiBcIlwiLFxyXG4gICAgYXp1cmVUYWJsZU5hbWU6IFwiXCIsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNldHRpbmdzID0gdHlwZW9mIERlZmF1bHRWYWx1ZXMiLCJpbXBvcnQgQ2hpbGRQcm9jZXNzIGZyb20gXCJjaGlsZF9wcm9jZXNzXCJcclxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIlxyXG5pbXBvcnQgZnMgZnJvbSBcImZzXCJcclxuaW1wb3J0IHsgYXBwIH0gZnJvbSBcImVsZWN0cm9uXCJcclxuXHJcbmV4cG9ydCBjb25zdCBkaXJTaXplID0gKGRpcmVjdG9yeTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGRpcmVjdG9yeSlcclxuXHJcbiAgICByZXR1cm4gZmlsZXMucmVkdWNlKChhY2N1bXVsYXRvciwgZmlsZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMocGF0aC5qb2luKGRpcmVjdG9yeSwgZmlsZSkpXHJcbiAgICAgICAgcmV0dXJuIHN0YXRzLmlzRmlsZSgpXHJcbiAgICAgICAgICAgID8gYWNjdW11bGF0b3IgKyBzdGF0cy5zaXplXHJcbiAgICAgICAgICAgIDogYWNjdW11bGF0b3IgKyBkaXJTaXplKHBhdGguam9pbihkaXJlY3RvcnksIGZpbGUpKVxyXG4gICAgfSwgMClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGhhbmRsZUNvbW1hbmQgPSAoY29tbWFuZCwgYXJncykgPT4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzLCByZWopID0+IHtcclxuICAgIGNvbnN0IHByb2MgPSBDaGlsZFByb2Nlc3Muc3Bhd24oY29tbWFuZCwgYXJncylcclxuXHJcbiAgICBsZXQgYnVmZmVyID0gW11cclxuICAgIHByb2Muc3Rkb3V0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xyXG5cclxuICAgICAgICBidWZmZXIucHVzaChkYXRhKVxyXG4gICAgfSlcclxuXHJcbiAgICBwcm9jLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbmFsU3Rkb3V0ID0gYnVmZmVyLmpvaW4oXCJcIilcclxuICAgICAgICByZXMoZmluYWxTdGRvdXQpXHJcbiAgICB9KVxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IHJlc29sdmVIdG1sUGF0aCA9IChodG1sRmlsZU5hbWU6IHN0cmluZywgc2VhcmNoOiBzdHJpbmcgPSBcIlwiKSA9PiB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIklOREVWVlwiKVxyXG4gICAgICAgIGNvbnN0IHBvcnQgPSBwcm9jZXNzLmVudi5QT1JUIHx8IDEyMTJcclxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGBodHRwOi8vbG9jYWxob3N0OiR7cG9ydH1gKVxyXG4gICAgICAgIHVybC5wYXRobmFtZSA9IGh0bWxGaWxlTmFtZVxyXG4gICAgICAgIHVybC5zZWFyY2ggPSBzZWFyY2hcclxuICAgICAgICByZXR1cm4gdXJsLmhyZWZcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKFwiTk9OREVWVlwiKVxyXG4gICAgcmV0dXJuIGBmaWxlOi8vJHtwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vcmVuZGVyZXIvJywgaHRtbEZpbGVOYW1lKX0ke3NlYXJjaH1gXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBSRVNPVVJDRVNfUEFUSCA9IGFwcC5pc1BhY2thZ2VkXHJcbiAgICA/IHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsICdhc3NldHMnKVxyXG4gICAgOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vLi4vYXNzZXRzJylcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBc3NldFBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+IHtcclxuICAgIHJldHVybiBwYXRoLmpvaW4oUkVTT1VSQ0VTX1BBVEgsIC4uLnBhdGhzKVxyXG59XHJcbiIsImltcG9ydCBwYXRoLCB7IGpvaW4gfSBmcm9tICdwYXRoJ1xuaW1wb3J0IHJvYm90IGZyb20gXCJyb2JvdGpzXCJcbmltcG9ydCB7IGdldFNldHRpbmdWYWx1ZSwgc2V0dGluZ3NDaGFuZ2VFbWl0dGVyIH0gZnJvbSBcIi4vc2V0dGluZ3NcIlxuaW1wb3J0IHsgZ2xvYmFsU2hvcnRjdXQsIGNsaXBib2FyZCwgQnJvd3NlcldpbmRvdywgYXBwLCBpcGNNYWluLCBuYXRpdmVUaGVtZSwgc2NyZWVuIH0gZnJvbSBcImVsZWN0cm9uXCJcbmltcG9ydCB7IGdldFRhYmxlQ2xpZW50LCBzdGFydENsaXBib2FyZExpc3RlbmVyLCBzdG9wQ2xpcGJvYXJkTGlzdGVuZXIgfSBmcm9tIFwiLi9jbGlwYm9hcmRcIlxuaW1wb3J0IHsgaXNMb2dpbiwgcmVnaXN0ZXJBdExvZ2luLCB1bnJlZ2lzdGVyQXRMb2dpbiB9IGZyb20gXCIuL2xvZ2luXCJcbmltcG9ydCBpbml0TWVzc2FnZUhhbmRsZXJzIGZyb20gJy4vbWVzc2FnZUhhbmRsZXJzJ1xuaW1wb3J0IHsgY3JlYXRlTWVkaWFUcmF5cywgZGVzdHJveU1lZGlhVHJheXMsIGNyZWF0ZU1haW5UcmF5IH0gZnJvbSAnLi90cmF5cydcbmltcG9ydCB7IHJlc29sdmVIdG1sUGF0aCB9IGZyb20gJy4uL2NvbW1vbi91dGlscydcblxubGV0IGlnbm9yZVNpbmdsZUNvcHkgPSBmYWxzZVxuXG5jb25zdCBzdGFydExpc3RlbmluZ1RvQ2xpcGJvYXJkID0gKCkgPT4ge1xuXG4gICAgY29uc3QgdGFibGVDbGllbnQgPSBnZXRUYWJsZUNsaWVudCgpXG5cbiAgICBzdGFydENsaXBib2FyZExpc3RlbmVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGNsaXBib2FyZC5hdmFpbGFibGVGb3JtYXRzKCkuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2luZ2xlQ29weSkge1xuICAgICAgICAgICAgICAgIGlnbm9yZVNpbmdsZUNvcHkgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2xpcGJvYXJkLnJlYWRUZXh0KClcblxuICAgICAgICAgICAgaWYgKHRleHQucmVwbGFjZShcIlxcclwiLCBcIlwiKS5yZXBsYWNlKFwiIFwiLCBcIlwiKS5yZXBsYWNlKFwiXFxuXCIsIFwiXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0YWJsZUNsaWVudC5jcmVhdGVFbnRpdHkoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aXRpb25LZXk6IFwicGNcIixcbiAgICAgICAgICAgICAgICAgICAgcm93S2V5OiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNsaXBib2FyZC5yZWFkVGV4dCgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBtYWluV2luZG93Py53ZWJDb250ZW50cy5zZW5kKCdjbGlwYm9hcmQ6Y2hhbmdlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbn1cblxuY29uc3Qgc3RvcExpc3RlbmluZ1RvQ2xpYnBvYXJkID0gKCkgPT4ge1xuICAgIHN0b3BDbGlwYm9hcmRMaXN0ZW5lcigpXG59XG5cbi8vIGVuYWJsZSBjbGlwYm9hcmQgbGlzdGVuZXIsIHRoZW4gcmVnaXN0ZXIgdG8gc2V0dGluZ3MgY2hhbmdlXG5pZiAoZ2V0U2V0dGluZ1ZhbHVlKFwiZW5hYmxlQ2xpcGJvYXJkU3luY1wiKSlcbiAgICBzdGFydExpc3RlbmluZ1RvQ2xpcGJvYXJkKClcblxuc2V0dGluZ3NDaGFuZ2VFbWl0dGVyLm9uKFwiZW5hYmxlQ2xpcGJvYXJkU3luY1wiLCAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUpXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nVG9DbGlwYm9hcmQoKVxuICAgIGVsc2VcbiAgICAgICAgc3RvcExpc3RlbmluZ1RvQ2xpYnBvYXJkKClcbn0pXG5cblxuXG4vLyBLZWVwIGEgZ2xvYmFsIHJlZmVyZW5jZSBvZiB0aGUgd2luZG93IG9iamVjdCwgaWYgeW91IGRvbid0LCB0aGUgd2luZG93IHdpbGxcbi8vIGJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIEphdmFTY3JpcHQgb2JqZWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG4vKiogQHR5cGUgQnJvd3NlcldpbmRvdyAqL1xubGV0IG1haW5XaW5kb3dcbi8qKiBAdHlwZSBCcm93c2VyV2luZG93ICovXG5sZXQgY2xpcGJvYXJkV2luZG93XG5cbmxldCB3aW5kb3dzQnlXZWJjb250ZW50c0lkID0ge31cblxuY29uc3QgY29sb3JQaWNrZXJLZXlDb21ibyA9ICdzdXBlcitjb250cm9sK3gnXG5cbmNvbnN0IHJlZ2lzdGVyQ29sb3JQaWNrZXIgPSAoKSA9PiB7XG4gICAgZ2xvYmFsU2hvcnRjdXQucmVnaXN0ZXIoY29sb3JQaWNrZXJLZXlDb21ibywgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSByb2JvdC5nZXRNb3VzZVBvcygpXG4gICAgICAgICAgICBjbGlwYm9hcmQud3JpdGVUZXh0KHJvYm90LmdldFBpeGVsQ29sb3IoeCwgeSkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH0pXG59XG5cbmNvbnN0IHVucmVnaXN0ZXJDb2xvclBpY2tlciA9ICgpID0+IHtcbiAgICBnbG9iYWxTaG9ydGN1dC51bnJlZ2lzdGVyKGNvbG9yUGlja2VyS2V5Q29tYm8pXG59XG5cbmNvbnN0IGNyZWF0ZUNsaXBib2FyZFdpbmRvdyA9ICgpID0+IHtcblxuICAgIGNvbnN0IGN1cnNvclBvaW50ID0gc2NyZWVuLmdldEN1cnNvclNjcmVlblBvaW50KClcblxuICAgIGNsaXBib2FyZFdpbmRvdyA9IG5ldyBCcm93c2VyV2luZG93KHtcbiAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgIHNraXBUYXNrYmFyOiB0cnVlLFxuICAgICAgICB3aWR0aDogNDAwLFxuICAgICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgICAgcmVzaXphYmxlOiBmYWxzZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzID8gXCIjMWExYjFlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIHRpdGxlQmFyU3R5bGU6IFwiaGlkZGVuXCIsXG4gICAgICAgIHg6IGN1cnNvclBvaW50LngsXG4gICAgICAgIHk6IGN1cnNvclBvaW50LnksXG4gICAgICAgIHdlYlByZWZlcmVuY2VzOiB7XG4gICAgICAgICAgICBwcmVsb2FkOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAncHJlbG9hZC5qcycpLFxuICAgICAgICAgICAgZGV2VG9vbHM6ICFhcHAuaXNQYWNrYWdlZCxcbiAgICAgICAgICAgIHdlYlNlY3VyaXR5OiBmYWxzZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHdpbmRvd3NCeVdlYmNvbnRlbnRzSWRbY2xpcGJvYXJkV2luZG93LndlYkNvbnRlbnRzLmlkXSA9IGNsaXBib2FyZFdpbmRvd1xuXG4gICAgY2xpcGJvYXJkV2luZG93LnJlbW92ZU1lbnUoKVxuICAgIGNsaXBib2FyZFdpbmRvdy5sb2FkVVJMKHJlc29sdmVIdG1sUGF0aCgnaW5kZXguaHRtbCcsIFwiP3BhZ2U9Y2xpcGJvYXJkXCIpKVxuXG5cbiAgICBjbGlwYm9hcmRXaW5kb3cub24oXCJibHVyXCIsICgpID0+IHtcbiAgICAgICAgY2xpcGJvYXJkV2luZG93LmNsb3NlKClcbiAgICB9KVxuXG4gICAgY2xpcGJvYXJkV2luZG93Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgZGVsZXRlIHdpbmRvd3NCeVdlYmNvbnRlbnRzSWRbY2xpcGJvYXJkV2luZG93LndlYkNvbnRlbnRzLmlkXVxuICAgICAgICBjbGlwYm9hcmRXaW5kb3cgPSBudWxsXG4gICAgfSlcblxufVxuXG5jb25zdCBzaG93T3JDcmVhdGVNYWluV2luZG93ID0gKCkgPT4ge1xuICAgIGlmIChtYWluV2luZG93KSB7XG4gICAgICAgIG1haW5XaW5kb3cuZm9jdXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZU1haW5XaW5kb3coKVxuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlTWFpbldpbmRvdyA9ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlBST1ZBIERFTCBOT1ZFXFxuXFxuXFxuXFxuXFxVT1wiKVxuICAgIC8vIENyZWF0ZSB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAgbWFpbldpbmRvdyA9IG5ldyBCcm93c2VyV2luZG93KHtcbiAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBtaW5IZWlnaHQ6IDQwMCxcbiAgICAgICAgbWluV2lkdGg6IDYwMCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzID8gXCIjMWExYjFlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIHRpdGxlQmFyU3R5bGU6IFwiaGlkZGVuXCIsXG4gICAgICAgIHRpdGxlQmFyT3ZlcmxheToge1xuICAgICAgICAgICAgY29sb3I6IG5hdGl2ZVRoZW1lLnNob3VsZFVzZURhcmtDb2xvcnMgPyBcIiMxYTFiMWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN5bWJvbENvbG9yOiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzID8gXCJ3aGl0ZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVpZ2h0OiA0MFxuICAgICAgICB9LFxuICAgICAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgICAgICAgcHJlbG9hZDogcGF0aC5qb2luKF9fZGlybmFtZSwgJ3ByZWxvYWQuanMnKSxcbiAgICAgICAgICAgIGRldlRvb2xzOiAhYXBwLmlzUGFja2FnZWQsXG4gICAgICAgICAgICB3ZWJTZWN1cml0eTogZmFsc2UsXG4gICAgICAgICAgICBzYW5kYm94OiB0cnVlLFxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHdpbmRvd3NCeVdlYmNvbnRlbnRzSWRbbWFpbldpbmRvdy53ZWJDb250ZW50cy5pZF0gPSBtYWluV2luZG93XG5cbiAgICBtYWluV2luZG93LnJlbW92ZU1lbnUoKVxuXG4gICAgLy8gT3BlbiB0aGUgRGV2VG9vbHMuXG4gICAgbWFpbldpbmRvdy5sb2FkVVJMKHJlc29sdmVIdG1sUGF0aCgnaW5kZXguaHRtbCcpKVxuICAgIGlmICghYXBwLmlzUGFja2FnZWQpXG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMub3BlbkRldlRvb2xzKClcblxuICAgIG1haW5XaW5kb3cub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBkZWxldGUgd2luZG93c0J5V2ViY29udGVudHNJZFttYWluV2luZG93LndlYkNvbnRlbnRzLmlkXVxuICAgICAgICBtYWluV2luZG93ID0gbnVsbFxuICAgIH0pXG59XG5cbmNvbnN0IG9uUmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKGFwcC5pc1BhY2thZ2VkKSB7XG4gICAgICAgIHNldHRpbmdzQ2hhbmdlRW1pdHRlci5vbihcImVuYWJsZVJ1bk9uTG9naW5cIiwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJBdExvZ2luKClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyQXRMb2dpbigpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY3JlYXRlTWFpblRyYXkoKCkgPT4gc2hvd09yQ3JlYXRlTWFpbldpbmRvdygpLCAoKSA9PiBhcHAucXVpdCgpKVxuXG4gICAgYXBwLm9uKFwic2Vjb25kLWluc3RhbmNlXCIsICgpID0+IHtcbiAgICAgICAgc2hvd09yQ3JlYXRlTWFpbldpbmRvdygpXG4gICAgfSlcblxuICAgIC8vIGVuYWJsZSBtZWRpYSB0cmF5IGljb25zLCB0aGVuIHJlZ2lzdGVyIG9uIHNldHRpbmcgY2hhbmdlXG4gICAgaWYgKGdldFNldHRpbmdWYWx1ZShcImVuYWJsZU1lZGlhQ29udHJvbHNcIikpXG4gICAgICAgIGNyZWF0ZU1lZGlhVHJheXMoKVxuXG4gICAgc2V0dGluZ3NDaGFuZ2VFbWl0dGVyLm9uKFwiZW5hYmxlTWVkaWFDb250cm9sc1wiLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgY3JlYXRlTWVkaWFUcmF5cygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlc3Ryb3lNZWRpYVRyYXlzKClcbiAgICB9KVxuXG4gICAgLy8gZW5hYmxlIGNvbG9yIHBpY2tlciwgdGhlbiByZWdpc3RlciBvbiBzZXR0aW5nIGNoYW5nZVxuICAgIGlmIChnZXRTZXR0aW5nVmFsdWUoXCJlbmFibGVDb2xvclBpY2tlclwiKSlcbiAgICAgICAgcmVnaXN0ZXJDb2xvclBpY2tlcigpXG5cbiAgICBzZXR0aW5nc0NoYW5nZUVtaXR0ZXIub24oXCJlbmFibGVDb2xvclBpY2tlclwiLCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVnaXN0ZXJDb2xvclBpY2tlcigpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVucmVnaXN0ZXJDb2xvclBpY2tlcigpXG4gICAgfSlcblxuICAgIGdsb2JhbFNob3J0Y3V0LnJlZ2lzdGVyKFwic3VwZXIrY29udHJvbCtiXCIsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJoZWxsbz9cIilcbiAgICAgICAgaWYgKCFjbGlwYm9hcmRXaW5kb3cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYW55b25lP1wiKVxuICAgICAgICAgICAgY3JlYXRlQ2xpcGJvYXJkV2luZG93KClcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpbml0TWVzc2FnZUhhbmRsZXJzKClcbiAgICBpcGNNYWluLm9uKFwiY2xpcGJvYXJkOnBhc3RlXCIsIChldiwgdGV4dCkgPT4ge1xuICAgICAgICBpZ25vcmVTaW5nbGVDb3B5ID0gdHJ1ZVxuICAgICAgICBjbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpXG4gICAgfSlcblxuICAgIC8vIG1ha2Ugc3VyZSB3aW5kb3cgYXJlIHNob3duIHdoZW4gUmVhY3QgaGFzIHJlbmRlcmVkXG4gICAgLy8gaG93IGl0IHdvcmtzOiBldmVyeSB3aW5kb3cgaGFzIGEgd2ViY29udGVudHMgaWQsXG4gICAgLy8gdGhlIHNhbWUgd2ViY29udGVudHMgaWQgaXMgaW4gZXZlcnkgZXZlbnQgZW1pdHRlZCBieSB0aGUgd2luZG93XG4gICAgLy8gc28gd2Ugc2hvdyB0aGUgd2luZG93IGJ5IGZpbmRpbmcgaXQgaW4gYSBkaWN0aW9uYXJ5XG4gICAgaXBjTWFpbi5vbihcInJlbmRlcjpyZWFkeVRvU2hvd1wiLCAoZXYpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gd2luZG93c0J5V2ViY29udGVudHNJZFtldi5zZW5kZXIuaWRdXG4gICAgICAgIHdpbmRvdy5zaG93KClcbiAgICB9KVxuXG4gICAgaWYgKCFpc0xvZ2luKCkpIHtcblxuICAgICAgICBjcmVhdGVNYWluV2luZG93KClcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgb25SZWFkeSIsImltcG9ydCB7IEF6dXJlU0FTQ3JlZGVudGlhbCwgVGFibGVDbGllbnQsIG9kYXRhIH0gZnJvbSBcIkBhenVyZS9kYXRhLXRhYmxlc1wiXHJcbmltcG9ydCB7IGdldFNldHRpbmdWYWx1ZSB9IGZyb20gXCIuL3NldHRpbmdzXCJcclxuaW1wb3J0IGNsaXBib2FyZExpc3RlbmVyIGZyb20gJ2NsaXBib2FyZC1ldmVudCdcclxuaW1wb3J0IHsgaXBjTWFpbiB9IGZyb20gXCJlbGVjdHJvblwiXHJcblxyXG5jb25zdCBnZXRUYWJsZUNsaWVudCA9ICgpID0+IHtcclxuICAgIGNvbnN0IGFjY291bnQgPSBnZXRTZXR0aW5nVmFsdWUoXCJhenVyZVN0b3JhZ2VBY2NvdW50XCIpXHJcbiAgICBjb25zdCBTQVNUb2tlbiA9IGdldFNldHRpbmdWYWx1ZShcImF6dXJlU0FTVG9rZW5cIilcclxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldFNldHRpbmdWYWx1ZShcImF6dXJlVGFibGVOYW1lXCIpXHJcbiAgICByZXR1cm4gbmV3IFRhYmxlQ2xpZW50KFxyXG4gICAgICAgIGBodHRwczovLyR7YWNjb3VudH0udGFibGUuY29yZS53aW5kb3dzLm5ldGAsXHJcbiAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgIG5ldyBBenVyZVNBU0NyZWRlbnRpYWwoU0FTVG9rZW4pXHJcbiAgICApXHJcblxyXG59XHJcblxyXG5jb25zdCBzdGFydENsaXBib2FyZExpc3RlbmVyID0gKGNhbGxiYWNrKSA9PiB7XHJcbiAgICBjbGlwYm9hcmRMaXN0ZW5lci5vbignY2hhbmdlJywgY2FsbGJhY2spXHJcbiAgICBjbGlwYm9hcmRMaXN0ZW5lci5zdGFydExpc3RlbmluZygpXHJcbn1cclxuXHJcbmNvbnN0IHN0b3BDbGlwYm9hcmRMaXN0ZW5lciA9ICgpID0+IHtcclxuICAgIGNsaXBib2FyZExpc3RlbmVyLnJlbW92ZUFsbExpc3RlbmVycygpXHJcbiAgICBjbGlwYm9hcmRMaXN0ZW5lci5zdG9wTGlzdGVuaW5nKClcclxufVxyXG5cclxuXHJcbmNvbnN0IGZldGNoQ2xpcHMgPSBhc3luYyAoZmlsdGVyKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gW11cclxuICAgIGNvbnN0IHRhYmxlQ2xpZW50ID0gZ2V0VGFibGVDbGllbnQoKVxyXG4gICAgY29uc3QgZGF5cyA9IGZpbHRlciA9PSBcInRvZGF5XCIgPyAxIDpcclxuICAgICAgICBmaWx0ZXIgPT0gXCJ0aGlzIHdlZWtcIiA/IDcgOlxyXG4gICAgICAgICAgICBmaWx0ZXIgPT0gXCJ0aGlzIG1vbnRoXCIgPyAzMCA6IDEwMDAwMFxyXG4gICAgY29uc3QgZmlsdGVyRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkgLy8gMSBkYXlzIGFnb1xyXG4gICAgZm9yIGF3YWl0IChjb25zdCBlbnRpdHkgb2YgdGFibGVDbGllbnQubGlzdEVudGl0aWVzKHtcclxuICAgICAgICBxdWVyeU9wdGlvbnM6IHtcclxuICAgICAgICAgICAgZmlsdGVyOiBvZGF0YWBUaW1lc3RhbXAgZ2UgJHtmaWx0ZXJEYXRlfWAsXHJcbiAgICAgICAgfVxyXG4gICAgfSkpIHtcclxuICAgICAgICBkYXRhLnB1c2goe1xyXG4gICAgICAgICAgICBkYXRlOiBlbnRpdHkudGltZXN0YW1wLFxyXG4gICAgICAgICAgICBpZDogZW50aXR5LnJvd0tleSxcclxuICAgICAgICAgICAgc291cmNlOiBlbnRpdHkucGFydGl0aW9uS2V5LFxyXG4gICAgICAgICAgICB0ZXh0OiBlbnRpdHkudGV4dFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGEuc29ydCgoYSwgYikgPT4gYS5kYXRlID4gYi5kYXRlID8gLTEgOiAxKVxyXG59XHJcblxyXG5pcGNNYWluLmhhbmRsZSgnY2xpcGJvYXJkOmZldGNoQ2xpcHMnLCBhc3luYyAoZXYsIGZpbHRlcikgPT4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IGZldGNoQ2xpcHMoZmlsdGVyKVxyXG59KVxyXG5cclxuZXhwb3J0IHsgZ2V0VGFibGVDbGllbnQsIHN0YXJ0Q2xpcGJvYXJkTGlzdGVuZXIsIHN0b3BDbGlwYm9hcmRMaXN0ZW5lciB9IiwiaW1wb3J0IHsgaGFuZGxlQ29tbWFuZCB9IGZyb20gJy4uL2NvbW1vbi91dGlscydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChzc2lkOiBzdHJpbmcpID0+IHtcclxuXHRjb25zdCBjbWQgPSAnbmV0c2gnXHJcblx0Y29uc3QgYXJncyA9IFsnd2xhbicsICdzaG93JywgJ3Byb2ZpbGUnLCBgbmFtZT0ke3NzaWR9YCwgJ2tleT1jbGVhciddXHJcblxyXG5cdGNvbnN0IHN0ZG91dCA9IGF3YWl0IGhhbmRsZUNvbW1hbmQoY21kLCBhcmdzKSBhcyBzdHJpbmdcclxuXHRsZXQgcmV0XHJcblxyXG5cdHJldCA9IC9eXFxzKkNvbnRlbnV0byBjaGlhdmVcXHMqOiAoLispXFxzKiQvZ20uZXhlYyhzdGRvdXQpXHJcblx0cmV0ID0gcmV0ICYmIHJldC5sZW5ndGggPyByZXRbMV0gOiBudWxsXHJcblxyXG5cdGlmICghcmV0KSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgcGFzc3dvcmQnKVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJldCBhcyBzdHJpbmdcclxufVxyXG4iLCJpbXBvcnQgeyBoYW5kbGVDb21tYW5kIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKCkgPT4ge1xyXG5cdGNvbnN0IGNtZCA9ICduZXRzaCdcclxuXHRjb25zdCBhcmdzID0gWyd3bGFuJywgJ3Nob3cnLCAnaW50ZXJmYWNlJ11cclxuXHJcblx0Y29uc3Qgc3Rkb3V0ID0gYXdhaXQgaGFuZGxlQ29tbWFuZChjbWQsIGFyZ3MpXHJcblx0bGV0IHJldFxyXG5cclxuXHRyZXQgPSAvXlxccypTU0lEXFxzKjogKC4rKVxccyokL2dtLmV4ZWMoc3Rkb3V0KVxyXG5cdHJldCA9IHJldCAmJiByZXQubGVuZ3RoID8gcmV0WzFdIDogbnVsbFxyXG5cclxuXHRpZiAoIXJldCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFNTSUQnKVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJldCBhcyBzdHJpbmdcclxufSIsImltcG9ydCBzdWRvIGZyb20gJ3N1ZG8tcHJvbXB0J1xyXG5jb25zdCBvblN0cmluZyA9IFwiQXV0b1wiXHJcbmNvbnN0IG9mZlN0cmluZyA9IFwiT2ZmXCJcclxuXHJcbmNvbnN0IHNldEh5cGVydmlzb3IgPSAoZW5hYmxlZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgY29uc3QgbGF1bmNoVHlwZSA9IGVuYWJsZWQgPyBvblN0cmluZyA6IG9mZlN0cmluZ1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXMsIHJlaikgPT4ge1xyXG4gICAgICAgIHN1ZG8uZXhlYyhgYmNkZWRpdCAvc2V0IGh5cGVydmlzb3JsYXVuY2h0eXBlICR7bGF1bmNoVHlwZX1gLFxyXG4gICAgICAgICAgICB7IG5hbWU6IFwibGIgdG9vbGtpdFwiIH0sXHJcbiAgICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICByZXMoKVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlaihlcnJvcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIClcclxuICAgIH0pXHJcbn1cclxuXHJcbmNvbnN0IGdldEh5cGVydmlzb3IgPSAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XHJcbiAgICAgICAgc3Vkby5leGVjKGBiY2RlZGl0IC9lbnVtYCxcclxuICAgICAgICAgICAgeyBuYW1lOiBcImxiIHRvb2xraXRcIiB9LFxyXG4gICAgICAgICAgICAoZXJyb3IsIHN0ZG91dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSAvXlxccypoeXBlcnZpc29ybGF1bmNodHlwZVxccyogKC4rKVxccyokL2dtLmV4ZWMoc3Rkb3V0LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzKHJldFsxXSA9PSBvblN0cmluZyA/IHRydWUgOiBmYWxzZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZWooZXJyb3IpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApXHJcbiAgICB9KVxyXG59XHJcblxyXG5leHBvcnQgeyBzZXRIeXBlcnZpc29yLCBnZXRIeXBlcnZpc29yIH0iLCJpbXBvcnQgeyBhcHAgfSBmcm9tIFwiZWxlY3Ryb25cIlxyXG5cclxuY29uc3QgYXRMb2dpbkZsYWcgPSBcIi0tbG9naW5cIlxyXG5cclxuY29uc3QgaXNMb2dpbiA9ICgpID0+IHByb2Nlc3MuYXJndi5pbmNsdWRlcyhhdExvZ2luRmxhZylcclxuXHJcbmNvbnN0IHJlZ2lzdGVyQXRMb2dpbiA9ICgpID0+IHtcclxuICAgIGFwcC5zZXRMb2dpbkl0ZW1TZXR0aW5ncyh7IG9wZW5BdExvZ2luOiB0cnVlLCBhcmdzOiBbYXRMb2dpbkZsYWddIH0pXHJcbn1cclxuXHJcbmNvbnN0IHVucmVnaXN0ZXJBdExvZ2luID0gKCkgPT4ge1xyXG4gICAgYXBwLnNldExvZ2luSXRlbVNldHRpbmdzKHsgb3BlbkF0TG9naW46IGZhbHNlIH0pXHJcbn1cclxuXHJcbmV4cG9ydCB7IGlzTG9naW4sIHJlZ2lzdGVyQXRMb2dpbiwgdW5yZWdpc3RlckF0TG9naW4gfSIsImltcG9ydCB7IGlwY01haW4sIGFwcCwgc2hlbGwgfSBmcm9tIFwiZWxlY3Ryb25cIlxyXG5pbXBvcnQgZ2V0V2lmaVBhc3N3b3JkIGZyb20gXCIuL2dldFdpZmlQYXNzd29yZFwiXHJcbmltcG9ydCBnZXRXaWZpU1NJRCBmcm9tIFwiLi9nZXRXaWZpU1NJRFwiXHJcbmltcG9ydCB7IGdldEh5cGVydmlzb3IsIHNldEh5cGVydmlzb3IgfSBmcm9tIFwiLi9oeXBlcnZpc29yXCJcclxuaW1wb3J0IHsgZ2V0U2V0dGluZ1ZhbHVlLCBzZXRTZXR0aW5nVmFsdWUgfSBmcm9tIFwiLi9zZXR0aW5nc1wiXHJcbmltcG9ydCB7IGdldEFzc2V0UGF0aCwgaGFuZGxlQ29tbWFuZCB9IGZyb20gXCIuLi9jb21tb24vdXRpbHNcIlxyXG5pbXBvcnQgc3VkbyBmcm9tICdzdWRvLXByb21wdCdcclxuaW1wb3J0IGVtcHR5VHJhc2ggZnJvbSBcImVtcHR5LXRyYXNoXCJcclxuXHJcbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcclxuICAgIGlwY01haW4uaGFuZGxlKCdjbWQ6ZmV0Y2hVcGRhdGVzJywgYXN5bmMgKCkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCBoYW5kbGVDb21tYW5kKFwid2luZ2V0XCIsIFtcInVwZ3JhZGVcIiwgXCItLWluY2x1ZGUtdW5rbm93blwiXSkgYXMgc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIHN0ZG91dC5zdWJzdHJpbmcoc3Rkb3V0LmluZGV4T2YoXCJOb21lXCIpKVxyXG5cclxuICAgIH0pXHJcblxyXG4gICAgaXBjTWFpbi5oYW5kbGUoJ2NtZDp1cGRhdGVQYWNrYWdlJywgYXN5bmMgKGV2LCBwYWNrYWdlTmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGhhbmRsZUNvbW1hbmQoXCJ3aW5nZXRcIiwgW1widXBncmFkZVwiLCBwYWNrYWdlTmFtZV0pXHJcbiAgICAgICAgcmV0dXJuIHN0ZG91dFxyXG5cclxuICAgIH0pXHJcblxyXG4gICAgaXBjTWFpbi5oYW5kbGUoJ2NtZDpyZXRyaWV2ZUh5cGVydmlzb3JTdGF0ZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0SHlwZXJ2aXNvcigpXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdjbWQ6ZXhlY3V0ZUh5cGVydmlzb3JDb21tYW5kJywgYXN5bmMgKGV2LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBzZXRIeXBlcnZpc29yKHZhbHVlKVxyXG4gICAgfSlcclxuXHJcbiAgICBpcGNNYWluLmhhbmRsZSgnc2V0dGluZ3M6Z2V0U2V0dGluZ1ZhbHVlJywgKGV2LCBzZXR0aW5nKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNldHRpbmdWYWx1ZShzZXR0aW5nKVxyXG4gICAgfSlcclxuXHJcbiAgICBpcGNNYWluLmhhbmRsZSgnc2V0dGluZ3M6c2V0U2V0dGluZ1ZhbHVlJywgKGV2LCBzZXR0aW5nLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBzZXRTZXR0aW5nVmFsdWUoc2V0dGluZywgdmFsdWUpXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdmczphcHBHZXRQYXRoJywgYXN5bmMgKGV2LCBuYW1lKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGFwcC5nZXRQYXRoKG5hbWUpXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICBpcGNNYWluLmhhbmRsZSgnZnM6Y2FsY3VsYXRlRm9sZGVyU2l6ZScsIGFzeW5jIChldiwgcGF0aCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcclxuICAgICAgICAgICAgc3Vkby5leGVjKGBwb3dlcnNoZWxsIC1ub3Byb2ZpbGUgLWNvbW1hbmQgXCIobHMgJHtwYXRofSAtciB8IG1lYXN1cmUgLXN1bSBMZW5ndGgpLlN1bVwiYCxcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogXCJsYnRvb2xraXRcIiB9LFxyXG4gICAgICAgICAgICAgICAgKGVycm9yLCBzdGRvdXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlaihlcnJvci5tZXNzYWdlKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXIgPSAoTnVtYmVyLnBhcnNlSW50KHN0ZG91dC50b1N0cmluZygpKSAvIDFfMDAwXzAwMClcclxuICAgICAgICAgICAgICAgICAgICByZXMoTnVtYmVyLmlzTmFOKG51bWJlcikgPyAwIDogbnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBpcGNNYWluLmhhbmRsZSgnZnM6Z2V0RW52aXJvbm1lbnRWYXJpYWJsZScsIGFzeW5jIChldiwgdmFyaWFibGUpID0+IHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbdmFyaWFibGVdXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdmczpkZWxldGVGb2xkZXInLCBhc3luYyAoZXYsIHBhdGgpID0+IHtcclxuXHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcmVjeWNsZSBiaW46IGl0J3Mgbm90IGEgcmVhbCBmb2xkZXJcclxuICAgICAgICBpZiAocGF0aCA9PSBcInNoZWxsOlJlY3ljbGVCaW5Gb2xkZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlUcmFzaCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlcywgcmVqKSA9PiB7XHJcbiAgICAgICAgICAgIHN1ZG8uZXhlYyhgcG93ZXJzaGVsbCAtbm9wcm9maWxlIC1jb21tYW5kIFwiR2V0LUNoaWxkSXRlbSAke3BhdGh9IHwgUmVtb3ZlLUl0ZW0g4oCTcmVjdXJzZSAtRm9yY2VcImAsXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6IFwibGJ0b29sa2l0XCIgfSxcclxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqKGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzKClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcblxyXG4gICAgaXBjTWFpbi5vbihcImZzOm9wZW5Gb2xkZXJcIiwgYXN5bmMgKGV2LCBwYXRoKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgdGhlIHJlY3ljbGUgYmluOiBpdCdzIG5vdCBhIHJlYWwgZm9sZGVyXHJcbiAgICAgICAgaWYgKHBhdGggPT0gXCJzaGVsbDpSZWN5Y2xlQmluRm9sZGVyXCIpIHtcclxuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQ29tbWFuZChcImV4cGxvcmVyXCIsIFtcInNoZWxsOlJlY3ljbGVCaW5Gb2xkZXJcIl0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzaGVsbC5zaG93SXRlbUluRm9sZGVyKHBhdGgpXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCd3aWZpOnJldHJpZXZlQ29ubmVjdGlvbkRldGFpbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3NpZCA9IGF3YWl0IGdldFdpZmlTU0lEKClcclxuICAgICAgICBjb25zdCBwYXNzd29yZCA9IGF3YWl0IGdldFdpZmlQYXNzd29yZChzc2lkKVxyXG5cclxuICAgICAgICByZXR1cm4geyBzc2lkLCBwYXNzd29yZCB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdkaXNwbGF5OmN1cnJlbnRSZWZyZXNoUmF0ZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCBoYW5kbGVDb21tYW5kKGdldEFzc2V0UGF0aChcImJpblxcXFxyZWZyZXNodG9vbFxcXFxyZWZyZXNodG9vbC5leGVcIiksIFtcImN1cnJlbnRcIl0pXHJcbiAgICAgICAgcmV0dXJuIHN0ZG91dC5yZXBsYWNlKFwiXFxyXFxuXCIsIFwiXCIpXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdkaXNwbGF5Omxpc3RSZWZyZXNoUmF0ZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgaGFuZGxlQ29tbWFuZChnZXRBc3NldFBhdGgoXCJiaW5cXFxccmVmcmVzaHRvb2xcXFxccmVmcmVzaHRvb2wuZXhlXCIpLCBbXCJsaXN0XCJdKVxyXG4gICAgICAgIHJldHVybiBzdGRvdXQuc3BsaXQoXCJcXHJcXG5cIikuZmlsdGVyKGVsID0+IGVsICE9IFwiXCIpXHJcbiAgICB9KVxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdkaXNwbGF5OnNldFJlZnJlc2hSYXRlJywgYXN5bmMgKGV2LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGhhbmRsZUNvbW1hbmQoZ2V0QXNzZXRQYXRoKFwiYmluXFxcXHJlZnJlc2h0b29sXFxcXHJlZnJlc2h0b29sLmV4ZVwiKSwgW1wiY2hhbmdlXCIsIHZhbHVlXSlcclxuICAgIH0pXHJcblxyXG5cclxuICAgIGlwY01haW4uaGFuZGxlKCdhcHA6Z2V0VmVyc2lvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXR1cm4gYXBwLmdldFZlcnNpb24oKVxyXG4gICAgfSlcclxuXHJcbn0iLCJpbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbidcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xyXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ3N0cmVhbSdcclxuaW1wb3J0IHsgRGVmYXVsdFZhbHVlcywgU2V0dGluZ3MgfSBmcm9tIFwiLi4vY29tbW9uL1NldHRpbmdzSXRlbXNcIlxyXG5cclxuY29uc3Qgc2V0dGluZ3NGaWxlTmFtZSA9IFwic2V0dGluZ3MuanNvblwiXHJcblxyXG5jb25zdCBzZXR0aW5nc0ZpbGVQYXRoID0gcGF0aC5qb2luKGFwcC5nZXRQYXRoKFwidXNlckRhdGFcIiksIHNldHRpbmdzRmlsZU5hbWUpXHJcblxyXG5jb25zdCBmaWxlID0gZnMucmVhZEZpbGVTeW5jKHNldHRpbmdzRmlsZVBhdGgsIHsgZmxhZzogXCJhK1wiIH0pXHJcbmxldCBkYXRhOiBTZXR0aW5nc1xyXG5cclxudHJ5IHtcclxuICAgIGRhdGEgPSBKU09OLnBhcnNlKGZpbGUudG9TdHJpbmcoKSkgYXMgU2V0dGluZ3NcclxufSBjYXRjaCAoZSkge1xyXG4gICAgZGF0YSA9IHsgLi4uRGVmYXVsdFZhbHVlcyB9XHJcbiAgICBmcy53cml0ZUZpbGVTeW5jKHNldHRpbmdzRmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxyXG59XHJcblxyXG50eXBlIFNldHRpbmdzRXZlbnRFbWl0dGVyID0ge1xyXG4gICAgb246IChrZXk6IGtleW9mIFNldHRpbmdzLCBjYWxsYmFjazogKHZhbHVlOiBhbnkpID0+IHZvaWQpID0+IHZvaWRcclxuICAgIGVtaXQ6IChrZXk6IGtleW9mIFNldHRpbmdzLCB2YWx1ZTogYW55KSA9PiB2b2lkXHJcbn1cclxuXHJcbmNvbnN0IHNldHRpbmdzQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKSBhcyBTZXR0aW5nc0V2ZW50RW1pdHRlclxyXG5cclxuY29uc3QgZ2V0U2V0dGluZ1ZhbHVlID0gPFQgZXh0ZW5kcyBrZXlvZiBTZXR0aW5ncz4oc2V0dGluZzogVCk6IFNldHRpbmdzW1RdID0+IGRhdGFbc2V0dGluZ11cclxuXHJcbmNvbnN0IHNldFNldHRpbmdWYWx1ZSA9IDxUIGV4dGVuZHMga2V5b2YgU2V0dGluZ3M+KHNldHRpbmc6IFQsIHZhbHVlOiBTZXR0aW5nc1tUXSkgPT4ge1xyXG4gICAgZGF0YVtzZXR0aW5nXSA9IHZhbHVlXHJcbiAgICBmcy53cml0ZUZpbGVTeW5jKHNldHRpbmdzRmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxyXG4gICAgc2V0dGluZ3NDaGFuZ2VFbWl0dGVyLmVtaXQoc2V0dGluZywgdmFsdWUpXHJcbn1cclxuXHJcbmV4cG9ydCB7IGdldFNldHRpbmdWYWx1ZSwgc2V0U2V0dGluZ1ZhbHVlLCBzZXR0aW5nc0NoYW5nZUVtaXR0ZXIgfVxyXG4iLCJpbXBvcnQgeyBUcmF5LCBNZW51LCBhcHAgfSBmcm9tIFwiZWxlY3Ryb25cIlxyXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiXHJcbmltcG9ydCByb2JvdCBmcm9tIFwicm9ib3Rqc1wiXHJcblxyXG5sZXQgbmV4dDogVHJheVxyXG5cclxubGV0IHByZXY6IFRyYXlcclxuXHJcbmxldCBwbGF5UGF1c2U6IFRyYXlcclxuXHJcbmxldCBtYWluSWNvbjogVHJheVxyXG5cclxuY29uc3QgY3JlYXRlTWVkaWFUcmF5cyA9ICgpID0+IHtcclxuICAgIG5leHQgPSBuZXcgVHJheShnZXRBc3NldFBhdGgoXCJuZXh0Lmljb1wiKSlcclxuICAgIG5leHQuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgcm9ib3Qua2V5VGFwKFwiYXVkaW9fbmV4dFwiKVxyXG4gICAgfSlcclxuXHJcbiAgICBwcmV2ID0gbmV3IFRyYXkoZ2V0QXNzZXRQYXRoKFwiYmFjay5pY29cIikpXHJcbiAgICBwcmV2LmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIHJvYm90LmtleVRhcChcImF1ZGlvX3ByZXZcIilcclxuICAgIH0pXHJcblxyXG4gICAgcGxheVBhdXNlID0gbmV3IFRyYXkoZ2V0QXNzZXRQYXRoKFwicGxheS5pY29cIikpXHJcbiAgICBwbGF5UGF1c2UuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgcm9ib3Qua2V5VGFwKFwiYXVkaW9fcGxheVwiKVxyXG4gICAgfSlcclxufVxyXG5cclxuY29uc3QgZGVzdHJveU1lZGlhVHJheXMgPSAoKSA9PiB7XHJcbiAgICBuZXh0LmRlc3Ryb3koKVxyXG4gICAgcHJldi5kZXN0cm95KClcclxuICAgIHBsYXlQYXVzZS5kZXN0cm95KClcclxufVxyXG5cclxuY29uc3QgUkVTT1VSQ0VTX1BBVEggPSBhcHAuaXNQYWNrYWdlZFxyXG4gICAgPyBwYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCAnYXNzZXRzJylcclxuICAgIDogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uLy4uL2Fzc2V0cycpXHJcblxyXG5jb25zdCBnZXRBc3NldFBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+IHtcclxuICAgIHJldHVybiBwYXRoLmpvaW4oUkVTT1VSQ0VTX1BBVEgsIC4uLnBhdGhzKVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVNYWluVHJheSA9IChzaG93Q2FsbGJhY2ssIHF1aXRDYWxsYmFjaykgPT4ge1xyXG5cclxuXHJcbiAgICBtYWluSWNvbiA9IG5ldyBUcmF5KGdldEFzc2V0UGF0aChcImZhdmljb24uaWNvXCIpKVxyXG4gICAgbWFpbkljb24uYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgc2hvd0NhbGxiYWNrKClcclxuICAgIH0pXHJcblxyXG4gICAgbWFpbkljb24uc2V0Q29udGV4dE1lbnUoTWVudS5idWlsZEZyb21UZW1wbGF0ZShbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogJ1Nob3cnLFxyXG4gICAgICAgICAgICBjbGljazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2hvd0NhbGxiYWNrKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogJ1F1aXQnLFxyXG4gICAgICAgICAgICBjbGljazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVpdENhbGxiYWNrKCkgLy8gYWN0dWFsbHkgcXVpdCB0aGUgYXBwLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIF0pKVxyXG59XHJcblxyXG5leHBvcnQgeyBjcmVhdGVNZWRpYVRyYXlzLCBkZXN0cm95TWVkaWFUcmF5cywgY3JlYXRlTWFpblRyYXkgfSIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ29zLWhvbWVkaXInKSgpO1xuIiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcblxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCJjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInIHx8XG4gICAgcHJvY2Vzcy5lbnYuT1NUWVBFID09PSAnY3lnd2luJyB8fFxuICAgIHByb2Nlc3MuZW52Lk9TVFlQRSA9PT0gJ21zeXMnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IENPTE9OID0gaXNXaW5kb3dzID8gJzsnIDogJzonXG5jb25zdCBpc2V4ZSA9IHJlcXVpcmUoJ2lzZXhlJylcblxuY29uc3QgZ2V0Tm90Rm91bmRFcnJvciA9IChjbWQpID0+XG4gIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBub3QgZm91bmQ6ICR7Y21kfWApLCB7IGNvZGU6ICdFTk9FTlQnIH0pXG5cbmNvbnN0IGdldFBhdGhJbmZvID0gKGNtZCwgb3B0KSA9PiB7XG4gIGNvbnN0IGNvbG9uID0gb3B0LmNvbG9uIHx8IENPTE9OXG5cbiAgLy8gSWYgaXQgaGFzIGEgc2xhc2gsIHRoZW4gd2UgZG9uJ3QgYm90aGVyIHNlYXJjaGluZyB0aGUgcGF0aGVudi5cbiAgLy8ganVzdCBjaGVjayB0aGUgZmlsZSBpdHNlbGYsIGFuZCB0aGF0J3MgaXQuXG4gIGNvbnN0IHBhdGhFbnYgPSBjbWQubWF0Y2goL1xcLy8pIHx8IGlzV2luZG93cyAmJiBjbWQubWF0Y2goL1xcXFwvKSA/IFsnJ11cbiAgICA6IChcbiAgICAgIFtcbiAgICAgICAgLy8gd2luZG93cyBhbHdheXMgY2hlY2tzIHRoZSBjd2QgZmlyc3RcbiAgICAgICAgLi4uKGlzV2luZG93cyA/IFtwcm9jZXNzLmN3ZCgpXSA6IFtdKSxcbiAgICAgICAgLi4uKG9wdC5wYXRoIHx8IHByb2Nlc3MuZW52LlBBVEggfHxcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdmVyeSB1bnVzdWFsICovICcnKS5zcGxpdChjb2xvbiksXG4gICAgICBdXG4gICAgKVxuICBjb25zdCBwYXRoRXh0RXhlID0gaXNXaW5kb3dzXG4gICAgPyBvcHQucGF0aEV4dCB8fCBwcm9jZXNzLmVudi5QQVRIRVhUIHx8ICcuRVhFOy5DTUQ7LkJBVDsuQ09NJ1xuICAgIDogJydcbiAgY29uc3QgcGF0aEV4dCA9IGlzV2luZG93cyA/IHBhdGhFeHRFeGUuc3BsaXQoY29sb24pIDogWycnXVxuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICBpZiAoY21kLmluZGV4T2YoJy4nKSAhPT0gLTEgJiYgcGF0aEV4dFswXSAhPT0gJycpXG4gICAgICBwYXRoRXh0LnVuc2hpZnQoJycpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhFbnYsXG4gICAgcGF0aEV4dCxcbiAgICBwYXRoRXh0RXhlLFxuICB9XG59XG5cbmNvbnN0IHdoaWNoID0gKGNtZCwgb3B0LCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0XG4gICAgb3B0ID0ge31cbiAgfVxuICBpZiAoIW9wdClcbiAgICBvcHQgPSB7fVxuXG4gIGNvbnN0IHsgcGF0aEVudiwgcGF0aEV4dCwgcGF0aEV4dEV4ZSB9ID0gZ2V0UGF0aEluZm8oY21kLCBvcHQpXG4gIGNvbnN0IGZvdW5kID0gW11cblxuICBjb25zdCBzdGVwID0gaSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGkgPT09IHBhdGhFbnYubGVuZ3RoKVxuICAgICAgcmV0dXJuIG9wdC5hbGwgJiYgZm91bmQubGVuZ3RoID8gcmVzb2x2ZShmb3VuZClcbiAgICAgICAgOiByZWplY3QoZ2V0Tm90Rm91bmRFcnJvcihjbWQpKVxuXG4gICAgY29uc3QgcHBSYXcgPSBwYXRoRW52W2ldXG4gICAgY29uc3QgcGF0aFBhcnQgPSAvXlwiLipcIiQvLnRlc3QocHBSYXcpID8gcHBSYXcuc2xpY2UoMSwgLTEpIDogcHBSYXdcblxuICAgIGNvbnN0IHBDbWQgPSBwYXRoLmpvaW4ocGF0aFBhcnQsIGNtZClcbiAgICBjb25zdCBwID0gIXBhdGhQYXJ0ICYmIC9eXFwuW1xcXFxcXC9dLy50ZXN0KGNtZCkgPyBjbWQuc2xpY2UoMCwgMikgKyBwQ21kXG4gICAgICA6IHBDbWRcblxuICAgIHJlc29sdmUoc3ViU3RlcChwLCBpLCAwKSlcbiAgfSlcblxuICBjb25zdCBzdWJTdGVwID0gKHAsIGksIGlpKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGlpID09PSBwYXRoRXh0Lmxlbmd0aClcbiAgICAgIHJldHVybiByZXNvbHZlKHN0ZXAoaSArIDEpKVxuICAgIGNvbnN0IGV4dCA9IHBhdGhFeHRbaWldXG4gICAgaXNleGUocCArIGV4dCwgeyBwYXRoRXh0OiBwYXRoRXh0RXhlIH0sIChlciwgaXMpID0+IHtcbiAgICAgIGlmICghZXIgJiYgaXMpIHtcbiAgICAgICAgaWYgKG9wdC5hbGwpXG4gICAgICAgICAgZm91bmQucHVzaChwICsgZXh0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocCArIGV4dClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlKHN1YlN0ZXAocCwgaSwgaWkgKyAxKSlcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBjYiA/IHN0ZXAoMCkudGhlbihyZXMgPT4gY2IobnVsbCwgcmVzKSwgY2IpIDogc3RlcCgwKVxufVxuXG5jb25zdCB3aGljaFN5bmMgPSAoY21kLCBvcHQpID0+IHtcbiAgb3B0ID0gb3B0IHx8IHt9XG5cbiAgY29uc3QgeyBwYXRoRW52LCBwYXRoRXh0LCBwYXRoRXh0RXhlIH0gPSBnZXRQYXRoSW5mbyhjbWQsIG9wdClcbiAgY29uc3QgZm91bmQgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEVudi5sZW5ndGg7IGkgKyspIHtcbiAgICBjb25zdCBwcFJhdyA9IHBhdGhFbnZbaV1cbiAgICBjb25zdCBwYXRoUGFydCA9IC9eXCIuKlwiJC8udGVzdChwcFJhdykgPyBwcFJhdy5zbGljZSgxLCAtMSkgOiBwcFJhd1xuXG4gICAgY29uc3QgcENtZCA9IHBhdGguam9pbihwYXRoUGFydCwgY21kKVxuICAgIGNvbnN0IHAgPSAhcGF0aFBhcnQgJiYgL15cXC5bXFxcXFxcL10vLnRlc3QoY21kKSA/IGNtZC5zbGljZSgwLCAyKSArIHBDbWRcbiAgICAgIDogcENtZFxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoRXh0Lmxlbmd0aDsgaiArKykge1xuICAgICAgY29uc3QgY3VyID0gcCArIHBhdGhFeHRbal1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlzID0gaXNleGUuc3luYyhjdXIsIHsgcGF0aEV4dDogcGF0aEV4dEV4ZSB9KVxuICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICBpZiAob3B0LmFsbClcbiAgICAgICAgICAgIGZvdW5kLnB1c2goY3VyKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjdXJcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdC5hbGwgJiYgZm91bmQubGVuZ3RoKVxuICAgIHJldHVybiBmb3VuZFxuXG4gIGlmIChvcHQubm90aHJvdylcbiAgICByZXR1cm4gbnVsbFxuXG4gIHRocm93IGdldE5vdEZvdW5kRXJyb3IoY21kKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdoaWNoXG53aGljaC5zeW5jID0gd2hpY2hTeW5jXG4iLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IGhvbWVEaXJlY3RvcnkgPSBvcy5ob21lZGlyKCk7XG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmV4cG9ydHMuZGF0YSA9IGVudi5YREdfREFUQV9IT01FIHx8XG5cdChob21lRGlyZWN0b3J5ID8gcGF0aC5qb2luKGhvbWVEaXJlY3RvcnksICcubG9jYWwnLCAnc2hhcmUnKSA6IHVuZGVmaW5lZCk7XG5cbmV4cG9ydHMuY29uZmlnID0gZW52LlhER19DT05GSUdfSE9NRSB8fFxuXHQoaG9tZURpcmVjdG9yeSA/IHBhdGguam9pbihob21lRGlyZWN0b3J5LCAnLmNvbmZpZycpIDogdW5kZWZpbmVkKTtcblxuZXhwb3J0cy5jYWNoZSA9IGVudi5YREdfQ0FDSEVfSE9NRSB8fCAoaG9tZURpcmVjdG9yeSA/IHBhdGguam9pbihob21lRGlyZWN0b3J5LCAnLmNhY2hlJykgOiB1bmRlZmluZWQpO1xuXG5leHBvcnRzLnJ1bnRpbWUgPSBlbnYuWERHX1JVTlRJTUVfRElSIHx8IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5kYXRhRGlycyA9IChlbnYuWERHX0RBVEFfRElSUyB8fCAnL3Vzci9sb2NhbC9zaGFyZS86L3Vzci9zaGFyZS8nKS5zcGxpdCgnOicpO1xuXG5pZiAoZXhwb3J0cy5kYXRhKSB7XG5cdGV4cG9ydHMuZGF0YURpcnMudW5zaGlmdChleHBvcnRzLmRhdGEpO1xufVxuXG5leHBvcnRzLmNvbmZpZ0RpcnMgPSAoZW52LlhER19DT05GSUdfRElSUyB8fCAnL2V0Yy94ZGcnKS5zcGxpdCgnOicpO1xuXG5pZiAoZXhwb3J0cy5jb25maWcpIHtcblx0ZXhwb3J0cy5jb25maWdEaXJzLnVuc2hpZnQoZXhwb3J0cy5jb25maWcpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpLnByb21pc2VzO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGRmID0gcmVxdWlyZSgnQHNpbmRyZXNvcmh1cy9kZicpO1xuY29uc3QgbW91bnRQb2ludCA9IHJlcXVpcmUoJ21vdW50LXBvaW50Jyk7XG5jb25zdCB1c2VySG9tZSA9IHJlcXVpcmUoJ3VzZXItaG9tZScpO1xuY29uc3QgeGRnQmFzZWRpciA9IHJlcXVpcmUoJ3hkZy1iYXNlZGlyJyk7XG5cbmNvbnN0IGNoZWNrID0gYXN5bmMgZmlsZVBhdGggPT4ge1xuXHRjb25zdCB0b3B1aWQgPSBgJHtmaWxlUGF0aH0tJHtwcm9jZXNzLmdldHVpZCgpfWA7XG5cdGNvbnN0IHN0aWNreUJpdE1vZGUgPSAxNzQwNztcblxuXHR0cnkge1xuXHRcdGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoZmlsZVBhdGgpO1xuXG5cdFx0aWYgKHN0YXRzLmlzU3ltYm9saWNMaW5rKCkgfHwgc3RhdHMubW9kZSAhPT0gc3RpY2t5Qml0TW9kZSkge1xuXHRcdFx0cmV0dXJuIHRvcHVpZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aC5qb2luKGZpbGVQYXRoLCBTdHJpbmcocHJvY2Vzcy5nZXR1aWQoKSkpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChlcnJvci5jb2RlID09PSAnRU5PRU5UJykge1xuXHRcdFx0cmV0dXJuIHRvcHVpZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aC5qb2luKHhkZ0Jhc2VkaXIuZGF0YSwgJ1RyYXNoJyk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZmlsZVBhdGggPT4ge1xuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2xpbnV4Jykge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ09ubHkgTGludXggc3lzdGVtcyBhcmUgc3VwcG9ydGVkJykpO1xuXHR9XG5cblx0aWYgKCFmaWxlUGF0aCkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocGF0aC5qb2luKHhkZ0Jhc2VkaXIuZGF0YSwgJ1RyYXNoJykpO1xuXHR9XG5cblx0Y29uc3QgW2hvbWVNb3VudFBvaW50LCBmaWxlTW91bnRQb2ludF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0bW91bnRQb2ludCh1c2VySG9tZSksXG5cdFx0Ly8gSWdub3JlIGVycm9ycyBpbiBjYXNlIGBmaWxlYCBpcyBhIGRhbmdsaW5nIHN5bWxpbmtcblx0XHRtb3VudFBvaW50KGZpbGVQYXRoKS5jYXRjaCgoKSA9PiB7fSlcblx0XSk7XG5cblx0aWYgKCFmaWxlTW91bnRQb2ludCB8fCBmaWxlTW91bnRQb2ludCA9PT0gaG9tZU1vdW50UG9pbnQpIHtcblx0XHRyZXR1cm4gcGF0aC5qb2luKHhkZ0Jhc2VkaXIuZGF0YSwgJ1RyYXNoJyk7XG5cdH1cblxuXHRyZXR1cm4gY2hlY2socGF0aC5qb2luKGZpbGVNb3VudFBvaW50LCAnLlRyYXNoJykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuYWxsID0gYXN5bmMgKCkgPT4ge1xuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2xpbnV4Jykge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ09ubHkgTGludXggc3lzdGVtcyBhcmUgc3VwcG9ydGVkJykpO1xuXHR9XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKChhd2FpdCBkZigpKS5tYXAoZmlsZVN5c3RlbSA9PiB7XG5cdFx0aWYgKGZpbGVTeXN0ZW0ubW91bnRwb2ludCA9PT0gJy8nKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKHhkZ0Jhc2VkaXIuZGF0YSwgJ1RyYXNoJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoZWNrKHBhdGguam9pbihmaWxlU3lzdGVtLm1vdW50cG9pbnQsICcuVHJhc2gnKSk7XG5cdH0pKTtcbn07XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFlhbGxpc3QpIHtcbiAgWWFsbGlzdC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXI7IHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgICB5aWVsZCB3YWxrZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcblxuICByZXR1cm4gbmV4dFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLm5leHQgPSBoZWFkXG4gIGlmIChoZWFkKSB7XG4gICAgaGVhZC5wcmV2ID0gbm9kZVxuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZVxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2hOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUucHJldiA9IHRhaWxcbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlXG4gIH1cblxuICB0aGlzLnRhaWwgPSBub2RlXG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHVuc2hpZnQodGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMudGFpbC52YWx1ZVxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldlxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy5oZWFkLnZhbHVlXG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0XG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLmhlYWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZVJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy50YWlsXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldlxuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXlSZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBmcm9tOyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHRvOyBpKyssIHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4ubm9kZXMpIHtcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMVxuICB9XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHN0YXJ0OyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgdmFyIHJldCA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgJiYgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcilcbiAgfVxuICBpZiAod2Fsa2VyID09PSBudWxsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsXG4gIH1cblxuICBpZiAod2Fsa2VyICE9PSB0aGlzLmhlYWQgJiYgd2Fsa2VyICE9PSB0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIG5vZGVzW2ldKVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/XG4gICAgbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDpcbiAgICBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKVxuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWRcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkXG4gIH1cblxuICBzZWxmLmxlbmd0aCsrXG5cbiAgcmV0dXJuIGluc2VydGVkXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlKCcuL2l0ZXJhdG9yLmpzJykoWWFsbGlzdClcbn0gY2F0Y2ggKGVyKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpjaGlsZF9wcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6ZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpmcy9wcm9taXNlc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOnBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpwcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6dXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6dXRpbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0bHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JvYm90anNfXzsiLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xyXG5pbXBvcnQgeyBleGVjRmlsZSB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xyXG5pbXBvcnQge2ZpbGVVUkxUb1BhdGh9IGZyb20gJ25vZGU6dXJsJztcclxuY29uc3QgX19kaXJuYW1lID0gcGF0aC5kaXJuYW1lKGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKSlcclxuXHJcbmNsYXNzIENsaXBib2FyZEV2ZW50TGlzdGVuZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY2hpbGQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRMaXN0ZW5pbmcoKSB7XHJcblxyXG4gICAgY29uc3QgeyBwbGF0Zm9ybSB9ID0gcHJvY2VzcztcclxuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICB0aGlzLmNoaWxkID0gZXhlY0ZpbGUocGF0aC5qb2luKF9fZGlybmFtZSwncGxhdGZvcm0vY2xpcGJvYXJkLWV2ZW50LWhhbmRsZXItd2luMzIuZXhlJykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpIHtcclxuICAgICAgdGhpcy5jaGlsZCA9IGV4ZWNGaWxlKHBhdGguam9pbihfX2Rpcm5hbWUsJ3BsYXRmb3JtL2NsaXBib2FyZC1ldmVudC1oYW5kbGVyLWxpbnV4JykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XHJcbiAgICAgIHRoaXMuY2hpbGQgPSBleGVjRmlsZShwYXRoLmpvaW4oX19kaXJuYW1lLCdwbGF0Zm9ybS9jbGlwYm9hcmQtZXZlbnQtaGFuZGxlci1tYWMnKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhyb3cgJ05vdCB5ZXQgc3VwcG9ydGVkJztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNoaWxkLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChkYXRhLnRyaW0oKSA9PT0gJ0NMSVBCT0FSRF9DSEFOR0UnKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgc3RvcExpc3RlbmluZygpIHtcclxuICAgIGNvbnN0IHJlcyA9IHRoaXMuY2hpbGQua2lsbCgpO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBDbGlwYm9hcmRFdmVudExpc3RlbmVyKCk7XHJcblxyXG4vLyBTYW1wbGUgdXNhZ2VcclxuLypcclxuaW1wb3J0IGNsaXBib2FyZExpc3RlbmVyIGZyb20gJ2NsaXBib2FyZC1ldmVudCdcclxuXHJcbi8vIFRvIHN0YXJ0IGxpc3RlbmluZ1xyXG5jbGlwYm9hcmRMaXN0ZW5lci5zdGFydExpc3RlbmluZygpO1xyXG5cclxuY2xpcGJvYXJkTGlzdGVuZXIub24oJ2NoYW5nZScsICgpID0+IHtcclxuICBjb25zb2xlLmxvZygnQ2xpcGJvYXJkIGNoYW5nZWQnKTtcclxufSk7XHJcblxyXG4vLyBUbyBzdG9wIGxpc3RlbmluZ1xyXG5jbGlwYm9hcmRMaXN0ZW5lci5zdG9wTGlzdGVuaW5nKCk7XHJcbiovXHJcbiIsImltcG9ydCB7cHJvbWlzaWZ5fSBmcm9tICd1dGlsJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuY29uc3QgcmFuZG9tQnl0ZXNBc3luYyA9IHByb21pc2lmeShjcnlwdG8ucmFuZG9tQnl0ZXMpO1xuXG5jb25zdCB1cmxTYWZlQ2hhcmFjdGVycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OS0uX34nLnNwbGl0KCcnKTtcbmNvbnN0IG51bWVyaWNDaGFyYWN0ZXJzID0gJzAxMjM0NTY3ODknLnNwbGl0KCcnKTtcbmNvbnN0IGRpc3Rpbmd1aXNoYWJsZUNoYXJhY3RlcnMgPSAnQ0RFSEtNUFJUVVdYWTAxMjQ1OCcuc3BsaXQoJycpO1xuY29uc3QgYXNjaWlQcmludGFibGVDaGFyYWN0ZXJzID0gJyFcIiMkJSZcXCcoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4nLnNwbGl0KCcnKTtcbmNvbnN0IGFscGhhbnVtZXJpY0NoYXJhY3RlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknLnNwbGl0KCcnKTtcblxuY29uc3QgZ2VuZXJhdGVGb3JDdXN0b21DaGFyYWN0ZXJzID0gKGxlbmd0aCwgY2hhcmFjdGVycykgPT4ge1xuXHQvLyBHZW5lcmF0aW5nIGVudHJvcHkgaXMgZmFzdGVyIHRoYW4gY29tcGxleCBtYXRoIG9wZXJhdGlvbnMsIHNvIHdlIHVzZSB0aGUgc2ltcGxlc3Qgd2F5XG5cdGNvbnN0IGNoYXJhY3RlckNvdW50ID0gY2hhcmFjdGVycy5sZW5ndGg7XG5cdGNvbnN0IG1heFZhbGlkU2VsZWN0b3IgPSAoTWF0aC5mbG9vcigweDEwMDAwIC8gY2hhcmFjdGVyQ291bnQpICogY2hhcmFjdGVyQ291bnQpIC0gMTsgLy8gVXNpbmcgdmFsdWVzIGFib3ZlIHRoaXMgd2lsbCBydWluIGRpc3RyaWJ1dGlvbiB3aGVuIHVzaW5nIG1vZHVsYXIgZGl2aXNpb25cblx0Y29uc3QgZW50cm9weUxlbmd0aCA9IDIgKiBNYXRoLmNlaWwoMS4xICogbGVuZ3RoKTsgLy8gR2VuZXJhdGluZyBhIGJpdCBtb3JlIHRoYW4gcmVxdWlyZWQgc28gY2hhbmNlcyB3ZSBuZWVkIG1vcmUgdGhhbiBvbmUgcGFzcyB3aWxsIGJlIHJlYWxseSBsb3dcblx0bGV0IHN0cmluZyA9ICcnO1xuXHRsZXQgc3RyaW5nTGVuZ3RoID0gMDtcblxuXHR3aGlsZSAoc3RyaW5nTGVuZ3RoIDwgbGVuZ3RoKSB7IC8vIEluIGNhc2Ugd2UgaGFkIG1hbnkgYmFkIHZhbHVlcywgd2hpY2ggbWF5IGhhcHBlbiBmb3IgY2hhcmFjdGVyIHNldHMgb2Ygc2l6ZSBhYm92ZSAweDgwMDAgYnV0IGNsb3NlIHRvIGl0XG5cdFx0Y29uc3QgZW50cm9weSA9IGNyeXB0by5yYW5kb21CeXRlcyhlbnRyb3B5TGVuZ3RoKTtcblx0XHRsZXQgZW50cm9weVBvc2l0aW9uID0gMDtcblxuXHRcdHdoaWxlIChlbnRyb3B5UG9zaXRpb24gPCBlbnRyb3B5TGVuZ3RoICYmIHN0cmluZ0xlbmd0aCA8IGxlbmd0aCkge1xuXHRcdFx0Y29uc3QgZW50cm9weVZhbHVlID0gZW50cm9weS5yZWFkVUludDE2TEUoZW50cm9weVBvc2l0aW9uKTtcblx0XHRcdGVudHJvcHlQb3NpdGlvbiArPSAyO1xuXHRcdFx0aWYgKGVudHJvcHlWYWx1ZSA+IG1heFZhbGlkU2VsZWN0b3IpIHsgLy8gU2tpcCB2YWx1ZXMgd2hpY2ggd2lsbCBydWluIGRpc3RyaWJ1dGlvbiB3aGVuIHVzaW5nIG1vZHVsYXIgZGl2aXNpb25cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHN0cmluZyArPSBjaGFyYWN0ZXJzW2VudHJvcHlWYWx1ZSAlIGNoYXJhY3RlckNvdW50XTtcblx0XHRcdHN0cmluZ0xlbmd0aCsrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG59O1xuXG5jb25zdCBnZW5lcmF0ZUZvckN1c3RvbUNoYXJhY3RlcnNBc3luYyA9IGFzeW5jIChsZW5ndGgsIGNoYXJhY3RlcnMpID0+IHtcblx0Ly8gR2VuZXJhdGluZyBlbnRyb3B5IGlzIGZhc3RlciB0aGFuIGNvbXBsZXggbWF0aCBvcGVyYXRpb25zLCBzbyB3ZSB1c2UgdGhlIHNpbXBsZXN0IHdheVxuXHRjb25zdCBjaGFyYWN0ZXJDb3VudCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuXHRjb25zdCBtYXhWYWxpZFNlbGVjdG9yID0gKE1hdGguZmxvb3IoMHgxMDAwMCAvIGNoYXJhY3RlckNvdW50KSAqIGNoYXJhY3RlckNvdW50KSAtIDE7IC8vIFVzaW5nIHZhbHVlcyBhYm92ZSB0aGlzIHdpbGwgcnVpbiBkaXN0cmlidXRpb24gd2hlbiB1c2luZyBtb2R1bGFyIGRpdmlzaW9uXG5cdGNvbnN0IGVudHJvcHlMZW5ndGggPSAyICogTWF0aC5jZWlsKDEuMSAqIGxlbmd0aCk7IC8vIEdlbmVyYXRpbmcgYSBiaXQgbW9yZSB0aGFuIHJlcXVpcmVkIHNvIGNoYW5jZXMgd2UgbmVlZCBtb3JlIHRoYW4gb25lIHBhc3Mgd2lsbCBiZSByZWFsbHkgbG93XG5cdGxldCBzdHJpbmcgPSAnJztcblx0bGV0IHN0cmluZ0xlbmd0aCA9IDA7XG5cblx0d2hpbGUgKHN0cmluZ0xlbmd0aCA8IGxlbmd0aCkgeyAvLyBJbiBjYXNlIHdlIGhhZCBtYW55IGJhZCB2YWx1ZXMsIHdoaWNoIG1heSBoYXBwZW4gZm9yIGNoYXJhY3RlciBzZXRzIG9mIHNpemUgYWJvdmUgMHg4MDAwIGJ1dCBjbG9zZSB0byBpdFxuXHRcdGNvbnN0IGVudHJvcHkgPSBhd2FpdCByYW5kb21CeXRlc0FzeW5jKGVudHJvcHlMZW5ndGgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRsZXQgZW50cm9weVBvc2l0aW9uID0gMDtcblxuXHRcdHdoaWxlIChlbnRyb3B5UG9zaXRpb24gPCBlbnRyb3B5TGVuZ3RoICYmIHN0cmluZ0xlbmd0aCA8IGxlbmd0aCkge1xuXHRcdFx0Y29uc3QgZW50cm9weVZhbHVlID0gZW50cm9weS5yZWFkVUludDE2TEUoZW50cm9weVBvc2l0aW9uKTtcblx0XHRcdGVudHJvcHlQb3NpdGlvbiArPSAyO1xuXHRcdFx0aWYgKGVudHJvcHlWYWx1ZSA+IG1heFZhbGlkU2VsZWN0b3IpIHsgLy8gU2tpcCB2YWx1ZXMgd2hpY2ggd2lsbCBydWluIGRpc3RyaWJ1dGlvbiB3aGVuIHVzaW5nIG1vZHVsYXIgZGl2aXNpb25cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHN0cmluZyArPSBjaGFyYWN0ZXJzW2VudHJvcHlWYWx1ZSAlIGNoYXJhY3RlckNvdW50XTtcblx0XHRcdHN0cmluZ0xlbmd0aCsrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVJhbmRvbUJ5dGVzID0gKGJ5dGVMZW5ndGgsIHR5cGUsIGxlbmd0aCkgPT4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpLnRvU3RyaW5nKHR5cGUpLnNsaWNlKDAsIGxlbmd0aCk7XG5cbmNvbnN0IGdlbmVyYXRlUmFuZG9tQnl0ZXNBc3luYyA9IGFzeW5jIChieXRlTGVuZ3RoLCB0eXBlLCBsZW5ndGgpID0+IHtcblx0Y29uc3QgYnVmZmVyID0gYXdhaXQgcmFuZG9tQnl0ZXNBc3luYyhieXRlTGVuZ3RoKTtcblx0cmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0eXBlKS5zbGljZSgwLCBsZW5ndGgpO1xufTtcblxuY29uc3QgYWxsb3dlZFR5cGVzID0gbmV3IFNldChbXG5cdHVuZGVmaW5lZCxcblx0J2hleCcsXG5cdCdiYXNlNjQnLFxuXHQndXJsLXNhZmUnLFxuXHQnbnVtZXJpYycsXG5cdCdkaXN0aW5ndWlzaGFibGUnLFxuXHQnYXNjaWktcHJpbnRhYmxlJyxcblx0J2FscGhhbnVtZXJpYydcbl0pO1xuXG5jb25zdCBjcmVhdGVHZW5lcmF0b3IgPSAoZ2VuZXJhdGVGb3JDdXN0b21DaGFyYWN0ZXJzLCBnZW5lcmF0ZVJhbmRvbUJ5dGVzKSA9PiAoe2xlbmd0aCwgdHlwZSwgY2hhcmFjdGVyc30pID0+IHtcblx0aWYgKCEobGVuZ3RoID49IDAgJiYgTnVtYmVyLmlzRmluaXRlKGxlbmd0aCkpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBgbGVuZ3RoYCB0byBiZSBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgbnVtYmVyJyk7XG5cdH1cblxuXHRpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIGNoYXJhY3RlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGVpdGhlciBgdHlwZWAgb3IgYGNoYXJhY3RlcnNgJyk7XG5cdH1cblxuXHRpZiAoY2hhcmFjdGVycyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjaGFyYWN0ZXJzICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBjaGFyYWN0ZXJzYCB0byBiZSBzdHJpbmcnKTtcblx0fVxuXG5cdGlmICghYWxsb3dlZFR5cGVzLmhhcyh0eXBlKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gdHlwZTogJHt0eXBlfWApO1xuXHR9XG5cblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBjaGFyYWN0ZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHR0eXBlID0gJ2hleCc7XG5cdH1cblxuXHRpZiAodHlwZSA9PT0gJ2hleCcgfHwgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBjaGFyYWN0ZXJzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0cmV0dXJuIGdlbmVyYXRlUmFuZG9tQnl0ZXMoTWF0aC5jZWlsKGxlbmd0aCAqIDAuNSksICdoZXgnLCBsZW5ndGgpOyAvLyBOZWVkIDAuNSBieXRlIGVudHJvcHkgcGVyIGNoYXJhY3RlclxuXHR9XG5cblx0aWYgKHR5cGUgPT09ICdiYXNlNjQnKSB7XG5cdFx0cmV0dXJuIGdlbmVyYXRlUmFuZG9tQnl0ZXMoTWF0aC5jZWlsKGxlbmd0aCAqIDAuNzUpLCAnYmFzZTY0JywgbGVuZ3RoKTsgLy8gTmVlZCAwLjc1IGJ5dGUgb2YgZW50cm9weSBwZXIgY2hhcmFjdGVyXG5cdH1cblxuXHRpZiAodHlwZSA9PT0gJ3VybC1zYWZlJykge1xuXHRcdHJldHVybiBnZW5lcmF0ZUZvckN1c3RvbUNoYXJhY3RlcnMobGVuZ3RoLCB1cmxTYWZlQ2hhcmFjdGVycyk7XG5cdH1cblxuXHRpZiAodHlwZSA9PT0gJ251bWVyaWMnKSB7XG5cdFx0cmV0dXJuIGdlbmVyYXRlRm9yQ3VzdG9tQ2hhcmFjdGVycyhsZW5ndGgsIG51bWVyaWNDaGFyYWN0ZXJzKTtcblx0fVxuXG5cdGlmICh0eXBlID09PSAnZGlzdGluZ3Vpc2hhYmxlJykge1xuXHRcdHJldHVybiBnZW5lcmF0ZUZvckN1c3RvbUNoYXJhY3RlcnMobGVuZ3RoLCBkaXN0aW5ndWlzaGFibGVDaGFyYWN0ZXJzKTtcblx0fVxuXG5cdGlmICh0eXBlID09PSAnYXNjaWktcHJpbnRhYmxlJykge1xuXHRcdHJldHVybiBnZW5lcmF0ZUZvckN1c3RvbUNoYXJhY3RlcnMobGVuZ3RoLCBhc2NpaVByaW50YWJsZUNoYXJhY3RlcnMpO1xuXHR9XG5cblx0aWYgKHR5cGUgPT09ICdhbHBoYW51bWVyaWMnKSB7XG5cdFx0cmV0dXJuIGdlbmVyYXRlRm9yQ3VzdG9tQ2hhcmFjdGVycyhsZW5ndGgsIGFscGhhbnVtZXJpY0NoYXJhY3RlcnMpO1xuXHR9XG5cblx0aWYgKGNoYXJhY3RlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGNoYXJhY3RlcnNgIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcblx0fVxuXG5cdGlmIChjaGFyYWN0ZXJzLmxlbmd0aCA+IDB4MTAwMDApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY2hhcmFjdGVyc2Agc3RyaW5nIGxlbmd0aCB0byBiZSBsZXNzIG9yIGVxdWFsIHRvIDY1NTM2Jyk7XG5cdH1cblxuXHRyZXR1cm4gZ2VuZXJhdGVGb3JDdXN0b21DaGFyYWN0ZXJzKGxlbmd0aCwgY2hhcmFjdGVycy5zcGxpdCgnJykpO1xufTtcblxuY29uc3QgY3J5cHRvUmFuZG9tU3RyaW5nID0gY3JlYXRlR2VuZXJhdG9yKGdlbmVyYXRlRm9yQ3VzdG9tQ2hhcmFjdGVycywgZ2VuZXJhdGVSYW5kb21CeXRlcyk7XG5cbmNyeXB0b1JhbmRvbVN0cmluZy5hc3luYyA9IGNyZWF0ZUdlbmVyYXRvcihnZW5lcmF0ZUZvckN1c3RvbUNoYXJhY3RlcnNBc3luYywgZ2VuZXJhdGVSYW5kb21CeXRlc0FzeW5jKTtcblxuZXhwb3J0IGRlZmF1bHQgY3J5cHRvUmFuZG9tU3RyaW5nO1xuIiwiaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbmltcG9ydCB7cHJvbWlzaWZ5fSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IGNoaWxkUHJvY2VzcyBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7ZmlsZVVSTFRvUGF0aH0gZnJvbSAnbm9kZTp1cmwnO1xuaW1wb3J0IHtydW5KeGF9IGZyb20gJ3J1bi1qeGEnO1xuaW1wb3J0IHhkZ1RyYXNoZGlyIGZyb20gJ3hkZy10cmFzaGRpcic7XG5pbXBvcnQge3BhdGhFeGlzdHN9IGZyb20gJ3BhdGgtZXhpc3RzJztcbmltcG9ydCBwRmlsdGVyIGZyb20gJ3AtZmlsdGVyJztcblxuY29uc3QgX19kaXJuYW1lID0gcGF0aC5kaXJuYW1lKGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKSk7XG5jb25zdCBleGVjRmlsZVAgPSBwcm9taXNpZnkoY2hpbGRQcm9jZXNzLmV4ZWNGaWxlKTtcblxuY29uc3Qgd2luZG93QmluYXJ5UGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdsaWIvZW1wdHktcmVjeWNsZS1iaW4uZXhlJyk7XG5cbmNvbnN0IGxpbnV4RW1wdHlUcmFzaCA9IGFzeW5jIGRpcmVjdG9yeSA9PiB7XG5cdGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcihkaXJlY3RvcnkpO1xuXHRhd2FpdCBQcm9taXNlLmFsbChmaWxlcy5tYXAoZmlsZSA9PiBmcy5ybShwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlKSwge3JlY3Vyc2l2ZTogdHJ1ZX0pKSk7XG59O1xuXG5jb25zdCBsaW51eEVtcHR5VHJhc2hlcyA9IGFzeW5jICgpID0+IHtcblx0Y29uc3QgZGlyZWN0b3JpZXMgPSBhd2FpdCBwRmlsdGVyKGF3YWl0IHhkZ1RyYXNoZGlyLmFsbCgpLCBwYXRoRXhpc3RzKTtcblx0YXdhaXQgUHJvbWlzZS5hbGwoZGlyZWN0b3JpZXMubWFwKGRpcmVjdG9yeSA9PiBsaW51eEVtcHR5VHJhc2goZGlyZWN0b3J5KSkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZW1wdHlUcmFzaCgpIHtcblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0YXdhaXQgcnVuSnhhKGBcblx0XHRcdGNvbnN0IGZpbmRlciA9IEFwcGxpY2F0aW9uKCdGaW5kZXInKTtcblxuXHRcdFx0aWYgKGZpbmRlci50cmFzaC5pdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGZpbmRlci5lbXB0eSgpO1xuXHRcdFx0fVxuXHRcdGApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0YXdhaXQgZXhlY0ZpbGVQKHdpbmRvd0JpbmFyeVBhdGgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGF3YWl0IGxpbnV4RW1wdHlUcmFzaGVzKCk7XG59XG4iLCJpbXBvcnQgZnMsIHtwcm9taXNlcyBhcyBmc1Byb21pc2VzfSBmcm9tICdub2RlOmZzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhdGhFeGlzdHMocGF0aCkge1xuXHR0cnkge1xuXHRcdGF3YWl0IGZzUHJvbWlzZXMuYWNjZXNzKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhFeGlzdHNTeW5jKHBhdGgpIHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cbiIsImltcG9ydCBwcm9jZXNzIGZyb20gJ25vZGU6cHJvY2Vzcyc7XG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmV4cG9ydCBjb25zdCBpc01hY09TID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2Rhcndpbic7XG5cbmxldCB2ZXJzaW9uO1xuXG5jb25zdCBjbGVhbiA9IHZlcnNpb24gPT4ge1xuXHRjb25zdCB7bGVuZ3RofSA9IHZlcnNpb24uc3BsaXQoJy4nKTtcblxuXHRpZiAobGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIGAke3ZlcnNpb259LjAuMGA7XG5cdH1cblxuXHRpZiAobGVuZ3RoID09PSAyKSB7XG5cdFx0cmV0dXJuIGAke3ZlcnNpb259LjBgO1xuXHR9XG5cblx0cmV0dXJuIHZlcnNpb247XG59O1xuXG5jb25zdCBwYXJzZVZlcnNpb24gPSBwbGlzdCA9PiB7XG5cdGNvbnN0IG1hdGNoZXMgPSAvPGtleT5Qcm9kdWN0VmVyc2lvbjxcXC9rZXk+XFxzKjxzdHJpbmc+KFtcXGQuXSspPFxcL3N0cmluZz4vLmV4ZWMocGxpc3QpO1xuXHRpZiAoIW1hdGNoZXMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlc1sxXS5yZXBsYWNlKCcxMC4xNicsICcxMScpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hY09TVmVyc2lvbigpIHtcblx0aWYgKCFpc01hY09TKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCF2ZXJzaW9uKSB7XG5cdFx0Y29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYygnL1N5c3RlbS9MaWJyYXJ5L0NvcmVTZXJ2aWNlcy9TeXN0ZW1WZXJzaW9uLnBsaXN0JywgJ3V0ZjgnKTtcblx0XHRjb25zdCBtYXRjaGVzID0gcGFyc2VWZXJzaW9uKGZpbGUpO1xuXG5cdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmVyc2lvbiA9IGNsZWFuKG1hdGNoZXMpO1xuXHR9XG5cblx0cmV0dXJuIHZlcnNpb247XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG5cdG1hY09TVmVyc2lvbi5fcGFyc2VWZXJzaW9uID0gcGFyc2VWZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYWNPU1ZlcnNpb24oc2VtdmVyUmFuZ2UpIHtcblx0aWYgKCFpc01hY09TKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0c2VtdmVyUmFuZ2UgPSBzZW12ZXJSYW5nZS5yZXBsYWNlKCcxMC4xNicsICcxMScpO1xuXG5cdHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKG1hY09TVmVyc2lvbigpLCBjbGVhbihzZW12ZXJSYW5nZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYWNPU1ZlcnNpb25HcmVhdGVyVGhhbk9yRXF1YWxUbyh2ZXJzaW9uKSB7XG5cdGlmICghaXNNYWNPUykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoJzEwLjE2JywgJzExJyk7XG5cblx0cmV0dXJuIHNlbXZlci5ndGUobWFjT1NWZXJzaW9uKCksIGNsZWFuKHZlcnNpb24pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE1hY09TVmVyc2lvbihzZW12ZXJSYW5nZSkge1xuXHRzZW12ZXJSYW5nZSA9IHNlbXZlclJhbmdlLnJlcGxhY2UoJzEwLjE2JywgJzExJyk7XG5cblx0aWYgKCFpc01hY09TVmVyc2lvbihzZW12ZXJSYW5nZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVzIG1hY09TICR7c2VtdmVyUmFuZ2V9YCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE1hY09TVmVyc2lvbkdyZWF0ZXJUaGFuT3JFcXVhbFRvKHZlcnNpb24pIHtcblx0dmVyc2lvbiA9IHZlcnNpb24ucmVwbGFjZSgnMTAuMTYnLCAnMTEnKTtcblxuXHRpZiAoIWlzTWFjT1NWZXJzaW9uR3JlYXRlclRoYW5PckVxdWFsVG8odmVyc2lvbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVzIG1hY09TICR7dmVyc2lvbn0gb3IgbGF0ZXJgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TWFjT1MoKSB7XG5cdGlmICghaXNNYWNPUykge1xuXHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgbWFjT1MnKTtcblx0fVxufVxuIiwiaW1wb3J0IHBNYXAgZnJvbSAncC1tYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwRmlsdGVyKGl0ZXJhYmxlLCBmaWx0ZXJlciwgb3B0aW9ucykge1xuXHRjb25zdCB2YWx1ZXMgPSBhd2FpdCBwTWFwKFxuXHRcdGl0ZXJhYmxlLFxuXHRcdChlbGVtZW50LCBpbmRleCkgPT4gUHJvbWlzZS5hbGwoW2ZpbHRlcmVyKGVsZW1lbnQsIGluZGV4KSwgZWxlbWVudF0pLFxuXHRcdG9wdGlvbnMsXG5cdCk7XG5cblx0cmV0dXJuIHZhbHVlcy5maWx0ZXIodmFsdWUgPT4gQm9vbGVhbih2YWx1ZVswXSkpLm1hcCh2YWx1ZSA9PiB2YWx1ZVsxXSk7XG59XG4iLCJpbXBvcnQgaW5kZW50U3RyaW5nIGZyb20gJ2luZGVudC1zdHJpbmcnO1xuaW1wb3J0IGNsZWFuU3RhY2sgZnJvbSAnY2xlYW4tc3RhY2snO1xuXG5jb25zdCBjbGVhbkludGVybmFsU3RhY2sgPSBzdGFjayA9PiBzdGFjay5yZXBsYWNlKC9cXHMrYXQgLiphZ2dyZWdhdGUtZXJyb3JcXC9pbmRleC5qczpcXGQrOlxcZCtcXCk/L2csICcnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdCNlcnJvcnM7XG5cblx0bmFtZSA9ICdBZ2dyZWdhdGVFcnJvcic7XG5cblx0Y29uc3RydWN0b3IoZXJyb3JzKSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGVycm9ycykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHRvIGJlIGFuIEFycmF5LCBnb3QgJHt0eXBlb2YgZXJyb3JzfWApO1xuXHRcdH1cblxuXHRcdGVycm9ycyA9IGVycm9ycy5tYXAoZXJyb3IgPT4ge1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyBIYW5kbGUgcGxhaW4gZXJyb3Igb2JqZWN0cyB3aXRoIG1lc3NhZ2UgcHJvcGVydHkgYW5kL29yIHBvc3NpYmx5IG90aGVyIG1ldGFkYXRhXG5cdFx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKSwgZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcblx0XHR9KTtcblxuXHRcdGxldCBtZXNzYWdlID0gZXJyb3JzXG5cdFx0XHQubWFwKGVycm9yID0+IHtcblx0XHRcdFx0Ly8gVGhlIGBzdGFja2AgcHJvcGVydHkgaXMgbm90IHN0YW5kYXJkaXplZCwgc28gd2UgY2FuJ3QgYXNzdW1lIGl0IGV4aXN0c1xuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGVycm9yLnN0YWNrID09PSAnc3RyaW5nJyAmJiBlcnJvci5zdGFjay5sZW5ndGggPiAwID8gY2xlYW5JbnRlcm5hbFN0YWNrKGNsZWFuU3RhY2soZXJyb3Iuc3RhY2spKSA6IFN0cmluZyhlcnJvcik7XG5cdFx0XHR9KVxuXHRcdFx0LmpvaW4oJ1xcbicpO1xuXHRcdG1lc3NhZ2UgPSAnXFxuJyArIGluZGVudFN0cmluZyhtZXNzYWdlLCA0KTtcblx0XHRzdXBlcihtZXNzYWdlKTtcblxuXHRcdHRoaXMuI2Vycm9ycyA9IGVycm9ycztcblx0fVxuXG5cdGdldCBlcnJvcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Vycm9ycy5zbGljZSgpO1xuXHR9XG59XG4iLCJpbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IGVzY2FwZVN0cmluZ1JlZ2V4cCBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCc7XG5cbmNvbnN0IGV4dHJhY3RQYXRoUmVnZXggPSAvXFxzK2F0LipbKFxcc10oLiopXFwpPy87XG5jb25zdCBwYXRoUmVnZXggPSAvXig/Oig/Oig/Om5vZGV8bm9kZTpbXFx3L10rfCg/Oig/Om5vZGU6KT9pbnRlcm5hbFxcL1tcXHcvXSp8Lipub2RlX21vZHVsZXNcXC8oPzpiYWJlbC1wb2x5ZmlsbHxwaXJhdGVzKVxcLy4qKT9cXHcrKSg/OlxcLmpzKT86XFxkKzpcXGQrKXxuYXRpdmUpLztcbmNvbnN0IGhvbWVEaXIgPSB0eXBlb2Ygb3MuaG9tZWRpciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IG9zLmhvbWVkaXIoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2ssIHtwcmV0dHkgPSBmYWxzZSwgYmFzZVBhdGh9ID0ge30pIHtcblx0Y29uc3QgYmFzZVBhdGhSZWdleCA9IGJhc2VQYXRoICYmIG5ldyBSZWdFeHAoYChhdCB8IFxcXFwoKSR7ZXNjYXBlU3RyaW5nUmVnZXhwKGJhc2VQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKSl9YCwgJ2cnKTtcblxuXHRpZiAodHlwZW9mIHN0YWNrICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRyZXR1cm4gc3RhY2sucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5maWx0ZXIobGluZSA9PiB7XG5cdFx0XHRjb25zdCBwYXRoTWF0Y2hlcyA9IGxpbmUubWF0Y2goZXh0cmFjdFBhdGhSZWdleCk7XG5cdFx0XHRpZiAocGF0aE1hdGNoZXMgPT09IG51bGwgfHwgIXBhdGhNYXRjaGVzWzFdKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRjaCA9IHBhdGhNYXRjaGVzWzFdO1xuXG5cdFx0XHQvLyBFbGVjdHJvblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRtYXRjaC5pbmNsdWRlcygnLmFwcC9Db250ZW50cy9SZXNvdXJjZXMvZWxlY3Ryb24uYXNhcicpIHx8XG5cdFx0XHRcdG1hdGNoLmluY2x1ZGVzKCcuYXBwL0NvbnRlbnRzL1Jlc291cmNlcy9kZWZhdWx0X2FwcC5hc2FyJykgfHxcblx0XHRcdFx0bWF0Y2guaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy9lbGVjdHJvbi9kaXN0L3Jlc291cmNlcy9lbGVjdHJvbi5hc2FyJykgfHxcblx0XHRcdFx0bWF0Y2guaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy9lbGVjdHJvbi9kaXN0L3Jlc291cmNlcy9kZWZhdWx0X2FwcC5hc2FyJylcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAhcGF0aFJlZ2V4LnRlc3QobWF0Y2gpO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJylcblx0XHQubWFwKGxpbmUgPT4ge1xuXHRcdFx0aWYgKGJhc2VQYXRoUmVnZXgpIHtcblx0XHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZShiYXNlUGF0aFJlZ2V4LCAnJDEnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXR0eSkge1xuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKGV4dHJhY3RQYXRoUmVnZXgsIChtLCBwMSkgPT4gbS5yZXBsYWNlKHAxLCBwMS5yZXBsYWNlKGhvbWVEaXIsICd+JykpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxpbmU7XG5cdFx0fSlcblx0XHQuam9pbignXFxuJyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgY291bnQgPSAxLCBvcHRpb25zID0ge30pIHtcblx0Y29uc3Qge1xuXHRcdGluZGVudCA9ICcgJyxcblx0XHRpbmNsdWRlRW1wdHlMaW5lcyA9IGZhbHNlXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgYSBcXGBzdHJpbmdcXGAsIGdvdCBcXGAke3R5cGVvZiBzdHJpbmd9XFxgYFxuXHRcdCk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRgRXhwZWN0ZWQgXFxgY291bnRcXGAgdG8gYmUgYSBcXGBudW1iZXJcXGAsIGdvdCBcXGAke3R5cGVvZiBjb3VudH1cXGBgXG5cdFx0KTtcblx0fVxuXG5cdGlmIChjb3VudCA8IDApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcblx0XHRcdGBFeHBlY3RlZCBcXGBjb3VudFxcYCB0byBiZSBhdCBsZWFzdCAwLCBnb3QgXFxgJHtjb3VudH1cXGBgXG5cdFx0KTtcblx0fVxuXG5cdGlmICh0eXBlb2YgaW5kZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRgRXhwZWN0ZWQgXFxgb3B0aW9ucy5pbmRlbnRcXGAgdG8gYmUgYSBcXGBzdHJpbmdcXGAsIGdvdCBcXGAke3R5cGVvZiBpbmRlbnR9XFxgYFxuXHRcdCk7XG5cdH1cblxuXHRpZiAoY291bnQgPT09IDApIHtcblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9XG5cblx0Y29uc3QgcmVnZXggPSBpbmNsdWRlRW1wdHlMaW5lcyA/IC9eL2dtIDogL14oPyFcXHMqJCkvZ207XG5cblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4LCBpbmRlbnQucmVwZWF0KGNvdW50KSk7XG59XG4iLCJpbXBvcnQgQWdncmVnYXRlRXJyb3IgZnJvbSAnYWdncmVnYXRlLWVycm9yJztcblxuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgcmVxdWVzdCBpcyBhYm9ydGVkIGJ5IEFib3J0Q29udHJvbGxlci5cbkRPTUV4Y2VwdGlvbiBpcyB0aHJvd24gaW5zdGVhZCBvZiB0aGlzIEVycm9yIHdoZW4gRE9NRXhjZXB0aW9uIGlzIGF2YWlsYWJsZS5cbiovXG5leHBvcnQgY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdH1cbn1cblxuLyoqXG5UT0RPOiBSZW1vdmUgQWJvcnRFcnJvciBhbmQganVzdCB0aHJvdyBET01FeGNlcHRpb24gd2hlbiB0YXJnZXRpbmcgTm9kZSAxOC5cbiovXG5jb25zdCBnZXRET01FeGNlcHRpb24gPSBlcnJvck1lc3NhZ2UgPT4gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24gPT09IHVuZGVmaW5lZFxuXHQ/IG5ldyBBYm9ydEVycm9yKGVycm9yTWVzc2FnZSlcblx0OiBuZXcgRE9NRXhjZXB0aW9uKGVycm9yTWVzc2FnZSk7XG5cbi8qKlxuVE9ETzogUmVtb3ZlIGJlbG93IGZ1bmN0aW9uIGFuZCBqdXN0ICdyZWplY3Qoc2lnbmFsLnJlYXNvbiknIHdoZW4gdGFyZ2V0aW5nIE5vZGUgMTguXG4qL1xuY29uc3QgZ2V0QWJvcnRlZFJlYXNvbiA9IHNpZ25hbCA9PiB7XG5cdGNvbnN0IHJlYXNvbiA9IHNpZ25hbC5yZWFzb24gPT09IHVuZGVmaW5lZFxuXHRcdD8gZ2V0RE9NRXhjZXB0aW9uKCdUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKVxuXHRcdDogc2lnbmFsLnJlYXNvbjtcblxuXHRyZXR1cm4gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiBnZXRET01FeGNlcHRpb24ocmVhc29uKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBNYXAoXG5cdGl0ZXJhYmxlLFxuXHRtYXBwZXIsXG5cdHtcblx0XHRjb25jdXJyZW5jeSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcblx0XHRzdG9wT25FcnJvciA9IHRydWUsXG5cdFx0c2lnbmFsLFxuXHR9ID0ge30sXG4pIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3RfKSA9PiB7XG5cdFx0aWYgKGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gPT09IHVuZGVmaW5lZCAmJiBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgZWl0aGVyIGFuIFxcYEl0ZXJhYmxlXFxgIG9yIFxcYEFzeW5jSXRlcmFibGVcXGAsIGdvdCAoJHt0eXBlb2YgaXRlcmFibGV9KWApO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgbWFwcGVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdNYXBwZXIgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcblx0XHR9XG5cblx0XHRpZiAoISgoTnVtYmVyLmlzU2FmZUludGVnZXIoY29uY3VycmVuY3kpIHx8IGNvbmN1cnJlbmN5ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpICYmIGNvbmN1cnJlbmN5ID49IDEpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb25jdXJyZW5jeVxcYCB0byBiZSBhbiBpbnRlZ2VyIGZyb20gMSBhbmQgdXAgb3IgXFxgSW5maW5pdHlcXGAsIGdvdCBcXGAke2NvbmN1cnJlbmN5fVxcYCAoJHt0eXBlb2YgY29uY3VycmVuY3l9KWApO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRcdGNvbnN0IGVycm9ycyA9IFtdO1xuXHRcdGNvbnN0IHNraXBwZWRJbmRleGVzTWFwID0gbmV3IE1hcCgpO1xuXHRcdGxldCBpc1JlamVjdGVkID0gZmFsc2U7XG5cdFx0bGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcblx0XHRsZXQgaXNJdGVyYWJsZURvbmUgPSBmYWxzZTtcblx0XHRsZXQgcmVzb2x2aW5nQ291bnQgPSAwO1xuXHRcdGxldCBjdXJyZW50SW5kZXggPSAwO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gdW5kZWZpbmVkID8gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkgOiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cblx0XHRjb25zdCByZWplY3QgPSByZWFzb24gPT4ge1xuXHRcdFx0aXNSZWplY3RlZCA9IHRydWU7XG5cdFx0XHRpc1Jlc29sdmVkID0gdHJ1ZTtcblx0XHRcdHJlamVjdF8ocmVhc29uKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0aWYgKHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdHJlamVjdChnZXRBYm9ydGVkUmVhc29uKHNpZ25hbCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG5cdFx0XHRcdHJlamVjdChnZXRBYm9ydGVkUmVhc29uKHNpZ25hbCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV4dCA9IGFzeW5jICgpID0+IHtcblx0XHRcdGlmIChpc1Jlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmV4dEl0ZW0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gY3VycmVudEluZGV4O1xuXHRcdFx0Y3VycmVudEluZGV4Kys7XG5cblx0XHRcdC8vIE5vdGU6IGBpdGVyYXRvci5uZXh0KClgIGNhbiBiZSBjYWxsZWQgbWFueSB0aW1lcyBpbiBwYXJhbGxlbC5cblx0XHRcdC8vIFRoaXMgY2FuIGNhdXNlIG11bHRpcGxlIGNhbGxzIHRvIHRoaXMgYG5leHQoKWAgZnVuY3Rpb24gdG9cblx0XHRcdC8vIHJlY2VpdmUgYSBgbmV4dEl0ZW1gIHdpdGggYGRvbmUgPT09IHRydWVgLlxuXHRcdFx0Ly8gVGhlIHNodXRkb3duIGxvZ2ljIHRoYXQgcmVqZWN0cy9yZXNvbHZlcyBtdXN0IGJlIHByb3RlY3RlZFxuXHRcdFx0Ly8gc28gaXQgcnVucyBvbmx5IG9uZSB0aW1lIGFzIHRoZSBgc2tpcHBlZEluZGV4YCBsb2dpYyBpc1xuXHRcdFx0Ly8gbm9uLWlkZW1wb3RlbnQuXG5cdFx0XHRpZiAobmV4dEl0ZW0uZG9uZSkge1xuXHRcdFx0XHRpc0l0ZXJhYmxlRG9uZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKHJlc29sdmluZ0NvdW50ID09PSAwICYmICFpc1Jlc29sdmVkKSB7XG5cdFx0XHRcdFx0aWYgKCFzdG9wT25FcnJvciAmJiBlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpc1Jlc29sdmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmIChza2lwcGVkSW5kZXhlc01hcC5zaXplID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgcHVyZVJlc3VsdCA9IFtdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydCBtdWx0aXBsZSBgcE1hcFNraXBgJ3MuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBbaW5kZXgsIHZhbHVlXSBvZiByZXN1bHQuZW50cmllcygpKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2tpcHBlZEluZGV4ZXNNYXAuZ2V0KGluZGV4KSA9PT0gcE1hcFNraXApIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHB1cmVSZXN1bHQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZShwdXJlUmVzdWx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0cmVzb2x2aW5nQ291bnQrKztcblxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBkZXRhY2hlZFxuXHRcdFx0KGFzeW5jICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gYXdhaXQgbmV4dEl0ZW0udmFsdWU7XG5cblx0XHRcdFx0XHRpZiAoaXNSZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gYXdhaXQgbWFwcGVyKGVsZW1lbnQsIGluZGV4KTtcblxuXHRcdFx0XHRcdC8vIFVzZSBNYXAgdG8gc3RhZ2UgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gcE1hcFNraXApIHtcblx0XHRcdFx0XHRcdHNraXBwZWRJbmRleGVzTWFwLnNldChpbmRleCwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdHJlc29sdmluZ0NvdW50LS07XG5cdFx0XHRcdFx0YXdhaXQgbmV4dCgpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChzdG9wT25FcnJvcikge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHRcdFx0cmVzb2x2aW5nQ291bnQtLTtcblxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhhdCBjYXNlIHdlIGNhbid0IHJlYWxseSBjb250aW51ZSByZWdhcmRsZXNzIG9mIGBzdG9wT25FcnJvcmAgc3RhdGVcblx0XHRcdFx0XHRcdC8vIHNpbmNlIGFuIGl0ZXJhYmxlIGlzIGxpa2VseSB0byBjb250aW51ZSB0aHJvd2luZyBhZnRlciBpdCB0aHJvd3Mgb25jZS5cblx0XHRcdFx0XHRcdC8vIElmIHdlIGNvbnRpbnVlIGNhbGxpbmcgYG5leHQoKWAgaW5kZWZpbml0ZWx5IHdlIHdpbGwgbGlrZWx5IGVuZCB1cFxuXHRcdFx0XHRcdFx0Ly8gaW4gYW4gaW5maW5pdGUgbG9vcCBvZiBmYWlsZWQgaXRlcmF0aW9uLlxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgbmV4dCgpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgY29uY3VycmVudCBydW5uZXJzIGluIGEgZGV0YWNoZWQgKG5vbi1hd2FpdGVkKVxuXHRcdC8vIHByb21pc2UuIFdlIG5lZWQgdGhpcyBzbyB3ZSBjYW4gYXdhaXQgdGhlIGBuZXh0KClgIGNhbGxzXG5cdFx0Ly8gdG8gc3RvcCBjcmVhdGluZyBydW5uZXJzIGJlZm9yZSBoaXR0aW5nIHRoZSBjb25jdXJyZW5jeSBsaW1pdFxuXHRcdC8vIGlmIHRoZSBpdGVyYWJsZSBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBhcyBkb25lLlxuXHRcdC8vIE5PVEU6IFdlICptdXN0KiBkbyB0aGlzIGZvciBhc3luYyBpdGVyYXRvcnMgb3RoZXJ3aXNlIHdlJ2xsIHNwaW4gdXBcblx0XHQvLyBpbmZpbml0ZSBgbmV4dCgpYCBjYWxscyBieSBkZWZhdWx0IGFuZCBuZXZlciBzdGFydCB0aGUgZXZlbnQgbG9vcC5cblx0XHQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbmN1cnJlbmN5OyBpbmRleCsrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRcdFx0XHRhd2FpdCBuZXh0KCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc0l0ZXJhYmxlRG9uZSB8fCBpc1JlamVjdGVkKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSgpO1xuXHR9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHBNYXBTa2lwID0gU3ltYm9sKCdza2lwJyk7XG4iLCJpbXBvcnQgZXhlY2EgZnJvbSAnZXhlY2EnO1xuaW1wb3J0IFN1YnN1bWUgZnJvbSAnc3Vic3VtZSc7XG5pbXBvcnQge2Fzc2VydE1hY09TVmVyc2lvbkdyZWF0ZXJUaGFuT3JFcXVhbFRvfSBmcm9tICdtYWNvcy12ZXJzaW9uJztcblxuY29uc3Qgc3Vic3VtZSA9IG5ldyBTdWJzdW1lKCk7XG5jb25zdCBjb21tYW5kQXJndW1lbnRzID0gWyctbCcsICdKYXZhU2NyaXB0J107XG5cbmNvbnN0IHByZXBhcmVPcHRpb25zID0gKGlucHV0LCBhcmd1bWVudHNfKSA9PiB7XG5cdGNvbnN0IHN0cmluZ1RlbXBsYXRlID0gYGZ1bmN0aW9uKCl7Y29uc3QgYXJncz1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XFxuJHtpbnB1dH1cXG59YDtcblx0Y29uc3QgZnVuY3Rpb25TdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgPyBpbnB1dC50b1N0cmluZygpIDogc3RyaW5nVGVtcGxhdGU7XG5cdGNvbnN0IGFyZ3NTdHJpbmcgPSAoYXJndW1lbnRzXyB8fCBbXSkubWFwKGFyZ3VtZW50ID0+IEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50KSkuam9pbignLCcpO1xuXHRjb25zdCBmdW5jdGlvbkNhbGwgPSBgKCR7ZnVuY3Rpb25TdHJpbmd9KSgke2FyZ3NTdHJpbmd9KWA7XG5cdGNvbnN0IG91dHB1dCA9IGBKU09OLnN0cmluZ2lmeSh7ZGF0YTogJHtmdW5jdGlvbkNhbGx9fSlgO1xuXHRjb25zdCBzY3JpcHQgPSBgY29uc29sZS5sb2coJyR7c3Vic3VtZS5wcmVmaXh9JyArICR7b3V0cHV0fSArICcke3N1YnN1bWUucG9zdGZpeH0nKTtgO1xuXHRyZXR1cm4ge2lucHV0OiBzY3JpcHR9O1xufTtcblxuY29uc3QgaGFuZGxlT3V0cHV0ID0gc3RyaW5nID0+IHtcblx0Y29uc3QgcmVzdWx0ID0gc3Vic3VtZS5wYXJzZShzdHJpbmcpO1xuXHRjb25zdCBsb2cgPSByZXN1bHQucmVzdC5zbGljZSgwLCAtMSk7XG5cblx0aWYgKGxvZy5sZW5ndGggPiAwKSB7XG5cdFx0Y29uc29sZS5sb2cobG9nKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQuZGF0YSAmJiBKU09OLnBhcnNlKHJlc3VsdC5kYXRhKS5kYXRhO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkp4YShpbnB1dCwgYXJndW1lbnRzXykge1xuXHRhc3NlcnRNYWNPU1ZlcnNpb25HcmVhdGVyVGhhbk9yRXF1YWxUbygnMTAuMTAnKTtcblx0Y29uc3Qge3N0ZGVycn0gPSBhd2FpdCBleGVjYSgnb3Nhc2NyaXB0JywgY29tbWFuZEFyZ3VtZW50cywgcHJlcGFyZU9wdGlvbnMoaW5wdXQsIGFyZ3VtZW50c18pKTtcblx0cmV0dXJuIGhhbmRsZU91dHB1dChzdGRlcnIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuSnhhU3luYyhpbnB1dCwgYXJndW1lbnRzXykge1xuXHRhc3NlcnRNYWNPU1ZlcnNpb25HcmVhdGVyVGhhbk9yRXF1YWxUbygnMTAuMTAnKTtcblx0Y29uc3Qge3N0ZGVycn0gPSBleGVjYS5zeW5jKCdvc2FzY3JpcHQnLCBjb21tYW5kQXJndW1lbnRzLCBwcmVwYXJlT3B0aW9ucyhpbnB1dCwgYXJndW1lbnRzXykpO1xuXHRyZXR1cm4gaGFuZGxlT3V0cHV0KHN0ZGVycik7XG59XG4iLCJpbXBvcnQgdW5pcXVlU3RyaW5nIGZyb20gJ3VuaXF1ZS1zdHJpbmcnO1xuaW1wb3J0IGVzY2FwZVN0cmluZ1JlZ2V4cCBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1YnN1bWUge1xuXHRzdGF0aWMgcGFyc2UodGV4dCwgaWQpIHtcblx0XHRyZXR1cm4gKG5ldyBTdWJzdW1lKGlkKSkucGFyc2UodGV4dCk7XG5cdH1cblxuXHRzdGF0aWMgcGFyc2VBbGwodGV4dCwgaWRzKSB7XG5cdFx0aWYgKGlkcyAmJiAhQXJyYXkuaXNBcnJheShpZHMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdJRHMgaXMgc3VwcG9zZWQgdG8gYmUgYW4gYXJyYXknKTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSB7ZGF0YTogbmV3IE1hcCgpLCByZXN0OiB0ZXh0fTtcblx0XHRjb25zdCBpZExpc3QgPSBpZHMgPyBpZHMgOiBTdWJzdW1lLl9leHRyYWN0SURzKHRleHQpO1xuXG5cdFx0aWYgKCFpZHMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdFN1YnN1bWUuX2NoZWNrSW50ZWdyaXR5KHRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgYmVjYXVzZSB0aGUgc3RyaW5nJ3MgaW50ZWdyaXR5IGlzIGNvbXByb21pc2VkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpZCBvZiBpZExpc3QpIHtcblx0XHRcdGlmIChyZXN1bHQuZGF0YS5nZXQoaWQpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSURzIGFyZW5cXCd0IHN1cHBvc2VkIHRvIGJlIHJlcGVhdGVkIGF0IHRoZSBzYW1lIGxldmVsIGluIGEgc3RyaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBhcnNlUmVzdWx0ID0gU3Vic3VtZS5wYXJzZShyZXN1bHQucmVzdCwgaWQpO1xuXHRcdFx0cmVzdWx0LmRhdGEuc2V0KGlkLCBwYXJzZVJlc3VsdC5kYXRhKTtcblx0XHRcdHJlc3VsdC5yZXN0ID0gcGFyc2VSZXN1bHQucmVzdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0c3RhdGljIF9leHRyYWN0SURzKHRleHQpIHtcblx0XHR0cnkge1xuXHRcdFx0U3Vic3VtZS5fY2hlY2tJbnRlZ3JpdHkodGV4dCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgSURzIGJlY2F1c2UgdGhlIHN0cmluZydzIGludGVncml0eSBpcyBjb21wcm9taXNlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlkUmVnZXggPSAvQEBcXFsoLnszMn0pXUBALiojI1xcW1xcMV0jIy9nO1xuXHRcdGNvbnN0IGlkTGlzdCA9IFtdO1xuXHRcdGxldCBtYXRjaDtcblxuXHRcdGRvIHtcblx0XHRcdG1hdGNoID0gaWRSZWdleC5leGVjKHRleHQpO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdGNvbnN0IFssIGlkXSA9IG1hdGNoO1xuXHRcdFx0XHRpZExpc3QucHVzaChpZCk7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAobWF0Y2gpO1xuXG5cdFx0cmV0dXJuIGlkTGlzdDtcblx0fVxuXG5cdHN0YXRpYyBfY2hlY2tJbnRlZ3JpdHkodGV4dCkge1xuXHRcdGNvbnN0IGRlbGltaXRlclJlZ2V4ID0gLyhbI3xAXSlcXDFcXFsoLnszMn0pXVxcMXsyfS9nO1xuXHRcdGNvbnN0IGlkcyA9IG5ldyBNYXAoKTtcblx0XHRjb25zdCBpZFN0YWNrID0gW107XG5cdFx0bGV0IG1hdGNoO1xuXG5cdFx0ZG8ge1xuXHRcdFx0bWF0Y2ggPSBkZWxpbWl0ZXJSZWdleC5leGVjKHRleHQpO1xuXG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgWywgZW1iZWRUb2tlbiwgaWRdID0gbWF0Y2g7XG5cblx0XHRcdFx0aWYgKGVtYmVkVG9rZW4gPT09ICdAJykge1xuXHRcdFx0XHRcdGxldCBtYXAgPSBpZHM7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBlbGVtZW50IG9mIGlkU3RhY2spIHtcblx0XHRcdFx0XHRcdG1hcCA9IG1hcC5nZXQoZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG1hcC5nZXQoaWQpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGFyZSBkdXBsaWNhdGUgSURzIGluIHRoZSBzYW1lIHNjb3BlLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1hcC5zZXQoaWQsIG5ldyBNYXAoKSk7XG5cblx0XHRcdFx0XHRpZFN0YWNrLnB1c2goaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlkU3RhY2sucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IHdoaWxlIChtYXRjaCk7XG5cblx0XHRpZiAoaWRTdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGEgbWlzbWF0Y2ggYmV0d2VlbiBwcmVmaXhlcyBhbmQgc3VmZml4ZXMnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaWRzO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoaWQpIHtcblx0XHRpZiAoaWQgJiYgKGlkLmluY2x1ZGVzKCdAQFsnKSB8fCBpZC5pbmNsdWRlcygnIyNbJykpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2BAQFtgIGFuZCBgIyNbYCBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgSUQnKTtcblx0XHR9XG5cblx0XHR0aGlzLmlkID0gaWQgPyBpZCA6IHVuaXF1ZVN0cmluZygpO1xuXHRcdHRoaXMucHJlZml4ID0gYEBAWyR7dGhpcy5pZH1dQEBgO1xuXHRcdHRoaXMucG9zdGZpeCA9IGAjI1ske3RoaXMuaWR9XSMjYDtcblx0XHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVTdHJpbmdSZWdleHAodGhpcy5wcmVmaXgpICsgJyhbXFxcXFNcXFxcc10qKScgKyBlc2NhcGVTdHJpbmdSZWdleHAodGhpcy5wb3N0Zml4KSwgJ2cnKTtcblx0fVxuXG5cdGNvbXBvc2UodGV4dCkge1xuXHRcdHJldHVybiB0aGlzLnByZWZpeCArIHRleHQgKyB0aGlzLnBvc3RmaXg7XG5cdH1cblxuXHRwYXJzZSh0ZXh0KSB7XG5cdFx0dHJ5IHtcblx0XHRcdFN1YnN1bWUuX2NoZWNrSW50ZWdyaXR5KHRleHQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBleHRyYWN0IElEcyBiZWNhdXNlIHRoZSBzdHJpbmcncyBpbnRlZ3JpdHkgaXMgY29tcHJvbWlzZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHR9XG5cblx0XHRjb25zdCByZXR1cm5WYWx1ZSA9IHt9O1xuXG5cdFx0cmV0dXJuVmFsdWUucmVzdCA9IHRleHQucmVwbGFjZSh0aGlzLnJlZ2V4LCAobSwgcDEpID0+IHtcblx0XHRcdGlmIChwMSkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZS5kYXRhID0gcDE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAnJztcblx0XHR9KTtcblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlU3RyaW5nUmVnZXhwKHN0cmluZykge1xuXHRpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0Ly8gRXNjYXBlIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmcgZWl0aGVyIGluc2lkZSBvciBvdXRzaWRlIGNoYXJhY3RlciBzZXRzLlxuXHQvLyBVc2UgYSBzaW1wbGUgYmFja3NsYXNoIGVzY2FwZSB3aGVuIGl04oCZcyBhbHdheXMgdmFsaWQsIGFuZCBhIGBcXHhubmAgZXNjYXBlIHdoZW4gdGhlIHNpbXBsZXIgZm9ybSB3b3VsZCBiZSBkaXNhbGxvd2VkIGJ5IFVuaWNvZGUgcGF0dGVybnPigJkgc3RyaWN0ZXIgZ3JhbW1hci5cblx0cmV0dXJuIHN0cmluZ1xuXHRcdC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpXG5cdFx0LnJlcGxhY2UoLy0vZywgJ1xcXFx4MmQnKTtcbn1cbiIsImltcG9ydCBjcnlwdG9SYW5kb21TdHJpbmcgZnJvbSAnY3J5cHRvLXJhbmRvbS1zdHJpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVTdHJpbmcoKSB7XG5cdHJldHVybiBjcnlwdG9SYW5kb21TdHJpbmcoe2xlbmd0aDogMzJ9KTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbidcclxuLy8gaW1wb3J0IHsgaXNTcXVpcnJlbCB9IGZyb20gJy4vc3F1aXJyZWwnXHJcbmltcG9ydCBvblJlYWR5IGZyb20gXCIuL2Jvb3RzdHJhcFwiXHJcbi8vIE1vZHVsZSB0byBjcmVhdGUgbmF0aXZlIGJyb3dzZXIgd2luZG93LlxyXG5cclxubGV0IGNhbkxvYWQgPSB0cnVlXHJcblxyXG4vLyAvLyB0aGlzIHBhY2thZ2UgY2hlY2tzIGlmIHdlIGFyZSBpbiBpbnN0YWxsIG1vZGUgYW5kIGV4ZWN1dGVzIHRoZSBpbnN0YWxsIHNjcmlwdHNcclxuLy8gaWYgKGlzU3F1aXJyZWwoKSkge1xyXG4vLyAgICAgY2FuTG9hZCA9IGZhbHNlXHJcbi8vICAgICBhcHAucXVpdCgpXHJcbi8vIH1cclxuXHJcbi8vIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgdGhlIG9ubHkgaW5zdGFuY2UgcnVubmluZywgb3RoZXJ3aXNlIHF1aXRcclxuaWYgKCFhcHAucmVxdWVzdFNpbmdsZUluc3RhbmNlTG9jaygpKSB7XHJcbiAgICBjYW5Mb2FkID0gZmFsc2VcclxuICAgIGFwcC5xdWl0KClcclxufVxyXG5cclxuaWYgKGNhbkxvYWQpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiY2lhb1wiKVxyXG4gICAgYXBwLndoZW5SZWFkeSgpLnRoZW4oKCkgPT4gb25SZWFkeSgpKTtcclxuXHJcbiAgICBhcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKGV2KSA9PiB7XHJcbiAgICAgICAgLy8gbGVhdmluZyB0aGlzIGVtcHR5IHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvblxyXG4gICAgfSlcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=